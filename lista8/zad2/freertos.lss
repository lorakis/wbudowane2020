
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  00002b00  00002b94  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b00  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000686  0080012e  0080012e  00002bc2  2**0
                  ALLOC
  3 .stab         00007668  00000000  00000000  00002bc4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004381  00000000  00000000  0000a22c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e5ad  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e5c0  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e600  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000ebf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f196  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f1b0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 c0 11 	jmp	0x2380	; 0x2380 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e0       	ldi	r30, 0x00	; 0
      7c:	fb e2       	ldi	r31, 0x2B	; 43
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ae 32       	cpi	r26, 0x2E	; 46
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ae e2       	ldi	r26, 0x2E	; 46
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a4 3b       	cpi	r26, 0xB4	; 180
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 ee 11 	call	0x23dc	; 0x23dc <main>
      9e:	0c 94 7e 15 	jmp	0x2afc	; 0x2afc <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vBlinkLed>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vBlinkLed+0x6>
      ac:	cd b7       	in	r28, 0x3d	; 61
      ae:	de b7       	in	r29, 0x3e	; 62
      b0:	7c 01       	movw	r14, r24
    QueueHandle_t xQueue = (QueueHandle_t)pvParameters;
    LED_DDR |= _BV(LED);
      b2:	25 9a       	sbi	0x04, 5	; 4
    uint16_t value;
    for ( ;; )
    {
        if (xQueueReceive(xQueue, &value, (TickType_t)10) == pdTRUE)
        {
          printf("%"PRIu16"\r\n", value);
      b4:	0e e0       	ldi	r16, 0x0E	; 14
      b6:	11 e0       	ldi	r17, 0x01	; 1
    QueueHandle_t xQueue = (QueueHandle_t)pvParameters;
    LED_DDR |= _BV(LED);
    uint16_t value;
    for ( ;; )
    {
        if (xQueueReceive(xQueue, &value, (TickType_t)10) == pdTRUE)
      b8:	4a e0       	ldi	r20, 0x0A	; 10
      ba:	50 e0       	ldi	r21, 0x00	; 0
      bc:	be 01       	movw	r22, r28
      be:	6f 5f       	subi	r22, 0xFF	; 255
      c0:	7f 4f       	sbci	r23, 0xFF	; 255
      c2:	c7 01       	movw	r24, r14
      c4:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <xQueueReceive>
      c8:	81 30       	cpi	r24, 0x01	; 1
      ca:	b1 f7       	brne	.-20     	; 0xb8 <vBlinkLed+0x12>
        {
          printf("%"PRIu16"\r\n", value);
      cc:	8a 81       	ldd	r24, Y+2	; 0x02
      ce:	8f 93       	push	r24
      d0:	89 81       	ldd	r24, Y+1	; 0x01
      d2:	8f 93       	push	r24
      d4:	1f 93       	push	r17
      d6:	0f 93       	push	r16
      d8:	0e 94 70 12 	call	0x24e0	; 0x24e0 <printf>
          LED_PORT |= _BV(LED);
      dc:	2d 9a       	sbi	0x05, 5	; 5
          vTaskDelay(value / portTICK_PERIOD_MS);
      de:	89 81       	ldd	r24, Y+1	; 0x01
      e0:	9a 81       	ldd	r25, Y+2	; 0x02
      e2:	0e 94 08 05 	call	0xa10	; 0xa10 <vTaskDelay>
          LED_PORT &= ~_BV(LED);
      e6:	2d 98       	cbi	0x05, 5	; 5
          vTaskDelay(1000 / portTICK_PERIOD_MS);
      e8:	88 ee       	ldi	r24, 0xE8	; 232
      ea:	93 e0       	ldi	r25, 0x03	; 3
      ec:	0e 94 08 05 	call	0xa10	; 0xa10 <vTaskDelay>
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	0f 90       	pop	r0
      f8:	df cf       	rjmp	.-66     	; 0xb8 <vBlinkLed+0x12>

000000fa <vSerial>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
      fa:	cf 93       	push	r28
      fc:	df 93       	push	r29
      fe:	00 d0       	rcall	.+0      	; 0x100 <vSerial+0x6>
     100:	cd b7       	in	r28, 0x3d	; 61
     102:	de b7       	in	r29, 0x3e	; 62
     104:	6c 01       	movw	r12, r24
    uart_init();
     106:	0e 94 dd 11 	call	0x23ba	; 0x23ba <uart_init>
    stdin = stdout = stderr = &uart_file;
     10a:	80 e0       	ldi	r24, 0x00	; 0
     10c:	91 e0       	ldi	r25, 0x01	; 1
     10e:	90 93 b3 07 	sts	0x07B3, r25	; 0x8007b3 <__iob+0x5>
     112:	80 93 b2 07 	sts	0x07B2, r24	; 0x8007b2 <__iob+0x4>
     116:	90 93 b1 07 	sts	0x07B1, r25	; 0x8007b1 <__iob+0x3>
     11a:	80 93 b0 07 	sts	0x07B0, r24	; 0x8007b0 <__iob+0x2>
     11e:	90 93 af 07 	sts	0x07AF, r25	; 0x8007af <__iob+0x1>
     122:	80 93 ae 07 	sts	0x07AE, r24	; 0x8007ae <__iob>
        value = 0;
        input = getchar();
        //printf("%"PRIu16", input - '0');
        while (input >= '0' && input <= '9')
        {
          printf("%"PRIu16"", input - '0');
     126:	83 e1       	ldi	r24, 0x13	; 19
     128:	e8 2e       	mov	r14, r24
     12a:	81 e0       	ldi	r24, 0x01	; 1
     12c:	f8 2e       	mov	r15, r24
          value = value * 10 + (input - '0');
     12e:	9a e0       	ldi	r25, 0x0A	; 10
     130:	b9 2e       	mov	r11, r25
    QueueHandle_t xQueue = (QueueHandle_t)pvParameters;
    char input;
    uint16_t value;
    for ( ;; )
    {
        value = 0;
     132:	1a 82       	std	Y+2, r1	; 0x02
     134:	19 82       	std	Y+1, r1	; 0x01
        input = getchar();
     136:	80 91 ae 07 	lds	r24, 0x07AE	; 0x8007ae <__iob>
     13a:	90 91 af 07 	lds	r25, 0x07AF	; 0x8007af <__iob+0x1>
     13e:	0e 94 32 12 	call	0x2464	; 0x2464 <fgetc>
        //printf("%"PRIu16", input - '0');
        while (input >= '0' && input <= '9')
     142:	90 ed       	ldi	r25, 0xD0	; 208
     144:	98 0f       	add	r25, r24
     146:	9a 30       	cpi	r25, 0x0A	; 10
     148:	10 f5       	brcc	.+68     	; 0x18e <vSerial+0x94>
        {
          printf("%"PRIu16"", input - '0');
     14a:	08 2f       	mov	r16, r24
     14c:	88 0f       	add	r24, r24
     14e:	11 0b       	sbc	r17, r17
     150:	c8 01       	movw	r24, r16
     152:	c0 97       	sbiw	r24, 0x30	; 48
     154:	9f 93       	push	r25
     156:	8f 93       	push	r24
     158:	ff 92       	push	r15
     15a:	ef 92       	push	r14
     15c:	0e 94 70 12 	call	0x24e0	; 0x24e0 <printf>
          value = value * 10 + (input - '0');
     160:	29 81       	ldd	r18, Y+1	; 0x01
     162:	3a 81       	ldd	r19, Y+2	; 0x02
     164:	b2 9e       	mul	r11, r18
     166:	c0 01       	movw	r24, r0
     168:	b3 9e       	mul	r11, r19
     16a:	90 0d       	add	r25, r0
     16c:	11 24       	eor	r1, r1
     16e:	c0 97       	sbiw	r24, 0x30	; 48
     170:	08 0f       	add	r16, r24
     172:	19 1f       	adc	r17, r25
     174:	1a 83       	std	Y+2, r17	; 0x02
     176:	09 83       	std	Y+1, r16	; 0x01
          input = getchar();
     178:	80 91 ae 07 	lds	r24, 0x07AE	; 0x8007ae <__iob>
     17c:	90 91 af 07 	lds	r25, 0x07AF	; 0x8007af <__iob+0x1>
     180:	0e 94 32 12 	call	0x2464	; 0x2464 <fgetc>
     184:	0f 90       	pop	r0
     186:	0f 90       	pop	r0
     188:	0f 90       	pop	r0
     18a:	0f 90       	pop	r0
     18c:	da cf       	rjmp	.-76     	; 0x142 <vSerial+0x48>
        }
        printf("\r\n");
     18e:	8a e1       	ldi	r24, 0x1A	; 26
     190:	91 e0       	ldi	r25, 0x01	; 1
     192:	0e 94 86 12 	call	0x250c	; 0x250c <puts>
        if( xQueueSend( xQueue,
     196:	20 e0       	ldi	r18, 0x00	; 0
     198:	40 e0       	ldi	r20, 0x00	; 0
     19a:	50 e0       	ldi	r21, 0x00	; 0
     19c:	be 01       	movw	r22, r28
     19e:	6f 5f       	subi	r22, 0xFF	; 255
     1a0:	7f 4f       	sbci	r23, 0xFF	; 255
     1a2:	c6 01       	movw	r24, r12
     1a4:	0e 94 ee 09 	call	0x13dc	; 0x13dc <xQueueGenericSend>
     1a8:	81 30       	cpi	r24, 0x01	; 1
     1aa:	19 f2       	breq	.-122    	; 0x132 <vSerial+0x38>
                       ( void * ) &value,
                       ( TickType_t ) 0 ) != pdPASS )
        {
            printf("blad\r\n");
     1ac:	86 e1       	ldi	r24, 0x16	; 22
     1ae:	91 e0       	ldi	r25, 0x01	; 1
     1b0:	0e 94 86 12 	call	0x250c	; 0x250c <puts>
     1b4:	be cf       	rjmp	.-132    	; 0x132 <vSerial+0x38>

000001b6 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     1b6:	08 95       	ret

000001b8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1b8:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     1bc:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     1c0:	80 81       	ld	r24, Z
     1c2:	81 11       	cpse	r24, r1
     1c4:	03 c0       	rjmp	.+6      	; 0x1cc <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1c6:	8f ef       	ldi	r24, 0xFF	; 255
     1c8:	9f ef       	ldi	r25, 0xFF	; 255
     1ca:	0c c0       	rjmp	.+24     	; 0x1e4 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     1cc:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     1d0:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     1d4:	05 80       	ldd	r0, Z+5	; 0x05
     1d6:	f6 81       	ldd	r31, Z+6	; 0x06
     1d8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     1da:	06 80       	ldd	r0, Z+6	; 0x06
     1dc:	f7 81       	ldd	r31, Z+7	; 0x07
     1de:	e0 2d       	mov	r30, r0
     1e0:	82 81       	ldd	r24, Z+2	; 0x02
     1e2:	93 81       	ldd	r25, Z+3	; 0x03
     1e4:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <xNextTaskUnblockTime+0x1>
     1e8:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xNextTaskUnblockTime>
     1ec:	08 95       	ret

000001ee <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     1ee:	ff 92       	push	r15
     1f0:	0f 93       	push	r16
     1f2:	1f 93       	push	r17
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	ec 01       	movw	r28, r24
     1fa:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     1fc:	00 91 3b 01 	lds	r16, 0x013B	; 0x80013b <xTickCount>
     200:	10 91 3c 01 	lds	r17, 0x013C	; 0x80013c <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     204:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     208:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     20c:	02 96       	adiw	r24, 0x02	; 2
     20e:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     212:	cf 3f       	cpi	r28, 0xFF	; 255
     214:	8f ef       	ldi	r24, 0xFF	; 255
     216:	d8 07       	cpc	r29, r24
     218:	89 f4       	brne	.+34     	; 0x23c <prvAddCurrentTaskToDelayedList+0x4e>
     21a:	ff 20       	and	r15, r15
     21c:	79 f0       	breq	.+30     	; 0x23c <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     21e:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     222:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
     226:	6e 5f       	subi	r22, 0xFE	; 254
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	8e e3       	ldi	r24, 0x3E	; 62
     22c:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     22e:	df 91       	pop	r29
     230:	cf 91       	pop	r28
     232:	1f 91       	pop	r17
     234:	0f 91       	pop	r16
     236:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     238:	0c 94 da 0d 	jmp	0x1bb4	; 0x1bb4 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     23c:	c0 0f       	add	r28, r16
     23e:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     240:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     244:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     248:	d3 83       	std	Z+3, r29	; 0x03
     24a:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     24c:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     250:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     254:	c0 17       	cp	r28, r16
     256:	d1 07       	cpc	r29, r17
     258:	68 f4       	brcc	.+26     	; 0x274 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     25a:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <pxOverflowDelayedTaskList>
     25e:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     262:	6e 5f       	subi	r22, 0xFE	; 254
     264:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     266:	df 91       	pop	r29
     268:	cf 91       	pop	r28
     26a:	1f 91       	pop	r17
     26c:	0f 91       	pop	r16
     26e:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     270:	0c 94 fb 0d 	jmp	0x1bf6	; 0x1bf6 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     274:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <pxDelayedTaskList>
     278:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     27c:	6e 5f       	subi	r22, 0xFE	; 254
     27e:	7f 4f       	sbci	r23, 0xFF	; 255
     280:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     284:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xNextTaskUnblockTime>
     288:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <xNextTaskUnblockTime+0x1>
     28c:	c8 17       	cp	r28, r24
     28e:	d9 07       	cpc	r29, r25
     290:	20 f4       	brcc	.+8      	; 0x29a <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     292:	d0 93 34 01 	sts	0x0134, r29	; 0x800134 <xNextTaskUnblockTime+0x1>
     296:	c0 93 33 01 	sts	0x0133, r28	; 0x800133 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     29a:	df 91       	pop	r29
     29c:	cf 91       	pop	r28
     29e:	1f 91       	pop	r17
     2a0:	0f 91       	pop	r16
     2a2:	ff 90       	pop	r15
     2a4:	08 95       	ret

000002a6 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     2a6:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     2aa:	88 23       	and	r24, r24
     2ac:	09 f1       	breq	.+66     	; 0x2f0 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     2ae:	0f b6       	in	r0, 0x3f	; 63
     2b0:	f8 94       	cli
     2b2:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2b4:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <xTasksWaitingTermination+0x5>
     2b8:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <xTasksWaitingTermination+0x6>
     2bc:	c6 81       	ldd	r28, Z+6	; 0x06
     2be:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     2c0:	ce 01       	movw	r24, r28
     2c2:	02 96       	adiw	r24, 0x02	; 2
     2c4:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
				--uxCurrentNumberOfTasks;
     2c8:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     2cc:	81 50       	subi	r24, 0x01	; 1
     2ce:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     2d2:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     2d6:	81 50       	subi	r24, 0x01	; 1
     2d8:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     2dc:	0f 90       	pop	r0
     2de:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     2e0:	8f 89       	ldd	r24, Y+23	; 0x17
     2e2:	98 8d       	ldd	r25, Y+24	; 0x18
     2e4:	0e 94 4f 10 	call	0x209e	; 0x209e <vPortFree>
			vPortFree( pxTCB );
     2e8:	ce 01       	movw	r24, r28
     2ea:	0e 94 4f 10 	call	0x209e	; 0x209e <vPortFree>
     2ee:	db cf       	rjmp	.-74     	; 0x2a6 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     2f0:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <pxReadyTasksLists>
     2f4:	82 30       	cpi	r24, 0x02	; 2
     2f6:	10 f0       	brcs	.+4      	; 0x2fc <prvIdleTask+0x56>
			{
				taskYIELD();
     2f8:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     2fc:	0e 94 db 00 	call	0x1b6	; 0x1b6 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     300:	d2 cf       	rjmp	.-92     	; 0x2a6 <prvIdleTask>

00000302 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     302:	3f 92       	push	r3
     304:	4f 92       	push	r4
     306:	5f 92       	push	r5
     308:	6f 92       	push	r6
     30a:	7f 92       	push	r7
     30c:	8f 92       	push	r8
     30e:	9f 92       	push	r9
     310:	af 92       	push	r10
     312:	bf 92       	push	r11
     314:	cf 92       	push	r12
     316:	df 92       	push	r13
     318:	ef 92       	push	r14
     31a:	ff 92       	push	r15
     31c:	0f 93       	push	r16
     31e:	1f 93       	push	r17
     320:	cf 93       	push	r28
     322:	df 93       	push	r29
     324:	4c 01       	movw	r8, r24
     326:	16 2f       	mov	r17, r22
     328:	37 2e       	mov	r3, r23
     32a:	6a 01       	movw	r12, r20
     32c:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     32e:	ca 01       	movw	r24, r20
     330:	0e 94 1d 10 	call	0x203a	; 0x203a <pvPortMalloc>
     334:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     336:	89 2b       	or	r24, r25
     338:	09 f4       	brne	.+2      	; 0x33c <xTaskCreate+0x3a>
     33a:	d1 c0       	rjmp	.+418    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     33c:	86 e2       	ldi	r24, 0x26	; 38
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	0e 94 1d 10 	call	0x203a	; 0x203a <pvPortMalloc>
     344:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     346:	89 2b       	or	r24, r25
     348:	79 f0       	breq	.+30     	; 0x368 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     34a:	58 8e       	std	Y+24, r5	; 0x18
     34c:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     34e:	c6 01       	movw	r24, r12
     350:	01 97       	sbiw	r24, 0x01	; 1
     352:	32 01       	movw	r6, r4
     354:	68 0e       	add	r6, r24
     356:	79 1e       	adc	r7, r25
     358:	be 01       	movw	r22, r28
     35a:	67 5e       	subi	r22, 0xE7	; 231
     35c:	7f 4f       	sbci	r23, 0xFF	; 255
     35e:	e1 2f       	mov	r30, r17
     360:	f3 2d       	mov	r31, r3
     362:	cf 01       	movw	r24, r30
     364:	08 96       	adiw	r24, 0x08	; 8
     366:	07 c0       	rjmp	.+14     	; 0x376 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     368:	c2 01       	movw	r24, r4
     36a:	0e 94 4f 10 	call	0x209e	; 0x209e <vPortFree>
     36e:	b7 c0       	rjmp	.+366    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     370:	e8 17       	cp	r30, r24
     372:	f9 07       	cpc	r31, r25
     374:	49 f0       	breq	.+18     	; 0x388 <xTaskCreate+0x86>
     376:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     378:	41 91       	ld	r20, Z+
     37a:	db 01       	movw	r26, r22
     37c:	4d 93       	st	X+, r20
     37e:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     380:	d9 01       	movw	r26, r18
     382:	2c 91       	ld	r18, X
     384:	21 11       	cpse	r18, r1
     386:	f4 cf       	rjmp	.-24     	; 0x370 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     388:	18 a2       	std	Y+32, r1	; 0x20
     38a:	04 30       	cpi	r16, 0x04	; 4
     38c:	08 f0       	brcs	.+2      	; 0x390 <xTaskCreate+0x8e>
     38e:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     390:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     392:	6e 01       	movw	r12, r28
     394:	b2 e0       	ldi	r27, 0x02	; 2
     396:	cb 0e       	add	r12, r27
     398:	d1 1c       	adc	r13, r1
     39a:	c6 01       	movw	r24, r12
     39c:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     3a0:	ce 01       	movw	r24, r28
     3a2:	0c 96       	adiw	r24, 0x0c	; 12
     3a4:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     3a8:	d9 87       	std	Y+9, r29	; 0x09
     3aa:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     3ac:	84 e0       	ldi	r24, 0x04	; 4
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	80 1b       	sub	r24, r16
     3b2:	91 09       	sbc	r25, r1
     3b4:	9d 87       	std	Y+13, r25	; 0x0d
     3b6:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     3b8:	db 8b       	std	Y+19, r29	; 0x13
     3ba:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     3bc:	19 a2       	std	Y+33, r1	; 0x21
     3be:	1a a2       	std	Y+34, r1	; 0x22
     3c0:	1b a2       	std	Y+35, r1	; 0x23
     3c2:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     3c4:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     3c6:	a5 01       	movw	r20, r10
     3c8:	b4 01       	movw	r22, r8
     3ca:	c3 01       	movw	r24, r6
     3cc:	0e 94 5e 10 	call	0x20bc	; 0x20bc <pxPortInitialiseStack>
     3d0:	99 83       	std	Y+1, r25	; 0x01
     3d2:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     3d4:	e1 14       	cp	r14, r1
     3d6:	f1 04       	cpc	r15, r1
     3d8:	19 f0       	breq	.+6      	; 0x3e0 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     3da:	f7 01       	movw	r30, r14
     3dc:	d1 83       	std	Z+1, r29	; 0x01
     3de:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	f8 94       	cli
     3e4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     3e6:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     3ea:	8f 5f       	subi	r24, 0xFF	; 255
     3ec:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     3f0:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     3f4:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     3f8:	89 2b       	or	r24, r25
     3fa:	d1 f5       	brne	.+116    	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     3fc:	d0 93 2f 01 	sts	0x012F, r29	; 0x80012f <__data_end+0x1>
     400:	c0 93 2e 01 	sts	0x012E, r28	; 0x80012e <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     404:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     408:	81 30       	cpi	r24, 0x01	; 1
     40a:	09 f0       	breq	.+2      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     40c:	41 c0       	rjmp	.+130    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     40e:	80 e7       	ldi	r24, 0x70	; 112
     410:	91 e0       	ldi	r25, 0x01	; 1
     412:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
     416:	89 e7       	ldi	r24, 0x79	; 121
     418:	91 e0       	ldi	r25, 0x01	; 1
     41a:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
     41e:	82 e8       	ldi	r24, 0x82	; 130
     420:	91 e0       	ldi	r25, 0x01	; 1
     422:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
     426:	8b e8       	ldi	r24, 0x8B	; 139
     428:	91 e0       	ldi	r25, 0x01	; 1
     42a:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     42e:	87 e6       	ldi	r24, 0x67	; 103
     430:	91 e0       	ldi	r25, 0x01	; 1
     432:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     436:	8e e5       	ldi	r24, 0x5E	; 94
     438:	91 e0       	ldi	r25, 0x01	; 1
     43a:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     43e:	81 e5       	ldi	r24, 0x51	; 81
     440:	91 e0       	ldi	r25, 0x01	; 1
     442:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     446:	88 e4       	ldi	r24, 0x48	; 72
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     44e:	8e e3       	ldi	r24, 0x3E	; 62
     450:	91 e0       	ldi	r25, 0x01	; 1
     452:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     456:	87 e6       	ldi	r24, 0x67	; 103
     458:	91 e0       	ldi	r25, 0x01	; 1
     45a:	90 93 5d 01 	sts	0x015D, r25	; 0x80015d <pxDelayedTaskList+0x1>
     45e:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     462:	8e e5       	ldi	r24, 0x5E	; 94
     464:	91 e0       	ldi	r25, 0x01	; 1
     466:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     46a:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <pxOverflowDelayedTaskList>
     46e:	10 c0       	rjmp	.+32     	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     470:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     474:	81 11       	cpse	r24, r1
     476:	0c c0       	rjmp	.+24     	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     478:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     47c:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     480:	96 89       	ldd	r25, Z+22	; 0x16
     482:	8e 89       	ldd	r24, Y+22	; 0x16
     484:	89 17       	cp	r24, r25
     486:	20 f0       	brcs	.+8      	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
				{
					pxCurrentTCB = pxNewTCB;
     488:	d0 93 2f 01 	sts	0x012F, r29	; 0x80012f <__data_end+0x1>
     48c:	c0 93 2e 01 	sts	0x012E, r28	; 0x80012e <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     490:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxTaskNumber>
     494:	8f 5f       	subi	r24, 0xFF	; 255
     496:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     49a:	8e 89       	ldd	r24, Y+22	; 0x16
     49c:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     4a0:	98 17       	cp	r25, r24
     4a2:	10 f4       	brcc	.+4      	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
     4a4:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     4a8:	f9 e0       	ldi	r31, 0x09	; 9
     4aa:	8f 9f       	mul	r24, r31
     4ac:	c0 01       	movw	r24, r0
     4ae:	11 24       	eor	r1, r1
     4b0:	b6 01       	movw	r22, r12
     4b2:	80 59       	subi	r24, 0x90	; 144
     4b4:	9e 4f       	sbci	r25, 0xFE	; 254
     4b6:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     4ba:	0f 90       	pop	r0
     4bc:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     4be:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     4c2:	88 23       	and	r24, r24
     4c4:	51 f0       	breq	.+20     	; 0x4da <__LOCK_REGION_LENGTH__+0xda>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     4c6:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     4ca:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     4ce:	96 89       	ldd	r25, Z+22	; 0x16
     4d0:	8e 89       	ldd	r24, Y+22	; 0x16
     4d2:	98 17       	cp	r25, r24
     4d4:	10 f4       	brcc	.+4      	; 0x4da <__LOCK_REGION_LENGTH__+0xda>
		{
			taskYIELD_IF_USING_PREEMPTION();
     4d6:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	01 c0       	rjmp	.+2      	; 0x4e0 <__LOCK_REGION_LENGTH__+0xe0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     4de:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     4e0:	df 91       	pop	r29
     4e2:	cf 91       	pop	r28
     4e4:	1f 91       	pop	r17
     4e6:	0f 91       	pop	r16
     4e8:	ff 90       	pop	r15
     4ea:	ef 90       	pop	r14
     4ec:	df 90       	pop	r13
     4ee:	cf 90       	pop	r12
     4f0:	bf 90       	pop	r11
     4f2:	af 90       	pop	r10
     4f4:	9f 90       	pop	r9
     4f6:	8f 90       	pop	r8
     4f8:	7f 90       	pop	r7
     4fa:	6f 90       	pop	r6
     4fc:	5f 90       	pop	r5
     4fe:	4f 90       	pop	r4
     500:	3f 90       	pop	r3
     502:	08 95       	ret

00000504 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     504:	0f 93       	push	r16
     506:	1f 93       	push	r17
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     514:	89 2b       	or	r24, r25
     516:	21 f4       	brne	.+8      	; 0x520 <vTaskDelete+0x1c>
     518:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <__data_end>
     51c:	d0 91 2f 01 	lds	r29, 0x012F	; 0x80012f <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     520:	8e 01       	movw	r16, r28
     522:	0e 5f       	subi	r16, 0xFE	; 254
     524:	1f 4f       	sbci	r17, 0xFF	; 255
     526:	c8 01       	movw	r24, r16
     528:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     52c:	8c 89       	ldd	r24, Y+20	; 0x14
     52e:	9d 89       	ldd	r25, Y+21	; 0x15
     530:	89 2b       	or	r24, r25
     532:	21 f0       	breq	.+8      	; 0x53c <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     534:	ce 01       	movw	r24, r28
     536:	0c 96       	adiw	r24, 0x0c	; 12
     538:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     53c:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxTaskNumber>
     540:	8f 5f       	subi	r24, 0xFF	; 255
     542:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     546:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     54a:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     54e:	c8 17       	cp	r28, r24
     550:	d9 07       	cpc	r29, r25
     552:	59 f4       	brne	.+22     	; 0x56a <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     554:	b8 01       	movw	r22, r16
     556:	88 e4       	ldi	r24, 0x48	; 72
     558:	91 e0       	ldi	r25, 0x01	; 1
     55a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     55e:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     562:	8f 5f       	subi	r24, 0xFF	; 255
     564:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     568:	0e c0       	rjmp	.+28     	; 0x586 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     56a:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     56e:	81 50       	subi	r24, 0x01	; 1
     570:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     574:	8f 89       	ldd	r24, Y+23	; 0x17
     576:	98 8d       	ldd	r25, Y+24	; 0x18
     578:	0e 94 4f 10 	call	0x209e	; 0x209e <vPortFree>
			vPortFree( pxTCB );
     57c:	ce 01       	movw	r24, r28
     57e:	0e 94 4f 10 	call	0x209e	; 0x209e <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     582:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     586:	0f 90       	pop	r0
     588:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     58a:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     58e:	88 23       	and	r24, r24
     590:	49 f0       	breq	.+18     	; 0x5a4 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     592:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     596:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     59a:	c8 17       	cp	r28, r24
     59c:	d9 07       	cpc	r29, r25
     59e:	11 f4       	brne	.+4      	; 0x5a4 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     5a0:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     5a4:	df 91       	pop	r29
     5a6:	cf 91       	pop	r28
     5a8:	1f 91       	pop	r17
     5aa:	0f 91       	pop	r16
     5ac:	08 95       	ret

000005ae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     5b6:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <__data_end>
     5ba:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <__data_end+0x1>
     5be:	82 17       	cp	r24, r18
     5c0:	93 07       	cpc	r25, r19
     5c2:	b9 f1       	breq	.+110    	; 0x632 <vTaskResume+0x84>
     5c4:	00 97       	sbiw	r24, 0x00	; 0
     5c6:	a9 f1       	breq	.+106    	; 0x632 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     5c8:	0f b6       	in	r0, 0x3f	; 63
     5ca:	f8 94       	cli
     5cc:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     5ce:	fc 01       	movw	r30, r24
     5d0:	22 85       	ldd	r18, Z+10	; 0x0a
     5d2:	33 85       	ldd	r19, Z+11	; 0x0b
     5d4:	2e 53       	subi	r18, 0x3E	; 62
     5d6:	31 40       	sbci	r19, 0x01	; 1
     5d8:	51 f5       	brne	.+84     	; 0x62e <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     5da:	fc 01       	movw	r30, r24
     5dc:	24 89       	ldd	r18, Z+20	; 0x14
     5de:	35 89       	ldd	r19, Z+21	; 0x15
     5e0:	f1 e0       	ldi	r31, 0x01	; 1
     5e2:	21 35       	cpi	r18, 0x51	; 81
     5e4:	3f 07       	cpc	r19, r31
     5e6:	19 f1       	breq	.+70     	; 0x62e <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     5e8:	23 2b       	or	r18, r19
     5ea:	09 f5       	brne	.+66     	; 0x62e <vTaskResume+0x80>
     5ec:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     5ee:	8c 01       	movw	r16, r24
     5f0:	0e 5f       	subi	r16, 0xFE	; 254
     5f2:	1f 4f       	sbci	r17, 0xFF	; 255
     5f4:	c8 01       	movw	r24, r16
     5f6:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     5fa:	8e 89       	ldd	r24, Y+22	; 0x16
     5fc:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     600:	98 17       	cp	r25, r24
     602:	10 f4       	brcc	.+4      	; 0x608 <vTaskResume+0x5a>
     604:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     608:	29 e0       	ldi	r18, 0x09	; 9
     60a:	82 9f       	mul	r24, r18
     60c:	c0 01       	movw	r24, r0
     60e:	11 24       	eor	r1, r1
     610:	b8 01       	movw	r22, r16
     612:	80 59       	subi	r24, 0x90	; 144
     614:	9e 4f       	sbci	r25, 0xFE	; 254
     616:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     61a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     61e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     622:	9e 89       	ldd	r25, Y+22	; 0x16
     624:	86 89       	ldd	r24, Z+22	; 0x16
     626:	98 17       	cp	r25, r24
     628:	10 f0       	brcs	.+4      	; 0x62e <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     62a:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     62e:	0f 90       	pop	r0
     630:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     632:	df 91       	pop	r29
     634:	cf 91       	pop	r28
     636:	1f 91       	pop	r17
     638:	0f 91       	pop	r16
     63a:	08 95       	ret

0000063c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     63c:	ef 92       	push	r14
     63e:	ff 92       	push	r15
     640:	1f 93       	push	r17
     642:	cf 93       	push	r28
     644:	df 93       	push	r29
     646:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     648:	8a 85       	ldd	r24, Y+10	; 0x0a
     64a:	9b 85       	ldd	r25, Y+11	; 0x0b
     64c:	8e 53       	subi	r24, 0x3E	; 62
     64e:	91 40       	sbci	r25, 0x01	; 1
     650:	99 f4       	brne	.+38     	; 0x678 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     652:	8c 89       	ldd	r24, Y+20	; 0x14
     654:	9d 89       	ldd	r25, Y+21	; 0x15
     656:	21 e0       	ldi	r18, 0x01	; 1
     658:	81 35       	cpi	r24, 0x51	; 81
     65a:	92 07       	cpc	r25, r18
     65c:	69 f0       	breq	.+26     	; 0x678 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     65e:	89 2b       	or	r24, r25
     660:	59 f4       	brne	.+22     	; 0x678 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     662:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     666:	88 23       	and	r24, r24
     668:	49 f0       	breq	.+18     	; 0x67c <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     66a:	be 01       	movw	r22, r28
     66c:	64 5f       	subi	r22, 0xF4	; 244
     66e:	7f 4f       	sbci	r23, 0xFF	; 255
     670:	81 e5       	ldi	r24, 0x51	; 81
     672:	91 e0       	ldi	r25, 0x01	; 1
     674:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     678:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     67a:	21 c0       	rjmp	.+66     	; 0x6be <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     67c:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     680:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     684:	11 e0       	ldi	r17, 0x01	; 1
     686:	9e 89       	ldd	r25, Y+22	; 0x16
     688:	86 89       	ldd	r24, Z+22	; 0x16
     68a:	98 17       	cp	r25, r24
     68c:	08 f4       	brcc	.+2      	; 0x690 <xTaskResumeFromISR+0x54>
     68e:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     690:	7e 01       	movw	r14, r28
     692:	82 e0       	ldi	r24, 0x02	; 2
     694:	e8 0e       	add	r14, r24
     696:	f1 1c       	adc	r15, r1
     698:	c7 01       	movw	r24, r14
     69a:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     69e:	8e 89       	ldd	r24, Y+22	; 0x16
     6a0:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     6a4:	98 17       	cp	r25, r24
     6a6:	10 f4       	brcc	.+4      	; 0x6ac <xTaskResumeFromISR+0x70>
     6a8:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     6ac:	29 e0       	ldi	r18, 0x09	; 9
     6ae:	82 9f       	mul	r24, r18
     6b0:	c0 01       	movw	r24, r0
     6b2:	11 24       	eor	r1, r1
     6b4:	b7 01       	movw	r22, r14
     6b6:	80 59       	subi	r24, 0x90	; 144
     6b8:	9e 4f       	sbci	r25, 0xFE	; 254
     6ba:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     6be:	81 2f       	mov	r24, r17
     6c0:	df 91       	pop	r29
     6c2:	cf 91       	pop	r28
     6c4:	1f 91       	pop	r17
     6c6:	ff 90       	pop	r15
     6c8:	ef 90       	pop	r14
     6ca:	08 95       	ret

000006cc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     6d2:	81 e3       	ldi	r24, 0x31	; 49
     6d4:	e8 2e       	mov	r14, r24
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	f8 2e       	mov	r15, r24
     6da:	00 e0       	ldi	r16, 0x00	; 0
     6dc:	20 e0       	ldi	r18, 0x00	; 0
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	45 e5       	ldi	r20, 0x55	; 85
     6e2:	50 e0       	ldi	r21, 0x00	; 0
     6e4:	69 e2       	ldi	r22, 0x29	; 41
     6e6:	71 e0       	ldi	r23, 0x01	; 1
     6e8:	83 e5       	ldi	r24, 0x53	; 83
     6ea:	91 e0       	ldi	r25, 0x01	; 1
     6ec:	0e 94 81 01 	call	0x302	; 0x302 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     6f0:	81 30       	cpi	r24, 0x01	; 1
     6f2:	91 f4       	brne	.+36     	; 0x718 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     6f4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     6f6:	2f ef       	ldi	r18, 0xFF	; 255
     6f8:	3f ef       	ldi	r19, 0xFF	; 255
     6fa:	30 93 34 01 	sts	0x0134, r19	; 0x800134 <xNextTaskUnblockTime+0x1>
     6fe:	20 93 33 01 	sts	0x0133, r18	; 0x800133 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     702:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     706:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <xTickCount+0x1>
     70a:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     70e:	0f 91       	pop	r16
     710:	ff 90       	pop	r15
     712:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     714:	0c 94 ca 10 	jmp	0x2194	; 0x2194 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     718:	0f 91       	pop	r16
     71a:	ff 90       	pop	r15
     71c:	ef 90       	pop	r14
     71e:	08 95       	ret

00000720 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     720:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     722:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <xSchedulerRunning>
	vPortEndScheduler();
     726:	0c 94 0a 11 	jmp	0x2214	; 0x2214 <vPortEndScheduler>

0000072a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     72a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     72e:	8f 5f       	subi	r24, 0xFF	; 255
     730:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxSchedulerSuspended>
     734:	08 95       	ret

00000736 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     736:	0f b6       	in	r0, 0x3f	; 63
     738:	f8 94       	cli
     73a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     73c:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xTickCount>
     740:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     744:	0f 90       	pop	r0
     746:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     748:	08 95       	ret

0000074a <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     74a:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xTickCount>
     74e:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     752:	08 95       	ret

00000754 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     754:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
}
     758:	08 95       	ret

0000075a <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     75a:	00 97       	sbiw	r24, 0x00	; 0
     75c:	21 f4       	brne	.+8      	; 0x766 <pcTaskGetName+0xc>
     75e:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     762:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     766:	49 96       	adiw	r24, 0x19	; 25
     768:	08 95       	ret

0000076a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     76a:	cf 92       	push	r12
     76c:	df 92       	push	r13
     76e:	ef 92       	push	r14
     770:	ff 92       	push	r15
     772:	0f 93       	push	r16
     774:	1f 93       	push	r17
     776:	cf 93       	push	r28
     778:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     77a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     77e:	81 11       	cpse	r24, r1
     780:	8c c0       	rjmp	.+280    	; 0x89a <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     782:	00 91 3b 01 	lds	r16, 0x013B	; 0x80013b <xTickCount>
     786:	10 91 3c 01 	lds	r17, 0x013C	; 0x80013c <xTickCount+0x1>
     78a:	0f 5f       	subi	r16, 0xFF	; 255
     78c:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     78e:	10 93 3c 01 	sts	0x013C, r17	; 0x80013c <xTickCount+0x1>
     792:	00 93 3b 01 	sts	0x013B, r16	; 0x80013b <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     796:	01 15       	cp	r16, r1
     798:	11 05       	cpc	r17, r1
     79a:	b9 f4       	brne	.+46     	; 0x7ca <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     79c:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <pxDelayedTaskList>
     7a0:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     7a4:	20 91 5a 01 	lds	r18, 0x015A	; 0x80015a <pxOverflowDelayedTaskList>
     7a8:	30 91 5b 01 	lds	r19, 0x015B	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     7ac:	30 93 5d 01 	sts	0x015D, r19	; 0x80015d <pxDelayedTaskList+0x1>
     7b0:	20 93 5c 01 	sts	0x015C, r18	; 0x80015c <pxDelayedTaskList>
     7b4:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     7b8:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <pxOverflowDelayedTaskList>
     7bc:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <xNumOfOverflows>
     7c0:	8f 5f       	subi	r24, 0xFF	; 255
     7c2:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <xNumOfOverflows>
     7c6:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     7ca:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xNextTaskUnblockTime>
     7ce:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <xNextTaskUnblockTime+0x1>
     7d2:	c0 e0       	ldi	r28, 0x00	; 0
     7d4:	08 17       	cp	r16, r24
     7d6:	19 07       	cpc	r17, r25
     7d8:	08 f4       	brcc	.+2      	; 0x7dc <xTaskIncrementTick+0x72>
     7da:	4f c0       	rjmp	.+158    	; 0x87a <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     7dc:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     7de:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     7e2:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     7e6:	80 81       	ld	r24, Z
     7e8:	81 11       	cpse	r24, r1
     7ea:	03 c0       	rjmp	.+6      	; 0x7f2 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7ec:	8f ef       	ldi	r24, 0xFF	; 255
     7ee:	9f ef       	ldi	r25, 0xFF	; 255
     7f0:	11 c0       	rjmp	.+34     	; 0x814 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     7f2:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     7f6:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     7fa:	05 80       	ldd	r0, Z+5	; 0x05
     7fc:	f6 81       	ldd	r31, Z+6	; 0x06
     7fe:	e0 2d       	mov	r30, r0
     800:	e6 80       	ldd	r14, Z+6	; 0x06
     802:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     804:	d7 01       	movw	r26, r14
     806:	12 96       	adiw	r26, 0x02	; 2
     808:	8d 91       	ld	r24, X+
     80a:	9c 91       	ld	r25, X
     80c:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     80e:	08 17       	cp	r16, r24
     810:	19 07       	cpc	r17, r25
     812:	28 f4       	brcc	.+10     	; 0x81e <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     814:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <xNextTaskUnblockTime+0x1>
     818:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     81c:	2e c0       	rjmp	.+92     	; 0x87a <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     81e:	67 01       	movw	r12, r14
     820:	b2 e0       	ldi	r27, 0x02	; 2
     822:	cb 0e       	add	r12, r27
     824:	d1 1c       	adc	r13, r1
     826:	c6 01       	movw	r24, r12
     828:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     82c:	f7 01       	movw	r30, r14
     82e:	84 89       	ldd	r24, Z+20	; 0x14
     830:	95 89       	ldd	r25, Z+21	; 0x15
     832:	89 2b       	or	r24, r25
     834:	21 f0       	breq	.+8      	; 0x83e <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     836:	c7 01       	movw	r24, r14
     838:	0c 96       	adiw	r24, 0x0c	; 12
     83a:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     83e:	d7 01       	movw	r26, r14
     840:	56 96       	adiw	r26, 0x16	; 22
     842:	8c 91       	ld	r24, X
     844:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     848:	98 17       	cp	r25, r24
     84a:	10 f4       	brcc	.+4      	; 0x850 <xTaskIncrementTick+0xe6>
     84c:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     850:	d8 9f       	mul	r29, r24
     852:	c0 01       	movw	r24, r0
     854:	11 24       	eor	r1, r1
     856:	b6 01       	movw	r22, r12
     858:	80 59       	subi	r24, 0x90	; 144
     85a:	9e 4f       	sbci	r25, 0xFE	; 254
     85c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     860:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     864:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     868:	d7 01       	movw	r26, r14
     86a:	56 96       	adiw	r26, 0x16	; 22
     86c:	9c 91       	ld	r25, X
     86e:	86 89       	ldd	r24, Z+22	; 0x16
     870:	98 17       	cp	r25, r24
     872:	08 f4       	brcc	.+2      	; 0x876 <xTaskIncrementTick+0x10c>
     874:	b4 cf       	rjmp	.-152    	; 0x7de <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     876:	c1 e0       	ldi	r28, 0x01	; 1
     878:	b2 cf       	rjmp	.-156    	; 0x7de <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     87a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     87e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     882:	e6 89       	ldd	r30, Z+22	; 0x16
     884:	b9 e0       	ldi	r27, 0x09	; 9
     886:	eb 9f       	mul	r30, r27
     888:	f0 01       	movw	r30, r0
     88a:	11 24       	eor	r1, r1
     88c:	e0 59       	subi	r30, 0x90	; 144
     88e:	fe 4f       	sbci	r31, 0xFE	; 254
     890:	80 81       	ld	r24, Z
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	40 f0       	brcs	.+16     	; 0x8a6 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     896:	c1 e0       	ldi	r28, 0x01	; 1
     898:	06 c0       	rjmp	.+12     	; 0x8a6 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     89a:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <uxPendedTicks>
     89e:	8f 5f       	subi	r24, 0xFF	; 255
     8a0:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     8a4:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     8a6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <xYieldPending>
     8aa:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     8ac:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     8ae:	8c 2f       	mov	r24, r28
     8b0:	df 91       	pop	r29
     8b2:	cf 91       	pop	r28
     8b4:	1f 91       	pop	r17
     8b6:	0f 91       	pop	r16
     8b8:	ff 90       	pop	r15
     8ba:	ef 90       	pop	r14
     8bc:	df 90       	pop	r13
     8be:	cf 90       	pop	r12
     8c0:	08 95       	ret

000008c2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     8c2:	ef 92       	push	r14
     8c4:	ff 92       	push	r15
     8c6:	0f 93       	push	r16
     8c8:	1f 93       	push	r17
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     8ce:	0f b6       	in	r0, 0x3f	; 63
     8d0:	f8 94       	cli
     8d2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     8d4:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     8d8:	81 50       	subi	r24, 0x01	; 1
     8da:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8de:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     8e2:	88 23       	and	r24, r24
     8e4:	11 f0       	breq	.+4      	; 0x8ea <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	52 c0       	rjmp	.+164    	; 0x98e <__stack+0x8f>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     8ea:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     8ee:	88 23       	and	r24, r24
     8f0:	d1 f3       	breq	.-12     	; 0x8e6 <xTaskResumeAll+0x24>
     8f2:	c0 e0       	ldi	r28, 0x00	; 0
     8f4:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     8f6:	89 e0       	ldi	r24, 0x09	; 9
     8f8:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     8fa:	ee 24       	eor	r14, r14
     8fc:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     8fe:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <xPendingReadyList>
     902:	88 23       	and	r24, r24
     904:	51 f1       	breq	.+84     	; 0x95a <__stack+0x5b>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     906:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <xPendingReadyList+0x5>
     90a:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <xPendingReadyList+0x6>
     90e:	c6 81       	ldd	r28, Z+6	; 0x06
     910:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     912:	ce 01       	movw	r24, r28
     914:	0c 96       	adiw	r24, 0x0c	; 12
     916:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     91a:	8e 01       	movw	r16, r28
     91c:	0e 5f       	subi	r16, 0xFE	; 254
     91e:	1f 4f       	sbci	r17, 0xFF	; 255
     920:	c8 01       	movw	r24, r16
     922:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     926:	8e 89       	ldd	r24, Y+22	; 0x16
     928:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     92c:	98 17       	cp	r25, r24
     92e:	10 f4       	brcc	.+4      	; 0x934 <__stack+0x35>
     930:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     934:	f8 9e       	mul	r15, r24
     936:	c0 01       	movw	r24, r0
     938:	11 24       	eor	r1, r1
     93a:	b8 01       	movw	r22, r16
     93c:	80 59       	subi	r24, 0x90	; 144
     93e:	9e 4f       	sbci	r25, 0xFE	; 254
     940:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     944:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     948:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     94c:	9e 89       	ldd	r25, Y+22	; 0x16
     94e:	86 89       	ldd	r24, Z+22	; 0x16
     950:	98 17       	cp	r25, r24
     952:	a8 f2       	brcs	.-86     	; 0x8fe <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     954:	e0 92 37 01 	sts	0x0137, r14	; 0x800137 <xYieldPending>
     958:	d2 cf       	rjmp	.-92     	; 0x8fe <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     95a:	cd 2b       	or	r28, r29
     95c:	11 f0       	breq	.+4      	; 0x962 <__stack+0x63>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     95e:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     962:	c0 91 38 01 	lds	r28, 0x0138	; 0x800138 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     966:	cc 23       	and	r28, r28
     968:	51 f0       	breq	.+20     	; 0x97e <__stack+0x7f>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     96a:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     96c:	0e 94 b5 03 	call	0x76a	; 0x76a <xTaskIncrementTick>
     970:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     972:	d0 93 37 01 	sts	0x0137, r29	; 0x800137 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     976:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     978:	c9 f7       	brne	.-14     	; 0x96c <__stack+0x6d>

						uxPendedTicks = 0;
     97a:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     97e:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <xYieldPending>
     982:	88 23       	and	r24, r24
     984:	09 f4       	brne	.+2      	; 0x988 <__stack+0x89>
     986:	af cf       	rjmp	.-162    	; 0x8e6 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     988:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     98c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     98e:	0f 90       	pop	r0
     990:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     992:	df 91       	pop	r29
     994:	cf 91       	pop	r28
     996:	1f 91       	pop	r17
     998:	0f 91       	pop	r16
     99a:	ff 90       	pop	r15
     99c:	ef 90       	pop	r14
     99e:	08 95       	ret

000009a0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     9a0:	0f 93       	push	r16
     9a2:	1f 93       	push	r17
     9a4:	cf 93       	push	r28
     9a6:	df 93       	push	r29
     9a8:	8c 01       	movw	r16, r24
     9aa:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     9ac:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     9b0:	40 91 3b 01 	lds	r20, 0x013B	; 0x80013b <xTickCount>
     9b4:	50 91 3c 01 	lds	r21, 0x013C	; 0x80013c <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     9b8:	f8 01       	movw	r30, r16
     9ba:	20 81       	ld	r18, Z
     9bc:	31 81       	ldd	r19, Z+1	; 0x01
     9be:	c9 01       	movw	r24, r18
     9c0:	8c 0f       	add	r24, r28
     9c2:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     9c4:	42 17       	cp	r20, r18
     9c6:	53 07       	cpc	r21, r19
     9c8:	20 f4       	brcc	.+8      	; 0x9d2 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     9ca:	82 17       	cp	r24, r18
     9cc:	93 07       	cpc	r25, r19
     9ce:	40 f4       	brcc	.+16     	; 0x9e0 <vTaskDelayUntil+0x40>
     9d0:	03 c0       	rjmp	.+6      	; 0x9d8 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     9d2:	82 17       	cp	r24, r18
     9d4:	93 07       	cpc	r25, r19
     9d6:	30 f0       	brcs	.+12     	; 0x9e4 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     9d8:	21 e0       	ldi	r18, 0x01	; 1
     9da:	48 17       	cp	r20, r24
     9dc:	59 07       	cpc	r21, r25
     9de:	18 f0       	brcs	.+6      	; 0x9e6 <vTaskDelayUntil+0x46>
     9e0:	20 e0       	ldi	r18, 0x00	; 0
     9e2:	01 c0       	rjmp	.+2      	; 0x9e6 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     9e4:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     9e6:	f8 01       	movw	r30, r16
     9e8:	91 83       	std	Z+1, r25	; 0x01
     9ea:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     9ec:	22 23       	and	r18, r18
     9ee:	29 f0       	breq	.+10     	; 0x9fa <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	84 1b       	sub	r24, r20
     9f4:	95 0b       	sbc	r25, r21
     9f6:	0e 94 f7 00 	call	0x1ee	; 0x1ee <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     9fa:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9fe:	81 11       	cpse	r24, r1
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a02:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
     a14:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     a16:	89 2b       	or	r24, r25
     a18:	19 f4       	brne	.+6      	; 0xa20 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     a1a:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
     a1e:	0a c0       	rjmp	.+20     	; 0xa34 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     a20:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	ce 01       	movw	r24, r28
     a28:	0e 94 f7 00 	call	0x1ee	; 0x1ee <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a2c:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a30:	88 23       	and	r24, r24
     a32:	99 f3       	breq	.-26     	; 0xa1a <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	08 95       	ret

00000a3a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a3a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     a3e:	88 23       	and	r24, r24
     a40:	21 f0       	breq	.+8      	; 0xa4a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a42:	81 e0       	ldi	r24, 0x01	; 1
     a44:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
     a48:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a4a:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a4e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxTopReadyPriority>
     a52:	69 e0       	ldi	r22, 0x09	; 9
     a54:	48 2f       	mov	r20, r24
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	64 9f       	mul	r22, r20
     a5a:	90 01       	movw	r18, r0
     a5c:	65 9f       	mul	r22, r21
     a5e:	30 0d       	add	r19, r0
     a60:	11 24       	eor	r1, r1
     a62:	f9 01       	movw	r30, r18
     a64:	e0 59       	subi	r30, 0x90	; 144
     a66:	fe 4f       	sbci	r31, 0xFE	; 254
     a68:	90 81       	ld	r25, Z
     a6a:	91 11       	cpse	r25, r1
     a6c:	02 c0       	rjmp	.+4      	; 0xa72 <vTaskSwitchContext+0x38>
     a6e:	81 50       	subi	r24, 0x01	; 1
     a70:	f1 cf       	rjmp	.-30     	; 0xa54 <vTaskSwitchContext+0x1a>
     a72:	a1 81       	ldd	r26, Z+1	; 0x01
     a74:	b2 81       	ldd	r27, Z+2	; 0x02
     a76:	12 96       	adiw	r26, 0x02	; 2
     a78:	0d 90       	ld	r0, X+
     a7a:	bc 91       	ld	r27, X
     a7c:	a0 2d       	mov	r26, r0
     a7e:	b2 83       	std	Z+2, r27	; 0x02
     a80:	a1 83       	std	Z+1, r26	; 0x01
     a82:	2d 58       	subi	r18, 0x8D	; 141
     a84:	3e 4f       	sbci	r19, 0xFE	; 254
     a86:	a2 17       	cp	r26, r18
     a88:	b3 07       	cpc	r27, r19
     a8a:	31 f4       	brne	.+12     	; 0xa98 <vTaskSwitchContext+0x5e>
     a8c:	12 96       	adiw	r26, 0x02	; 2
     a8e:	2d 91       	ld	r18, X+
     a90:	3c 91       	ld	r19, X
     a92:	13 97       	sbiw	r26, 0x03	; 3
     a94:	32 83       	std	Z+2, r19	; 0x02
     a96:	21 83       	std	Z+1, r18	; 0x01
     a98:	99 e0       	ldi	r25, 0x09	; 9
     a9a:	94 9f       	mul	r25, r20
     a9c:	f0 01       	movw	r30, r0
     a9e:	95 9f       	mul	r25, r21
     aa0:	f0 0d       	add	r31, r0
     aa2:	11 24       	eor	r1, r1
     aa4:	e0 59       	subi	r30, 0x90	; 144
     aa6:	fe 4f       	sbci	r31, 0xFE	; 254
     aa8:	01 80       	ldd	r0, Z+1	; 0x01
     aaa:	f2 81       	ldd	r31, Z+2	; 0x02
     aac:	e0 2d       	mov	r30, r0
     aae:	26 81       	ldd	r18, Z+6	; 0x06
     ab0:	37 81       	ldd	r19, Z+7	; 0x07
     ab2:	30 93 2f 01 	sts	0x012F, r19	; 0x80012f <__data_end+0x1>
     ab6:	20 93 2e 01 	sts	0x012E, r18	; 0x80012e <__data_end>
     aba:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     abe:	08 95       	ret

00000ac0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     ac0:	0f 93       	push	r16
     ac2:	1f 93       	push	r17
     ac4:	cf 93       	push	r28
     ac6:	df 93       	push	r29
     ac8:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	f8 94       	cli
     ace:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     ad0:	89 2b       	or	r24, r25
     ad2:	21 f4       	brne	.+8      	; 0xadc <vTaskSuspend+0x1c>
     ad4:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <__data_end>
     ad8:	d0 91 2f 01 	lds	r29, 0x012F	; 0x80012f <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     adc:	8e 01       	movw	r16, r28
     ade:	0e 5f       	subi	r16, 0xFE	; 254
     ae0:	1f 4f       	sbci	r17, 0xFF	; 255
     ae2:	c8 01       	movw	r24, r16
     ae4:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     ae8:	8c 89       	ldd	r24, Y+20	; 0x14
     aea:	9d 89       	ldd	r25, Y+21	; 0x15
     aec:	89 2b       	or	r24, r25
     aee:	21 f0       	breq	.+8      	; 0xaf8 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     af0:	ce 01       	movw	r24, r28
     af2:	0c 96       	adiw	r24, 0x0c	; 12
     af4:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     af8:	b8 01       	movw	r22, r16
     afa:	8e e3       	ldi	r24, 0x3E	; 62
     afc:	91 e0       	ldi	r25, 0x01	; 1
     afe:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b02:	8d a1       	ldd	r24, Y+37	; 0x25
     b04:	81 30       	cpi	r24, 0x01	; 1
     b06:	09 f4       	brne	.+2      	; 0xb0a <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b08:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b0a:	0f 90       	pop	r0
     b0c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b0e:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     b12:	88 23       	and	r24, r24
     b14:	39 f0       	breq	.+14     	; 0xb24 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	f8 94       	cli
     b1a:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     b1c:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     b20:	0f 90       	pop	r0
     b22:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     b24:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     b28:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     b2c:	c8 17       	cp	r28, r24
     b2e:	d9 07       	cpc	r29, r25
     b30:	c1 f4       	brne	.+48     	; 0xb62 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b32:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     b36:	88 23       	and	r24, r24
     b38:	19 f0       	breq	.+6      	; 0xb40 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b3a:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
     b3e:	11 c0       	rjmp	.+34     	; 0xb62 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b40:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <xSuspendedTaskList>
     b44:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     b48:	98 13       	cpse	r25, r24
     b4a:	05 c0       	rjmp	.+10     	; 0xb56 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b4c:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <__data_end+0x1>
     b50:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <__data_end>
     b54:	06 c0       	rjmp	.+12     	; 0xb62 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b56:	df 91       	pop	r29
     b58:	cf 91       	pop	r28
     b5a:	1f 91       	pop	r17
     b5c:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b5e:	0c 94 1d 05 	jmp	0xa3a	; 0xa3a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b62:	df 91       	pop	r29
     b64:	cf 91       	pop	r28
     b66:	1f 91       	pop	r17
     b68:	0f 91       	pop	r16
     b6a:	08 95       	ret

00000b6c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     b6c:	cf 93       	push	r28
     b6e:	df 93       	push	r29
     b70:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b72:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     b76:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
     b7a:	64 5f       	subi	r22, 0xF4	; 244
     b7c:	7f 4f       	sbci	r23, 0xFF	; 255
     b7e:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b82:	61 e0       	ldi	r22, 0x01	; 1
     b84:	ce 01       	movw	r24, r28
}
     b86:	df 91       	pop	r29
     b88:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b8a:	0c 94 f7 00 	jmp	0x1ee	; 0x1ee <prvAddCurrentTaskToDelayedList>

00000b8e <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     b8e:	cf 93       	push	r28
     b90:	df 93       	push	r29
     b92:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b94:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     b98:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     b9c:	70 68       	ori	r23, 0x80	; 128
     b9e:	75 87       	std	Z+13, r23	; 0x0d
     ba0:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ba2:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     ba6:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
     baa:	64 5f       	subi	r22, 0xF4	; 244
     bac:	7f 4f       	sbci	r23, 0xFF	; 255
     bae:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bb2:	61 e0       	ldi	r22, 0x01	; 1
     bb4:	ce 01       	movw	r24, r28
}
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bba:	0c 94 f7 00 	jmp	0x1ee	; 0x1ee <prvAddCurrentTaskToDelayedList>

00000bbe <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     bbe:	0f 93       	push	r16
     bc0:	1f 93       	push	r17
     bc2:	cf 93       	push	r28
     bc4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     bc6:	dc 01       	movw	r26, r24
     bc8:	15 96       	adiw	r26, 0x05	; 5
     bca:	ed 91       	ld	r30, X+
     bcc:	fc 91       	ld	r31, X
     bce:	16 97       	sbiw	r26, 0x06	; 6
     bd0:	c6 81       	ldd	r28, Z+6	; 0x06
     bd2:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     bd4:	8e 01       	movw	r16, r28
     bd6:	04 5f       	subi	r16, 0xF4	; 244
     bd8:	1f 4f       	sbci	r17, 0xFF	; 255
     bda:	c8 01       	movw	r24, r16
     bdc:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     be0:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     be4:	81 11       	cpse	r24, r1
     be6:	14 c0       	rjmp	.+40     	; 0xc10 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     be8:	0a 50       	subi	r16, 0x0A	; 10
     bea:	11 09       	sbc	r17, r1
     bec:	c8 01       	movw	r24, r16
     bee:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     bf2:	8e 89       	ldd	r24, Y+22	; 0x16
     bf4:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     bf8:	98 17       	cp	r25, r24
     bfa:	10 f4       	brcc	.+4      	; 0xc00 <xTaskRemoveFromEventList+0x42>
     bfc:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     c00:	b9 e0       	ldi	r27, 0x09	; 9
     c02:	8b 9f       	mul	r24, r27
     c04:	c0 01       	movw	r24, r0
     c06:	11 24       	eor	r1, r1
     c08:	b8 01       	movw	r22, r16
     c0a:	80 59       	subi	r24, 0x90	; 144
     c0c:	9e 4f       	sbci	r25, 0xFE	; 254
     c0e:	03 c0       	rjmp	.+6      	; 0xc16 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c10:	b8 01       	movw	r22, r16
     c12:	81 e5       	ldi	r24, 0x51	; 81
     c14:	91 e0       	ldi	r25, 0x01	; 1
     c16:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c1a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     c1e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     c22:	9e 89       	ldd	r25, Y+22	; 0x16
     c24:	86 89       	ldd	r24, Z+22	; 0x16
     c26:	89 17       	cp	r24, r25
     c28:	20 f4       	brcc	.+8      	; 0xc32 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c2a:	81 e0       	ldi	r24, 0x01	; 1
     c2c:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
     c30:	01 c0       	rjmp	.+2      	; 0xc34 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c32:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	1f 91       	pop	r17
     c3a:	0f 91       	pop	r16
     c3c:	08 95       	ret

00000c3e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c3e:	0f 93       	push	r16
     c40:	1f 93       	push	r17
     c42:	cf 93       	push	r28
     c44:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c46:	70 68       	ori	r23, 0x80	; 128
     c48:	fc 01       	movw	r30, r24
     c4a:	71 83       	std	Z+1, r23	; 0x01
     c4c:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c4e:	c6 81       	ldd	r28, Z+6	; 0x06
     c50:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c52:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c56:	8e 01       	movw	r16, r28
     c58:	0e 5f       	subi	r16, 0xFE	; 254
     c5a:	1f 4f       	sbci	r17, 0xFF	; 255
     c5c:	c8 01       	movw	r24, r16
     c5e:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c62:	8e 89       	ldd	r24, Y+22	; 0x16
     c64:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     c68:	98 17       	cp	r25, r24
     c6a:	10 f4       	brcc	.+4      	; 0xc70 <vTaskRemoveFromUnorderedEventList+0x32>
     c6c:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     c70:	f9 e0       	ldi	r31, 0x09	; 9
     c72:	8f 9f       	mul	r24, r31
     c74:	c0 01       	movw	r24, r0
     c76:	11 24       	eor	r1, r1
     c78:	b8 01       	movw	r22, r16
     c7a:	80 59       	subi	r24, 0x90	; 144
     c7c:	9e 4f       	sbci	r25, 0xFE	; 254
     c7e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c82:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     c86:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     c8a:	9e 89       	ldd	r25, Y+22	; 0x16
     c8c:	86 89       	ldd	r24, Z+22	; 0x16
     c8e:	89 17       	cp	r24, r25
     c90:	18 f4       	brcc	.+6      	; 0xc98 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
	}
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     ca2:	0f b6       	in	r0, 0x3f	; 63
     ca4:	f8 94       	cli
     ca6:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     ca8:	20 91 36 01 	lds	r18, 0x0136	; 0x800136 <xNumOfOverflows>
     cac:	fc 01       	movw	r30, r24
     cae:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     cb0:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <xTickCount>
     cb4:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <xTickCount+0x1>
     cb8:	32 83       	std	Z+2, r19	; 0x02
     cba:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     cbc:	0f 90       	pop	r0
     cbe:	0f be       	out	0x3f, r0	; 63
     cc0:	08 95       	ret

00000cc2 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     cc2:	20 91 36 01 	lds	r18, 0x0136	; 0x800136 <xNumOfOverflows>
     cc6:	fc 01       	movw	r30, r24
     cc8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     cca:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <xTickCount>
     cce:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <xTickCount+0x1>
     cd2:	32 83       	std	Z+2, r19	; 0x02
     cd4:	21 83       	std	Z+1, r18	; 0x01
     cd6:	08 95       	ret

00000cd8 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     cd8:	cf 93       	push	r28
     cda:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     ce2:	40 91 3b 01 	lds	r20, 0x013B	; 0x80013b <xTickCount>
     ce6:	50 91 3c 01 	lds	r21, 0x013C	; 0x80013c <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     cea:	db 01       	movw	r26, r22
     cec:	2d 91       	ld	r18, X+
     cee:	3c 91       	ld	r19, X
     cf0:	2f 3f       	cpi	r18, 0xFF	; 255
     cf2:	bf ef       	ldi	r27, 0xFF	; 255
     cf4:	3b 07       	cpc	r19, r27
     cf6:	d9 f0       	breq	.+54     	; 0xd2e <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     cf8:	ec 01       	movw	r28, r24
     cfa:	e9 81       	ldd	r30, Y+1	; 0x01
     cfc:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     cfe:	a0 91 36 01 	lds	r26, 0x0136	; 0x800136 <xNumOfOverflows>
     d02:	b8 81       	ld	r27, Y
     d04:	ba 17       	cp	r27, r26
     d06:	19 f0       	breq	.+6      	; 0xd0e <xTaskCheckForTimeOut+0x36>
     d08:	4e 17       	cp	r20, r30
     d0a:	5f 07       	cpc	r21, r31
     d0c:	90 f4       	brcc	.+36     	; 0xd32 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d0e:	4e 1b       	sub	r20, r30
     d10:	5f 0b       	sbc	r21, r31
     d12:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     d14:	42 17       	cp	r20, r18
     d16:	53 07       	cpc	r21, r19
     d18:	38 f4       	brcc	.+14     	; 0xd28 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     d1a:	24 1b       	sub	r18, r20
     d1c:	35 0b       	sbc	r19, r21
     d1e:	31 83       	std	Z+1, r19	; 0x01
     d20:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     d22:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskInternalSetTimeOutState>
     d26:	03 c0       	rjmp	.+6      	; 0xd2e <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     d28:	11 82       	std	Z+1, r1	; 0x01
     d2a:	10 82       	st	Z, r1
     d2c:	02 c0       	rjmp	.+4      	; 0xd32 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     d2e:	80 e0       	ldi	r24, 0x00	; 0
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d32:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d34:	0f 90       	pop	r0
     d36:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d38:	df 91       	pop	r29
     d3a:	cf 91       	pop	r28
     d3c:	08 95       	ret

00000d3e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d3e:	81 e0       	ldi	r24, 0x01	; 1
     d40:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
     d44:	08 95       	ret

00000d46 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d46:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d4a:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d4e:	84 85       	ldd	r24, Z+12	; 0x0c
     d50:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d52:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d56:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d5a:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
     d5e:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
     d62:	56 96       	adiw	r26, 0x16	; 22
     d64:	4c 91       	ld	r20, X
     d66:	24 e0       	ldi	r18, 0x04	; 4
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	24 1b       	sub	r18, r20
     d6c:	31 09       	sbc	r19, r1
     d6e:	35 87       	std	Z+13, r19	; 0x0d
     d70:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     d72:	08 95       	ret

00000d74 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     d74:	0f 93       	push	r16
     d76:	1f 93       	push	r17
     d78:	18 2f       	mov	r17, r24
     d7a:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     d82:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d86:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d8a:	41 a1       	ldd	r20, Z+33	; 0x21
     d8c:	52 a1       	ldd	r21, Z+34	; 0x22
     d8e:	63 a1       	ldd	r22, Z+35	; 0x23
     d90:	74 a1       	ldd	r23, Z+36	; 0x24
     d92:	45 2b       	or	r20, r21
     d94:	46 2b       	or	r20, r22
     d96:	47 2b       	or	r20, r23
     d98:	69 f4       	brne	.+26     	; 0xdb4 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     d9a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d9e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     da2:	21 e0       	ldi	r18, 0x01	; 1
     da4:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     da6:	00 97       	sbiw	r24, 0x00	; 0
     da8:	29 f0       	breq	.+10     	; 0xdb4 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     daa:	61 e0       	ldi	r22, 0x01	; 1
     dac:	0e 94 f7 00 	call	0x1ee	; 0x1ee <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     db0:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     db4:	0f 90       	pop	r0
     db6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     db8:	0f b6       	in	r0, 0x3f	; 63
     dba:	f8 94       	cli
     dbc:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     dbe:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     dc2:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     dc6:	61 a1       	ldd	r22, Z+33	; 0x21
     dc8:	72 a1       	ldd	r23, Z+34	; 0x22
     dca:	83 a1       	ldd	r24, Z+35	; 0x23
     dcc:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     dce:	61 15       	cp	r22, r1
     dd0:	71 05       	cpc	r23, r1
     dd2:	81 05       	cpc	r24, r1
     dd4:	91 05       	cpc	r25, r1
     dd6:	a9 f0       	breq	.+42     	; 0xe02 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     dd8:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     ddc:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     de0:	11 23       	and	r17, r17
     de2:	29 f0       	breq	.+10     	; 0xdee <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     de4:	11 a2       	std	Z+33, r1	; 0x21
     de6:	12 a2       	std	Z+34, r1	; 0x22
     de8:	13 a2       	std	Z+35, r1	; 0x23
     dea:	14 a2       	std	Z+36, r1	; 0x24
     dec:	0a c0       	rjmp	.+20     	; 0xe02 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     dee:	8b 01       	movw	r16, r22
     df0:	9c 01       	movw	r18, r24
     df2:	01 50       	subi	r16, 0x01	; 1
     df4:	11 09       	sbc	r17, r1
     df6:	21 09       	sbc	r18, r1
     df8:	31 09       	sbc	r19, r1
     dfa:	01 a3       	std	Z+33, r16	; 0x21
     dfc:	12 a3       	std	Z+34, r17	; 0x22
     dfe:	23 a3       	std	Z+35, r18	; 0x23
     e00:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e02:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e06:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e0a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     e0c:	0f 90       	pop	r0
     e0e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     e10:	1f 91       	pop	r17
     e12:	0f 91       	pop	r16
     e14:	08 95       	ret

00000e16 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     e16:	4f 92       	push	r4
     e18:	5f 92       	push	r5
     e1a:	6f 92       	push	r6
     e1c:	7f 92       	push	r7
     e1e:	8f 92       	push	r8
     e20:	9f 92       	push	r9
     e22:	af 92       	push	r10
     e24:	bf 92       	push	r11
     e26:	ef 92       	push	r14
     e28:	ff 92       	push	r15
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	49 01       	movw	r8, r18
     e30:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e38:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e3c:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e40:	25 a1       	ldd	r18, Z+37	; 0x25
     e42:	22 30       	cpi	r18, 0x02	; 2
     e44:	39 f1       	breq	.+78     	; 0xe94 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e46:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e4a:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e4e:	21 a1       	ldd	r18, Z+33	; 0x21
     e50:	32 a1       	ldd	r19, Z+34	; 0x22
     e52:	43 a1       	ldd	r20, Z+35	; 0x23
     e54:	54 a1       	ldd	r21, Z+36	; 0x24
     e56:	2b 01       	movw	r4, r22
     e58:	3c 01       	movw	r6, r24
     e5a:	40 94       	com	r4
     e5c:	50 94       	com	r5
     e5e:	60 94       	com	r6
     e60:	70 94       	com	r7
     e62:	d3 01       	movw	r26, r6
     e64:	c2 01       	movw	r24, r4
     e66:	82 23       	and	r24, r18
     e68:	93 23       	and	r25, r19
     e6a:	a4 23       	and	r26, r20
     e6c:	b5 23       	and	r27, r21
     e6e:	81 a3       	std	Z+33, r24	; 0x21
     e70:	92 a3       	std	Z+34, r25	; 0x22
     e72:	a3 a3       	std	Z+35, r26	; 0x23
     e74:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e76:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e7a:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e82:	e1 14       	cp	r14, r1
     e84:	f1 04       	cpc	r15, r1
     e86:	31 f0       	breq	.+12     	; 0xe94 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e88:	61 e0       	ldi	r22, 0x01	; 1
     e8a:	c7 01       	movw	r24, r14
     e8c:	0e 94 f7 00 	call	0x1ee	; 0x1ee <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e90:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e94:	0f 90       	pop	r0
     e96:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     e98:	0f b6       	in	r0, 0x3f	; 63
     e9a:	f8 94       	cli
     e9c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     e9e:	01 15       	cp	r16, r1
     ea0:	11 05       	cpc	r17, r1
     ea2:	69 f0       	breq	.+26     	; 0xebe <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     ea4:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     ea8:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     eac:	81 a1       	ldd	r24, Z+33	; 0x21
     eae:	92 a1       	ldd	r25, Z+34	; 0x22
     eb0:	a3 a1       	ldd	r26, Z+35	; 0x23
     eb2:	b4 a1       	ldd	r27, Z+36	; 0x24
     eb4:	f8 01       	movw	r30, r16
     eb6:	80 83       	st	Z, r24
     eb8:	91 83       	std	Z+1, r25	; 0x01
     eba:	a2 83       	std	Z+2, r26	; 0x02
     ebc:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     ebe:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     ec2:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     ec6:	85 a1       	ldd	r24, Z+37	; 0x25
     ec8:	82 30       	cpi	r24, 0x02	; 2
     eca:	c1 f4       	brne	.+48     	; 0xefc <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     ecc:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     ed0:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     ed4:	41 a1       	ldd	r20, Z+33	; 0x21
     ed6:	52 a1       	ldd	r21, Z+34	; 0x22
     ed8:	63 a1       	ldd	r22, Z+35	; 0x23
     eda:	74 a1       	ldd	r23, Z+36	; 0x24
     edc:	d5 01       	movw	r26, r10
     ede:	c4 01       	movw	r24, r8
     ee0:	80 95       	com	r24
     ee2:	90 95       	com	r25
     ee4:	a0 95       	com	r26
     ee6:	b0 95       	com	r27
     ee8:	84 23       	and	r24, r20
     eea:	95 23       	and	r25, r21
     eec:	a6 23       	and	r26, r22
     eee:	b7 23       	and	r27, r23
     ef0:	81 a3       	std	Z+33, r24	; 0x21
     ef2:	92 a3       	std	Z+34, r25	; 0x22
     ef4:	a3 a3       	std	Z+35, r26	; 0x23
     ef6:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	01 c0       	rjmp	.+2      	; 0xefe <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     efc:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     efe:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     f02:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     f06:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f08:	0f 90       	pop	r0
     f0a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f0c:	1f 91       	pop	r17
     f0e:	0f 91       	pop	r16
     f10:	ff 90       	pop	r15
     f12:	ef 90       	pop	r14
     f14:	bf 90       	pop	r11
     f16:	af 90       	pop	r10
     f18:	9f 90       	pop	r9
     f1a:	8f 90       	pop	r8
     f1c:	7f 90       	pop	r7
     f1e:	6f 90       	pop	r6
     f20:	5f 90       	pop	r5
     f22:	4f 90       	pop	r4
     f24:	08 95       	ret

00000f26 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     f26:	0f 93       	push	r16
     f28:	1f 93       	push	r17
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
     f2e:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	f8 94       	cli
     f34:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     f36:	01 15       	cp	r16, r1
     f38:	11 05       	cpc	r17, r1
     f3a:	49 f0       	breq	.+18     	; 0xf4e <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f3c:	81 a1       	ldd	r24, Z+33	; 0x21
     f3e:	92 a1       	ldd	r25, Z+34	; 0x22
     f40:	a3 a1       	ldd	r26, Z+35	; 0x23
     f42:	b4 a1       	ldd	r27, Z+36	; 0x24
     f44:	e8 01       	movw	r28, r16
     f46:	88 83       	st	Y, r24
     f48:	99 83       	std	Y+1, r25	; 0x01
     f4a:	aa 83       	std	Y+2, r26	; 0x02
     f4c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f4e:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f50:	82 e0       	ldi	r24, 0x02	; 2
     f52:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f54:	22 30       	cpi	r18, 0x02	; 2
     f56:	89 f0       	breq	.+34     	; 0xf7a <xTaskGenericNotify+0x54>
     f58:	58 f4       	brcc	.+22     	; 0xf70 <xTaskGenericNotify+0x4a>
     f5a:	21 30       	cpi	r18, 0x01	; 1
     f5c:	01 f5       	brne	.+64     	; 0xf9e <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f5e:	81 a1       	ldd	r24, Z+33	; 0x21
     f60:	92 a1       	ldd	r25, Z+34	; 0x22
     f62:	a3 a1       	ldd	r26, Z+35	; 0x23
     f64:	b4 a1       	ldd	r27, Z+36	; 0x24
     f66:	48 2b       	or	r20, r24
     f68:	59 2b       	or	r21, r25
     f6a:	6a 2b       	or	r22, r26
     f6c:	7b 2b       	or	r23, r27
     f6e:	13 c0       	rjmp	.+38     	; 0xf96 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     f70:	23 30       	cpi	r18, 0x03	; 3
     f72:	89 f0       	breq	.+34     	; 0xf96 <xTaskGenericNotify+0x70>
     f74:	24 30       	cpi	r18, 0x04	; 4
     f76:	69 f0       	breq	.+26     	; 0xf92 <xTaskGenericNotify+0x6c>
     f78:	12 c0       	rjmp	.+36     	; 0xf9e <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     f7a:	81 a1       	ldd	r24, Z+33	; 0x21
     f7c:	92 a1       	ldd	r25, Z+34	; 0x22
     f7e:	a3 a1       	ldd	r26, Z+35	; 0x23
     f80:	b4 a1       	ldd	r27, Z+36	; 0x24
     f82:	01 96       	adiw	r24, 0x01	; 1
     f84:	a1 1d       	adc	r26, r1
     f86:	b1 1d       	adc	r27, r1
     f88:	81 a3       	std	Z+33, r24	; 0x21
     f8a:	92 a3       	std	Z+34, r25	; 0x22
     f8c:	a3 a3       	std	Z+35, r26	; 0x23
     f8e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     f90:	06 c0       	rjmp	.+12     	; 0xf9e <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     f92:	32 30       	cpi	r19, 0x02	; 2
     f94:	49 f1       	breq	.+82     	; 0xfe8 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     f96:	41 a3       	std	Z+33, r20	; 0x21
     f98:	52 a3       	std	Z+34, r21	; 0x22
     f9a:	63 a3       	std	Z+35, r22	; 0x23
     f9c:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     f9e:	31 30       	cpi	r19, 0x01	; 1
     fa0:	09 f5       	brne	.+66     	; 0xfe4 <xTaskGenericNotify+0xbe>
     fa2:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     fa4:	8f 01       	movw	r16, r30
     fa6:	0e 5f       	subi	r16, 0xFE	; 254
     fa8:	1f 4f       	sbci	r17, 0xFF	; 255
     faa:	c8 01       	movw	r24, r16
     fac:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     fb0:	8e 89       	ldd	r24, Y+22	; 0x16
     fb2:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     fb6:	98 17       	cp	r25, r24
     fb8:	10 f4       	brcc	.+4      	; 0xfbe <xTaskGenericNotify+0x98>
     fba:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     fbe:	29 e0       	ldi	r18, 0x09	; 9
     fc0:	82 9f       	mul	r24, r18
     fc2:	c0 01       	movw	r24, r0
     fc4:	11 24       	eor	r1, r1
     fc6:	b8 01       	movw	r22, r16
     fc8:	80 59       	subi	r24, 0x90	; 144
     fca:	9e 4f       	sbci	r25, 0xFE	; 254
     fcc:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     fd0:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     fd4:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     fd8:	9e 89       	ldd	r25, Y+22	; 0x16
     fda:	86 89       	ldd	r24, Z+22	; 0x16
     fdc:	89 17       	cp	r24, r25
     fde:	10 f4       	brcc	.+4      	; 0xfe4 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     fe0:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	01 c0       	rjmp	.+2      	; 0xfea <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     fe8:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     fea:	0f 90       	pop	r0
     fec:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
     ff6:	08 95       	ret

00000ff8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     ff8:	ef 92       	push	r14
     ffa:	ff 92       	push	r15
     ffc:	0f 93       	push	r16
     ffe:	1f 93       	push	r17
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1006:	01 15       	cp	r16, r1
    1008:	11 05       	cpc	r17, r1
    100a:	49 f0       	breq	.+18     	; 0x101e <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    100c:	81 a1       	ldd	r24, Z+33	; 0x21
    100e:	92 a1       	ldd	r25, Z+34	; 0x22
    1010:	a3 a1       	ldd	r26, Z+35	; 0x23
    1012:	b4 a1       	ldd	r27, Z+36	; 0x24
    1014:	e8 01       	movw	r28, r16
    1016:	88 83       	st	Y, r24
    1018:	99 83       	std	Y+1, r25	; 0x01
    101a:	aa 83       	std	Y+2, r26	; 0x02
    101c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    101e:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1020:	82 e0       	ldi	r24, 0x02	; 2
    1022:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1024:	22 30       	cpi	r18, 0x02	; 2
    1026:	89 f0       	breq	.+34     	; 0x104a <xTaskGenericNotifyFromISR+0x52>
    1028:	58 f4       	brcc	.+22     	; 0x1040 <xTaskGenericNotifyFromISR+0x48>
    102a:	21 30       	cpi	r18, 0x01	; 1
    102c:	01 f5       	brne	.+64     	; 0x106e <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    102e:	81 a1       	ldd	r24, Z+33	; 0x21
    1030:	92 a1       	ldd	r25, Z+34	; 0x22
    1032:	a3 a1       	ldd	r26, Z+35	; 0x23
    1034:	b4 a1       	ldd	r27, Z+36	; 0x24
    1036:	48 2b       	or	r20, r24
    1038:	59 2b       	or	r21, r25
    103a:	6a 2b       	or	r22, r26
    103c:	7b 2b       	or	r23, r27
    103e:	13 c0       	rjmp	.+38     	; 0x1066 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1040:	23 30       	cpi	r18, 0x03	; 3
    1042:	89 f0       	breq	.+34     	; 0x1066 <xTaskGenericNotifyFromISR+0x6e>
    1044:	24 30       	cpi	r18, 0x04	; 4
    1046:	69 f0       	breq	.+26     	; 0x1062 <xTaskGenericNotifyFromISR+0x6a>
    1048:	12 c0       	rjmp	.+36     	; 0x106e <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    104a:	81 a1       	ldd	r24, Z+33	; 0x21
    104c:	92 a1       	ldd	r25, Z+34	; 0x22
    104e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1050:	b4 a1       	ldd	r27, Z+36	; 0x24
    1052:	01 96       	adiw	r24, 0x01	; 1
    1054:	a1 1d       	adc	r26, r1
    1056:	b1 1d       	adc	r27, r1
    1058:	81 a3       	std	Z+33, r24	; 0x21
    105a:	92 a3       	std	Z+34, r25	; 0x22
    105c:	a3 a3       	std	Z+35, r26	; 0x23
    105e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1060:	06 c0       	rjmp	.+12     	; 0x106e <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1062:	32 30       	cpi	r19, 0x02	; 2
    1064:	d9 f1       	breq	.+118    	; 0x10dc <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1066:	41 a3       	std	Z+33, r20	; 0x21
    1068:	52 a3       	std	Z+34, r21	; 0x22
    106a:	63 a3       	std	Z+35, r22	; 0x23
    106c:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    106e:	31 30       	cpi	r19, 0x01	; 1
    1070:	11 f0       	breq	.+4      	; 0x1076 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	34 c0       	rjmp	.+104    	; 0x10de <xTaskGenericNotifyFromISR+0xe6>
    1076:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1078:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
    107c:	81 11       	cpse	r24, r1
    107e:	15 c0       	rjmp	.+42     	; 0x10aa <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1080:	8f 01       	movw	r16, r30
    1082:	0e 5f       	subi	r16, 0xFE	; 254
    1084:	1f 4f       	sbci	r17, 0xFF	; 255
    1086:	c8 01       	movw	r24, r16
    1088:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    108c:	8e 89       	ldd	r24, Y+22	; 0x16
    108e:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
    1092:	98 17       	cp	r25, r24
    1094:	10 f4       	brcc	.+4      	; 0x109a <xTaskGenericNotifyFromISR+0xa2>
    1096:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
    109a:	e9 e0       	ldi	r30, 0x09	; 9
    109c:	8e 9f       	mul	r24, r30
    109e:	c0 01       	movw	r24, r0
    10a0:	11 24       	eor	r1, r1
    10a2:	b8 01       	movw	r22, r16
    10a4:	80 59       	subi	r24, 0x90	; 144
    10a6:	9e 4f       	sbci	r25, 0xFE	; 254
    10a8:	05 c0       	rjmp	.+10     	; 0x10b4 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    10aa:	bf 01       	movw	r22, r30
    10ac:	64 5f       	subi	r22, 0xF4	; 244
    10ae:	7f 4f       	sbci	r23, 0xFF	; 255
    10b0:	81 e5       	ldi	r24, 0x51	; 81
    10b2:	91 e0       	ldi	r25, 0x01	; 1
    10b4:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10b8:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
    10bc:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
    10c0:	9e 89       	ldd	r25, Y+22	; 0x16
    10c2:	86 89       	ldd	r24, Z+22	; 0x16
    10c4:	89 17       	cp	r24, r25
    10c6:	a8 f6       	brcc	.-86     	; 0x1072 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    10c8:	e1 14       	cp	r14, r1
    10ca:	f1 04       	cpc	r15, r1
    10cc:	19 f0       	breq	.+6      	; 0x10d4 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	e7 01       	movw	r28, r14
    10d2:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
    10da:	01 c0       	rjmp	.+2      	; 0x10de <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10dc:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	1f 91       	pop	r17
    10e4:	0f 91       	pop	r16
    10e6:	ff 90       	pop	r15
    10e8:	ef 90       	pop	r14
    10ea:	08 95       	ret

000010ec <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10ec:	ef 92       	push	r14
    10ee:	ff 92       	push	r15
    10f0:	0f 93       	push	r16
    10f2:	1f 93       	push	r17
    10f4:	cf 93       	push	r28
    10f6:	df 93       	push	r29
    10f8:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    10fa:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    10fc:	82 e0       	ldi	r24, 0x02	; 2
    10fe:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1100:	81 a1       	ldd	r24, Z+33	; 0x21
    1102:	92 a1       	ldd	r25, Z+34	; 0x22
    1104:	a3 a1       	ldd	r26, Z+35	; 0x23
    1106:	b4 a1       	ldd	r27, Z+36	; 0x24
    1108:	01 96       	adiw	r24, 0x01	; 1
    110a:	a1 1d       	adc	r26, r1
    110c:	b1 1d       	adc	r27, r1
    110e:	81 a3       	std	Z+33, r24	; 0x21
    1110:	92 a3       	std	Z+34, r25	; 0x22
    1112:	a3 a3       	std	Z+35, r26	; 0x23
    1114:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1116:	21 30       	cpi	r18, 0x01	; 1
    1118:	a1 f5       	brne	.+104    	; 0x1182 <vTaskNotifyGiveFromISR+0x96>
    111a:	8b 01       	movw	r16, r22
    111c:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    111e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
    1122:	81 11       	cpse	r24, r1
    1124:	16 c0       	rjmp	.+44     	; 0x1152 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1126:	7f 01       	movw	r14, r30
    1128:	22 e0       	ldi	r18, 0x02	; 2
    112a:	e2 0e       	add	r14, r18
    112c:	f1 1c       	adc	r15, r1
    112e:	c7 01       	movw	r24, r14
    1130:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1134:	8e 89       	ldd	r24, Y+22	; 0x16
    1136:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
    113a:	98 17       	cp	r25, r24
    113c:	10 f4       	brcc	.+4      	; 0x1142 <vTaskNotifyGiveFromISR+0x56>
    113e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
    1142:	e9 e0       	ldi	r30, 0x09	; 9
    1144:	8e 9f       	mul	r24, r30
    1146:	c0 01       	movw	r24, r0
    1148:	11 24       	eor	r1, r1
    114a:	b7 01       	movw	r22, r14
    114c:	80 59       	subi	r24, 0x90	; 144
    114e:	9e 4f       	sbci	r25, 0xFE	; 254
    1150:	05 c0       	rjmp	.+10     	; 0x115c <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1152:	bf 01       	movw	r22, r30
    1154:	64 5f       	subi	r22, 0xF4	; 244
    1156:	7f 4f       	sbci	r23, 0xFF	; 255
    1158:	81 e5       	ldi	r24, 0x51	; 81
    115a:	91 e0       	ldi	r25, 0x01	; 1
    115c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1160:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
    1164:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
    1168:	9e 89       	ldd	r25, Y+22	; 0x16
    116a:	86 89       	ldd	r24, Z+22	; 0x16
    116c:	89 17       	cp	r24, r25
    116e:	48 f4       	brcc	.+18     	; 0x1182 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1170:	01 15       	cp	r16, r1
    1172:	11 05       	cpc	r17, r1
    1174:	19 f0       	breq	.+6      	; 0x117c <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	f8 01       	movw	r30, r16
    117a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1182:	df 91       	pop	r29
    1184:	cf 91       	pop	r28
    1186:	1f 91       	pop	r17
    1188:	0f 91       	pop	r16
    118a:	ff 90       	pop	r15
    118c:	ef 90       	pop	r14
    118e:	08 95       	ret

00001190 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1190:	00 97       	sbiw	r24, 0x00	; 0
    1192:	21 f4       	brne	.+8      	; 0x119c <xTaskNotifyStateClear+0xc>
    1194:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
    1198:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>

		taskENTER_CRITICAL();
    119c:	0f b6       	in	r0, 0x3f	; 63
    119e:	f8 94       	cli
    11a0:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    11a2:	fc 01       	movw	r30, r24
    11a4:	25 a1       	ldd	r18, Z+37	; 0x25
    11a6:	22 30       	cpi	r18, 0x02	; 2
    11a8:	19 f4       	brne	.+6      	; 0x11b0 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11aa:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	01 c0       	rjmp	.+2      	; 0x11b2 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    11b0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    11b2:	0f 90       	pop	r0
    11b4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11b6:	08 95       	ret

000011b8 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11b8:	0f b6       	in	r0, 0x3f	; 63
    11ba:	f8 94       	cli
    11bc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    11be:	fc 01       	movw	r30, r24
    11c0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    11c2:	0f 90       	pop	r0
    11c4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11c6:	81 e0       	ldi	r24, 0x01	; 1
    11c8:	91 11       	cpse	r25, r1
    11ca:	80 e0       	ldi	r24, 0x00	; 0
}
    11cc:	08 95       	ret

000011ce <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    11ce:	0f 93       	push	r16
    11d0:	1f 93       	push	r17
    11d2:	cf 93       	push	r28
    11d4:	df 93       	push	r29
    11d6:	ec 01       	movw	r28, r24
    11d8:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11da:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    11dc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11de:	44 23       	and	r20, r20
    11e0:	b1 f1       	breq	.+108    	; 0x124e <prvCopyDataToQueue+0x80>
    11e2:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    11e4:	01 11       	cpse	r16, r1
    11e6:	15 c0       	rjmp	.+42     	; 0x1212 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    11e8:	8a 81       	ldd	r24, Y+2	; 0x02
    11ea:	9b 81       	ldd	r25, Y+3	; 0x03
    11ec:	0e 94 29 12 	call	0x2452	; 0x2452 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    11f0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11f2:	8a 81       	ldd	r24, Y+2	; 0x02
    11f4:	9b 81       	ldd	r25, Y+3	; 0x03
    11f6:	82 0f       	add	r24, r18
    11f8:	91 1d       	adc	r25, r1
    11fa:	9b 83       	std	Y+3, r25	; 0x03
    11fc:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1200:	3d 81       	ldd	r19, Y+5	; 0x05
    1202:	82 17       	cp	r24, r18
    1204:	93 07       	cpc	r25, r19
    1206:	18 f1       	brcs	.+70     	; 0x124e <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1208:	88 81       	ld	r24, Y
    120a:	99 81       	ldd	r25, Y+1	; 0x01
    120c:	9b 83       	std	Y+3, r25	; 0x03
    120e:	8a 83       	std	Y+2, r24	; 0x02
    1210:	1e c0       	rjmp	.+60     	; 0x124e <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1212:	8e 81       	ldd	r24, Y+6	; 0x06
    1214:	9f 81       	ldd	r25, Y+7	; 0x07
    1216:	0e 94 29 12 	call	0x2452	; 0x2452 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    121a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	91 95       	neg	r25
    1220:	81 95       	neg	r24
    1222:	91 09       	sbc	r25, r1
    1224:	2e 81       	ldd	r18, Y+6	; 0x06
    1226:	3f 81       	ldd	r19, Y+7	; 0x07
    1228:	28 0f       	add	r18, r24
    122a:	39 1f       	adc	r19, r25
    122c:	3f 83       	std	Y+7, r19	; 0x07
    122e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1230:	48 81       	ld	r20, Y
    1232:	59 81       	ldd	r21, Y+1	; 0x01
    1234:	24 17       	cp	r18, r20
    1236:	35 07       	cpc	r19, r21
    1238:	30 f4       	brcc	.+12     	; 0x1246 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    123a:	2c 81       	ldd	r18, Y+4	; 0x04
    123c:	3d 81       	ldd	r19, Y+5	; 0x05
    123e:	82 0f       	add	r24, r18
    1240:	93 1f       	adc	r25, r19
    1242:	9f 83       	std	Y+7, r25	; 0x07
    1244:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1246:	02 30       	cpi	r16, 0x02	; 2
    1248:	11 f4       	brne	.+4      	; 0x124e <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    124a:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    124c:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    124e:	1f 5f       	subi	r17, 0xFF	; 255
    1250:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1252:	80 e0       	ldi	r24, 0x00	; 0
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	1f 91       	pop	r17
    125a:	0f 91       	pop	r16
    125c:	08 95       	ret

0000125e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    125e:	fc 01       	movw	r30, r24
    1260:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1262:	44 8d       	ldd	r20, Z+28	; 0x1c
    1264:	44 23       	and	r20, r20
    1266:	a1 f0       	breq	.+40     	; 0x1290 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1268:	50 e0       	ldi	r21, 0x00	; 0
    126a:	26 81       	ldd	r18, Z+6	; 0x06
    126c:	37 81       	ldd	r19, Z+7	; 0x07
    126e:	24 0f       	add	r18, r20
    1270:	35 1f       	adc	r19, r21
    1272:	37 83       	std	Z+7, r19	; 0x07
    1274:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1276:	64 81       	ldd	r22, Z+4	; 0x04
    1278:	75 81       	ldd	r23, Z+5	; 0x05
    127a:	26 17       	cp	r18, r22
    127c:	37 07       	cpc	r19, r23
    127e:	20 f0       	brcs	.+8      	; 0x1288 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1280:	20 81       	ld	r18, Z
    1282:	31 81       	ldd	r19, Z+1	; 0x01
    1284:	37 83       	std	Z+7, r19	; 0x07
    1286:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1288:	66 81       	ldd	r22, Z+6	; 0x06
    128a:	77 81       	ldd	r23, Z+7	; 0x07
    128c:	0c 94 29 12 	jmp	0x2452	; 0x2452 <memcpy>
    1290:	08 95       	ret

00001292 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1292:	ef 92       	push	r14
    1294:	ff 92       	push	r15
    1296:	1f 93       	push	r17
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    12a4:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12a6:	7c 01       	movw	r14, r24
    12a8:	81 e1       	ldi	r24, 0x11	; 17
    12aa:	e8 0e       	add	r14, r24
    12ac:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    12ae:	11 16       	cp	r1, r17
    12b0:	5c f4       	brge	.+22     	; 0x12c8 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12b2:	89 89       	ldd	r24, Y+17	; 0x11
    12b4:	88 23       	and	r24, r24
    12b6:	41 f0       	breq	.+16     	; 0x12c8 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12b8:	c7 01       	movw	r24, r14
    12ba:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    12be:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    12c0:	0e 94 9f 06 	call	0xd3e	; 0xd3e <vTaskMissedYield>
    12c4:	11 50       	subi	r17, 0x01	; 1
    12c6:	f3 cf       	rjmp	.-26     	; 0x12ae <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    12c8:	8f ef       	ldi	r24, 0xFF	; 255
    12ca:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    12cc:	0f 90       	pop	r0
    12ce:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    12d6:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12d8:	7e 01       	movw	r14, r28
    12da:	88 e0       	ldi	r24, 0x08	; 8
    12dc:	e8 0e       	add	r14, r24
    12de:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    12e0:	11 16       	cp	r1, r17
    12e2:	5c f4       	brge	.+22     	; 0x12fa <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12e4:	88 85       	ldd	r24, Y+8	; 0x08
    12e6:	88 23       	and	r24, r24
    12e8:	41 f0       	breq	.+16     	; 0x12fa <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12ea:	c7 01       	movw	r24, r14
    12ec:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    12f0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    12f2:	0e 94 9f 06 	call	0xd3e	; 0xd3e <vTaskMissedYield>
    12f6:	11 50       	subi	r17, 0x01	; 1
    12f8:	f3 cf       	rjmp	.-26     	; 0x12e0 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    12fa:	8f ef       	ldi	r24, 0xFF	; 255
    12fc:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    12fe:	0f 90       	pop	r0
    1300:	0f be       	out	0x3f, r0	; 63
}
    1302:	df 91       	pop	r29
    1304:	cf 91       	pop	r28
    1306:	1f 91       	pop	r17
    1308:	ff 90       	pop	r15
    130a:	ef 90       	pop	r14
    130c:	08 95       	ret

0000130e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    130e:	cf 93       	push	r28
    1310:	df 93       	push	r29
    1312:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    131a:	48 81       	ld	r20, Y
    131c:	59 81       	ldd	r21, Y+1	; 0x01
    131e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1320:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1322:	9a 01       	movw	r18, r20
    1324:	87 9f       	mul	r24, r23
    1326:	20 0d       	add	r18, r0
    1328:	31 1d       	adc	r19, r1
    132a:	11 24       	eor	r1, r1
    132c:	3d 83       	std	Y+5, r19	; 0x05
    132e:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1330:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1332:	5b 83       	std	Y+3, r21	; 0x03
    1334:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	01 97       	sbiw	r24, 0x01	; 1
    133a:	78 9f       	mul	r23, r24
    133c:	90 01       	movw	r18, r0
    133e:	79 9f       	mul	r23, r25
    1340:	30 0d       	add	r19, r0
    1342:	11 24       	eor	r1, r1
    1344:	ca 01       	movw	r24, r20
    1346:	82 0f       	add	r24, r18
    1348:	93 1f       	adc	r25, r19
    134a:	9f 83       	std	Y+7, r25	; 0x07
    134c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    134e:	8f ef       	ldi	r24, 0xFF	; 255
    1350:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1352:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1354:	61 11       	cpse	r22, r1
    1356:	0c c0       	rjmp	.+24     	; 0x1370 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1358:	88 85       	ldd	r24, Y+8	; 0x08
    135a:	88 23       	and	r24, r24
    135c:	89 f0       	breq	.+34     	; 0x1380 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    135e:	ce 01       	movw	r24, r28
    1360:	08 96       	adiw	r24, 0x08	; 8
    1362:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    1366:	88 23       	and	r24, r24
    1368:	59 f0       	breq	.+22     	; 0x1380 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    136a:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    136e:	08 c0       	rjmp	.+16     	; 0x1380 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1370:	ce 01       	movw	r24, r28
    1372:	08 96       	adiw	r24, 0x08	; 8
    1374:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1378:	ce 01       	movw	r24, r28
    137a:	41 96       	adiw	r24, 0x11	; 17
    137c:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1380:	0f 90       	pop	r0
    1382:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	08 95       	ret

0000138c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    138c:	0f 93       	push	r16
    138e:	1f 93       	push	r17
    1390:	cf 93       	push	r28
    1392:	df 93       	push	r29
    1394:	08 2f       	mov	r16, r24
    1396:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1398:	66 23       	and	r22, r22
    139a:	21 f0       	breq	.+8      	; 0x13a4 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    139c:	86 9f       	mul	r24, r22
    139e:	c0 01       	movw	r24, r0
    13a0:	11 24       	eor	r1, r1
    13a2:	02 c0       	rjmp	.+4      	; 0x13a8 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    13a4:	80 e0       	ldi	r24, 0x00	; 0
    13a6:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    13a8:	4f 96       	adiw	r24, 0x1f	; 31
    13aa:	0e 94 1d 10 	call	0x203a	; 0x203a <pvPortMalloc>
    13ae:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    13b0:	00 97       	sbiw	r24, 0x00	; 0
    13b2:	71 f0       	breq	.+28     	; 0x13d0 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    13b4:	11 11       	cpse	r17, r1
    13b6:	03 c0       	rjmp	.+6      	; 0x13be <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    13b8:	99 83       	std	Y+1, r25	; 0x01
    13ba:	88 83       	st	Y, r24
    13bc:	03 c0       	rjmp	.+6      	; 0x13c4 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    13be:	4f 96       	adiw	r24, 0x1f	; 31
    13c0:	99 83       	std	Y+1, r25	; 0x01
    13c2:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    13c4:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    13c6:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    13c8:	61 e0       	ldi	r22, 0x01	; 1
    13ca:	ce 01       	movw	r24, r28
    13cc:	0e 94 87 09 	call	0x130e	; 0x130e <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    13d0:	ce 01       	movw	r24, r28
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	1f 91       	pop	r17
    13d8:	0f 91       	pop	r16
    13da:	08 95       	ret

000013dc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    13dc:	af 92       	push	r10
    13de:	bf 92       	push	r11
    13e0:	cf 92       	push	r12
    13e2:	df 92       	push	r13
    13e4:	ff 92       	push	r15
    13e6:	0f 93       	push	r16
    13e8:	1f 93       	push	r17
    13ea:	cf 93       	push	r28
    13ec:	df 93       	push	r29
    13ee:	00 d0       	rcall	.+0      	; 0x13f0 <xQueueGenericSend+0x14>
    13f0:	00 d0       	rcall	.+0      	; 0x13f2 <xQueueGenericSend+0x16>
    13f2:	1f 92       	push	r1
    13f4:	cd b7       	in	r28, 0x3d	; 61
    13f6:	de b7       	in	r29, 0x3e	; 62
    13f8:	8c 01       	movw	r16, r24
    13fa:	6b 01       	movw	r12, r22
    13fc:	5d 83       	std	Y+5, r21	; 0x05
    13fe:	4c 83       	std	Y+4, r20	; 0x04
    1400:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1402:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1404:	58 01       	movw	r10, r16
    1406:	98 e0       	ldi	r25, 0x08	; 8
    1408:	a9 0e       	add	r10, r25
    140a:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    140c:	0f b6       	in	r0, 0x3f	; 63
    140e:	f8 94       	cli
    1410:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1412:	f8 01       	movw	r30, r16
    1414:	22 8d       	ldd	r18, Z+26	; 0x1a
    1416:	93 8d       	ldd	r25, Z+27	; 0x1b
    1418:	29 17       	cp	r18, r25
    141a:	18 f0       	brcs	.+6      	; 0x1422 <xQueueGenericSend+0x46>
    141c:	f2 e0       	ldi	r31, 0x02	; 2
    141e:	ff 12       	cpse	r15, r31
    1420:	14 c0       	rjmp	.+40     	; 0x144a <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1422:	4f 2d       	mov	r20, r15
    1424:	b6 01       	movw	r22, r12
    1426:	c8 01       	movw	r24, r16
    1428:	0e 94 e7 08 	call	0x11ce	; 0x11ce <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    142c:	f8 01       	movw	r30, r16
    142e:	91 89       	ldd	r25, Z+17	; 0x11
    1430:	99 23       	and	r25, r25
    1432:	21 f0       	breq	.+8      	; 0x143c <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1434:	c8 01       	movw	r24, r16
    1436:	41 96       	adiw	r24, 0x11	; 17
    1438:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    143c:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    143e:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1442:	0f 90       	pop	r0
    1444:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	50 c0       	rjmp	.+160    	; 0x14ea <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    144a:	2c 81       	ldd	r18, Y+4	; 0x04
    144c:	3d 81       	ldd	r19, Y+5	; 0x05
    144e:	23 2b       	or	r18, r19
    1450:	19 f4       	brne	.+6      	; 0x1458 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	48 c0       	rjmp	.+144    	; 0x14e8 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1458:	81 11       	cpse	r24, r1
    145a:	04 c0       	rjmp	.+8      	; 0x1464 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    145c:	ce 01       	movw	r24, r28
    145e:	01 96       	adiw	r24, 0x01	; 1
    1460:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1464:	0f 90       	pop	r0
    1466:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1468:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    146c:	0f b6       	in	r0, 0x3f	; 63
    146e:	f8 94       	cli
    1470:	0f 92       	push	r0
    1472:	f8 01       	movw	r30, r16
    1474:	85 8d       	ldd	r24, Z+29	; 0x1d
    1476:	8f 3f       	cpi	r24, 0xFF	; 255
    1478:	09 f4       	brne	.+2      	; 0x147c <xQueueGenericSend+0xa0>
    147a:	15 8e       	std	Z+29, r1	; 0x1d
    147c:	f8 01       	movw	r30, r16
    147e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1480:	8f 3f       	cpi	r24, 0xFF	; 255
    1482:	09 f4       	brne	.+2      	; 0x1486 <xQueueGenericSend+0xaa>
    1484:	16 8e       	std	Z+30, r1	; 0x1e
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    148a:	be 01       	movw	r22, r28
    148c:	6c 5f       	subi	r22, 0xFC	; 252
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	ce 01       	movw	r24, r28
    1492:	01 96       	adiw	r24, 0x01	; 1
    1494:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskCheckForTimeOut>
    1498:	81 11       	cpse	r24, r1
    149a:	21 c0       	rjmp	.+66     	; 0x14de <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	f8 94       	cli
    14a0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    14a2:	f8 01       	movw	r30, r16
    14a4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14a6:	0f 90       	pop	r0
    14a8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    14ac:	98 13       	cpse	r25, r24
    14ae:	11 c0       	rjmp	.+34     	; 0x14d2 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14b0:	6c 81       	ldd	r22, Y+4	; 0x04
    14b2:	7d 81       	ldd	r23, Y+5	; 0x05
    14b4:	c5 01       	movw	r24, r10
    14b6:	0e 94 b6 05 	call	0xb6c	; 0xb6c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14ba:	c8 01       	movw	r24, r16
    14bc:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14c0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    14c4:	88 23       	and	r24, r24
    14c6:	11 f0       	breq	.+4      	; 0x14cc <xQueueGenericSend+0xf0>
    14c8:	81 e0       	ldi	r24, 0x01	; 1
    14ca:	a0 cf       	rjmp	.-192    	; 0x140c <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    14cc:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    14d0:	fb cf       	rjmp	.-10     	; 0x14c8 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14d2:	c8 01       	movw	r24, r16
    14d4:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14d8:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    14dc:	f5 cf       	rjmp	.-22     	; 0x14c8 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    14de:	c8 01       	movw	r24, r16
    14e0:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14e4:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    14e8:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    14ea:	0f 90       	pop	r0
    14ec:	0f 90       	pop	r0
    14ee:	0f 90       	pop	r0
    14f0:	0f 90       	pop	r0
    14f2:	0f 90       	pop	r0
    14f4:	df 91       	pop	r29
    14f6:	cf 91       	pop	r28
    14f8:	1f 91       	pop	r17
    14fa:	0f 91       	pop	r16
    14fc:	ff 90       	pop	r15
    14fe:	df 90       	pop	r13
    1500:	cf 90       	pop	r12
    1502:	bf 90       	pop	r11
    1504:	af 90       	pop	r10
    1506:	08 95       	ret

00001508 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1508:	ef 92       	push	r14
    150a:	ff 92       	push	r15
    150c:	1f 93       	push	r17
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1514:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1516:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1518:	98 17       	cp	r25, r24
    151a:	10 f0       	brcs	.+4      	; 0x1520 <xQueueGenericSendFromISR+0x18>
    151c:	22 30       	cpi	r18, 0x02	; 2
    151e:	e1 f4       	brne	.+56     	; 0x1558 <xQueueGenericSendFromISR+0x50>
    1520:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1522:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1524:	42 2f       	mov	r20, r18
    1526:	ce 01       	movw	r24, r28
    1528:	0e 94 e7 08 	call	0x11ce	; 0x11ce <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    152c:	1f 3f       	cpi	r17, 0xFF	; 255
    152e:	81 f4       	brne	.+32     	; 0x1550 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1530:	89 89       	ldd	r24, Y+17	; 0x11
    1532:	88 23       	and	r24, r24
    1534:	79 f0       	breq	.+30     	; 0x1554 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1536:	ce 01       	movw	r24, r28
    1538:	41 96       	adiw	r24, 0x11	; 17
    153a:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    153e:	88 23       	and	r24, r24
    1540:	49 f0       	breq	.+18     	; 0x1554 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1542:	e1 14       	cp	r14, r1
    1544:	f1 04       	cpc	r15, r1
    1546:	31 f0       	breq	.+12     	; 0x1554 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	f7 01       	movw	r30, r14
    154c:	80 83       	st	Z, r24
    154e:	05 c0       	rjmp	.+10     	; 0x155a <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1550:	1f 5f       	subi	r17, 0xFF	; 255
    1552:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1554:	81 e0       	ldi	r24, 0x01	; 1
    1556:	01 c0       	rjmp	.+2      	; 0x155a <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1558:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    155a:	df 91       	pop	r29
    155c:	cf 91       	pop	r28
    155e:	1f 91       	pop	r17
    1560:	ff 90       	pop	r15
    1562:	ef 90       	pop	r14
    1564:	08 95       	ret

00001566 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1566:	cf 93       	push	r28
    1568:	df 93       	push	r29
    156a:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    156c:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    156e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1570:	98 17       	cp	r25, r24
    1572:	c0 f4       	brcc	.+48     	; 0x15a4 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1574:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1576:	9f 5f       	subi	r25, 0xFF	; 255
    1578:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    157a:	8f 3f       	cpi	r24, 0xFF	; 255
    157c:	79 f4       	brne	.+30     	; 0x159c <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    157e:	81 89       	ldd	r24, Z+17	; 0x11
    1580:	88 23       	and	r24, r24
    1582:	71 f0       	breq	.+28     	; 0x15a0 <xQueueGiveFromISR+0x3a>
    1584:	eb 01       	movw	r28, r22
    1586:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1588:	41 96       	adiw	r24, 0x11	; 17
    158a:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    158e:	88 23       	and	r24, r24
    1590:	39 f0       	breq	.+14     	; 0x15a0 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1592:	20 97       	sbiw	r28, 0x00	; 0
    1594:	29 f0       	breq	.+10     	; 0x15a0 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	88 83       	st	Y, r24
    159a:	05 c0       	rjmp	.+10     	; 0x15a6 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    159c:	8f 5f       	subi	r24, 0xFF	; 255
    159e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	01 c0       	rjmp	.+2      	; 0x15a6 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15a4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15a6:	df 91       	pop	r29
    15a8:	cf 91       	pop	r28
    15aa:	08 95       	ret

000015ac <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    15ac:	af 92       	push	r10
    15ae:	bf 92       	push	r11
    15b0:	cf 92       	push	r12
    15b2:	df 92       	push	r13
    15b4:	ff 92       	push	r15
    15b6:	0f 93       	push	r16
    15b8:	1f 93       	push	r17
    15ba:	cf 93       	push	r28
    15bc:	df 93       	push	r29
    15be:	00 d0       	rcall	.+0      	; 0x15c0 <xQueueReceive+0x14>
    15c0:	00 d0       	rcall	.+0      	; 0x15c2 <xQueueReceive+0x16>
    15c2:	1f 92       	push	r1
    15c4:	cd b7       	in	r28, 0x3d	; 61
    15c6:	de b7       	in	r29, 0x3e	; 62
    15c8:	8c 01       	movw	r16, r24
    15ca:	6b 01       	movw	r12, r22
    15cc:	5d 83       	std	Y+5, r21	; 0x05
    15ce:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    15d0:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15d2:	58 01       	movw	r10, r16
    15d4:	91 e1       	ldi	r25, 0x11	; 17
    15d6:	a9 0e       	add	r10, r25
    15d8:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15da:	0f b6       	in	r0, 0x3f	; 63
    15dc:	f8 94       	cli
    15de:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15e0:	f8 01       	movw	r30, r16
    15e2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15e4:	ff 20       	and	r15, r15
    15e6:	a9 f0       	breq	.+42     	; 0x1612 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15e8:	b6 01       	movw	r22, r12
    15ea:	c8 01       	movw	r24, r16
    15ec:	0e 94 2f 09 	call	0x125e	; 0x125e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15f0:	fa 94       	dec	r15
    15f2:	f8 01       	movw	r30, r16
    15f4:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15f6:	80 85       	ldd	r24, Z+8	; 0x08
    15f8:	88 23       	and	r24, r24
    15fa:	39 f0       	breq	.+14     	; 0x160a <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15fc:	c8 01       	movw	r24, r16
    15fe:	08 96       	adiw	r24, 0x08	; 8
    1600:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    1604:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1606:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    160a:	0f 90       	pop	r0
    160c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	50 c0       	rjmp	.+160    	; 0x16b2 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1612:	2c 81       	ldd	r18, Y+4	; 0x04
    1614:	3d 81       	ldd	r19, Y+5	; 0x05
    1616:	23 2b       	or	r18, r19
    1618:	19 f4       	brne	.+6      	; 0x1620 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	48 c0       	rjmp	.+144    	; 0x16b0 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1620:	81 11       	cpse	r24, r1
    1622:	04 c0       	rjmp	.+8      	; 0x162c <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1624:	ce 01       	movw	r24, r28
    1626:	01 96       	adiw	r24, 0x01	; 1
    1628:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    162c:	0f 90       	pop	r0
    162e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1630:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	0f 92       	push	r0
    163a:	f8 01       	movw	r30, r16
    163c:	85 8d       	ldd	r24, Z+29	; 0x1d
    163e:	8f 3f       	cpi	r24, 0xFF	; 255
    1640:	09 f4       	brne	.+2      	; 0x1644 <xQueueReceive+0x98>
    1642:	15 8e       	std	Z+29, r1	; 0x1d
    1644:	f8 01       	movw	r30, r16
    1646:	86 8d       	ldd	r24, Z+30	; 0x1e
    1648:	8f 3f       	cpi	r24, 0xFF	; 255
    164a:	09 f4       	brne	.+2      	; 0x164e <xQueueReceive+0xa2>
    164c:	16 8e       	std	Z+30, r1	; 0x1e
    164e:	0f 90       	pop	r0
    1650:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1652:	be 01       	movw	r22, r28
    1654:	6c 5f       	subi	r22, 0xFC	; 252
    1656:	7f 4f       	sbci	r23, 0xFF	; 255
    1658:	ce 01       	movw	r24, r28
    165a:	01 96       	adiw	r24, 0x01	; 1
    165c:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskCheckForTimeOut>
    1660:	81 11       	cpse	r24, r1
    1662:	1c c0       	rjmp	.+56     	; 0x169c <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1664:	c8 01       	movw	r24, r16
    1666:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <prvIsQueueEmpty>
    166a:	88 23       	and	r24, r24
    166c:	89 f0       	breq	.+34     	; 0x1690 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    166e:	6c 81       	ldd	r22, Y+4	; 0x04
    1670:	7d 81       	ldd	r23, Y+5	; 0x05
    1672:	c5 01       	movw	r24, r10
    1674:	0e 94 b6 05 	call	0xb6c	; 0xb6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1678:	c8 01       	movw	r24, r16
    167a:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    167e:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    1682:	88 23       	and	r24, r24
    1684:	11 f0       	breq	.+4      	; 0x168a <xQueueReceive+0xde>
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	a8 cf       	rjmp	.-176    	; 0x15da <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    168a:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    168e:	fb cf       	rjmp	.-10     	; 0x1686 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1690:	c8 01       	movw	r24, r16
    1692:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1696:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    169a:	f5 cf       	rjmp	.-22     	; 0x1686 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    169c:	c8 01       	movw	r24, r16
    169e:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16a2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16a6:	c8 01       	movw	r24, r16
    16a8:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <prvIsQueueEmpty>
    16ac:	88 23       	and	r24, r24
    16ae:	59 f3       	breq	.-42     	; 0x1686 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    16b0:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    16b2:	0f 90       	pop	r0
    16b4:	0f 90       	pop	r0
    16b6:	0f 90       	pop	r0
    16b8:	0f 90       	pop	r0
    16ba:	0f 90       	pop	r0
    16bc:	df 91       	pop	r29
    16be:	cf 91       	pop	r28
    16c0:	1f 91       	pop	r17
    16c2:	0f 91       	pop	r16
    16c4:	ff 90       	pop	r15
    16c6:	df 90       	pop	r13
    16c8:	cf 90       	pop	r12
    16ca:	bf 90       	pop	r11
    16cc:	af 90       	pop	r10
    16ce:	08 95       	ret

000016d0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    16d0:	ef 92       	push	r14
    16d2:	ff 92       	push	r15
    16d4:	0f 93       	push	r16
    16d6:	1f 93       	push	r17
    16d8:	cf 93       	push	r28
    16da:	df 93       	push	r29
    16dc:	00 d0       	rcall	.+0      	; 0x16de <xQueueSemaphoreTake+0xe>
    16de:	00 d0       	rcall	.+0      	; 0x16e0 <xQueueSemaphoreTake+0x10>
    16e0:	1f 92       	push	r1
    16e2:	cd b7       	in	r28, 0x3d	; 61
    16e4:	de b7       	in	r29, 0x3e	; 62
    16e6:	8c 01       	movw	r16, r24
    16e8:	7d 83       	std	Y+5, r23	; 0x05
    16ea:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    16ec:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16ee:	78 01       	movw	r14, r16
    16f0:	81 e1       	ldi	r24, 0x11	; 17
    16f2:	e8 0e       	add	r14, r24
    16f4:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	f8 94       	cli
    16fa:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    16fc:	f8 01       	movw	r30, r16
    16fe:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1700:	88 23       	and	r24, r24
    1702:	81 f0       	breq	.+32     	; 0x1724 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1704:	81 50       	subi	r24, 0x01	; 1
    1706:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1708:	80 85       	ldd	r24, Z+8	; 0x08
    170a:	88 23       	and	r24, r24
    170c:	39 f0       	breq	.+14     	; 0x171c <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    170e:	c8 01       	movw	r24, r16
    1710:	08 96       	adiw	r24, 0x08	; 8
    1712:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    1716:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1718:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    171c:	0f 90       	pop	r0
    171e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	50 c0       	rjmp	.+160    	; 0x17c4 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1724:	2c 81       	ldd	r18, Y+4	; 0x04
    1726:	3d 81       	ldd	r19, Y+5	; 0x05
    1728:	23 2b       	or	r18, r19
    172a:	19 f4       	brne	.+6      	; 0x1732 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    172c:	0f 90       	pop	r0
    172e:	0f be       	out	0x3f, r0	; 63
    1730:	48 c0       	rjmp	.+144    	; 0x17c2 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1732:	91 11       	cpse	r25, r1
    1734:	04 c0       	rjmp	.+8      	; 0x173e <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1736:	ce 01       	movw	r24, r28
    1738:	01 96       	adiw	r24, 0x01	; 1
    173a:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    173e:	0f 90       	pop	r0
    1740:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1742:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1746:	0f b6       	in	r0, 0x3f	; 63
    1748:	f8 94       	cli
    174a:	0f 92       	push	r0
    174c:	f8 01       	movw	r30, r16
    174e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1750:	8f 3f       	cpi	r24, 0xFF	; 255
    1752:	09 f4       	brne	.+2      	; 0x1756 <xQueueSemaphoreTake+0x86>
    1754:	15 8e       	std	Z+29, r1	; 0x1d
    1756:	f8 01       	movw	r30, r16
    1758:	86 8d       	ldd	r24, Z+30	; 0x1e
    175a:	8f 3f       	cpi	r24, 0xFF	; 255
    175c:	09 f4       	brne	.+2      	; 0x1760 <xQueueSemaphoreTake+0x90>
    175e:	16 8e       	std	Z+30, r1	; 0x1e
    1760:	0f 90       	pop	r0
    1762:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1764:	be 01       	movw	r22, r28
    1766:	6c 5f       	subi	r22, 0xFC	; 252
    1768:	7f 4f       	sbci	r23, 0xFF	; 255
    176a:	ce 01       	movw	r24, r28
    176c:	01 96       	adiw	r24, 0x01	; 1
    176e:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskCheckForTimeOut>
    1772:	81 11       	cpse	r24, r1
    1774:	1c c0       	rjmp	.+56     	; 0x17ae <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1776:	c8 01       	movw	r24, r16
    1778:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <prvIsQueueEmpty>
    177c:	88 23       	and	r24, r24
    177e:	89 f0       	breq	.+34     	; 0x17a2 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1780:	6c 81       	ldd	r22, Y+4	; 0x04
    1782:	7d 81       	ldd	r23, Y+5	; 0x05
    1784:	c7 01       	movw	r24, r14
    1786:	0e 94 b6 05 	call	0xb6c	; 0xb6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    178a:	c8 01       	movw	r24, r16
    178c:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1790:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    1794:	88 23       	and	r24, r24
    1796:	11 f0       	breq	.+4      	; 0x179c <xQueueSemaphoreTake+0xcc>
    1798:	91 e0       	ldi	r25, 0x01	; 1
    179a:	ad cf       	rjmp	.-166    	; 0x16f6 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    179c:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    17a0:	fb cf       	rjmp	.-10     	; 0x1798 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    17a2:	c8 01       	movw	r24, r16
    17a4:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17a8:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    17ac:	f5 cf       	rjmp	.-22     	; 0x1798 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    17ae:	c8 01       	movw	r24, r16
    17b0:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17b4:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17b8:	c8 01       	movw	r24, r16
    17ba:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <prvIsQueueEmpty>
    17be:	88 23       	and	r24, r24
    17c0:	59 f3       	breq	.-42     	; 0x1798 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17c2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17c4:	0f 90       	pop	r0
    17c6:	0f 90       	pop	r0
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	df 91       	pop	r29
    17d0:	cf 91       	pop	r28
    17d2:	1f 91       	pop	r17
    17d4:	0f 91       	pop	r16
    17d6:	ff 90       	pop	r15
    17d8:	ef 90       	pop	r14
    17da:	08 95       	ret

000017dc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    17dc:	cf 92       	push	r12
    17de:	df 92       	push	r13
    17e0:	ef 92       	push	r14
    17e2:	ff 92       	push	r15
    17e4:	0f 93       	push	r16
    17e6:	1f 93       	push	r17
    17e8:	cf 93       	push	r28
    17ea:	df 93       	push	r29
    17ec:	00 d0       	rcall	.+0      	; 0x17ee <xQueuePeek+0x12>
    17ee:	00 d0       	rcall	.+0      	; 0x17f0 <xQueuePeek+0x14>
    17f0:	1f 92       	push	r1
    17f2:	cd b7       	in	r28, 0x3d	; 61
    17f4:	de b7       	in	r29, 0x3e	; 62
    17f6:	8c 01       	movw	r16, r24
    17f8:	7b 01       	movw	r14, r22
    17fa:	5d 83       	std	Y+5, r21	; 0x05
    17fc:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    17fe:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1800:	68 01       	movw	r12, r16
    1802:	91 e1       	ldi	r25, 0x11	; 17
    1804:	c9 0e       	add	r12, r25
    1806:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1808:	0f b6       	in	r0, 0x3f	; 63
    180a:	f8 94       	cli
    180c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    180e:	f8 01       	movw	r30, r16
    1810:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1812:	99 23       	and	r25, r25
    1814:	b9 f0       	breq	.+46     	; 0x1844 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1816:	c6 80       	ldd	r12, Z+6	; 0x06
    1818:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    181a:	b7 01       	movw	r22, r14
    181c:	c8 01       	movw	r24, r16
    181e:	0e 94 2f 09 	call	0x125e	; 0x125e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1822:	f8 01       	movw	r30, r16
    1824:	d7 82       	std	Z+7, r13	; 0x07
    1826:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1828:	81 89       	ldd	r24, Z+17	; 0x11
    182a:	88 23       	and	r24, r24
    182c:	39 f0       	breq	.+14     	; 0x183c <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    182e:	c8 01       	movw	r24, r16
    1830:	41 96       	adiw	r24, 0x11	; 17
    1832:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    1836:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1838:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    183c:	0f 90       	pop	r0
    183e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	50 c0       	rjmp	.+160    	; 0x18e4 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1844:	2c 81       	ldd	r18, Y+4	; 0x04
    1846:	3d 81       	ldd	r19, Y+5	; 0x05
    1848:	23 2b       	or	r18, r19
    184a:	19 f4       	brne	.+6      	; 0x1852 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    184c:	0f 90       	pop	r0
    184e:	0f be       	out	0x3f, r0	; 63
    1850:	48 c0       	rjmp	.+144    	; 0x18e2 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1852:	81 11       	cpse	r24, r1
    1854:	04 c0       	rjmp	.+8      	; 0x185e <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1856:	ce 01       	movw	r24, r28
    1858:	01 96       	adiw	r24, 0x01	; 1
    185a:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    185e:	0f 90       	pop	r0
    1860:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1862:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1866:	0f b6       	in	r0, 0x3f	; 63
    1868:	f8 94       	cli
    186a:	0f 92       	push	r0
    186c:	f8 01       	movw	r30, r16
    186e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1870:	8f 3f       	cpi	r24, 0xFF	; 255
    1872:	09 f4       	brne	.+2      	; 0x1876 <xQueuePeek+0x9a>
    1874:	15 8e       	std	Z+29, r1	; 0x1d
    1876:	f8 01       	movw	r30, r16
    1878:	86 8d       	ldd	r24, Z+30	; 0x1e
    187a:	8f 3f       	cpi	r24, 0xFF	; 255
    187c:	09 f4       	brne	.+2      	; 0x1880 <xQueuePeek+0xa4>
    187e:	16 8e       	std	Z+30, r1	; 0x1e
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1884:	be 01       	movw	r22, r28
    1886:	6c 5f       	subi	r22, 0xFC	; 252
    1888:	7f 4f       	sbci	r23, 0xFF	; 255
    188a:	ce 01       	movw	r24, r28
    188c:	01 96       	adiw	r24, 0x01	; 1
    188e:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskCheckForTimeOut>
    1892:	81 11       	cpse	r24, r1
    1894:	1c c0       	rjmp	.+56     	; 0x18ce <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1896:	c8 01       	movw	r24, r16
    1898:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <prvIsQueueEmpty>
    189c:	88 23       	and	r24, r24
    189e:	89 f0       	breq	.+34     	; 0x18c2 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18a0:	6c 81       	ldd	r22, Y+4	; 0x04
    18a2:	7d 81       	ldd	r23, Y+5	; 0x05
    18a4:	c6 01       	movw	r24, r12
    18a6:	0e 94 b6 05 	call	0xb6c	; 0xb6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18b0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    18b4:	88 23       	and	r24, r24
    18b6:	11 f0       	breq	.+4      	; 0x18bc <xQueuePeek+0xe0>
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	a6 cf       	rjmp	.-180    	; 0x1808 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    18bc:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    18c0:	fb cf       	rjmp	.-10     	; 0x18b8 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18c2:	c8 01       	movw	r24, r16
    18c4:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18c8:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
    18cc:	f5 cf       	rjmp	.-22     	; 0x18b8 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18ce:	c8 01       	movw	r24, r16
    18d0:	0e 94 49 09 	call	0x1292	; 0x1292 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18d4:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18d8:	c8 01       	movw	r24, r16
    18da:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <prvIsQueueEmpty>
    18de:	88 23       	and	r24, r24
    18e0:	59 f3       	breq	.-42     	; 0x18b8 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18e2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18e4:	0f 90       	pop	r0
    18e6:	0f 90       	pop	r0
    18e8:	0f 90       	pop	r0
    18ea:	0f 90       	pop	r0
    18ec:	0f 90       	pop	r0
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	1f 91       	pop	r17
    18f4:	0f 91       	pop	r16
    18f6:	ff 90       	pop	r15
    18f8:	ef 90       	pop	r14
    18fa:	df 90       	pop	r13
    18fc:	cf 90       	pop	r12
    18fe:	08 95       	ret

00001900 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1900:	ef 92       	push	r14
    1902:	ff 92       	push	r15
    1904:	0f 93       	push	r16
    1906:	1f 93       	push	r17
    1908:	cf 93       	push	r28
    190a:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    190c:	fc 01       	movw	r30, r24
    190e:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1910:	00 23       	and	r16, r16
    1912:	e9 f0       	breq	.+58     	; 0x194e <xQueueReceiveFromISR+0x4e>
    1914:	7a 01       	movw	r14, r20
    1916:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1918:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    191a:	0e 94 2f 09 	call	0x125e	; 0x125e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    191e:	01 50       	subi	r16, 0x01	; 1
    1920:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1922:	1f 3f       	cpi	r17, 0xFF	; 255
    1924:	81 f4       	brne	.+32     	; 0x1946 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1926:	88 85       	ldd	r24, Y+8	; 0x08
    1928:	88 23       	and	r24, r24
    192a:	79 f0       	breq	.+30     	; 0x194a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    192c:	ce 01       	movw	r24, r28
    192e:	08 96       	adiw	r24, 0x08	; 8
    1930:	0e 94 df 05 	call	0xbbe	; 0xbbe <xTaskRemoveFromEventList>
    1934:	88 23       	and	r24, r24
    1936:	49 f0       	breq	.+18     	; 0x194a <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1938:	e1 14       	cp	r14, r1
    193a:	f1 04       	cpc	r15, r1
    193c:	31 f0       	breq	.+12     	; 0x194a <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    193e:	81 e0       	ldi	r24, 0x01	; 1
    1940:	f7 01       	movw	r30, r14
    1942:	80 83       	st	Z, r24
    1944:	05 c0       	rjmp	.+10     	; 0x1950 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1946:	1f 5f       	subi	r17, 0xFF	; 255
    1948:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	01 c0       	rjmp	.+2      	; 0x1950 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    194e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	08 95       	ret

0000195e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    195e:	0f 93       	push	r16
    1960:	1f 93       	push	r17
    1962:	cf 93       	push	r28
    1964:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1966:	fc 01       	movw	r30, r24
    1968:	22 8d       	ldd	r18, Z+26	; 0x1a
    196a:	22 23       	and	r18, r18
    196c:	49 f0       	breq	.+18     	; 0x1980 <xQueuePeekFromISR+0x22>
    196e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1970:	06 81       	ldd	r16, Z+6	; 0x06
    1972:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1974:	0e 94 2f 09 	call	0x125e	; 0x125e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1978:	1f 83       	std	Y+7, r17	; 0x07
    197a:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    197c:	81 e0       	ldi	r24, 0x01	; 1
    197e:	01 c0       	rjmp	.+2      	; 0x1982 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1980:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1982:	df 91       	pop	r29
    1984:	cf 91       	pop	r28
    1986:	1f 91       	pop	r17
    1988:	0f 91       	pop	r16
    198a:	08 95       	ret

0000198c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    198c:	0f b6       	in	r0, 0x3f	; 63
    198e:	f8 94       	cli
    1990:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1992:	fc 01       	movw	r30, r24
    1994:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1996:	0f 90       	pop	r0
    1998:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    199a:	08 95       	ret

0000199c <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19a2:	fc 01       	movw	r30, r24
    19a4:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19a6:	0f 90       	pop	r0
    19a8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    19aa:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19ac:	82 1b       	sub	r24, r18
    19ae:	08 95       	ret

000019b0 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    19b0:	fc 01       	movw	r30, r24
    19b2:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19b4:	08 95       	ret

000019b6 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    19b6:	0c 94 4f 10 	jmp	0x209e	; 0x209e <vPortFree>

000019ba <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19ba:	fc 01       	movw	r30, r24
    19bc:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19be:	81 e0       	ldi	r24, 0x01	; 1
    19c0:	91 11       	cpse	r25, r1
    19c2:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19c4:	08 95       	ret

000019c6 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    19c6:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19c8:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19ca:	81 e0       	ldi	r24, 0x01	; 1
    19cc:	23 8d       	ldd	r18, Z+27	; 0x1b
    19ce:	29 13       	cpse	r18, r25
    19d0:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19d2:	08 95       	ret

000019d4 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
    19d8:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    19da:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19e4:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19e6:	0f 90       	pop	r0
    19e8:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19ea:	89 13       	cpse	r24, r25
    19ec:	0f c0       	rjmp	.+30     	; 0x1a0c <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    19ee:	41 15       	cp	r20, r1
    19f0:	51 05       	cpc	r21, r1
    19f2:	49 f0       	breq	.+18     	; 0x1a06 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    19f4:	be 01       	movw	r22, r28
    19f6:	68 5f       	subi	r22, 0xF8	; 248
    19f8:	7f 4f       	sbci	r23, 0xFF	; 255
    19fa:	ca 01       	movw	r24, r20
    19fc:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a00:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a02:	8c ef       	ldi	r24, 0xFC	; 252
    1a04:	1b c0       	rjmp	.+54     	; 0x1a3c <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a06:	78 94       	sei
					return errQUEUE_FULL;
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	18 c0       	rjmp	.+48     	; 0x1a3c <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1a0c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a0e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a12:	89 17       	cp	r24, r25
    1a14:	88 f4       	brcc	.+34     	; 0x1a38 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a16:	40 e0       	ldi	r20, 0x00	; 0
    1a18:	ce 01       	movw	r24, r28
    1a1a:	0e 94 e7 08 	call	0x11ce	; 0x11ce <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a1e:	89 89       	ldd	r24, Y+17	; 0x11
    1a20:	81 11       	cpse	r24, r1
    1a22:	02 c0       	rjmp	.+4      	; 0x1a28 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	09 c0       	rjmp	.+18     	; 0x1a3a <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a28:	ce 01       	movw	r24, r28
    1a2a:	41 96       	adiw	r24, 0x11	; 17
    1a2c:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <xCoRoutineRemoveFromEventList>
    1a30:	88 23       	and	r24, r24
    1a32:	c1 f3       	breq	.-16     	; 0x1a24 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1a34:	8b ef       	ldi	r24, 0xFB	; 251
    1a36:	01 c0       	rjmp	.+2      	; 0x1a3a <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1a38:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a3a:	78 94       	sei

		return xReturn;
	}
    1a3c:	df 91       	pop	r29
    1a3e:	cf 91       	pop	r28
    1a40:	08 95       	ret

00001a42 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
    1a46:	ec 01       	movw	r28, r24
    1a48:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a4a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a4e:	81 11       	cpse	r24, r1
    1a50:	0f c0       	rjmp	.+30     	; 0x1a70 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a52:	41 15       	cp	r20, r1
    1a54:	51 05       	cpc	r21, r1
    1a56:	49 f0       	breq	.+18     	; 0x1a6a <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a58:	be 01       	movw	r22, r28
    1a5a:	6f 5e       	subi	r22, 0xEF	; 239
    1a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5e:	ca 01       	movw	r24, r20
    1a60:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a64:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a66:	8c ef       	ldi	r24, 0xFC	; 252
    1a68:	30 c0       	rjmp	.+96     	; 0x1aca <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a6a:	78 94       	sei
					return errQUEUE_FULL;
    1a6c:	80 e0       	ldi	r24, 0x00	; 0
    1a6e:	2d c0       	rjmp	.+90     	; 0x1aca <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1a70:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a72:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a74:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a76:	88 23       	and	r24, r24
    1a78:	31 f1       	breq	.+76     	; 0x1ac6 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1a7a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a7c:	50 e0       	ldi	r21, 0x00	; 0
    1a7e:	2e 81       	ldd	r18, Y+6	; 0x06
    1a80:	3f 81       	ldd	r19, Y+7	; 0x07
    1a82:	24 0f       	add	r18, r20
    1a84:	35 1f       	adc	r19, r21
    1a86:	3f 83       	std	Y+7, r19	; 0x07
    1a88:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a8e:	28 17       	cp	r18, r24
    1a90:	39 07       	cpc	r19, r25
    1a92:	20 f0       	brcs	.+8      	; 0x1a9c <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1a94:	88 81       	ld	r24, Y
    1a96:	99 81       	ldd	r25, Y+1	; 0x01
    1a98:	9f 83       	std	Y+7, r25	; 0x07
    1a9a:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1a9c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a9e:	91 50       	subi	r25, 0x01	; 1
    1aa0:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1aa2:	6e 81       	ldd	r22, Y+6	; 0x06
    1aa4:	7f 81       	ldd	r23, Y+7	; 0x07
    1aa6:	cf 01       	movw	r24, r30
    1aa8:	0e 94 29 12 	call	0x2452	; 0x2452 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1aac:	88 85       	ldd	r24, Y+8	; 0x08
    1aae:	81 11       	cpse	r24, r1
    1ab0:	02 c0       	rjmp	.+4      	; 0x1ab6 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	09 c0       	rjmp	.+18     	; 0x1ac8 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ab6:	ce 01       	movw	r24, r28
    1ab8:	08 96       	adiw	r24, 0x08	; 8
    1aba:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <xCoRoutineRemoveFromEventList>
    1abe:	88 23       	and	r24, r24
    1ac0:	c1 f3       	breq	.-16     	; 0x1ab2 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1ac2:	8b ef       	ldi	r24, 0xFB	; 251
    1ac4:	01 c0       	rjmp	.+2      	; 0x1ac8 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1ac8:	78 94       	sei

		return xReturn;
	}
    1aca:	df 91       	pop	r29
    1acc:	cf 91       	pop	r28
    1ace:	08 95       	ret

00001ad0 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1ad0:	0f 93       	push	r16
    1ad2:	1f 93       	push	r17
    1ad4:	cf 93       	push	r28
    1ad6:	8c 01       	movw	r16, r24
    1ad8:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ada:	fc 01       	movw	r30, r24
    1adc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ade:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ae0:	98 17       	cp	r25, r24
    1ae2:	10 f0       	brcs	.+4      	; 0x1ae8 <xQueueCRSendFromISR+0x18>
    1ae4:	4c 2f       	mov	r20, r28
    1ae6:	12 c0       	rjmp	.+36     	; 0x1b0c <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1ae8:	40 e0       	ldi	r20, 0x00	; 0
    1aea:	c8 01       	movw	r24, r16
    1aec:	0e 94 e7 08 	call	0x11ce	; 0x11ce <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1af0:	c1 11       	cpse	r28, r1
    1af2:	f8 cf       	rjmp	.-16     	; 0x1ae4 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1af4:	f8 01       	movw	r30, r16
    1af6:	81 89       	ldd	r24, Z+17	; 0x11
    1af8:	88 23       	and	r24, r24
    1afa:	39 f0       	breq	.+14     	; 0x1b0a <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1afc:	c8 01       	movw	r24, r16
    1afe:	41 96       	adiw	r24, 0x11	; 17
    1b00:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1b04:	41 e0       	ldi	r20, 0x01	; 1
    1b06:	81 11       	cpse	r24, r1
    1b08:	01 c0       	rjmp	.+2      	; 0x1b0c <xQueueCRSendFromISR+0x3c>
    1b0a:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1b0c:	84 2f       	mov	r24, r20
    1b0e:	cf 91       	pop	r28
    1b10:	1f 91       	pop	r17
    1b12:	0f 91       	pop	r16
    1b14:	08 95       	ret

00001b16 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1b16:	0f 93       	push	r16
    1b18:	1f 93       	push	r17
    1b1a:	cf 93       	push	r28
    1b1c:	df 93       	push	r29
    1b1e:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b20:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b22:	88 23       	and	r24, r24
    1b24:	79 f1       	breq	.+94     	; 0x1b84 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b26:	24 8d       	ldd	r18, Z+28	; 0x1c
    1b28:	30 e0       	ldi	r19, 0x00	; 0
    1b2a:	a6 81       	ldd	r26, Z+6	; 0x06
    1b2c:	b7 81       	ldd	r27, Z+7	; 0x07
    1b2e:	a2 0f       	add	r26, r18
    1b30:	b3 1f       	adc	r27, r19
    1b32:	b7 83       	std	Z+7, r27	; 0x07
    1b34:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b36:	84 81       	ldd	r24, Z+4	; 0x04
    1b38:	95 81       	ldd	r25, Z+5	; 0x05
    1b3a:	a8 17       	cp	r26, r24
    1b3c:	b9 07       	cpc	r27, r25
    1b3e:	20 f0       	brcs	.+8      	; 0x1b48 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b40:	80 81       	ld	r24, Z
    1b42:	91 81       	ldd	r25, Z+1	; 0x01
    1b44:	97 83       	std	Z+7, r25	; 0x07
    1b46:	86 83       	std	Z+6, r24	; 0x06
    1b48:	8a 01       	movw	r16, r20
    1b4a:	cb 01       	movw	r24, r22
    1b4c:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b4e:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b50:	41 50       	subi	r20, 0x01	; 1
    1b52:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b54:	66 81       	ldd	r22, Z+6	; 0x06
    1b56:	77 81       	ldd	r23, Z+7	; 0x07
    1b58:	a9 01       	movw	r20, r18
    1b5a:	0e 94 29 12 	call	0x2452	; 0x2452 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b5e:	f8 01       	movw	r30, r16
    1b60:	80 81       	ld	r24, Z
    1b62:	88 23       	and	r24, r24
    1b64:	11 f0       	breq	.+4      	; 0x1b6a <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b66:	81 e0       	ldi	r24, 0x01	; 1
    1b68:	0e c0       	rjmp	.+28     	; 0x1b86 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b6a:	88 85       	ldd	r24, Y+8	; 0x08
    1b6c:	88 23       	and	r24, r24
    1b6e:	d9 f3       	breq	.-10     	; 0x1b66 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b70:	ce 01       	movw	r24, r28
    1b72:	08 96       	adiw	r24, 0x08	; 8
    1b74:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <xCoRoutineRemoveFromEventList>
    1b78:	88 23       	and	r24, r24
    1b7a:	a9 f3       	breq	.-22     	; 0x1b66 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	f8 01       	movw	r30, r16
    1b80:	80 83       	st	Z, r24
    1b82:	01 c0       	rjmp	.+2      	; 0x1b86 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b84:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1b86:	df 91       	pop	r29
    1b88:	cf 91       	pop	r28
    1b8a:	1f 91       	pop	r17
    1b8c:	0f 91       	pop	r16
    1b8e:	08 95       	ret

00001b90 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b90:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b92:	03 96       	adiw	r24, 0x03	; 3
    1b94:	92 83       	std	Z+2, r25	; 0x02
    1b96:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b98:	2f ef       	ldi	r18, 0xFF	; 255
    1b9a:	3f ef       	ldi	r19, 0xFF	; 255
    1b9c:	34 83       	std	Z+4, r19	; 0x04
    1b9e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ba0:	96 83       	std	Z+6, r25	; 0x06
    1ba2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ba4:	90 87       	std	Z+8, r25	; 0x08
    1ba6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ba8:	10 82       	st	Z, r1
    1baa:	08 95       	ret

00001bac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1bac:	fc 01       	movw	r30, r24
    1bae:	11 86       	std	Z+9, r1	; 0x09
    1bb0:	10 86       	std	Z+8, r1	; 0x08
    1bb2:	08 95       	ret

00001bb4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	9c 01       	movw	r18, r24
    1bba:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1bbc:	dc 01       	movw	r26, r24
    1bbe:	11 96       	adiw	r26, 0x01	; 1
    1bc0:	cd 91       	ld	r28, X+
    1bc2:	dc 91       	ld	r29, X
    1bc4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bc6:	d3 83       	std	Z+3, r29	; 0x03
    1bc8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bca:	8c 81       	ldd	r24, Y+4	; 0x04
    1bcc:	9d 81       	ldd	r25, Y+5	; 0x05
    1bce:	95 83       	std	Z+5, r25	; 0x05
    1bd0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1bd2:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd4:	9d 81       	ldd	r25, Y+5	; 0x05
    1bd6:	dc 01       	movw	r26, r24
    1bd8:	13 96       	adiw	r26, 0x03	; 3
    1bda:	7c 93       	st	X, r23
    1bdc:	6e 93       	st	-X, r22
    1bde:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1be0:	7d 83       	std	Y+5, r23	; 0x05
    1be2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1be4:	31 87       	std	Z+9, r19	; 0x09
    1be6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1be8:	f9 01       	movw	r30, r18
    1bea:	80 81       	ld	r24, Z
    1bec:	8f 5f       	subi	r24, 0xFF	; 255
    1bee:	80 83       	st	Z, r24
}
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	08 95       	ret

00001bf6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bf6:	0f 93       	push	r16
    1bf8:	1f 93       	push	r17
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
    1bfe:	8c 01       	movw	r16, r24
    1c00:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c02:	80 81       	ld	r24, Z
    1c04:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c06:	8f 3f       	cpi	r24, 0xFF	; 255
    1c08:	2f ef       	ldi	r18, 0xFF	; 255
    1c0a:	92 07       	cpc	r25, r18
    1c0c:	21 f4       	brne	.+8      	; 0x1c16 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c0e:	e8 01       	movw	r28, r16
    1c10:	af 81       	ldd	r26, Y+7	; 0x07
    1c12:	b8 85       	ldd	r27, Y+8	; 0x08
    1c14:	0e c0       	rjmp	.+28     	; 0x1c32 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c16:	d8 01       	movw	r26, r16
    1c18:	13 96       	adiw	r26, 0x03	; 3
    1c1a:	12 96       	adiw	r26, 0x02	; 2
    1c1c:	2d 91       	ld	r18, X+
    1c1e:	3c 91       	ld	r19, X
    1c20:	13 97       	sbiw	r26, 0x03	; 3
    1c22:	e9 01       	movw	r28, r18
    1c24:	48 81       	ld	r20, Y
    1c26:	59 81       	ldd	r21, Y+1	; 0x01
    1c28:	84 17       	cp	r24, r20
    1c2a:	95 07       	cpc	r25, r21
    1c2c:	10 f0       	brcs	.+4      	; 0x1c32 <vListInsert+0x3c>
    1c2e:	d9 01       	movw	r26, r18
    1c30:	f4 cf       	rjmp	.-24     	; 0x1c1a <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c32:	12 96       	adiw	r26, 0x02	; 2
    1c34:	8d 91       	ld	r24, X+
    1c36:	9c 91       	ld	r25, X
    1c38:	13 97       	sbiw	r26, 0x03	; 3
    1c3a:	93 83       	std	Z+3, r25	; 0x03
    1c3c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c3e:	ec 01       	movw	r28, r24
    1c40:	fd 83       	std	Y+5, r31	; 0x05
    1c42:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c44:	b5 83       	std	Z+5, r27	; 0x05
    1c46:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c48:	13 96       	adiw	r26, 0x03	; 3
    1c4a:	fc 93       	st	X, r31
    1c4c:	ee 93       	st	-X, r30
    1c4e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c50:	11 87       	std	Z+9, r17	; 0x09
    1c52:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c54:	f8 01       	movw	r30, r16
    1c56:	80 81       	ld	r24, Z
    1c58:	8f 5f       	subi	r24, 0xFF	; 255
    1c5a:	80 83       	st	Z, r24
}
    1c5c:	df 91       	pop	r29
    1c5e:	cf 91       	pop	r28
    1c60:	1f 91       	pop	r17
    1c62:	0f 91       	pop	r16
    1c64:	08 95       	ret

00001c66 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c66:	cf 93       	push	r28
    1c68:	df 93       	push	r29
    1c6a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c6c:	a0 85       	ldd	r26, Z+8	; 0x08
    1c6e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c70:	82 81       	ldd	r24, Z+2	; 0x02
    1c72:	93 81       	ldd	r25, Z+3	; 0x03
    1c74:	24 81       	ldd	r18, Z+4	; 0x04
    1c76:	35 81       	ldd	r19, Z+5	; 0x05
    1c78:	ec 01       	movw	r28, r24
    1c7a:	3d 83       	std	Y+5, r19	; 0x05
    1c7c:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c7e:	c4 81       	ldd	r28, Z+4	; 0x04
    1c80:	d5 81       	ldd	r29, Z+5	; 0x05
    1c82:	9b 83       	std	Y+3, r25	; 0x03
    1c84:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c86:	11 96       	adiw	r26, 0x01	; 1
    1c88:	8d 91       	ld	r24, X+
    1c8a:	9c 91       	ld	r25, X
    1c8c:	12 97       	sbiw	r26, 0x02	; 2
    1c8e:	e8 17       	cp	r30, r24
    1c90:	f9 07       	cpc	r31, r25
    1c92:	21 f4       	brne	.+8      	; 0x1c9c <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c94:	12 96       	adiw	r26, 0x02	; 2
    1c96:	dc 93       	st	X, r29
    1c98:	ce 93       	st	-X, r28
    1c9a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1c9c:	11 86       	std	Z+9, r1	; 0x09
    1c9e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1ca0:	8c 91       	ld	r24, X
    1ca2:	81 50       	subi	r24, 0x01	; 1
    1ca4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1ca6:	8c 91       	ld	r24, X
}
    1ca8:	df 91       	pop	r29
    1caa:	cf 91       	pop	r28
    1cac:	08 95       	ret

00001cae <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1cae:	cf 92       	push	r12
    1cb0:	df 92       	push	r13
    1cb2:	ef 92       	push	r14
    1cb4:	ff 92       	push	r15
    1cb6:	1f 93       	push	r17
    1cb8:	cf 93       	push	r28
    1cba:	df 93       	push	r29
    1cbc:	6c 01       	movw	r12, r24
    1cbe:	16 2f       	mov	r17, r22
    1cc0:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1cc2:	8a e1       	ldi	r24, 0x1A	; 26
    1cc4:	90 e0       	ldi	r25, 0x00	; 0
    1cc6:	0e 94 1d 10 	call	0x203a	; 0x203a <pvPortMalloc>
    1cca:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1ccc:	89 2b       	or	r24, r25
    1cce:	09 f4       	brne	.+2      	; 0x1cd2 <xCoRoutineCreate+0x24>
    1cd0:	57 c0       	rjmp	.+174    	; 0x1d80 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1cd2:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1cd6:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1cda:	89 2b       	or	r24, r25
    1cdc:	21 f5       	brne	.+72     	; 0x1d26 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1cde:	d0 93 95 01 	sts	0x0195, r29	; 0x800195 <pxCurrentCoRoutine+0x1>
    1ce2:	c0 93 94 01 	sts	0x0194, r28	; 0x800194 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1ce6:	8c eb       	ldi	r24, 0xBC	; 188
    1ce8:	91 e0       	ldi	r25, 0x01	; 1
    1cea:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
    1cee:	85 ec       	ldi	r24, 0xC5	; 197
    1cf0:	91 e0       	ldi	r25, 0x01	; 1
    1cf2:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1cf6:	83 eb       	ldi	r24, 0xB3	; 179
    1cf8:	91 e0       	ldi	r25, 0x01	; 1
    1cfa:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1cfe:	8a ea       	ldi	r24, 0xAA	; 170
    1d00:	91 e0       	ldi	r25, 0x01	; 1
    1d02:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1d06:	8d e9       	ldi	r24, 0x9D	; 157
    1d08:	91 e0       	ldi	r25, 0x01	; 1
    1d0a:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1d0e:	83 eb       	ldi	r24, 0xB3	; 179
    1d10:	91 e0       	ldi	r25, 0x01	; 1
    1d12:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1d16:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1d1a:	8a ea       	ldi	r24, 0xAA	; 170
    1d1c:	91 e0       	ldi	r25, 0x01	; 1
    1d1e:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1d22:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1d26:	11 11       	cpse	r17, r1
    1d28:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1d2a:	19 8e       	std	Y+25, r1	; 0x19
    1d2c:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1d2e:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1d30:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1d32:	fe 01       	movw	r30, r28
    1d34:	c1 92       	st	Z+, r12
    1d36:	d1 92       	st	Z+, r13
    1d38:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1d3a:	cf 01       	movw	r24, r30
    1d3c:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d40:	ce 01       	movw	r24, r28
    1d42:	0c 96       	adiw	r24, 0x0c	; 12
    1d44:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d48:	d9 87       	std	Y+9, r29	; 0x09
    1d4a:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d4c:	db 8b       	std	Y+19, r29	; 0x13
    1d4e:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d50:	82 e0       	ldi	r24, 0x02	; 2
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	81 1b       	sub	r24, r17
    1d56:	91 09       	sbc	r25, r1
    1d58:	9d 87       	std	Y+13, r25	; 0x0d
    1d5a:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d5c:	8e 89       	ldd	r24, Y+22	; 0x16
    1d5e:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>
    1d62:	98 17       	cp	r25, r24
    1d64:	10 f4       	brcc	.+4      	; 0x1d6a <xCoRoutineCreate+0xbc>
    1d66:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
    1d6a:	f9 e0       	ldi	r31, 0x09	; 9
    1d6c:	8f 9f       	mul	r24, r31
    1d6e:	c0 01       	movw	r24, r0
    1d70:	11 24       	eor	r1, r1
    1d72:	b7 01       	movw	r22, r14
    1d74:	84 54       	subi	r24, 0x44	; 68
    1d76:	9e 4f       	sbci	r25, 0xFE	; 254
    1d78:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

		xReturn = pdPASS;
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	01 c0       	rjmp	.+2      	; 0x1d82 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d80:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1d82:	df 91       	pop	r29
    1d84:	cf 91       	pop	r28
    1d86:	1f 91       	pop	r17
    1d88:	ff 90       	pop	r15
    1d8a:	ef 90       	pop	r14
    1d8c:	df 90       	pop	r13
    1d8e:	cf 90       	pop	r12
    1d90:	08 95       	ret

00001d92 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1d92:	0f 93       	push	r16
    1d94:	1f 93       	push	r17
    1d96:	cf 93       	push	r28
    1d98:	df 93       	push	r29
    1d9a:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1d9c:	c0 91 9a 01 	lds	r28, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1da0:	d0 91 9b 01 	lds	r29, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1da4:	c8 0f       	add	r28, r24
    1da6:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1da8:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1dac:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1db0:	02 96       	adiw	r24, 0x02	; 2
    1db2:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1db6:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1dba:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1dbe:	d3 83       	std	Z+3, r29	; 0x03
    1dc0:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1dc2:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1dc6:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1dca:	bf 01       	movw	r22, r30
    1dcc:	6e 5f       	subi	r22, 0xFE	; 254
    1dce:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd0:	c8 17       	cp	r28, r24
    1dd2:	d9 07       	cpc	r29, r25
    1dd4:	28 f4       	brcc	.+10     	; 0x1de0 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dd6:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1dda:	90 91 a7 01 	lds	r25, 0x01A7	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1dde:	04 c0       	rjmp	.+8      	; 0x1de8 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1de0:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <pxDelayedCoRoutineList>
    1de4:	90 91 a9 01 	lds	r25, 0x01A9	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1de8:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vListInsert>
	}

	if( pxEventList )
    1dec:	01 15       	cp	r16, r1
    1dee:	11 05       	cpc	r17, r1
    1df0:	69 f0       	breq	.+26     	; 0x1e0c <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1df2:	60 91 94 01 	lds	r22, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1df6:	70 91 95 01 	lds	r23, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1dfa:	64 5f       	subi	r22, 0xF4	; 244
    1dfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1dfe:	c8 01       	movw	r24, r16
	}
}
    1e00:	df 91       	pop	r29
    1e02:	cf 91       	pop	r28
    1e04:	1f 91       	pop	r17
    1e06:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e08:	0c 94 fb 0d 	jmp	0x1bf6	; 0x1bf6 <vListInsert>
	}
}
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	1f 91       	pop	r17
    1e12:	0f 91       	pop	r16
    1e14:	08 95       	ret

00001e16 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e16:	ff 92       	push	r15
    1e18:	0f 93       	push	r16
    1e1a:	1f 93       	push	r17
    1e1c:	cf 93       	push	r28
    1e1e:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e20:	99 e0       	ldi	r25, 0x09	; 9
    1e22:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1e24:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <xPendingReadyCoRoutineList>
    1e28:	88 23       	and	r24, r24
    1e2a:	11 f1       	breq	.+68     	; 0x1e70 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1e2c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1e2e:	e0 91 a2 01 	lds	r30, 0x01A2	; 0x8001a2 <xPendingReadyCoRoutineList+0x5>
    1e32:	f0 91 a3 01 	lds	r31, 0x01A3	; 0x8001a3 <xPendingReadyCoRoutineList+0x6>
    1e36:	c6 81       	ldd	r28, Z+6	; 0x06
    1e38:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e3a:	ce 01       	movw	r24, r28
    1e3c:	0c 96       	adiw	r24, 0x0c	; 12
    1e3e:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e42:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e44:	8e 01       	movw	r16, r28
    1e46:	0e 5f       	subi	r16, 0xFE	; 254
    1e48:	1f 4f       	sbci	r17, 0xFF	; 255
    1e4a:	c8 01       	movw	r24, r16
    1e4c:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e50:	8e 89       	ldd	r24, Y+22	; 0x16
    1e52:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>
    1e56:	98 17       	cp	r25, r24
    1e58:	10 f4       	brcc	.+4      	; 0x1e5e <vCoRoutineSchedule+0x48>
    1e5a:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
    1e5e:	f8 9e       	mul	r15, r24
    1e60:	c0 01       	movw	r24, r0
    1e62:	11 24       	eor	r1, r1
    1e64:	b8 01       	movw	r22, r16
    1e66:	84 54       	subi	r24, 0x44	; 68
    1e68:	9e 4f       	sbci	r25, 0xFE	; 254
    1e6a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
    1e6e:	da cf       	rjmp	.-76     	; 0x1e24 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e70:	0e 94 9b 03 	call	0x736	; 0x736 <xTaskGetTickCount>
    1e74:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <xLastTickCount>
    1e78:	30 91 99 01 	lds	r19, 0x0199	; 0x800199 <xLastTickCount+0x1>
    1e7c:	82 1b       	sub	r24, r18
    1e7e:	93 0b       	sbc	r25, r19
    1e80:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <xPassedTicks+0x1>
    1e84:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1e88:	89 e0       	ldi	r24, 0x09	; 9
    1e8a:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e8c:	20 91 96 01 	lds	r18, 0x0196	; 0x800196 <xPassedTicks>
    1e90:	30 91 97 01 	lds	r19, 0x0197	; 0x800197 <xPassedTicks+0x1>
    1e94:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1e98:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1e9c:	21 15       	cp	r18, r1
    1e9e:	31 05       	cpc	r19, r1
    1ea0:	09 f4       	brne	.+2      	; 0x1ea4 <vCoRoutineSchedule+0x8e>
    1ea2:	54 c0       	rjmp	.+168    	; 0x1f4c <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1ea4:	01 96       	adiw	r24, 0x01	; 1
    1ea6:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <xCoRoutineTickCount+0x1>
    1eaa:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <xCoRoutineTickCount>
		xPassedTicks--;
    1eae:	21 50       	subi	r18, 0x01	; 1
    1eb0:	31 09       	sbc	r19, r1
    1eb2:	30 93 97 01 	sts	0x0197, r19	; 0x800197 <xPassedTicks+0x1>
    1eb6:	20 93 96 01 	sts	0x0196, r18	; 0x800196 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1eba:	89 2b       	or	r24, r25
    1ebc:	09 f0       	breq	.+2      	; 0x1ec0 <vCoRoutineSchedule+0xaa>
    1ebe:	3e c0       	rjmp	.+124    	; 0x1f3c <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1ec0:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <pxDelayedCoRoutineList>
    1ec4:	90 91 a9 01 	lds	r25, 0x01A9	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1ec8:	20 91 a6 01 	lds	r18, 0x01A6	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1ecc:	30 91 a7 01 	lds	r19, 0x01A7	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1ed0:	30 93 a9 01 	sts	0x01A9, r19	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1ed4:	20 93 a8 01 	sts	0x01A8, r18	; 0x8001a8 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1ed8:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1edc:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1ee0:	2d c0       	rjmp	.+90     	; 0x1f3c <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1ee2:	05 80       	ldd	r0, Z+5	; 0x05
    1ee4:	f6 81       	ldd	r31, Z+6	; 0x06
    1ee6:	e0 2d       	mov	r30, r0
    1ee8:	c6 81       	ldd	r28, Z+6	; 0x06
    1eea:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1eec:	2a 81       	ldd	r18, Y+2	; 0x02
    1eee:	3b 81       	ldd	r19, Y+3	; 0x03
    1ef0:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1ef4:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1ef8:	82 17       	cp	r24, r18
    1efa:	93 07       	cpc	r25, r19
    1efc:	38 f2       	brcs	.-114    	; 0x1e8c <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1efe:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1f00:	8e 01       	movw	r16, r28
    1f02:	0e 5f       	subi	r16, 0xFE	; 254
    1f04:	1f 4f       	sbci	r17, 0xFF	; 255
    1f06:	c8 01       	movw	r24, r16
    1f08:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1f0c:	8c 89       	ldd	r24, Y+20	; 0x14
    1f0e:	9d 89       	ldd	r25, Y+21	; 0x15
    1f10:	89 2b       	or	r24, r25
    1f12:	21 f0       	breq	.+8      	; 0x1f1c <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1f14:	ce 01       	movw	r24, r28
    1f16:	0c 96       	adiw	r24, 0x0c	; 12
    1f18:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1f1c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f1e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f20:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>
    1f24:	98 17       	cp	r25, r24
    1f26:	10 f4       	brcc	.+4      	; 0x1f2c <vCoRoutineSchedule+0x116>
    1f28:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
    1f2c:	f8 9e       	mul	r15, r24
    1f2e:	c0 01       	movw	r24, r0
    1f30:	11 24       	eor	r1, r1
    1f32:	b8 01       	movw	r22, r16
    1f34:	84 54       	subi	r24, 0x44	; 68
    1f36:	9e 4f       	sbci	r25, 0xFE	; 254
    1f38:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f3c:	e0 91 a8 01 	lds	r30, 0x01A8	; 0x8001a8 <pxDelayedCoRoutineList>
    1f40:	f0 91 a9 01 	lds	r31, 0x01A9	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1f44:	80 81       	ld	r24, Z
    1f46:	81 11       	cpse	r24, r1
    1f48:	cc cf       	rjmp	.-104    	; 0x1ee2 <vCoRoutineSchedule+0xcc>
    1f4a:	a0 cf       	rjmp	.-192    	; 0x1e8c <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f4c:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <xLastTickCount+0x1>
    1f50:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <xLastTickCount>
    1f54:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f58:	69 e0       	ldi	r22, 0x09	; 9
    1f5a:	48 2f       	mov	r20, r24
    1f5c:	50 e0       	ldi	r21, 0x00	; 0
    1f5e:	64 9f       	mul	r22, r20
    1f60:	90 01       	movw	r18, r0
    1f62:	65 9f       	mul	r22, r21
    1f64:	30 0d       	add	r19, r0
    1f66:	11 24       	eor	r1, r1
    1f68:	f9 01       	movw	r30, r18
    1f6a:	e4 54       	subi	r30, 0x44	; 68
    1f6c:	fe 4f       	sbci	r31, 0xFE	; 254
    1f6e:	90 81       	ld	r25, Z
    1f70:	91 11       	cpse	r25, r1
    1f72:	0c c0       	rjmp	.+24     	; 0x1f8c <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1f74:	81 11       	cpse	r24, r1
    1f76:	08 c0       	rjmp	.+16     	; 0x1f88 <vCoRoutineSchedule+0x172>
    1f78:	10 92 9c 01 	sts	0x019C, r1	; 0x80019c <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1f7c:	df 91       	pop	r29
    1f7e:	cf 91       	pop	r28
    1f80:	1f 91       	pop	r17
    1f82:	0f 91       	pop	r16
    1f84:	ff 90       	pop	r15
    1f86:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1f88:	81 50       	subi	r24, 0x01	; 1
    1f8a:	e7 cf       	rjmp	.-50     	; 0x1f5a <vCoRoutineSchedule+0x144>
    1f8c:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f90:	a1 81       	ldd	r26, Z+1	; 0x01
    1f92:	b2 81       	ldd	r27, Z+2	; 0x02
    1f94:	12 96       	adiw	r26, 0x02	; 2
    1f96:	0d 90       	ld	r0, X+
    1f98:	bc 91       	ld	r27, X
    1f9a:	a0 2d       	mov	r26, r0
    1f9c:	b2 83       	std	Z+2, r27	; 0x02
    1f9e:	a1 83       	std	Z+1, r26	; 0x01
    1fa0:	21 54       	subi	r18, 0x41	; 65
    1fa2:	3e 4f       	sbci	r19, 0xFE	; 254
    1fa4:	a2 17       	cp	r26, r18
    1fa6:	b3 07       	cpc	r27, r19
    1fa8:	31 f4       	brne	.+12     	; 0x1fb6 <vCoRoutineSchedule+0x1a0>
    1faa:	12 96       	adiw	r26, 0x02	; 2
    1fac:	8d 91       	ld	r24, X+
    1fae:	9c 91       	ld	r25, X
    1fb0:	13 97       	sbiw	r26, 0x03	; 3
    1fb2:	92 83       	std	Z+2, r25	; 0x02
    1fb4:	81 83       	std	Z+1, r24	; 0x01
    1fb6:	89 e0       	ldi	r24, 0x09	; 9
    1fb8:	84 9f       	mul	r24, r20
    1fba:	f0 01       	movw	r30, r0
    1fbc:	85 9f       	mul	r24, r21
    1fbe:	f0 0d       	add	r31, r0
    1fc0:	11 24       	eor	r1, r1
    1fc2:	e4 54       	subi	r30, 0x44	; 68
    1fc4:	fe 4f       	sbci	r31, 0xFE	; 254
    1fc6:	01 80       	ldd	r0, Z+1	; 0x01
    1fc8:	f2 81       	ldd	r31, Z+2	; 0x02
    1fca:	e0 2d       	mov	r30, r0
    1fcc:	86 81       	ldd	r24, Z+6	; 0x06
    1fce:	97 81       	ldd	r25, Z+7	; 0x07
    1fd0:	90 93 95 01 	sts	0x0195, r25	; 0x800195 <pxCurrentCoRoutine+0x1>
    1fd4:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fd8:	dc 01       	movw	r26, r24
    1fda:	ed 91       	ld	r30, X+
    1fdc:	fc 91       	ld	r31, X
    1fde:	11 97       	sbiw	r26, 0x01	; 1
    1fe0:	57 96       	adiw	r26, 0x17	; 23
    1fe2:	6c 91       	ld	r22, X

	return;
}
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fee:	09 94       	ijmp

00001ff0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1ff8:	dc 01       	movw	r26, r24
    1ffa:	15 96       	adiw	r26, 0x05	; 5
    1ffc:	ed 91       	ld	r30, X+
    1ffe:	fc 91       	ld	r31, X
    2000:	16 97       	sbiw	r26, 0x06	; 6
    2002:	c6 81       	ldd	r28, Z+6	; 0x06
    2004:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2006:	8e 01       	movw	r16, r28
    2008:	04 5f       	subi	r16, 0xF4	; 244
    200a:	1f 4f       	sbci	r17, 0xFF	; 255
    200c:	c8 01       	movw	r24, r16
    200e:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2012:	b8 01       	movw	r22, r16
    2014:	8d e9       	ldi	r24, 0x9D	; 157
    2016:	91 e0       	ldi	r25, 0x01	; 1
    2018:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    201c:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    2020:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2024:	81 e0       	ldi	r24, 0x01	; 1
    2026:	2e 89       	ldd	r18, Y+22	; 0x16
    2028:	96 89       	ldd	r25, Z+22	; 0x16
    202a:	29 17       	cp	r18, r25
    202c:	08 f4       	brcc	.+2      	; 0x2030 <xCoRoutineRemoveFromEventList+0x40>
    202e:	80 e0       	ldi	r24, 0x00	; 0
}
    2030:	df 91       	pop	r29
    2032:	cf 91       	pop	r28
    2034:	1f 91       	pop	r17
    2036:	0f 91       	pop	r16
    2038:	08 95       	ret

0000203a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    203a:	cf 93       	push	r28
    203c:	df 93       	push	r29
    203e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2040:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2044:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <pucAlignedHeap.2081>
    2048:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <pucAlignedHeap.2081+0x1>
    204c:	89 2b       	or	r24, r25
    204e:	31 f4       	brne	.+12     	; 0x205c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2050:	83 ed       	ldi	r24, 0xD3	; 211
    2052:	91 e0       	ldi	r25, 0x01	; 1
    2054:	90 93 cf 01 	sts	0x01CF, r25	; 0x8001cf <pucAlignedHeap.2081+0x1>
    2058:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    205c:	20 91 d0 01 	lds	r18, 0x01D0	; 0x8001d0 <xNextFreeByte>
    2060:	30 91 d1 01 	lds	r19, 0x01D1	; 0x8001d1 <xNextFreeByte+0x1>
    2064:	c9 01       	movw	r24, r18
    2066:	8c 0f       	add	r24, r28
    2068:	9d 1f       	adc	r25, r29
    206a:	8b 3d       	cpi	r24, 0xDB	; 219
    206c:	45 e0       	ldi	r20, 0x05	; 5
    206e:	94 07       	cpc	r25, r20
    2070:	70 f4       	brcc	.+28     	; 0x208e <pvPortMalloc+0x54>
    2072:	28 17       	cp	r18, r24
    2074:	39 07       	cpc	r19, r25
    2076:	58 f4       	brcc	.+22     	; 0x208e <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2078:	c0 91 ce 01 	lds	r28, 0x01CE	; 0x8001ce <pucAlignedHeap.2081>
    207c:	d0 91 cf 01 	lds	r29, 0x01CF	; 0x8001cf <pucAlignedHeap.2081+0x1>
    2080:	c2 0f       	add	r28, r18
    2082:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2084:	90 93 d1 01 	sts	0x01D1, r25	; 0x8001d1 <xNextFreeByte+0x1>
    2088:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <xNextFreeByte>
    208c:	02 c0       	rjmp	.+4      	; 0x2092 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    208e:	c0 e0       	ldi	r28, 0x00	; 0
    2090:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2092:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2096:	ce 01       	movw	r24, r28
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	08 95       	ret

0000209e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    209e:	08 95       	ret

000020a0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    20a0:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <xNextFreeByte+0x1>
    20a4:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <xNextFreeByte>
    20a8:	08 95       	ret

000020aa <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    20aa:	20 91 d0 01 	lds	r18, 0x01D0	; 0x8001d0 <xNextFreeByte>
    20ae:	30 91 d1 01 	lds	r19, 0x01D1	; 0x8001d1 <xNextFreeByte+0x1>
}
    20b2:	8b ed       	ldi	r24, 0xDB	; 219
    20b4:	95 e0       	ldi	r25, 0x05	; 5
    20b6:	82 1b       	sub	r24, r18
    20b8:	93 0b       	sbc	r25, r19
    20ba:	08 95       	ret

000020bc <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    20bc:	31 e1       	ldi	r19, 0x11	; 17
    20be:	fc 01       	movw	r30, r24
    20c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    20c2:	31 97       	sbiw	r30, 0x01	; 1
    20c4:	22 e2       	ldi	r18, 0x22	; 34
    20c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    20c8:	31 97       	sbiw	r30, 0x01	; 1
    20ca:	a3 e3       	ldi	r26, 0x33	; 51
    20cc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20ce:	31 97       	sbiw	r30, 0x01	; 1
    20d0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20d2:	31 97       	sbiw	r30, 0x01	; 1
    20d4:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    20d6:	31 97       	sbiw	r30, 0x01	; 1
    20d8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20da:	31 97       	sbiw	r30, 0x01	; 1
    20dc:	60 e8       	ldi	r22, 0x80	; 128
    20de:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    20e0:	31 97       	sbiw	r30, 0x01	; 1
    20e2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    20e4:	31 97       	sbiw	r30, 0x01	; 1
    20e6:	62 e0       	ldi	r22, 0x02	; 2
    20e8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    20ea:	31 97       	sbiw	r30, 0x01	; 1
    20ec:	63 e0       	ldi	r22, 0x03	; 3
    20ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    20f0:	31 97       	sbiw	r30, 0x01	; 1
    20f2:	64 e0       	ldi	r22, 0x04	; 4
    20f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	65 e0       	ldi	r22, 0x05	; 5
    20fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	66 e0       	ldi	r22, 0x06	; 6
    2100:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	67 e0       	ldi	r22, 0x07	; 7
    2106:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	68 e0       	ldi	r22, 0x08	; 8
    210c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	69 e0       	ldi	r22, 0x09	; 9
    2112:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2114:	31 97       	sbiw	r30, 0x01	; 1
    2116:	60 e1       	ldi	r22, 0x10	; 16
    2118:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    211a:	31 97       	sbiw	r30, 0x01	; 1
    211c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    211e:	31 97       	sbiw	r30, 0x01	; 1
    2120:	32 e1       	ldi	r19, 0x12	; 18
    2122:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2124:	31 97       	sbiw	r30, 0x01	; 1
    2126:	33 e1       	ldi	r19, 0x13	; 19
    2128:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    212a:	31 97       	sbiw	r30, 0x01	; 1
    212c:	34 e1       	ldi	r19, 0x14	; 20
    212e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	35 e1       	ldi	r19, 0x15	; 21
    2134:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	36 e1       	ldi	r19, 0x16	; 22
    213a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	37 e1       	ldi	r19, 0x17	; 23
    2140:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	38 e1       	ldi	r19, 0x18	; 24
    2146:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	39 e1       	ldi	r19, 0x19	; 25
    214c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    214e:	31 97       	sbiw	r30, 0x01	; 1
    2150:	30 e2       	ldi	r19, 0x20	; 32
    2152:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2154:	31 97       	sbiw	r30, 0x01	; 1
    2156:	31 e2       	ldi	r19, 0x21	; 33
    2158:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    215a:	31 97       	sbiw	r30, 0x01	; 1
    215c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    215e:	31 97       	sbiw	r30, 0x01	; 1
    2160:	23 e2       	ldi	r18, 0x23	; 35
    2162:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2164:	31 97       	sbiw	r30, 0x01	; 1
    2166:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2168:	31 97       	sbiw	r30, 0x01	; 1
    216a:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    216c:	31 97       	sbiw	r30, 0x01	; 1
    216e:	26 e2       	ldi	r18, 0x26	; 38
    2170:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2172:	31 97       	sbiw	r30, 0x01	; 1
    2174:	27 e2       	ldi	r18, 0x27	; 39
    2176:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2178:	31 97       	sbiw	r30, 0x01	; 1
    217a:	28 e2       	ldi	r18, 0x28	; 40
    217c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    217e:	31 97       	sbiw	r30, 0x01	; 1
    2180:	29 e2       	ldi	r18, 0x29	; 41
    2182:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2184:	31 97       	sbiw	r30, 0x01	; 1
    2186:	20 e3       	ldi	r18, 0x30	; 48
    2188:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    218a:	31 97       	sbiw	r30, 0x01	; 1
    218c:	21 e3       	ldi	r18, 0x31	; 49
    218e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2190:	86 97       	sbiw	r24, 0x26	; 38
    2192:	08 95       	ret

00002194 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2194:	89 ef       	ldi	r24, 0xF9	; 249
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    219c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    21a0:	e0 e8       	ldi	r30, 0x80	; 128
    21a2:	f0 e0       	ldi	r31, 0x00	; 0
    21a4:	80 81       	ld	r24, Z
    21a6:	8c 7f       	andi	r24, 0xFC	; 252
    21a8:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21aa:	8b e0       	ldi	r24, 0x0B	; 11
    21ac:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    21b0:	ef e6       	ldi	r30, 0x6F	; 111
    21b2:	f0 e0       	ldi	r31, 0x00	; 0
    21b4:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21b6:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    21b8:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21ba:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    21be:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    21c2:	cd 91       	ld	r28, X+
    21c4:	cd bf       	out	0x3d, r28	; 61
    21c6:	dd 91       	ld	r29, X+
    21c8:	de bf       	out	0x3e, r29	; 62
    21ca:	ff 91       	pop	r31
    21cc:	ef 91       	pop	r30
    21ce:	df 91       	pop	r29
    21d0:	cf 91       	pop	r28
    21d2:	bf 91       	pop	r27
    21d4:	af 91       	pop	r26
    21d6:	9f 91       	pop	r25
    21d8:	8f 91       	pop	r24
    21da:	7f 91       	pop	r23
    21dc:	6f 91       	pop	r22
    21de:	5f 91       	pop	r21
    21e0:	4f 91       	pop	r20
    21e2:	3f 91       	pop	r19
    21e4:	2f 91       	pop	r18
    21e6:	1f 91       	pop	r17
    21e8:	0f 91       	pop	r16
    21ea:	ff 90       	pop	r15
    21ec:	ef 90       	pop	r14
    21ee:	df 90       	pop	r13
    21f0:	cf 90       	pop	r12
    21f2:	bf 90       	pop	r11
    21f4:	af 90       	pop	r10
    21f6:	9f 90       	pop	r9
    21f8:	8f 90       	pop	r8
    21fa:	7f 90       	pop	r7
    21fc:	6f 90       	pop	r6
    21fe:	5f 90       	pop	r5
    2200:	4f 90       	pop	r4
    2202:	3f 90       	pop	r3
    2204:	2f 90       	pop	r2
    2206:	1f 90       	pop	r1
    2208:	0f 90       	pop	r0
    220a:	0f be       	out	0x3f, r0	; 63
    220c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    220e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2210:	81 e0       	ldi	r24, 0x01	; 1
    2212:	08 95       	ret

00002214 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2214:	08 95       	ret

00002216 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2216:	0f 92       	push	r0
    2218:	0f b6       	in	r0, 0x3f	; 63
    221a:	f8 94       	cli
    221c:	0f 92       	push	r0
    221e:	1f 92       	push	r1
    2220:	11 24       	eor	r1, r1
    2222:	2f 92       	push	r2
    2224:	3f 92       	push	r3
    2226:	4f 92       	push	r4
    2228:	5f 92       	push	r5
    222a:	6f 92       	push	r6
    222c:	7f 92       	push	r7
    222e:	8f 92       	push	r8
    2230:	9f 92       	push	r9
    2232:	af 92       	push	r10
    2234:	bf 92       	push	r11
    2236:	cf 92       	push	r12
    2238:	df 92       	push	r13
    223a:	ef 92       	push	r14
    223c:	ff 92       	push	r15
    223e:	0f 93       	push	r16
    2240:	1f 93       	push	r17
    2242:	2f 93       	push	r18
    2244:	3f 93       	push	r19
    2246:	4f 93       	push	r20
    2248:	5f 93       	push	r21
    224a:	6f 93       	push	r22
    224c:	7f 93       	push	r23
    224e:	8f 93       	push	r24
    2250:	9f 93       	push	r25
    2252:	af 93       	push	r26
    2254:	bf 93       	push	r27
    2256:	cf 93       	push	r28
    2258:	df 93       	push	r29
    225a:	ef 93       	push	r30
    225c:	ff 93       	push	r31
    225e:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    2262:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    2266:	0d b6       	in	r0, 0x3d	; 61
    2268:	0d 92       	st	X+, r0
    226a:	0e b6       	in	r0, 0x3e	; 62
    226c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    226e:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2272:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    2276:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    227a:	cd 91       	ld	r28, X+
    227c:	cd bf       	out	0x3d, r28	; 61
    227e:	dd 91       	ld	r29, X+
    2280:	de bf       	out	0x3e, r29	; 62
    2282:	ff 91       	pop	r31
    2284:	ef 91       	pop	r30
    2286:	df 91       	pop	r29
    2288:	cf 91       	pop	r28
    228a:	bf 91       	pop	r27
    228c:	af 91       	pop	r26
    228e:	9f 91       	pop	r25
    2290:	8f 91       	pop	r24
    2292:	7f 91       	pop	r23
    2294:	6f 91       	pop	r22
    2296:	5f 91       	pop	r21
    2298:	4f 91       	pop	r20
    229a:	3f 91       	pop	r19
    229c:	2f 91       	pop	r18
    229e:	1f 91       	pop	r17
    22a0:	0f 91       	pop	r16
    22a2:	ff 90       	pop	r15
    22a4:	ef 90       	pop	r14
    22a6:	df 90       	pop	r13
    22a8:	cf 90       	pop	r12
    22aa:	bf 90       	pop	r11
    22ac:	af 90       	pop	r10
    22ae:	9f 90       	pop	r9
    22b0:	8f 90       	pop	r8
    22b2:	7f 90       	pop	r7
    22b4:	6f 90       	pop	r6
    22b6:	5f 90       	pop	r5
    22b8:	4f 90       	pop	r4
    22ba:	3f 90       	pop	r3
    22bc:	2f 90       	pop	r2
    22be:	1f 90       	pop	r1
    22c0:	0f 90       	pop	r0
    22c2:	0f be       	out	0x3f, r0	; 63
    22c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22c6:	08 95       	ret

000022c8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22c8:	0f 92       	push	r0
    22ca:	0f b6       	in	r0, 0x3f	; 63
    22cc:	f8 94       	cli
    22ce:	0f 92       	push	r0
    22d0:	1f 92       	push	r1
    22d2:	11 24       	eor	r1, r1
    22d4:	2f 92       	push	r2
    22d6:	3f 92       	push	r3
    22d8:	4f 92       	push	r4
    22da:	5f 92       	push	r5
    22dc:	6f 92       	push	r6
    22de:	7f 92       	push	r7
    22e0:	8f 92       	push	r8
    22e2:	9f 92       	push	r9
    22e4:	af 92       	push	r10
    22e6:	bf 92       	push	r11
    22e8:	cf 92       	push	r12
    22ea:	df 92       	push	r13
    22ec:	ef 92       	push	r14
    22ee:	ff 92       	push	r15
    22f0:	0f 93       	push	r16
    22f2:	1f 93       	push	r17
    22f4:	2f 93       	push	r18
    22f6:	3f 93       	push	r19
    22f8:	4f 93       	push	r20
    22fa:	5f 93       	push	r21
    22fc:	6f 93       	push	r22
    22fe:	7f 93       	push	r23
    2300:	8f 93       	push	r24
    2302:	9f 93       	push	r25
    2304:	af 93       	push	r26
    2306:	bf 93       	push	r27
    2308:	cf 93       	push	r28
    230a:	df 93       	push	r29
    230c:	ef 93       	push	r30
    230e:	ff 93       	push	r31
    2310:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    2314:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    2318:	0d b6       	in	r0, 0x3d	; 61
    231a:	0d 92       	st	X+, r0
    231c:	0e b6       	in	r0, 0x3e	; 62
    231e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2320:	0e 94 b5 03 	call	0x76a	; 0x76a <xTaskIncrementTick>
    2324:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2326:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    232a:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    232e:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    2332:	cd 91       	ld	r28, X+
    2334:	cd bf       	out	0x3d, r28	; 61
    2336:	dd 91       	ld	r29, X+
    2338:	de bf       	out	0x3e, r29	; 62
    233a:	ff 91       	pop	r31
    233c:	ef 91       	pop	r30
    233e:	df 91       	pop	r29
    2340:	cf 91       	pop	r28
    2342:	bf 91       	pop	r27
    2344:	af 91       	pop	r26
    2346:	9f 91       	pop	r25
    2348:	8f 91       	pop	r24
    234a:	7f 91       	pop	r23
    234c:	6f 91       	pop	r22
    234e:	5f 91       	pop	r21
    2350:	4f 91       	pop	r20
    2352:	3f 91       	pop	r19
    2354:	2f 91       	pop	r18
    2356:	1f 91       	pop	r17
    2358:	0f 91       	pop	r16
    235a:	ff 90       	pop	r15
    235c:	ef 90       	pop	r14
    235e:	df 90       	pop	r13
    2360:	cf 90       	pop	r12
    2362:	bf 90       	pop	r11
    2364:	af 90       	pop	r10
    2366:	9f 90       	pop	r9
    2368:	8f 90       	pop	r8
    236a:	7f 90       	pop	r7
    236c:	6f 90       	pop	r6
    236e:	5f 90       	pop	r5
    2370:	4f 90       	pop	r4
    2372:	3f 90       	pop	r3
    2374:	2f 90       	pop	r2
    2376:	1f 90       	pop	r1
    2378:	0f 90       	pop	r0
    237a:	0f be       	out	0x3f, r0	; 63
    237c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    237e:	08 95       	ret

00002380 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2380:	0e 94 64 11 	call	0x22c8	; 0x22c8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2384:	18 95       	reti

00002386 <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
}

int uart_transmit(char c, FILE *stream) {
    2386:	cf 93       	push	r28
    2388:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
    238a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    238e:	85 fd       	sbrc	r24, 5
    2390:	03 c0       	rjmp	.+6      	; 0x2398 <uart_transmit+0x12>
    2392:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    2396:	f9 cf       	rjmp	.-14     	; 0x238a <uart_transmit+0x4>
  UDR0 = c;
    2398:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  return 0;
}
    239c:	80 e0       	ldi	r24, 0x00	; 0
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	cf 91       	pop	r28
    23a2:	08 95       	ret

000023a4 <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
    23a4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    23a8:	87 fd       	sbrc	r24, 7
    23aa:	03 c0       	rjmp	.+6      	; 0x23b2 <uart_receive+0xe>
    23ac:	0e 94 0b 11 	call	0x2216	; 0x2216 <vPortYield>
    23b0:	f9 cf       	rjmp	.-14     	; 0x23a4 <uart_receive>
  return UDR0;
    23b2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	08 95       	ret

000023ba <uart_init>:
    23ba:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    23be:	87 e6       	ldi	r24, 0x67	; 103
    23c0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    23c4:	e0 ec       	ldi	r30, 0xC0	; 192
    23c6:	f0 e0       	ldi	r31, 0x00	; 0
    23c8:	80 81       	ld	r24, Z
    23ca:	8d 7f       	andi	r24, 0xFD	; 253
    23cc:	80 83       	st	Z, r24
    23ce:	86 e0       	ldi	r24, 0x06	; 6
    23d0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    23d4:	88 e1       	ldi	r24, 0x18	; 24
    23d6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    23da:	08 95       	ret

000023dc <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    23dc:	cf 92       	push	r12
    23de:	df 92       	push	r13
    23e0:	ef 92       	push	r14
    23e2:	ff 92       	push	r15
    23e4:	0f 93       	push	r16
    23e6:	cf 93       	push	r28
    23e8:	df 93       	push	r29
    23ea:	00 d0       	rcall	.+0      	; 0x23ec <main+0x10>
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <main+0x12>
    23ee:	cd b7       	in	r28, 0x3d	; 61
    23f0:	de b7       	in	r29, 0x3e	; 62
    // Create task.
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;
    QueueHandle_t xQueue = xQueueCreate(100, sizeof(uint16_t));
    23f2:	40 e0       	ldi	r20, 0x00	; 0
    23f4:	62 e0       	ldi	r22, 0x02	; 2
    23f6:	84 e6       	ldi	r24, 0x64	; 100
    23f8:	0e 94 c6 09 	call	0x138c	; 0x138c <xQueueGenericCreate>
    23fc:	6c 01       	movw	r12, r24

    xTaskCreate
    23fe:	ce 01       	movw	r24, r28
    2400:	01 96       	adiw	r24, 0x01	; 1
    2402:	7c 01       	movw	r14, r24
    2404:	01 e0       	ldi	r16, 0x01	; 1
    2406:	96 01       	movw	r18, r12
    2408:	45 e5       	ldi	r20, 0x55	; 85
    240a:	50 e0       	ldi	r21, 0x00	; 0
    240c:	6c e1       	ldi	r22, 0x1C	; 28
    240e:	71 e0       	ldi	r23, 0x01	; 1
    2410:	8d e7       	ldi	r24, 0x7D	; 125
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	0e 94 81 01 	call	0x302	; 0x302 <xTaskCreate>
      configMINIMAL_STACK_SIZE,
      (void *)xQueue,
      mainSERIAL_TASK_PRIORITY,
      &serial_handle
    );
    xTaskCreate
    2418:	ce 01       	movw	r24, r28
    241a:	03 96       	adiw	r24, 0x03	; 3
    241c:	7c 01       	movw	r14, r24
    241e:	02 e0       	ldi	r16, 0x02	; 2
    2420:	96 01       	movw	r18, r12
    2422:	45 e5       	ldi	r20, 0x55	; 85
    2424:	50 e0       	ldi	r21, 0x00	; 0
    2426:	63 e2       	ldi	r22, 0x23	; 35
    2428:	71 e0       	ldi	r23, 0x01	; 1
    242a:	83 e5       	ldi	r24, 0x53	; 83
    242c:	90 e0       	ldi	r25, 0x00	; 0
    242e:	0e 94 81 01 	call	0x302	; 0x302 <xTaskCreate>
     &blink_handle
    );


    // Start scheduler.
    vTaskStartScheduler();
    2432:	0e 94 66 03 	call	0x6cc	; 0x6cc <vTaskStartScheduler>

    return 0;
}
    2436:	80 e0       	ldi	r24, 0x00	; 0
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	0f 90       	pop	r0
    2440:	0f 90       	pop	r0
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	0f 91       	pop	r16
    2448:	ff 90       	pop	r15
    244a:	ef 90       	pop	r14
    244c:	df 90       	pop	r13
    244e:	cf 90       	pop	r12
    2450:	08 95       	ret

00002452 <memcpy>:
    2452:	fb 01       	movw	r30, r22
    2454:	dc 01       	movw	r26, r24
    2456:	02 c0       	rjmp	.+4      	; 0x245c <memcpy+0xa>
    2458:	01 90       	ld	r0, Z+
    245a:	0d 92       	st	X+, r0
    245c:	41 50       	subi	r20, 0x01	; 1
    245e:	50 40       	sbci	r21, 0x00	; 0
    2460:	d8 f7       	brcc	.-10     	; 0x2458 <memcpy+0x6>
    2462:	08 95       	ret

00002464 <fgetc>:
    2464:	cf 93       	push	r28
    2466:	df 93       	push	r29
    2468:	ec 01       	movw	r28, r24
    246a:	2b 81       	ldd	r18, Y+3	; 0x03
    246c:	20 ff       	sbrs	r18, 0
    246e:	33 c0       	rjmp	.+102    	; 0x24d6 <fgetc+0x72>
    2470:	26 ff       	sbrs	r18, 6
    2472:	0a c0       	rjmp	.+20     	; 0x2488 <fgetc+0x24>
    2474:	2f 7b       	andi	r18, 0xBF	; 191
    2476:	2b 83       	std	Y+3, r18	; 0x03
    2478:	8e 81       	ldd	r24, Y+6	; 0x06
    247a:	9f 81       	ldd	r25, Y+7	; 0x07
    247c:	01 96       	adiw	r24, 0x01	; 1
    247e:	9f 83       	std	Y+7, r25	; 0x07
    2480:	8e 83       	std	Y+6, r24	; 0x06
    2482:	8a 81       	ldd	r24, Y+2	; 0x02
    2484:	90 e0       	ldi	r25, 0x00	; 0
    2486:	29 c0       	rjmp	.+82     	; 0x24da <fgetc+0x76>
    2488:	22 ff       	sbrs	r18, 2
    248a:	0f c0       	rjmp	.+30     	; 0x24aa <fgetc+0x46>
    248c:	e8 81       	ld	r30, Y
    248e:	f9 81       	ldd	r31, Y+1	; 0x01
    2490:	80 81       	ld	r24, Z
    2492:	08 2e       	mov	r0, r24
    2494:	00 0c       	add	r0, r0
    2496:	99 0b       	sbc	r25, r25
    2498:	00 97       	sbiw	r24, 0x00	; 0
    249a:	19 f4       	brne	.+6      	; 0x24a2 <fgetc+0x3e>
    249c:	20 62       	ori	r18, 0x20	; 32
    249e:	2b 83       	std	Y+3, r18	; 0x03
    24a0:	1a c0       	rjmp	.+52     	; 0x24d6 <fgetc+0x72>
    24a2:	31 96       	adiw	r30, 0x01	; 1
    24a4:	f9 83       	std	Y+1, r31	; 0x01
    24a6:	e8 83       	st	Y, r30
    24a8:	0e c0       	rjmp	.+28     	; 0x24c6 <fgetc+0x62>
    24aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    24ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    24ae:	09 95       	icall
    24b0:	97 ff       	sbrs	r25, 7
    24b2:	09 c0       	rjmp	.+18     	; 0x24c6 <fgetc+0x62>
    24b4:	2b 81       	ldd	r18, Y+3	; 0x03
    24b6:	01 96       	adiw	r24, 0x01	; 1
    24b8:	11 f0       	breq	.+4      	; 0x24be <fgetc+0x5a>
    24ba:	80 e2       	ldi	r24, 0x20	; 32
    24bc:	01 c0       	rjmp	.+2      	; 0x24c0 <fgetc+0x5c>
    24be:	80 e1       	ldi	r24, 0x10	; 16
    24c0:	82 2b       	or	r24, r18
    24c2:	8b 83       	std	Y+3, r24	; 0x03
    24c4:	08 c0       	rjmp	.+16     	; 0x24d6 <fgetc+0x72>
    24c6:	2e 81       	ldd	r18, Y+6	; 0x06
    24c8:	3f 81       	ldd	r19, Y+7	; 0x07
    24ca:	2f 5f       	subi	r18, 0xFF	; 255
    24cc:	3f 4f       	sbci	r19, 0xFF	; 255
    24ce:	3f 83       	std	Y+7, r19	; 0x07
    24d0:	2e 83       	std	Y+6, r18	; 0x06
    24d2:	99 27       	eor	r25, r25
    24d4:	02 c0       	rjmp	.+4      	; 0x24da <fgetc+0x76>
    24d6:	8f ef       	ldi	r24, 0xFF	; 255
    24d8:	9f ef       	ldi	r25, 0xFF	; 255
    24da:	df 91       	pop	r29
    24dc:	cf 91       	pop	r28
    24de:	08 95       	ret

000024e0 <printf>:
    24e0:	a0 e0       	ldi	r26, 0x00	; 0
    24e2:	b0 e0       	ldi	r27, 0x00	; 0
    24e4:	e6 e7       	ldi	r30, 0x76	; 118
    24e6:	f2 e1       	ldi	r31, 0x12	; 18
    24e8:	0c 94 57 15 	jmp	0x2aae	; 0x2aae <__prologue_saves__+0x20>
    24ec:	ae 01       	movw	r20, r28
    24ee:	4b 5f       	subi	r20, 0xFB	; 251
    24f0:	5f 4f       	sbci	r21, 0xFF	; 255
    24f2:	fa 01       	movw	r30, r20
    24f4:	61 91       	ld	r22, Z+
    24f6:	71 91       	ld	r23, Z+
    24f8:	af 01       	movw	r20, r30
    24fa:	80 91 b0 07 	lds	r24, 0x07B0	; 0x8007b0 <__iob+0x2>
    24fe:	90 91 b1 07 	lds	r25, 0x07B1	; 0x8007b1 <__iob+0x3>
    2502:	0e 94 b6 12 	call	0x256c	; 0x256c <vfprintf>
    2506:	e2 e0       	ldi	r30, 0x02	; 2
    2508:	0c 94 73 15 	jmp	0x2ae6	; 0x2ae6 <__epilogue_restores__+0x20>

0000250c <puts>:
    250c:	0f 93       	push	r16
    250e:	1f 93       	push	r17
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
    2514:	e0 91 b0 07 	lds	r30, 0x07B0	; 0x8007b0 <__iob+0x2>
    2518:	f0 91 b1 07 	lds	r31, 0x07B1	; 0x8007b1 <__iob+0x3>
    251c:	23 81       	ldd	r18, Z+3	; 0x03
    251e:	21 ff       	sbrs	r18, 1
    2520:	1b c0       	rjmp	.+54     	; 0x2558 <puts+0x4c>
    2522:	8c 01       	movw	r16, r24
    2524:	d0 e0       	ldi	r29, 0x00	; 0
    2526:	c0 e0       	ldi	r28, 0x00	; 0
    2528:	f8 01       	movw	r30, r16
    252a:	81 91       	ld	r24, Z+
    252c:	8f 01       	movw	r16, r30
    252e:	60 91 b0 07 	lds	r22, 0x07B0	; 0x8007b0 <__iob+0x2>
    2532:	70 91 b1 07 	lds	r23, 0x07B1	; 0x8007b1 <__iob+0x3>
    2536:	db 01       	movw	r26, r22
    2538:	18 96       	adiw	r26, 0x08	; 8
    253a:	ed 91       	ld	r30, X+
    253c:	fc 91       	ld	r31, X
    253e:	19 97       	sbiw	r26, 0x09	; 9
    2540:	88 23       	and	r24, r24
    2542:	31 f0       	breq	.+12     	; 0x2550 <puts+0x44>
    2544:	09 95       	icall
    2546:	89 2b       	or	r24, r25
    2548:	79 f3       	breq	.-34     	; 0x2528 <puts+0x1c>
    254a:	df ef       	ldi	r29, 0xFF	; 255
    254c:	cf ef       	ldi	r28, 0xFF	; 255
    254e:	ec cf       	rjmp	.-40     	; 0x2528 <puts+0x1c>
    2550:	8a e0       	ldi	r24, 0x0A	; 10
    2552:	09 95       	icall
    2554:	89 2b       	or	r24, r25
    2556:	19 f0       	breq	.+6      	; 0x255e <puts+0x52>
    2558:	8f ef       	ldi	r24, 0xFF	; 255
    255a:	9f ef       	ldi	r25, 0xFF	; 255
    255c:	02 c0       	rjmp	.+4      	; 0x2562 <puts+0x56>
    255e:	8d 2f       	mov	r24, r29
    2560:	9c 2f       	mov	r25, r28
    2562:	df 91       	pop	r29
    2564:	cf 91       	pop	r28
    2566:	1f 91       	pop	r17
    2568:	0f 91       	pop	r16
    256a:	08 95       	ret

0000256c <vfprintf>:
    256c:	ab e0       	ldi	r26, 0x0B	; 11
    256e:	b0 e0       	ldi	r27, 0x00	; 0
    2570:	ec eb       	ldi	r30, 0xBC	; 188
    2572:	f2 e1       	ldi	r31, 0x12	; 18
    2574:	0c 94 47 15 	jmp	0x2a8e	; 0x2a8e <__prologue_saves__>
    2578:	6c 01       	movw	r12, r24
    257a:	7b 01       	movw	r14, r22
    257c:	8a 01       	movw	r16, r20
    257e:	fc 01       	movw	r30, r24
    2580:	17 82       	std	Z+7, r1	; 0x07
    2582:	16 82       	std	Z+6, r1	; 0x06
    2584:	83 81       	ldd	r24, Z+3	; 0x03
    2586:	81 ff       	sbrs	r24, 1
    2588:	cc c1       	rjmp	.+920    	; 0x2922 <vfprintf+0x3b6>
    258a:	ce 01       	movw	r24, r28
    258c:	01 96       	adiw	r24, 0x01	; 1
    258e:	3c 01       	movw	r6, r24
    2590:	f6 01       	movw	r30, r12
    2592:	93 81       	ldd	r25, Z+3	; 0x03
    2594:	f7 01       	movw	r30, r14
    2596:	93 fd       	sbrc	r25, 3
    2598:	85 91       	lpm	r24, Z+
    259a:	93 ff       	sbrs	r25, 3
    259c:	81 91       	ld	r24, Z+
    259e:	7f 01       	movw	r14, r30
    25a0:	88 23       	and	r24, r24
    25a2:	09 f4       	brne	.+2      	; 0x25a6 <vfprintf+0x3a>
    25a4:	ba c1       	rjmp	.+884    	; 0x291a <vfprintf+0x3ae>
    25a6:	85 32       	cpi	r24, 0x25	; 37
    25a8:	39 f4       	brne	.+14     	; 0x25b8 <vfprintf+0x4c>
    25aa:	93 fd       	sbrc	r25, 3
    25ac:	85 91       	lpm	r24, Z+
    25ae:	93 ff       	sbrs	r25, 3
    25b0:	81 91       	ld	r24, Z+
    25b2:	7f 01       	movw	r14, r30
    25b4:	85 32       	cpi	r24, 0x25	; 37
    25b6:	29 f4       	brne	.+10     	; 0x25c2 <vfprintf+0x56>
    25b8:	b6 01       	movw	r22, r12
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    25c0:	e7 cf       	rjmp	.-50     	; 0x2590 <vfprintf+0x24>
    25c2:	91 2c       	mov	r9, r1
    25c4:	21 2c       	mov	r2, r1
    25c6:	31 2c       	mov	r3, r1
    25c8:	ff e1       	ldi	r31, 0x1F	; 31
    25ca:	f3 15       	cp	r31, r3
    25cc:	d8 f0       	brcs	.+54     	; 0x2604 <vfprintf+0x98>
    25ce:	8b 32       	cpi	r24, 0x2B	; 43
    25d0:	79 f0       	breq	.+30     	; 0x25f0 <vfprintf+0x84>
    25d2:	38 f4       	brcc	.+14     	; 0x25e2 <vfprintf+0x76>
    25d4:	80 32       	cpi	r24, 0x20	; 32
    25d6:	79 f0       	breq	.+30     	; 0x25f6 <vfprintf+0x8a>
    25d8:	83 32       	cpi	r24, 0x23	; 35
    25da:	a1 f4       	brne	.+40     	; 0x2604 <vfprintf+0x98>
    25dc:	23 2d       	mov	r18, r3
    25de:	20 61       	ori	r18, 0x10	; 16
    25e0:	1d c0       	rjmp	.+58     	; 0x261c <vfprintf+0xb0>
    25e2:	8d 32       	cpi	r24, 0x2D	; 45
    25e4:	61 f0       	breq	.+24     	; 0x25fe <vfprintf+0x92>
    25e6:	80 33       	cpi	r24, 0x30	; 48
    25e8:	69 f4       	brne	.+26     	; 0x2604 <vfprintf+0x98>
    25ea:	23 2d       	mov	r18, r3
    25ec:	21 60       	ori	r18, 0x01	; 1
    25ee:	16 c0       	rjmp	.+44     	; 0x261c <vfprintf+0xb0>
    25f0:	83 2d       	mov	r24, r3
    25f2:	82 60       	ori	r24, 0x02	; 2
    25f4:	38 2e       	mov	r3, r24
    25f6:	e3 2d       	mov	r30, r3
    25f8:	e4 60       	ori	r30, 0x04	; 4
    25fa:	3e 2e       	mov	r3, r30
    25fc:	2a c0       	rjmp	.+84     	; 0x2652 <vfprintf+0xe6>
    25fe:	f3 2d       	mov	r31, r3
    2600:	f8 60       	ori	r31, 0x08	; 8
    2602:	1d c0       	rjmp	.+58     	; 0x263e <vfprintf+0xd2>
    2604:	37 fc       	sbrc	r3, 7
    2606:	2d c0       	rjmp	.+90     	; 0x2662 <vfprintf+0xf6>
    2608:	20 ed       	ldi	r18, 0xD0	; 208
    260a:	28 0f       	add	r18, r24
    260c:	2a 30       	cpi	r18, 0x0A	; 10
    260e:	40 f0       	brcs	.+16     	; 0x2620 <vfprintf+0xb4>
    2610:	8e 32       	cpi	r24, 0x2E	; 46
    2612:	b9 f4       	brne	.+46     	; 0x2642 <vfprintf+0xd6>
    2614:	36 fc       	sbrc	r3, 6
    2616:	81 c1       	rjmp	.+770    	; 0x291a <vfprintf+0x3ae>
    2618:	23 2d       	mov	r18, r3
    261a:	20 64       	ori	r18, 0x40	; 64
    261c:	32 2e       	mov	r3, r18
    261e:	19 c0       	rjmp	.+50     	; 0x2652 <vfprintf+0xe6>
    2620:	36 fe       	sbrs	r3, 6
    2622:	06 c0       	rjmp	.+12     	; 0x2630 <vfprintf+0xc4>
    2624:	8a e0       	ldi	r24, 0x0A	; 10
    2626:	98 9e       	mul	r9, r24
    2628:	20 0d       	add	r18, r0
    262a:	11 24       	eor	r1, r1
    262c:	92 2e       	mov	r9, r18
    262e:	11 c0       	rjmp	.+34     	; 0x2652 <vfprintf+0xe6>
    2630:	ea e0       	ldi	r30, 0x0A	; 10
    2632:	2e 9e       	mul	r2, r30
    2634:	20 0d       	add	r18, r0
    2636:	11 24       	eor	r1, r1
    2638:	22 2e       	mov	r2, r18
    263a:	f3 2d       	mov	r31, r3
    263c:	f0 62       	ori	r31, 0x20	; 32
    263e:	3f 2e       	mov	r3, r31
    2640:	08 c0       	rjmp	.+16     	; 0x2652 <vfprintf+0xe6>
    2642:	8c 36       	cpi	r24, 0x6C	; 108
    2644:	21 f4       	brne	.+8      	; 0x264e <vfprintf+0xe2>
    2646:	83 2d       	mov	r24, r3
    2648:	80 68       	ori	r24, 0x80	; 128
    264a:	38 2e       	mov	r3, r24
    264c:	02 c0       	rjmp	.+4      	; 0x2652 <vfprintf+0xe6>
    264e:	88 36       	cpi	r24, 0x68	; 104
    2650:	41 f4       	brne	.+16     	; 0x2662 <vfprintf+0xf6>
    2652:	f7 01       	movw	r30, r14
    2654:	93 fd       	sbrc	r25, 3
    2656:	85 91       	lpm	r24, Z+
    2658:	93 ff       	sbrs	r25, 3
    265a:	81 91       	ld	r24, Z+
    265c:	7f 01       	movw	r14, r30
    265e:	81 11       	cpse	r24, r1
    2660:	b3 cf       	rjmp	.-154    	; 0x25c8 <vfprintf+0x5c>
    2662:	98 2f       	mov	r25, r24
    2664:	9f 7d       	andi	r25, 0xDF	; 223
    2666:	95 54       	subi	r25, 0x45	; 69
    2668:	93 30       	cpi	r25, 0x03	; 3
    266a:	28 f4       	brcc	.+10     	; 0x2676 <vfprintf+0x10a>
    266c:	0c 5f       	subi	r16, 0xFC	; 252
    266e:	1f 4f       	sbci	r17, 0xFF	; 255
    2670:	9f e3       	ldi	r25, 0x3F	; 63
    2672:	99 83       	std	Y+1, r25	; 0x01
    2674:	0d c0       	rjmp	.+26     	; 0x2690 <vfprintf+0x124>
    2676:	83 36       	cpi	r24, 0x63	; 99
    2678:	31 f0       	breq	.+12     	; 0x2686 <vfprintf+0x11a>
    267a:	83 37       	cpi	r24, 0x73	; 115
    267c:	71 f0       	breq	.+28     	; 0x269a <vfprintf+0x12e>
    267e:	83 35       	cpi	r24, 0x53	; 83
    2680:	09 f0       	breq	.+2      	; 0x2684 <vfprintf+0x118>
    2682:	59 c0       	rjmp	.+178    	; 0x2736 <vfprintf+0x1ca>
    2684:	21 c0       	rjmp	.+66     	; 0x26c8 <vfprintf+0x15c>
    2686:	f8 01       	movw	r30, r16
    2688:	80 81       	ld	r24, Z
    268a:	89 83       	std	Y+1, r24	; 0x01
    268c:	0e 5f       	subi	r16, 0xFE	; 254
    268e:	1f 4f       	sbci	r17, 0xFF	; 255
    2690:	88 24       	eor	r8, r8
    2692:	83 94       	inc	r8
    2694:	91 2c       	mov	r9, r1
    2696:	53 01       	movw	r10, r6
    2698:	13 c0       	rjmp	.+38     	; 0x26c0 <vfprintf+0x154>
    269a:	28 01       	movw	r4, r16
    269c:	f2 e0       	ldi	r31, 0x02	; 2
    269e:	4f 0e       	add	r4, r31
    26a0:	51 1c       	adc	r5, r1
    26a2:	f8 01       	movw	r30, r16
    26a4:	a0 80       	ld	r10, Z
    26a6:	b1 80       	ldd	r11, Z+1	; 0x01
    26a8:	36 fe       	sbrs	r3, 6
    26aa:	03 c0       	rjmp	.+6      	; 0x26b2 <vfprintf+0x146>
    26ac:	69 2d       	mov	r22, r9
    26ae:	70 e0       	ldi	r23, 0x00	; 0
    26b0:	02 c0       	rjmp	.+4      	; 0x26b6 <vfprintf+0x14a>
    26b2:	6f ef       	ldi	r22, 0xFF	; 255
    26b4:	7f ef       	ldi	r23, 0xFF	; 255
    26b6:	c5 01       	movw	r24, r10
    26b8:	0e 94 a2 14 	call	0x2944	; 0x2944 <strnlen>
    26bc:	4c 01       	movw	r8, r24
    26be:	82 01       	movw	r16, r4
    26c0:	f3 2d       	mov	r31, r3
    26c2:	ff 77       	andi	r31, 0x7F	; 127
    26c4:	3f 2e       	mov	r3, r31
    26c6:	16 c0       	rjmp	.+44     	; 0x26f4 <vfprintf+0x188>
    26c8:	28 01       	movw	r4, r16
    26ca:	22 e0       	ldi	r18, 0x02	; 2
    26cc:	42 0e       	add	r4, r18
    26ce:	51 1c       	adc	r5, r1
    26d0:	f8 01       	movw	r30, r16
    26d2:	a0 80       	ld	r10, Z
    26d4:	b1 80       	ldd	r11, Z+1	; 0x01
    26d6:	36 fe       	sbrs	r3, 6
    26d8:	03 c0       	rjmp	.+6      	; 0x26e0 <vfprintf+0x174>
    26da:	69 2d       	mov	r22, r9
    26dc:	70 e0       	ldi	r23, 0x00	; 0
    26de:	02 c0       	rjmp	.+4      	; 0x26e4 <vfprintf+0x178>
    26e0:	6f ef       	ldi	r22, 0xFF	; 255
    26e2:	7f ef       	ldi	r23, 0xFF	; 255
    26e4:	c5 01       	movw	r24, r10
    26e6:	0e 94 97 14 	call	0x292e	; 0x292e <strnlen_P>
    26ea:	4c 01       	movw	r8, r24
    26ec:	f3 2d       	mov	r31, r3
    26ee:	f0 68       	ori	r31, 0x80	; 128
    26f0:	3f 2e       	mov	r3, r31
    26f2:	82 01       	movw	r16, r4
    26f4:	33 fc       	sbrc	r3, 3
    26f6:	1b c0       	rjmp	.+54     	; 0x272e <vfprintf+0x1c2>
    26f8:	82 2d       	mov	r24, r2
    26fa:	90 e0       	ldi	r25, 0x00	; 0
    26fc:	88 16       	cp	r8, r24
    26fe:	99 06       	cpc	r9, r25
    2700:	b0 f4       	brcc	.+44     	; 0x272e <vfprintf+0x1c2>
    2702:	b6 01       	movw	r22, r12
    2704:	80 e2       	ldi	r24, 0x20	; 32
    2706:	90 e0       	ldi	r25, 0x00	; 0
    2708:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    270c:	2a 94       	dec	r2
    270e:	f4 cf       	rjmp	.-24     	; 0x26f8 <vfprintf+0x18c>
    2710:	f5 01       	movw	r30, r10
    2712:	37 fc       	sbrc	r3, 7
    2714:	85 91       	lpm	r24, Z+
    2716:	37 fe       	sbrs	r3, 7
    2718:	81 91       	ld	r24, Z+
    271a:	5f 01       	movw	r10, r30
    271c:	b6 01       	movw	r22, r12
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    2724:	21 10       	cpse	r2, r1
    2726:	2a 94       	dec	r2
    2728:	21 e0       	ldi	r18, 0x01	; 1
    272a:	82 1a       	sub	r8, r18
    272c:	91 08       	sbc	r9, r1
    272e:	81 14       	cp	r8, r1
    2730:	91 04       	cpc	r9, r1
    2732:	71 f7       	brne	.-36     	; 0x2710 <vfprintf+0x1a4>
    2734:	e8 c0       	rjmp	.+464    	; 0x2906 <vfprintf+0x39a>
    2736:	84 36       	cpi	r24, 0x64	; 100
    2738:	11 f0       	breq	.+4      	; 0x273e <vfprintf+0x1d2>
    273a:	89 36       	cpi	r24, 0x69	; 105
    273c:	41 f5       	brne	.+80     	; 0x278e <vfprintf+0x222>
    273e:	f8 01       	movw	r30, r16
    2740:	37 fe       	sbrs	r3, 7
    2742:	07 c0       	rjmp	.+14     	; 0x2752 <vfprintf+0x1e6>
    2744:	60 81       	ld	r22, Z
    2746:	71 81       	ldd	r23, Z+1	; 0x01
    2748:	82 81       	ldd	r24, Z+2	; 0x02
    274a:	93 81       	ldd	r25, Z+3	; 0x03
    274c:	0c 5f       	subi	r16, 0xFC	; 252
    274e:	1f 4f       	sbci	r17, 0xFF	; 255
    2750:	08 c0       	rjmp	.+16     	; 0x2762 <vfprintf+0x1f6>
    2752:	60 81       	ld	r22, Z
    2754:	71 81       	ldd	r23, Z+1	; 0x01
    2756:	07 2e       	mov	r0, r23
    2758:	00 0c       	add	r0, r0
    275a:	88 0b       	sbc	r24, r24
    275c:	99 0b       	sbc	r25, r25
    275e:	0e 5f       	subi	r16, 0xFE	; 254
    2760:	1f 4f       	sbci	r17, 0xFF	; 255
    2762:	f3 2d       	mov	r31, r3
    2764:	ff 76       	andi	r31, 0x6F	; 111
    2766:	3f 2e       	mov	r3, r31
    2768:	97 ff       	sbrs	r25, 7
    276a:	09 c0       	rjmp	.+18     	; 0x277e <vfprintf+0x212>
    276c:	90 95       	com	r25
    276e:	80 95       	com	r24
    2770:	70 95       	com	r23
    2772:	61 95       	neg	r22
    2774:	7f 4f       	sbci	r23, 0xFF	; 255
    2776:	8f 4f       	sbci	r24, 0xFF	; 255
    2778:	9f 4f       	sbci	r25, 0xFF	; 255
    277a:	f0 68       	ori	r31, 0x80	; 128
    277c:	3f 2e       	mov	r3, r31
    277e:	2a e0       	ldi	r18, 0x0A	; 10
    2780:	30 e0       	ldi	r19, 0x00	; 0
    2782:	a3 01       	movw	r20, r6
    2784:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__ultoa_invert>
    2788:	88 2e       	mov	r8, r24
    278a:	86 18       	sub	r8, r6
    278c:	45 c0       	rjmp	.+138    	; 0x2818 <vfprintf+0x2ac>
    278e:	85 37       	cpi	r24, 0x75	; 117
    2790:	31 f4       	brne	.+12     	; 0x279e <vfprintf+0x232>
    2792:	23 2d       	mov	r18, r3
    2794:	2f 7e       	andi	r18, 0xEF	; 239
    2796:	b2 2e       	mov	r11, r18
    2798:	2a e0       	ldi	r18, 0x0A	; 10
    279a:	30 e0       	ldi	r19, 0x00	; 0
    279c:	25 c0       	rjmp	.+74     	; 0x27e8 <vfprintf+0x27c>
    279e:	93 2d       	mov	r25, r3
    27a0:	99 7f       	andi	r25, 0xF9	; 249
    27a2:	b9 2e       	mov	r11, r25
    27a4:	8f 36       	cpi	r24, 0x6F	; 111
    27a6:	c1 f0       	breq	.+48     	; 0x27d8 <vfprintf+0x26c>
    27a8:	18 f4       	brcc	.+6      	; 0x27b0 <vfprintf+0x244>
    27aa:	88 35       	cpi	r24, 0x58	; 88
    27ac:	79 f0       	breq	.+30     	; 0x27cc <vfprintf+0x260>
    27ae:	b5 c0       	rjmp	.+362    	; 0x291a <vfprintf+0x3ae>
    27b0:	80 37       	cpi	r24, 0x70	; 112
    27b2:	19 f0       	breq	.+6      	; 0x27ba <vfprintf+0x24e>
    27b4:	88 37       	cpi	r24, 0x78	; 120
    27b6:	21 f0       	breq	.+8      	; 0x27c0 <vfprintf+0x254>
    27b8:	b0 c0       	rjmp	.+352    	; 0x291a <vfprintf+0x3ae>
    27ba:	e9 2f       	mov	r30, r25
    27bc:	e0 61       	ori	r30, 0x10	; 16
    27be:	be 2e       	mov	r11, r30
    27c0:	b4 fe       	sbrs	r11, 4
    27c2:	0d c0       	rjmp	.+26     	; 0x27de <vfprintf+0x272>
    27c4:	fb 2d       	mov	r31, r11
    27c6:	f4 60       	ori	r31, 0x04	; 4
    27c8:	bf 2e       	mov	r11, r31
    27ca:	09 c0       	rjmp	.+18     	; 0x27de <vfprintf+0x272>
    27cc:	34 fe       	sbrs	r3, 4
    27ce:	0a c0       	rjmp	.+20     	; 0x27e4 <vfprintf+0x278>
    27d0:	29 2f       	mov	r18, r25
    27d2:	26 60       	ori	r18, 0x06	; 6
    27d4:	b2 2e       	mov	r11, r18
    27d6:	06 c0       	rjmp	.+12     	; 0x27e4 <vfprintf+0x278>
    27d8:	28 e0       	ldi	r18, 0x08	; 8
    27da:	30 e0       	ldi	r19, 0x00	; 0
    27dc:	05 c0       	rjmp	.+10     	; 0x27e8 <vfprintf+0x27c>
    27de:	20 e1       	ldi	r18, 0x10	; 16
    27e0:	30 e0       	ldi	r19, 0x00	; 0
    27e2:	02 c0       	rjmp	.+4      	; 0x27e8 <vfprintf+0x27c>
    27e4:	20 e1       	ldi	r18, 0x10	; 16
    27e6:	32 e0       	ldi	r19, 0x02	; 2
    27e8:	f8 01       	movw	r30, r16
    27ea:	b7 fe       	sbrs	r11, 7
    27ec:	07 c0       	rjmp	.+14     	; 0x27fc <vfprintf+0x290>
    27ee:	60 81       	ld	r22, Z
    27f0:	71 81       	ldd	r23, Z+1	; 0x01
    27f2:	82 81       	ldd	r24, Z+2	; 0x02
    27f4:	93 81       	ldd	r25, Z+3	; 0x03
    27f6:	0c 5f       	subi	r16, 0xFC	; 252
    27f8:	1f 4f       	sbci	r17, 0xFF	; 255
    27fa:	06 c0       	rjmp	.+12     	; 0x2808 <vfprintf+0x29c>
    27fc:	60 81       	ld	r22, Z
    27fe:	71 81       	ldd	r23, Z+1	; 0x01
    2800:	80 e0       	ldi	r24, 0x00	; 0
    2802:	90 e0       	ldi	r25, 0x00	; 0
    2804:	0e 5f       	subi	r16, 0xFE	; 254
    2806:	1f 4f       	sbci	r17, 0xFF	; 255
    2808:	a3 01       	movw	r20, r6
    280a:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__ultoa_invert>
    280e:	88 2e       	mov	r8, r24
    2810:	86 18       	sub	r8, r6
    2812:	fb 2d       	mov	r31, r11
    2814:	ff 77       	andi	r31, 0x7F	; 127
    2816:	3f 2e       	mov	r3, r31
    2818:	36 fe       	sbrs	r3, 6
    281a:	0d c0       	rjmp	.+26     	; 0x2836 <vfprintf+0x2ca>
    281c:	23 2d       	mov	r18, r3
    281e:	2e 7f       	andi	r18, 0xFE	; 254
    2820:	a2 2e       	mov	r10, r18
    2822:	89 14       	cp	r8, r9
    2824:	58 f4       	brcc	.+22     	; 0x283c <vfprintf+0x2d0>
    2826:	34 fe       	sbrs	r3, 4
    2828:	0b c0       	rjmp	.+22     	; 0x2840 <vfprintf+0x2d4>
    282a:	32 fc       	sbrc	r3, 2
    282c:	09 c0       	rjmp	.+18     	; 0x2840 <vfprintf+0x2d4>
    282e:	83 2d       	mov	r24, r3
    2830:	8e 7e       	andi	r24, 0xEE	; 238
    2832:	a8 2e       	mov	r10, r24
    2834:	05 c0       	rjmp	.+10     	; 0x2840 <vfprintf+0x2d4>
    2836:	b8 2c       	mov	r11, r8
    2838:	a3 2c       	mov	r10, r3
    283a:	03 c0       	rjmp	.+6      	; 0x2842 <vfprintf+0x2d6>
    283c:	b8 2c       	mov	r11, r8
    283e:	01 c0       	rjmp	.+2      	; 0x2842 <vfprintf+0x2d6>
    2840:	b9 2c       	mov	r11, r9
    2842:	a4 fe       	sbrs	r10, 4
    2844:	0f c0       	rjmp	.+30     	; 0x2864 <vfprintf+0x2f8>
    2846:	fe 01       	movw	r30, r28
    2848:	e8 0d       	add	r30, r8
    284a:	f1 1d       	adc	r31, r1
    284c:	80 81       	ld	r24, Z
    284e:	80 33       	cpi	r24, 0x30	; 48
    2850:	21 f4       	brne	.+8      	; 0x285a <vfprintf+0x2ee>
    2852:	9a 2d       	mov	r25, r10
    2854:	99 7e       	andi	r25, 0xE9	; 233
    2856:	a9 2e       	mov	r10, r25
    2858:	09 c0       	rjmp	.+18     	; 0x286c <vfprintf+0x300>
    285a:	a2 fe       	sbrs	r10, 2
    285c:	06 c0       	rjmp	.+12     	; 0x286a <vfprintf+0x2fe>
    285e:	b3 94       	inc	r11
    2860:	b3 94       	inc	r11
    2862:	04 c0       	rjmp	.+8      	; 0x286c <vfprintf+0x300>
    2864:	8a 2d       	mov	r24, r10
    2866:	86 78       	andi	r24, 0x86	; 134
    2868:	09 f0       	breq	.+2      	; 0x286c <vfprintf+0x300>
    286a:	b3 94       	inc	r11
    286c:	a3 fc       	sbrc	r10, 3
    286e:	11 c0       	rjmp	.+34     	; 0x2892 <vfprintf+0x326>
    2870:	a0 fe       	sbrs	r10, 0
    2872:	06 c0       	rjmp	.+12     	; 0x2880 <vfprintf+0x314>
    2874:	b2 14       	cp	r11, r2
    2876:	88 f4       	brcc	.+34     	; 0x289a <vfprintf+0x32e>
    2878:	28 0c       	add	r2, r8
    287a:	92 2c       	mov	r9, r2
    287c:	9b 18       	sub	r9, r11
    287e:	0e c0       	rjmp	.+28     	; 0x289c <vfprintf+0x330>
    2880:	b2 14       	cp	r11, r2
    2882:	60 f4       	brcc	.+24     	; 0x289c <vfprintf+0x330>
    2884:	b6 01       	movw	r22, r12
    2886:	80 e2       	ldi	r24, 0x20	; 32
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    288e:	b3 94       	inc	r11
    2890:	f7 cf       	rjmp	.-18     	; 0x2880 <vfprintf+0x314>
    2892:	b2 14       	cp	r11, r2
    2894:	18 f4       	brcc	.+6      	; 0x289c <vfprintf+0x330>
    2896:	2b 18       	sub	r2, r11
    2898:	02 c0       	rjmp	.+4      	; 0x289e <vfprintf+0x332>
    289a:	98 2c       	mov	r9, r8
    289c:	21 2c       	mov	r2, r1
    289e:	a4 fe       	sbrs	r10, 4
    28a0:	10 c0       	rjmp	.+32     	; 0x28c2 <vfprintf+0x356>
    28a2:	b6 01       	movw	r22, r12
    28a4:	80 e3       	ldi	r24, 0x30	; 48
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    28ac:	a2 fe       	sbrs	r10, 2
    28ae:	17 c0       	rjmp	.+46     	; 0x28de <vfprintf+0x372>
    28b0:	a1 fc       	sbrc	r10, 1
    28b2:	03 c0       	rjmp	.+6      	; 0x28ba <vfprintf+0x34e>
    28b4:	88 e7       	ldi	r24, 0x78	; 120
    28b6:	90 e0       	ldi	r25, 0x00	; 0
    28b8:	02 c0       	rjmp	.+4      	; 0x28be <vfprintf+0x352>
    28ba:	88 e5       	ldi	r24, 0x58	; 88
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	b6 01       	movw	r22, r12
    28c0:	0c c0       	rjmp	.+24     	; 0x28da <vfprintf+0x36e>
    28c2:	8a 2d       	mov	r24, r10
    28c4:	86 78       	andi	r24, 0x86	; 134
    28c6:	59 f0       	breq	.+22     	; 0x28de <vfprintf+0x372>
    28c8:	a1 fe       	sbrs	r10, 1
    28ca:	02 c0       	rjmp	.+4      	; 0x28d0 <vfprintf+0x364>
    28cc:	8b e2       	ldi	r24, 0x2B	; 43
    28ce:	01 c0       	rjmp	.+2      	; 0x28d2 <vfprintf+0x366>
    28d0:	80 e2       	ldi	r24, 0x20	; 32
    28d2:	a7 fc       	sbrc	r10, 7
    28d4:	8d e2       	ldi	r24, 0x2D	; 45
    28d6:	b6 01       	movw	r22, r12
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    28de:	89 14       	cp	r8, r9
    28e0:	38 f4       	brcc	.+14     	; 0x28f0 <vfprintf+0x384>
    28e2:	b6 01       	movw	r22, r12
    28e4:	80 e3       	ldi	r24, 0x30	; 48
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    28ec:	9a 94       	dec	r9
    28ee:	f7 cf       	rjmp	.-18     	; 0x28de <vfprintf+0x372>
    28f0:	8a 94       	dec	r8
    28f2:	f3 01       	movw	r30, r6
    28f4:	e8 0d       	add	r30, r8
    28f6:	f1 1d       	adc	r31, r1
    28f8:	80 81       	ld	r24, Z
    28fa:	b6 01       	movw	r22, r12
    28fc:	90 e0       	ldi	r25, 0x00	; 0
    28fe:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    2902:	81 10       	cpse	r8, r1
    2904:	f5 cf       	rjmp	.-22     	; 0x28f0 <vfprintf+0x384>
    2906:	22 20       	and	r2, r2
    2908:	09 f4       	brne	.+2      	; 0x290c <vfprintf+0x3a0>
    290a:	42 ce       	rjmp	.-892    	; 0x2590 <vfprintf+0x24>
    290c:	b6 01       	movw	r22, r12
    290e:	80 e2       	ldi	r24, 0x20	; 32
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	0e 94 ad 14 	call	0x295a	; 0x295a <fputc>
    2916:	2a 94       	dec	r2
    2918:	f6 cf       	rjmp	.-20     	; 0x2906 <vfprintf+0x39a>
    291a:	f6 01       	movw	r30, r12
    291c:	86 81       	ldd	r24, Z+6	; 0x06
    291e:	97 81       	ldd	r25, Z+7	; 0x07
    2920:	02 c0       	rjmp	.+4      	; 0x2926 <vfprintf+0x3ba>
    2922:	8f ef       	ldi	r24, 0xFF	; 255
    2924:	9f ef       	ldi	r25, 0xFF	; 255
    2926:	2b 96       	adiw	r28, 0x0b	; 11
    2928:	e2 e1       	ldi	r30, 0x12	; 18
    292a:	0c 94 63 15 	jmp	0x2ac6	; 0x2ac6 <__epilogue_restores__>

0000292e <strnlen_P>:
    292e:	fc 01       	movw	r30, r24
    2930:	05 90       	lpm	r0, Z+
    2932:	61 50       	subi	r22, 0x01	; 1
    2934:	70 40       	sbci	r23, 0x00	; 0
    2936:	01 10       	cpse	r0, r1
    2938:	d8 f7       	brcc	.-10     	; 0x2930 <strnlen_P+0x2>
    293a:	80 95       	com	r24
    293c:	90 95       	com	r25
    293e:	8e 0f       	add	r24, r30
    2940:	9f 1f       	adc	r25, r31
    2942:	08 95       	ret

00002944 <strnlen>:
    2944:	fc 01       	movw	r30, r24
    2946:	61 50       	subi	r22, 0x01	; 1
    2948:	70 40       	sbci	r23, 0x00	; 0
    294a:	01 90       	ld	r0, Z+
    294c:	01 10       	cpse	r0, r1
    294e:	d8 f7       	brcc	.-10     	; 0x2946 <strnlen+0x2>
    2950:	80 95       	com	r24
    2952:	90 95       	com	r25
    2954:	8e 0f       	add	r24, r30
    2956:	9f 1f       	adc	r25, r31
    2958:	08 95       	ret

0000295a <fputc>:
    295a:	0f 93       	push	r16
    295c:	1f 93       	push	r17
    295e:	cf 93       	push	r28
    2960:	df 93       	push	r29
    2962:	fb 01       	movw	r30, r22
    2964:	23 81       	ldd	r18, Z+3	; 0x03
    2966:	21 fd       	sbrc	r18, 1
    2968:	03 c0       	rjmp	.+6      	; 0x2970 <fputc+0x16>
    296a:	8f ef       	ldi	r24, 0xFF	; 255
    296c:	9f ef       	ldi	r25, 0xFF	; 255
    296e:	2c c0       	rjmp	.+88     	; 0x29c8 <fputc+0x6e>
    2970:	22 ff       	sbrs	r18, 2
    2972:	16 c0       	rjmp	.+44     	; 0x29a0 <fputc+0x46>
    2974:	46 81       	ldd	r20, Z+6	; 0x06
    2976:	57 81       	ldd	r21, Z+7	; 0x07
    2978:	24 81       	ldd	r18, Z+4	; 0x04
    297a:	35 81       	ldd	r19, Z+5	; 0x05
    297c:	42 17       	cp	r20, r18
    297e:	53 07       	cpc	r21, r19
    2980:	44 f4       	brge	.+16     	; 0x2992 <fputc+0x38>
    2982:	a0 81       	ld	r26, Z
    2984:	b1 81       	ldd	r27, Z+1	; 0x01
    2986:	9d 01       	movw	r18, r26
    2988:	2f 5f       	subi	r18, 0xFF	; 255
    298a:	3f 4f       	sbci	r19, 0xFF	; 255
    298c:	31 83       	std	Z+1, r19	; 0x01
    298e:	20 83       	st	Z, r18
    2990:	8c 93       	st	X, r24
    2992:	26 81       	ldd	r18, Z+6	; 0x06
    2994:	37 81       	ldd	r19, Z+7	; 0x07
    2996:	2f 5f       	subi	r18, 0xFF	; 255
    2998:	3f 4f       	sbci	r19, 0xFF	; 255
    299a:	37 83       	std	Z+7, r19	; 0x07
    299c:	26 83       	std	Z+6, r18	; 0x06
    299e:	14 c0       	rjmp	.+40     	; 0x29c8 <fputc+0x6e>
    29a0:	8b 01       	movw	r16, r22
    29a2:	ec 01       	movw	r28, r24
    29a4:	fb 01       	movw	r30, r22
    29a6:	00 84       	ldd	r0, Z+8	; 0x08
    29a8:	f1 85       	ldd	r31, Z+9	; 0x09
    29aa:	e0 2d       	mov	r30, r0
    29ac:	09 95       	icall
    29ae:	89 2b       	or	r24, r25
    29b0:	e1 f6       	brne	.-72     	; 0x296a <fputc+0x10>
    29b2:	d8 01       	movw	r26, r16
    29b4:	16 96       	adiw	r26, 0x06	; 6
    29b6:	8d 91       	ld	r24, X+
    29b8:	9c 91       	ld	r25, X
    29ba:	17 97       	sbiw	r26, 0x07	; 7
    29bc:	01 96       	adiw	r24, 0x01	; 1
    29be:	17 96       	adiw	r26, 0x07	; 7
    29c0:	9c 93       	st	X, r25
    29c2:	8e 93       	st	-X, r24
    29c4:	16 97       	sbiw	r26, 0x06	; 6
    29c6:	ce 01       	movw	r24, r28
    29c8:	df 91       	pop	r29
    29ca:	cf 91       	pop	r28
    29cc:	1f 91       	pop	r17
    29ce:	0f 91       	pop	r16
    29d0:	08 95       	ret

000029d2 <__ultoa_invert>:
    29d2:	fa 01       	movw	r30, r20
    29d4:	aa 27       	eor	r26, r26
    29d6:	28 30       	cpi	r18, 0x08	; 8
    29d8:	51 f1       	breq	.+84     	; 0x2a2e <__ultoa_invert+0x5c>
    29da:	20 31       	cpi	r18, 0x10	; 16
    29dc:	81 f1       	breq	.+96     	; 0x2a3e <__ultoa_invert+0x6c>
    29de:	e8 94       	clt
    29e0:	6f 93       	push	r22
    29e2:	6e 7f       	andi	r22, 0xFE	; 254
    29e4:	6e 5f       	subi	r22, 0xFE	; 254
    29e6:	7f 4f       	sbci	r23, 0xFF	; 255
    29e8:	8f 4f       	sbci	r24, 0xFF	; 255
    29ea:	9f 4f       	sbci	r25, 0xFF	; 255
    29ec:	af 4f       	sbci	r26, 0xFF	; 255
    29ee:	b1 e0       	ldi	r27, 0x01	; 1
    29f0:	3e d0       	rcall	.+124    	; 0x2a6e <__ultoa_invert+0x9c>
    29f2:	b4 e0       	ldi	r27, 0x04	; 4
    29f4:	3c d0       	rcall	.+120    	; 0x2a6e <__ultoa_invert+0x9c>
    29f6:	67 0f       	add	r22, r23
    29f8:	78 1f       	adc	r23, r24
    29fa:	89 1f       	adc	r24, r25
    29fc:	9a 1f       	adc	r25, r26
    29fe:	a1 1d       	adc	r26, r1
    2a00:	68 0f       	add	r22, r24
    2a02:	79 1f       	adc	r23, r25
    2a04:	8a 1f       	adc	r24, r26
    2a06:	91 1d       	adc	r25, r1
    2a08:	a1 1d       	adc	r26, r1
    2a0a:	6a 0f       	add	r22, r26
    2a0c:	71 1d       	adc	r23, r1
    2a0e:	81 1d       	adc	r24, r1
    2a10:	91 1d       	adc	r25, r1
    2a12:	a1 1d       	adc	r26, r1
    2a14:	20 d0       	rcall	.+64     	; 0x2a56 <__ultoa_invert+0x84>
    2a16:	09 f4       	brne	.+2      	; 0x2a1a <__ultoa_invert+0x48>
    2a18:	68 94       	set
    2a1a:	3f 91       	pop	r19
    2a1c:	2a e0       	ldi	r18, 0x0A	; 10
    2a1e:	26 9f       	mul	r18, r22
    2a20:	11 24       	eor	r1, r1
    2a22:	30 19       	sub	r19, r0
    2a24:	30 5d       	subi	r19, 0xD0	; 208
    2a26:	31 93       	st	Z+, r19
    2a28:	de f6       	brtc	.-74     	; 0x29e0 <__ultoa_invert+0xe>
    2a2a:	cf 01       	movw	r24, r30
    2a2c:	08 95       	ret
    2a2e:	46 2f       	mov	r20, r22
    2a30:	47 70       	andi	r20, 0x07	; 7
    2a32:	40 5d       	subi	r20, 0xD0	; 208
    2a34:	41 93       	st	Z+, r20
    2a36:	b3 e0       	ldi	r27, 0x03	; 3
    2a38:	0f d0       	rcall	.+30     	; 0x2a58 <__ultoa_invert+0x86>
    2a3a:	c9 f7       	brne	.-14     	; 0x2a2e <__ultoa_invert+0x5c>
    2a3c:	f6 cf       	rjmp	.-20     	; 0x2a2a <__ultoa_invert+0x58>
    2a3e:	46 2f       	mov	r20, r22
    2a40:	4f 70       	andi	r20, 0x0F	; 15
    2a42:	40 5d       	subi	r20, 0xD0	; 208
    2a44:	4a 33       	cpi	r20, 0x3A	; 58
    2a46:	18 f0       	brcs	.+6      	; 0x2a4e <__ultoa_invert+0x7c>
    2a48:	49 5d       	subi	r20, 0xD9	; 217
    2a4a:	31 fd       	sbrc	r19, 1
    2a4c:	40 52       	subi	r20, 0x20	; 32
    2a4e:	41 93       	st	Z+, r20
    2a50:	02 d0       	rcall	.+4      	; 0x2a56 <__ultoa_invert+0x84>
    2a52:	a9 f7       	brne	.-22     	; 0x2a3e <__ultoa_invert+0x6c>
    2a54:	ea cf       	rjmp	.-44     	; 0x2a2a <__ultoa_invert+0x58>
    2a56:	b4 e0       	ldi	r27, 0x04	; 4
    2a58:	a6 95       	lsr	r26
    2a5a:	97 95       	ror	r25
    2a5c:	87 95       	ror	r24
    2a5e:	77 95       	ror	r23
    2a60:	67 95       	ror	r22
    2a62:	ba 95       	dec	r27
    2a64:	c9 f7       	brne	.-14     	; 0x2a58 <__ultoa_invert+0x86>
    2a66:	00 97       	sbiw	r24, 0x00	; 0
    2a68:	61 05       	cpc	r22, r1
    2a6a:	71 05       	cpc	r23, r1
    2a6c:	08 95       	ret
    2a6e:	9b 01       	movw	r18, r22
    2a70:	ac 01       	movw	r20, r24
    2a72:	0a 2e       	mov	r0, r26
    2a74:	06 94       	lsr	r0
    2a76:	57 95       	ror	r21
    2a78:	47 95       	ror	r20
    2a7a:	37 95       	ror	r19
    2a7c:	27 95       	ror	r18
    2a7e:	ba 95       	dec	r27
    2a80:	c9 f7       	brne	.-14     	; 0x2a74 <__ultoa_invert+0xa2>
    2a82:	62 0f       	add	r22, r18
    2a84:	73 1f       	adc	r23, r19
    2a86:	84 1f       	adc	r24, r20
    2a88:	95 1f       	adc	r25, r21
    2a8a:	a0 1d       	adc	r26, r0
    2a8c:	08 95       	ret

00002a8e <__prologue_saves__>:
    2a8e:	2f 92       	push	r2
    2a90:	3f 92       	push	r3
    2a92:	4f 92       	push	r4
    2a94:	5f 92       	push	r5
    2a96:	6f 92       	push	r6
    2a98:	7f 92       	push	r7
    2a9a:	8f 92       	push	r8
    2a9c:	9f 92       	push	r9
    2a9e:	af 92       	push	r10
    2aa0:	bf 92       	push	r11
    2aa2:	cf 92       	push	r12
    2aa4:	df 92       	push	r13
    2aa6:	ef 92       	push	r14
    2aa8:	ff 92       	push	r15
    2aaa:	0f 93       	push	r16
    2aac:	1f 93       	push	r17
    2aae:	cf 93       	push	r28
    2ab0:	df 93       	push	r29
    2ab2:	cd b7       	in	r28, 0x3d	; 61
    2ab4:	de b7       	in	r29, 0x3e	; 62
    2ab6:	ca 1b       	sub	r28, r26
    2ab8:	db 0b       	sbc	r29, r27
    2aba:	0f b6       	in	r0, 0x3f	; 63
    2abc:	f8 94       	cli
    2abe:	de bf       	out	0x3e, r29	; 62
    2ac0:	0f be       	out	0x3f, r0	; 63
    2ac2:	cd bf       	out	0x3d, r28	; 61
    2ac4:	09 94       	ijmp

00002ac6 <__epilogue_restores__>:
    2ac6:	2a 88       	ldd	r2, Y+18	; 0x12
    2ac8:	39 88       	ldd	r3, Y+17	; 0x11
    2aca:	48 88       	ldd	r4, Y+16	; 0x10
    2acc:	5f 84       	ldd	r5, Y+15	; 0x0f
    2ace:	6e 84       	ldd	r6, Y+14	; 0x0e
    2ad0:	7d 84       	ldd	r7, Y+13	; 0x0d
    2ad2:	8c 84       	ldd	r8, Y+12	; 0x0c
    2ad4:	9b 84       	ldd	r9, Y+11	; 0x0b
    2ad6:	aa 84       	ldd	r10, Y+10	; 0x0a
    2ad8:	b9 84       	ldd	r11, Y+9	; 0x09
    2ada:	c8 84       	ldd	r12, Y+8	; 0x08
    2adc:	df 80       	ldd	r13, Y+7	; 0x07
    2ade:	ee 80       	ldd	r14, Y+6	; 0x06
    2ae0:	fd 80       	ldd	r15, Y+5	; 0x05
    2ae2:	0c 81       	ldd	r16, Y+4	; 0x04
    2ae4:	1b 81       	ldd	r17, Y+3	; 0x03
    2ae6:	aa 81       	ldd	r26, Y+2	; 0x02
    2ae8:	b9 81       	ldd	r27, Y+1	; 0x01
    2aea:	ce 0f       	add	r28, r30
    2aec:	d1 1d       	adc	r29, r1
    2aee:	0f b6       	in	r0, 0x3f	; 63
    2af0:	f8 94       	cli
    2af2:	de bf       	out	0x3e, r29	; 62
    2af4:	0f be       	out	0x3f, r0	; 63
    2af6:	cd bf       	out	0x3d, r28	; 61
    2af8:	ed 01       	movw	r28, r26
    2afa:	08 95       	ret

00002afc <_exit>:
    2afc:	f8 94       	cli

00002afe <__stop_program>:
    2afe:	ff cf       	rjmp	.-2      	; 0x2afe <__stop_program>
