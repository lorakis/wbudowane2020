
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00002900  00002994  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002900  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068b  00800124  00800124  000029b8  2**0
                  ALLOC
  3 .stab         00007dac  00000000  00000000  000029b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004667  00000000  00000000  0000a764  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000edcb  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000eddc  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000ee1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000f410  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f9b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f9cc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 4b 13 	jmp	0x2696	; 0x2696 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e0       	ldi	r30, 0x00	; 0
      7c:	f9 e2       	ldi	r31, 0x29	; 41
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a4 32       	cpi	r26, 0x24	; 36
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a4 e2       	ldi	r26, 0x24	; 36
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	af 3a       	cpi	r26, 0xAF	; 175
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 79 13 	call	0x26f2	; 0x26f2 <main>
      9e:	0c 94 7e 14 	jmp	0x28fc	; 0x28fc <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <adc_init>:
SemaphoreHandle_t mutex_r, mutex_a;
uint8_t i = 0;

void adc_init()
{
  ADMUX = _BV(REFS0); // ref wyjscia na ADC0
      a6:	80 e4       	ldi	r24, 0x40	; 64
      a8:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
  DIDR0 = _BV(ADC0D) | _BV(ADC1D) | _BV(ADC2D); // włączamy A0 A1 A2
      ac:	87 e0       	ldi	r24, 0x07	; 7
      ae:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
  ADCSRA  = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2); // preskaler 128
      b2:	ea e7       	ldi	r30, 0x7A	; 122
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 83       	st	Z, r24
  ADCSRA |= _BV(ADIE); // ADC interrupt enable
      b8:	80 81       	ld	r24, Z
      ba:	88 60       	ori	r24, 0x08	; 8
      bc:	80 83       	st	Z, r24
  ADCSRA |= _BV(ADEN); // włącz ADC
      be:	80 81       	ld	r24, Z
      c0:	80 68       	ori	r24, 0x80	; 128
      c2:	80 83       	st	Z, r24
      c4:	08 95       	ret

000000c6 <readADC>:
}

uint16_t readADC(uint8_t mux)
{
  ADMUX = _BV(REFS0) | mux;
      c6:	80 64       	ori	r24, 0x40	; 64
      c8:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
  ADCSRA |= _BV(ADSC);
      cc:	ea e7       	ldi	r30, 0x7A	; 122
      ce:	f0 e0       	ldi	r31, 0x00	; 0
      d0:	80 81       	ld	r24, Z
      d2:	80 64       	ori	r24, 0x40	; 64
      d4:	80 83       	st	Z, r24
  xSemaphoreTake(mutex_a, portMAX_DELAY); // blokada na mutex a
      d6:	6f ef       	ldi	r22, 0xFF	; 255
      d8:	7f ef       	ldi	r23, 0xFF	; 255
      da:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <mutex_a>
      de:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <mutex_a+0x1>
      e2:	0e 94 b7 0c 	call	0x196e	; 0x196e <xQueueSemaphoreTake>
  uint16_t w = ADC;
      e6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
      ea:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
  return w;
}
      ee:	08 95       	ret

000000f0 <vADC>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vADC(void* pvParameters)
{
      f0:	cf 93       	push	r28
      f2:	df 93       	push	r29
      f4:	00 d0       	rcall	.+0      	; 0xf6 <vADC+0x6>
      f6:	00 d0       	rcall	.+0      	; 0xf8 <vADC+0x8>
      f8:	1f 92       	push	r1
      fa:	cd b7       	in	r28, 0x3d	; 61
      fc:	de b7       	in	r29, 0x3e	; 62
      fe:	8c 01       	movw	r16, r24
  uart_init();
     100:	0e 94 68 13 	call	0x26d0	; 0x26d0 <uart_init>
  stdin = stdout = stderr = &uart_file;
     104:	80 e0       	ldi	r24, 0x00	; 0
     106:	91 e0       	ldi	r25, 0x01	; 1
     108:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <__iob+0x5>
     10c:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <__iob+0x4>
     110:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <__iob+0x3>
     114:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <__iob+0x2>
     118:	90 93 aa 07 	sts	0x07AA, r25	; 0x8007aa <__iob+0x1>
     11c:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <__iob>
  uint8_t port = (uint8_t)pvParameters;
     120:	b0 2e       	mov	r11, r16
    utoa(value, result, 10);
    putchar(':');
    puts(result);
    puts("\r");
    xSemaphoreGive(mutex_r); // zwolnienie r
    vTaskDelay(((port*100)+3000) / portTICK_PERIOD_MS);
     122:	78 01       	movw	r14, r16
     124:	ff 24       	eor	r15, r15
     126:	84 e6       	ldi	r24, 0x64	; 100
     128:	08 9f       	mul	r16, r24
     12a:	80 01       	movw	r16, r0
     12c:	11 24       	eor	r1, r1
     12e:	08 54       	subi	r16, 0x48	; 72
     130:	14 4f       	sbci	r17, 0xF4	; 244
  while (1)
  {
    xSemaphoreTake(mutex_r, portMAX_DELAY); // blokada mutexu r
    value = readADC(port);
    putchar('A');
    putchar('0'+port);
     132:	80 e3       	ldi	r24, 0x30	; 48
     134:	e8 0e       	add	r14, r24
     136:	f1 1c       	adc	r15, r1
  uint8_t port = (uint8_t)pvParameters;
  uint16_t value;
  char result[5];
  while (1)
  {
    xSemaphoreTake(mutex_r, portMAX_DELAY); // blokada mutexu r
     138:	6f ef       	ldi	r22, 0xFF	; 255
     13a:	7f ef       	ldi	r23, 0xFF	; 255
     13c:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <mutex_r>
     140:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <mutex_r+0x1>
     144:	0e 94 b7 0c 	call	0x196e	; 0x196e <xQueueSemaphoreTake>
    value = readADC(port);
     148:	8b 2d       	mov	r24, r11
     14a:	0e 94 63 00 	call	0xc6	; 0xc6 <readADC>
     14e:	6c 01       	movw	r12, r24
    putchar('A');
     150:	60 91 ab 07 	lds	r22, 0x07AB	; 0x8007ab <__iob+0x2>
     154:	70 91 ac 07 	lds	r23, 0x07AC	; 0x8007ac <__iob+0x3>
     158:	81 e4       	ldi	r24, 0x41	; 65
     15a:	90 e0       	ldi	r25, 0x00	; 0
     15c:	0e 94 02 14 	call	0x2804	; 0x2804 <fputc>
    putchar('0'+port);
     160:	60 91 ab 07 	lds	r22, 0x07AB	; 0x8007ab <__iob+0x2>
     164:	70 91 ac 07 	lds	r23, 0x07AC	; 0x8007ac <__iob+0x3>
     168:	c7 01       	movw	r24, r14
     16a:	0e 94 02 14 	call	0x2804	; 0x2804 <fputc>
    utoa(value, result, 10);
     16e:	4a e0       	ldi	r20, 0x0A	; 10
     170:	50 e0       	ldi	r21, 0x00	; 0
     172:	be 01       	movw	r22, r28
     174:	6f 5f       	subi	r22, 0xFF	; 255
     176:	7f 4f       	sbci	r23, 0xFF	; 255
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 dd 13 	call	0x27ba	; 0x27ba <utoa>
    putchar(':');
     17e:	60 91 ab 07 	lds	r22, 0x07AB	; 0x8007ab <__iob+0x2>
     182:	70 91 ac 07 	lds	r23, 0x07AC	; 0x8007ac <__iob+0x3>
     186:	8a e3       	ldi	r24, 0x3A	; 58
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	0e 94 02 14 	call	0x2804	; 0x2804 <fputc>
    puts(result);
     18e:	ce 01       	movw	r24, r28
     190:	01 96       	adiw	r24, 0x01	; 1
     192:	0e 94 3e 14 	call	0x287c	; 0x287c <puts>
    puts("\r");
     196:	8e e0       	ldi	r24, 0x0E	; 14
     198:	91 e0       	ldi	r25, 0x01	; 1
     19a:	0e 94 3e 14 	call	0x287c	; 0x287c <puts>
    xSemaphoreGive(mutex_r); // zwolnienie r
     19e:	20 e0       	ldi	r18, 0x00	; 0
     1a0:	40 e0       	ldi	r20, 0x00	; 0
     1a2:	50 e0       	ldi	r21, 0x00	; 0
     1a4:	60 e0       	ldi	r22, 0x00	; 0
     1a6:	70 e0       	ldi	r23, 0x00	; 0
     1a8:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <mutex_r>
     1ac:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <mutex_r+0x1>
     1b0:	0e 94 23 0b 	call	0x1646	; 0x1646 <xQueueGenericSend>
    vTaskDelay(((port*100)+3000) / portTICK_PERIOD_MS);
     1b4:	c8 01       	movw	r24, r16
     1b6:	0e 94 37 05 	call	0xa6e	; 0xa6e <vTaskDelay>
     1ba:	be cf       	rjmp	.-132    	; 0x138 <vADC+0x48>

000001bc <__vector_21>:
  uint16_t w = ADC;
  return w;
}

ISR(ADC_vect)
{
     1bc:	1f 92       	push	r1
     1be:	0f 92       	push	r0
     1c0:	0f b6       	in	r0, 0x3f	; 63
     1c2:	0f 92       	push	r0
     1c4:	11 24       	eor	r1, r1
     1c6:	2f 93       	push	r18
     1c8:	3f 93       	push	r19
     1ca:	4f 93       	push	r20
     1cc:	5f 93       	push	r21
     1ce:	6f 93       	push	r22
     1d0:	7f 93       	push	r23
     1d2:	8f 93       	push	r24
     1d4:	9f 93       	push	r25
     1d6:	af 93       	push	r26
     1d8:	bf 93       	push	r27
     1da:	ef 93       	push	r30
     1dc:	ff 93       	push	r31
  xSemaphoreGiveFromISR(mutex_a, NULL); // odblokuj mutex a
     1de:	60 e0       	ldi	r22, 0x00	; 0
     1e0:	70 e0       	ldi	r23, 0x00	; 0
     1e2:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <mutex_a>
     1e6:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <mutex_a+0x1>
     1ea:	0e 94 02 0c 	call	0x1804	; 0x1804 <xQueueGiveFromISR>
}
     1ee:	ff 91       	pop	r31
     1f0:	ef 91       	pop	r30
     1f2:	bf 91       	pop	r27
     1f4:	af 91       	pop	r26
     1f6:	9f 91       	pop	r25
     1f8:	8f 91       	pop	r24
     1fa:	7f 91       	pop	r23
     1fc:	6f 91       	pop	r22
     1fe:	5f 91       	pop	r21
     200:	4f 91       	pop	r20
     202:	3f 91       	pop	r19
     204:	2f 91       	pop	r18
     206:	0f 90       	pop	r0
     208:	0f be       	out	0x3f, r0	; 63
     20a:	0f 90       	pop	r0
     20c:	1f 90       	pop	r1
     20e:	18 95       	reti

00000210 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     210:	08 95       	ret

00000212 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     212:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     216:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     21a:	80 81       	ld	r24, Z
     21c:	81 11       	cpse	r24, r1
     21e:	03 c0       	rjmp	.+6      	; 0x226 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     220:	8f ef       	ldi	r24, 0xFF	; 255
     222:	9f ef       	ldi	r25, 0xFF	; 255
     224:	0c c0       	rjmp	.+24     	; 0x23e <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     226:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     22a:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     22e:	05 80       	ldd	r0, Z+5	; 0x05
     230:	f6 81       	ldd	r31, Z+6	; 0x06
     232:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     234:	06 80       	ldd	r0, Z+6	; 0x06
     236:	f7 81       	ldd	r31, Z+7	; 0x07
     238:	e0 2d       	mov	r30, r0
     23a:	82 81       	ldd	r24, Z+2	; 0x02
     23c:	93 81       	ldd	r25, Z+3	; 0x03
     23e:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <xNextTaskUnblockTime+0x1>
     242:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <xNextTaskUnblockTime>
     246:	08 95       	ret

00000248 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     248:	ff 92       	push	r15
     24a:	0f 93       	push	r16
     24c:	1f 93       	push	r17
     24e:	cf 93       	push	r28
     250:	df 93       	push	r29
     252:	ec 01       	movw	r28, r24
     254:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     256:	00 91 32 01 	lds	r16, 0x0132	; 0x800132 <xTickCount>
     25a:	10 91 33 01 	lds	r17, 0x0133	; 0x800133 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     25e:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     262:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     266:	02 96       	adiw	r24, 0x02	; 2
     268:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     26c:	cf 3f       	cpi	r28, 0xFF	; 255
     26e:	8f ef       	ldi	r24, 0xFF	; 255
     270:	d8 07       	cpc	r29, r24
     272:	89 f4       	brne	.+34     	; 0x296 <prvAddCurrentTaskToDelayedList+0x4e>
     274:	ff 20       	and	r15, r15
     276:	79 f0       	breq	.+30     	; 0x296 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     278:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     27c:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     280:	6e 5f       	subi	r22, 0xFE	; 254
     282:	7f 4f       	sbci	r23, 0xFF	; 255
     284:	85 e3       	ldi	r24, 0x35	; 53
     286:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     288:	df 91       	pop	r29
     28a:	cf 91       	pop	r28
     28c:	1f 91       	pop	r17
     28e:	0f 91       	pop	r16
     290:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     292:	0c 94 65 0f 	jmp	0x1eca	; 0x1eca <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     296:	c0 0f       	add	r28, r16
     298:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     29a:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     29e:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     2a2:	d3 83       	std	Z+3, r29	; 0x03
     2a4:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2a6:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     2aa:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     2ae:	c0 17       	cp	r28, r16
     2b0:	d1 07       	cpc	r29, r17
     2b2:	68 f4       	brcc	.+26     	; 0x2ce <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2b4:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <pxOverflowDelayedTaskList>
     2b8:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     2bc:	6e 5f       	subi	r22, 0xFE	; 254
     2be:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2c0:	df 91       	pop	r29
     2c2:	cf 91       	pop	r28
     2c4:	1f 91       	pop	r17
     2c6:	0f 91       	pop	r16
     2c8:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2ca:	0c 94 86 0f 	jmp	0x1f0c	; 0x1f0c <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2ce:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <pxDelayedTaskList>
     2d2:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     2d6:	6e 5f       	subi	r22, 0xFE	; 254
     2d8:	7f 4f       	sbci	r23, 0xFF	; 255
     2da:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     2de:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <xNextTaskUnblockTime>
     2e2:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <xNextTaskUnblockTime+0x1>
     2e6:	c8 17       	cp	r28, r24
     2e8:	d9 07       	cpc	r29, r25
     2ea:	20 f4       	brcc	.+8      	; 0x2f4 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     2ec:	d0 93 2b 01 	sts	0x012B, r29	; 0x80012b <xNextTaskUnblockTime+0x1>
     2f0:	c0 93 2a 01 	sts	0x012A, r28	; 0x80012a <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2f4:	df 91       	pop	r29
     2f6:	cf 91       	pop	r28
     2f8:	1f 91       	pop	r17
     2fa:	0f 91       	pop	r16
     2fc:	ff 90       	pop	r15
     2fe:	08 95       	ret

00000300 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     300:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     304:	88 23       	and	r24, r24
     306:	09 f1       	breq	.+66     	; 0x34a <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     308:	0f b6       	in	r0, 0x3f	; 63
     30a:	f8 94       	cli
     30c:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     30e:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <xTasksWaitingTermination+0x5>
     312:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <xTasksWaitingTermination+0x6>
     316:	c6 81       	ldd	r28, Z+6	; 0x06
     318:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     31a:	ce 01       	movw	r24, r28
     31c:	02 96       	adiw	r24, 0x02	; 2
     31e:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
				--uxCurrentNumberOfTasks;
     322:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     326:	81 50       	subi	r24, 0x01	; 1
     328:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     32c:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     330:	81 50       	subi	r24, 0x01	; 1
     332:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     336:	0f 90       	pop	r0
     338:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     33a:	8f 89       	ldd	r24, Y+23	; 0x17
     33c:	98 8d       	ldd	r25, Y+24	; 0x18
     33e:	0e 94 da 11 	call	0x23b4	; 0x23b4 <vPortFree>
			vPortFree( pxTCB );
     342:	ce 01       	movw	r24, r28
     344:	0e 94 da 11 	call	0x23b4	; 0x23b4 <vPortFree>
     348:	db cf       	rjmp	.-74     	; 0x300 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     34a:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <pxReadyTasksLists>
     34e:	82 30       	cpi	r24, 0x02	; 2
     350:	10 f0       	brcs	.+4      	; 0x356 <prvIdleTask+0x56>
			{
				taskYIELD();
     352:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     356:	0e 94 08 01 	call	0x210	; 0x210 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     35a:	d2 cf       	rjmp	.-92     	; 0x300 <prvIdleTask>

0000035c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     35c:	3f 92       	push	r3
     35e:	4f 92       	push	r4
     360:	5f 92       	push	r5
     362:	6f 92       	push	r6
     364:	7f 92       	push	r7
     366:	8f 92       	push	r8
     368:	9f 92       	push	r9
     36a:	af 92       	push	r10
     36c:	bf 92       	push	r11
     36e:	cf 92       	push	r12
     370:	df 92       	push	r13
     372:	ef 92       	push	r14
     374:	ff 92       	push	r15
     376:	0f 93       	push	r16
     378:	1f 93       	push	r17
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	4c 01       	movw	r8, r24
     380:	16 2f       	mov	r17, r22
     382:	37 2e       	mov	r3, r23
     384:	6a 01       	movw	r12, r20
     386:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     388:	ca 01       	movw	r24, r20
     38a:	0e 94 a8 11 	call	0x2350	; 0x2350 <pvPortMalloc>
     38e:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     390:	89 2b       	or	r24, r25
     392:	09 f4       	brne	.+2      	; 0x396 <xTaskCreate+0x3a>
     394:	d3 c0       	rjmp	.+422    	; 0x53c <__LOCK_REGION_LENGTH__+0x13c>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     396:	88 e2       	ldi	r24, 0x28	; 40
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	0e 94 a8 11 	call	0x2350	; 0x2350 <pvPortMalloc>
     39e:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     3a0:	89 2b       	or	r24, r25
     3a2:	79 f0       	breq	.+30     	; 0x3c2 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     3a4:	58 8e       	std	Y+24, r5	; 0x18
     3a6:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     3a8:	c6 01       	movw	r24, r12
     3aa:	01 97       	sbiw	r24, 0x01	; 1
     3ac:	32 01       	movw	r6, r4
     3ae:	68 0e       	add	r6, r24
     3b0:	79 1e       	adc	r7, r25
     3b2:	be 01       	movw	r22, r28
     3b4:	67 5e       	subi	r22, 0xE7	; 231
     3b6:	7f 4f       	sbci	r23, 0xFF	; 255
     3b8:	e1 2f       	mov	r30, r17
     3ba:	f3 2d       	mov	r31, r3
     3bc:	cf 01       	movw	r24, r30
     3be:	08 96       	adiw	r24, 0x08	; 8
     3c0:	07 c0       	rjmp	.+14     	; 0x3d0 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     3c2:	c2 01       	movw	r24, r4
     3c4:	0e 94 da 11 	call	0x23b4	; 0x23b4 <vPortFree>
     3c8:	b9 c0       	rjmp	.+370    	; 0x53c <__LOCK_REGION_LENGTH__+0x13c>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     3ca:	e8 17       	cp	r30, r24
     3cc:	f9 07       	cpc	r31, r25
     3ce:	49 f0       	breq	.+18     	; 0x3e2 <xTaskCreate+0x86>
     3d0:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     3d2:	41 91       	ld	r20, Z+
     3d4:	db 01       	movw	r26, r22
     3d6:	4d 93       	st	X+, r20
     3d8:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     3da:	d9 01       	movw	r26, r18
     3dc:	2c 91       	ld	r18, X
     3de:	21 11       	cpse	r18, r1
     3e0:	f4 cf       	rjmp	.-24     	; 0x3ca <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     3e2:	18 a2       	std	Y+32, r1	; 0x20
     3e4:	04 30       	cpi	r16, 0x04	; 4
     3e6:	08 f0       	brcs	.+2      	; 0x3ea <xTaskCreate+0x8e>
     3e8:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     3ea:	0e 8b       	std	Y+22, r16	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
     3ec:	09 a3       	std	Y+33, r16	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
     3ee:	1a a2       	std	Y+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     3f0:	6e 01       	movw	r12, r28
     3f2:	b2 e0       	ldi	r27, 0x02	; 2
     3f4:	cb 0e       	add	r12, r27
     3f6:	d1 1c       	adc	r13, r1
     3f8:	c6 01       	movw	r24, r12
     3fa:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     3fe:	ce 01       	movw	r24, r28
     400:	0c 96       	adiw	r24, 0x0c	; 12
     402:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     406:	d9 87       	std	Y+9, r29	; 0x09
     408:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     40a:	84 e0       	ldi	r24, 0x04	; 4
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	80 1b       	sub	r24, r16
     410:	91 09       	sbc	r25, r1
     412:	9d 87       	std	Y+13, r25	; 0x0d
     414:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     416:	db 8b       	std	Y+19, r29	; 0x13
     418:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     41a:	1b a2       	std	Y+35, r1	; 0x23
     41c:	1c a2       	std	Y+36, r1	; 0x24
     41e:	1d a2       	std	Y+37, r1	; 0x25
     420:	1e a2       	std	Y+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     422:	1f a2       	std	Y+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     424:	a5 01       	movw	r20, r10
     426:	b4 01       	movw	r22, r8
     428:	c3 01       	movw	r24, r6
     42a:	0e 94 e9 11 	call	0x23d2	; 0x23d2 <pxPortInitialiseStack>
     42e:	99 83       	std	Y+1, r25	; 0x01
     430:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     432:	e1 14       	cp	r14, r1
     434:	f1 04       	cpc	r15, r1
     436:	19 f0       	breq	.+6      	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     438:	f7 01       	movw	r30, r14
     43a:	d1 83       	std	Z+1, r29	; 0x01
     43c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     43e:	0f b6       	in	r0, 0x3f	; 63
     440:	f8 94       	cli
     442:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     444:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     448:	8f 5f       	subi	r24, 0xFF	; 255
     44a:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     44e:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     452:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     456:	89 2b       	or	r24, r25
     458:	d1 f5       	brne	.+116    	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     45a:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <pxCurrentTCB+0x1>
     45e:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     462:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     466:	81 30       	cpi	r24, 0x01	; 1
     468:	09 f0       	breq	.+2      	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
     46a:	41 c0       	rjmp	.+130    	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     46c:	87 e6       	ldi	r24, 0x67	; 103
     46e:	91 e0       	ldi	r25, 0x01	; 1
     470:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
     474:	80 e7       	ldi	r24, 0x70	; 112
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
     47c:	89 e7       	ldi	r24, 0x79	; 121
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
     484:	82 e8       	ldi	r24, 0x82	; 130
     486:	91 e0       	ldi	r25, 0x01	; 1
     488:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     48c:	8e e5       	ldi	r24, 0x5E	; 94
     48e:	91 e0       	ldi	r25, 0x01	; 1
     490:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     494:	85 e5       	ldi	r24, 0x55	; 85
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     49c:	88 e4       	ldi	r24, 0x48	; 72
     49e:	91 e0       	ldi	r25, 0x01	; 1
     4a0:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     4a4:	8f e3       	ldi	r24, 0x3F	; 63
     4a6:	91 e0       	ldi	r25, 0x01	; 1
     4a8:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     4ac:	85 e3       	ldi	r24, 0x35	; 53
     4ae:	91 e0       	ldi	r25, 0x01	; 1
     4b0:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     4b4:	8e e5       	ldi	r24, 0x5E	; 94
     4b6:	91 e0       	ldi	r25, 0x01	; 1
     4b8:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <pxDelayedTaskList+0x1>
     4bc:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     4c0:	85 e5       	ldi	r24, 0x55	; 85
     4c2:	91 e0       	ldi	r25, 0x01	; 1
     4c4:	90 93 52 01 	sts	0x0152, r25	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     4c8:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <pxOverflowDelayedTaskList>
     4cc:	10 c0       	rjmp	.+32     	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     4ce:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     4d2:	81 11       	cpse	r24, r1
     4d4:	0c c0       	rjmp	.+24     	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4d6:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     4da:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     4de:	96 89       	ldd	r25, Z+22	; 0x16
     4e0:	8e 89       	ldd	r24, Y+22	; 0x16
     4e2:	89 17       	cp	r24, r25
     4e4:	20 f0       	brcs	.+8      	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
				{
					pxCurrentTCB = pxNewTCB;
     4e6:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <pxCurrentTCB+0x1>
     4ea:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     4ee:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTaskNumber>
     4f2:	8f 5f       	subi	r24, 0xFF	; 255
     4f4:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     4f8:	8e 89       	ldd	r24, Y+22	; 0x16
     4fa:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     4fe:	98 17       	cp	r25, r24
     500:	10 f4       	brcc	.+4      	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
     502:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     506:	f9 e0       	ldi	r31, 0x09	; 9
     508:	8f 9f       	mul	r24, r31
     50a:	c0 01       	movw	r24, r0
     50c:	11 24       	eor	r1, r1
     50e:	b6 01       	movw	r22, r12
     510:	89 59       	subi	r24, 0x99	; 153
     512:	9e 4f       	sbci	r25, 0xFE	; 254
     514:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     518:	0f 90       	pop	r0
     51a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     51c:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     520:	88 23       	and	r24, r24
     522:	51 f0       	breq	.+20     	; 0x538 <__LOCK_REGION_LENGTH__+0x138>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     524:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     528:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     52c:	96 89       	ldd	r25, Z+22	; 0x16
     52e:	8e 89       	ldd	r24, Y+22	; 0x16
     530:	98 17       	cp	r25, r24
     532:	10 f4       	brcc	.+4      	; 0x538 <__LOCK_REGION_LENGTH__+0x138>
		{
			taskYIELD_IF_USING_PREEMPTION();
     534:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     538:	81 e0       	ldi	r24, 0x01	; 1
     53a:	01 c0       	rjmp	.+2      	; 0x53e <__LOCK_REGION_LENGTH__+0x13e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     53c:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     53e:	df 91       	pop	r29
     540:	cf 91       	pop	r28
     542:	1f 91       	pop	r17
     544:	0f 91       	pop	r16
     546:	ff 90       	pop	r15
     548:	ef 90       	pop	r14
     54a:	df 90       	pop	r13
     54c:	cf 90       	pop	r12
     54e:	bf 90       	pop	r11
     550:	af 90       	pop	r10
     552:	9f 90       	pop	r9
     554:	8f 90       	pop	r8
     556:	7f 90       	pop	r7
     558:	6f 90       	pop	r6
     55a:	5f 90       	pop	r5
     55c:	4f 90       	pop	r4
     55e:	3f 90       	pop	r3
     560:	08 95       	ret

00000562 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     562:	0f 93       	push	r16
     564:	1f 93       	push	r17
     566:	cf 93       	push	r28
     568:	df 93       	push	r29
     56a:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     572:	89 2b       	or	r24, r25
     574:	21 f4       	brne	.+8      	; 0x57e <vTaskDelete+0x1c>
     576:	c0 91 25 01 	lds	r28, 0x0125	; 0x800125 <pxCurrentTCB>
     57a:	d0 91 26 01 	lds	r29, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     57e:	8e 01       	movw	r16, r28
     580:	0e 5f       	subi	r16, 0xFE	; 254
     582:	1f 4f       	sbci	r17, 0xFF	; 255
     584:	c8 01       	movw	r24, r16
     586:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     58a:	8c 89       	ldd	r24, Y+20	; 0x14
     58c:	9d 89       	ldd	r25, Y+21	; 0x15
     58e:	89 2b       	or	r24, r25
     590:	21 f0       	breq	.+8      	; 0x59a <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     592:	ce 01       	movw	r24, r28
     594:	0c 96       	adiw	r24, 0x0c	; 12
     596:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     59a:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTaskNumber>
     59e:	8f 5f       	subi	r24, 0xFF	; 255
     5a0:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     5a4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     5a8:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     5ac:	c8 17       	cp	r28, r24
     5ae:	d9 07       	cpc	r29, r25
     5b0:	59 f4       	brne	.+22     	; 0x5c8 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     5b2:	b8 01       	movw	r22, r16
     5b4:	8f e3       	ldi	r24, 0x3F	; 63
     5b6:	91 e0       	ldi	r25, 0x01	; 1
     5b8:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     5bc:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     5c0:	8f 5f       	subi	r24, 0xFF	; 255
     5c2:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     5c6:	0e c0       	rjmp	.+28     	; 0x5e4 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     5c8:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     5cc:	81 50       	subi	r24, 0x01	; 1
     5ce:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     5d2:	8f 89       	ldd	r24, Y+23	; 0x17
     5d4:	98 8d       	ldd	r25, Y+24	; 0x18
     5d6:	0e 94 da 11 	call	0x23b4	; 0x23b4 <vPortFree>
			vPortFree( pxTCB );
     5da:	ce 01       	movw	r24, r28
     5dc:	0e 94 da 11 	call	0x23b4	; 0x23b4 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     5e0:	0e 94 09 01 	call	0x212	; 0x212 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     5e4:	0f 90       	pop	r0
     5e6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     5e8:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     5ec:	88 23       	and	r24, r24
     5ee:	49 f0       	breq	.+18     	; 0x602 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     5f0:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     5f4:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     5f8:	c8 17       	cp	r28, r24
     5fa:	d9 07       	cpc	r29, r25
     5fc:	11 f4       	brne	.+4      	; 0x602 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     5fe:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	08 95       	ret

0000060c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     60c:	0f 93       	push	r16
     60e:	1f 93       	push	r17
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     614:	20 91 25 01 	lds	r18, 0x0125	; 0x800125 <pxCurrentTCB>
     618:	30 91 26 01 	lds	r19, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     61c:	82 17       	cp	r24, r18
     61e:	93 07       	cpc	r25, r19
     620:	b9 f1       	breq	.+110    	; 0x690 <vTaskResume+0x84>
     622:	00 97       	sbiw	r24, 0x00	; 0
     624:	a9 f1       	breq	.+106    	; 0x690 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     626:	0f b6       	in	r0, 0x3f	; 63
     628:	f8 94       	cli
     62a:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     62c:	fc 01       	movw	r30, r24
     62e:	22 85       	ldd	r18, Z+10	; 0x0a
     630:	33 85       	ldd	r19, Z+11	; 0x0b
     632:	25 53       	subi	r18, 0x35	; 53
     634:	31 40       	sbci	r19, 0x01	; 1
     636:	51 f5       	brne	.+84     	; 0x68c <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     638:	fc 01       	movw	r30, r24
     63a:	24 89       	ldd	r18, Z+20	; 0x14
     63c:	35 89       	ldd	r19, Z+21	; 0x15
     63e:	f1 e0       	ldi	r31, 0x01	; 1
     640:	28 34       	cpi	r18, 0x48	; 72
     642:	3f 07       	cpc	r19, r31
     644:	19 f1       	breq	.+70     	; 0x68c <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     646:	23 2b       	or	r18, r19
     648:	09 f5       	brne	.+66     	; 0x68c <vTaskResume+0x80>
     64a:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     64c:	8c 01       	movw	r16, r24
     64e:	0e 5f       	subi	r16, 0xFE	; 254
     650:	1f 4f       	sbci	r17, 0xFF	; 255
     652:	c8 01       	movw	r24, r16
     654:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     658:	8e 89       	ldd	r24, Y+22	; 0x16
     65a:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     65e:	98 17       	cp	r25, r24
     660:	10 f4       	brcc	.+4      	; 0x666 <vTaskResume+0x5a>
     662:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     666:	29 e0       	ldi	r18, 0x09	; 9
     668:	82 9f       	mul	r24, r18
     66a:	c0 01       	movw	r24, r0
     66c:	11 24       	eor	r1, r1
     66e:	b8 01       	movw	r22, r16
     670:	89 59       	subi	r24, 0x99	; 153
     672:	9e 4f       	sbci	r25, 0xFE	; 254
     674:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     678:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     67c:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     680:	9e 89       	ldd	r25, Y+22	; 0x16
     682:	86 89       	ldd	r24, Z+22	; 0x16
     684:	98 17       	cp	r25, r24
     686:	10 f0       	brcs	.+4      	; 0x68c <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     688:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     68c:	0f 90       	pop	r0
     68e:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	1f 91       	pop	r17
     696:	0f 91       	pop	r16
     698:	08 95       	ret

0000069a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     69a:	ef 92       	push	r14
     69c:	ff 92       	push	r15
     69e:	1f 93       	push	r17
     6a0:	cf 93       	push	r28
     6a2:	df 93       	push	r29
     6a4:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     6a6:	8a 85       	ldd	r24, Y+10	; 0x0a
     6a8:	9b 85       	ldd	r25, Y+11	; 0x0b
     6aa:	85 53       	subi	r24, 0x35	; 53
     6ac:	91 40       	sbci	r25, 0x01	; 1
     6ae:	99 f4       	brne	.+38     	; 0x6d6 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     6b0:	8c 89       	ldd	r24, Y+20	; 0x14
     6b2:	9d 89       	ldd	r25, Y+21	; 0x15
     6b4:	21 e0       	ldi	r18, 0x01	; 1
     6b6:	88 34       	cpi	r24, 0x48	; 72
     6b8:	92 07       	cpc	r25, r18
     6ba:	69 f0       	breq	.+26     	; 0x6d6 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     6bc:	89 2b       	or	r24, r25
     6be:	59 f4       	brne	.+22     	; 0x6d6 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     6c0:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     6c4:	88 23       	and	r24, r24
     6c6:	49 f0       	breq	.+18     	; 0x6da <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     6c8:	be 01       	movw	r22, r28
     6ca:	64 5f       	subi	r22, 0xF4	; 244
     6cc:	7f 4f       	sbci	r23, 0xFF	; 255
     6ce:	88 e4       	ldi	r24, 0x48	; 72
     6d0:	91 e0       	ldi	r25, 0x01	; 1
     6d2:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     6d6:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     6d8:	21 c0       	rjmp	.+66     	; 0x71c <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     6da:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     6de:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     6e2:	11 e0       	ldi	r17, 0x01	; 1
     6e4:	9e 89       	ldd	r25, Y+22	; 0x16
     6e6:	86 89       	ldd	r24, Z+22	; 0x16
     6e8:	98 17       	cp	r25, r24
     6ea:	08 f4       	brcc	.+2      	; 0x6ee <xTaskResumeFromISR+0x54>
     6ec:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     6ee:	7e 01       	movw	r14, r28
     6f0:	82 e0       	ldi	r24, 0x02	; 2
     6f2:	e8 0e       	add	r14, r24
     6f4:	f1 1c       	adc	r15, r1
     6f6:	c7 01       	movw	r24, r14
     6f8:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6fc:	8e 89       	ldd	r24, Y+22	; 0x16
     6fe:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     702:	98 17       	cp	r25, r24
     704:	10 f4       	brcc	.+4      	; 0x70a <xTaskResumeFromISR+0x70>
     706:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     70a:	29 e0       	ldi	r18, 0x09	; 9
     70c:	82 9f       	mul	r24, r18
     70e:	c0 01       	movw	r24, r0
     710:	11 24       	eor	r1, r1
     712:	b7 01       	movw	r22, r14
     714:	89 59       	subi	r24, 0x99	; 153
     716:	9e 4f       	sbci	r25, 0xFE	; 254
     718:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     71c:	81 2f       	mov	r24, r17
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	1f 91       	pop	r17
     724:	ff 90       	pop	r15
     726:	ef 90       	pop	r14
     728:	08 95       	ret

0000072a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     72a:	ef 92       	push	r14
     72c:	ff 92       	push	r15
     72e:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     730:	88 e2       	ldi	r24, 0x28	; 40
     732:	e8 2e       	mov	r14, r24
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	f8 2e       	mov	r15, r24
     738:	00 e0       	ldi	r16, 0x00	; 0
     73a:	20 e0       	ldi	r18, 0x00	; 0
     73c:	30 e0       	ldi	r19, 0x00	; 0
     73e:	45 e5       	ldi	r20, 0x55	; 85
     740:	50 e0       	ldi	r21, 0x00	; 0
     742:	6f e1       	ldi	r22, 0x1F	; 31
     744:	71 e0       	ldi	r23, 0x01	; 1
     746:	80 e8       	ldi	r24, 0x80	; 128
     748:	91 e0       	ldi	r25, 0x01	; 1
     74a:	0e 94 ae 01 	call	0x35c	; 0x35c <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     74e:	81 30       	cpi	r24, 0x01	; 1
     750:	91 f4       	brne	.+36     	; 0x776 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     752:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     754:	2f ef       	ldi	r18, 0xFF	; 255
     756:	3f ef       	ldi	r19, 0xFF	; 255
     758:	30 93 2b 01 	sts	0x012B, r19	; 0x80012b <xNextTaskUnblockTime+0x1>
     75c:	20 93 2a 01 	sts	0x012A, r18	; 0x80012a <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     760:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     764:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <xTickCount+0x1>
     768:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     76c:	0f 91       	pop	r16
     76e:	ff 90       	pop	r15
     770:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     772:	0c 94 55 12 	jmp	0x24aa	; 0x24aa <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     776:	0f 91       	pop	r16
     778:	ff 90       	pop	r15
     77a:	ef 90       	pop	r14
     77c:	08 95       	ret

0000077e <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     77e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     780:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <xSchedulerRunning>
	vPortEndScheduler();
     784:	0c 94 95 12 	jmp	0x252a	; 0x252a <vPortEndScheduler>

00000788 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     788:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     78c:	8f 5f       	subi	r24, 0xFF	; 255
     78e:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxSchedulerSuspended>
     792:	08 95       	ret

00000794 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     794:	0f b6       	in	r0, 0x3f	; 63
     796:	f8 94       	cli
     798:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     79a:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xTickCount>
     79e:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     7a2:	0f 90       	pop	r0
     7a4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     7a6:	08 95       	ret

000007a8 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     7a8:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xTickCount>
     7ac:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7b0:	08 95       	ret

000007b2 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     7b2:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
}
     7b6:	08 95       	ret

000007b8 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     7b8:	00 97       	sbiw	r24, 0x00	; 0
     7ba:	21 f4       	brne	.+8      	; 0x7c4 <pcTaskGetName+0xc>
     7bc:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     7c0:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     7c4:	49 96       	adiw	r24, 0x19	; 25
     7c6:	08 95       	ret

000007c8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     7c8:	cf 92       	push	r12
     7ca:	df 92       	push	r13
     7cc:	ef 92       	push	r14
     7ce:	ff 92       	push	r15
     7d0:	0f 93       	push	r16
     7d2:	1f 93       	push	r17
     7d4:	cf 93       	push	r28
     7d6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     7d8:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     7dc:	81 11       	cpse	r24, r1
     7de:	8c c0       	rjmp	.+280    	; 0x8f8 <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     7e0:	00 91 32 01 	lds	r16, 0x0132	; 0x800132 <xTickCount>
     7e4:	10 91 33 01 	lds	r17, 0x0133	; 0x800133 <xTickCount+0x1>
     7e8:	0f 5f       	subi	r16, 0xFF	; 255
     7ea:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     7ec:	10 93 33 01 	sts	0x0133, r17	; 0x800133 <xTickCount+0x1>
     7f0:	00 93 32 01 	sts	0x0132, r16	; 0x800132 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     7f4:	01 15       	cp	r16, r1
     7f6:	11 05       	cpc	r17, r1
     7f8:	b9 f4       	brne	.+46     	; 0x828 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     7fa:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <pxDelayedTaskList>
     7fe:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     802:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <pxOverflowDelayedTaskList>
     806:	30 91 52 01 	lds	r19, 0x0152	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     80a:	30 93 54 01 	sts	0x0154, r19	; 0x800154 <pxDelayedTaskList+0x1>
     80e:	20 93 53 01 	sts	0x0153, r18	; 0x800153 <pxDelayedTaskList>
     812:	90 93 52 01 	sts	0x0152, r25	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     816:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <pxOverflowDelayedTaskList>
     81a:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xNumOfOverflows>
     81e:	8f 5f       	subi	r24, 0xFF	; 255
     820:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <xNumOfOverflows>
     824:	0e 94 09 01 	call	0x212	; 0x212 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     828:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <xNextTaskUnblockTime>
     82c:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <xNextTaskUnblockTime+0x1>
     830:	c0 e0       	ldi	r28, 0x00	; 0
     832:	08 17       	cp	r16, r24
     834:	19 07       	cpc	r17, r25
     836:	08 f4       	brcc	.+2      	; 0x83a <xTaskIncrementTick+0x72>
     838:	4f c0       	rjmp	.+158    	; 0x8d8 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     83a:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     83c:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     840:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     844:	80 81       	ld	r24, Z
     846:	81 11       	cpse	r24, r1
     848:	03 c0       	rjmp	.+6      	; 0x850 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     84a:	8f ef       	ldi	r24, 0xFF	; 255
     84c:	9f ef       	ldi	r25, 0xFF	; 255
     84e:	11 c0       	rjmp	.+34     	; 0x872 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     850:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     854:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     858:	05 80       	ldd	r0, Z+5	; 0x05
     85a:	f6 81       	ldd	r31, Z+6	; 0x06
     85c:	e0 2d       	mov	r30, r0
     85e:	e6 80       	ldd	r14, Z+6	; 0x06
     860:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     862:	d7 01       	movw	r26, r14
     864:	12 96       	adiw	r26, 0x02	; 2
     866:	8d 91       	ld	r24, X+
     868:	9c 91       	ld	r25, X
     86a:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     86c:	08 17       	cp	r16, r24
     86e:	19 07       	cpc	r17, r25
     870:	28 f4       	brcc	.+10     	; 0x87c <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     872:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <xNextTaskUnblockTime+0x1>
     876:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     87a:	2e c0       	rjmp	.+92     	; 0x8d8 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     87c:	67 01       	movw	r12, r14
     87e:	b2 e0       	ldi	r27, 0x02	; 2
     880:	cb 0e       	add	r12, r27
     882:	d1 1c       	adc	r13, r1
     884:	c6 01       	movw	r24, r12
     886:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     88a:	f7 01       	movw	r30, r14
     88c:	84 89       	ldd	r24, Z+20	; 0x14
     88e:	95 89       	ldd	r25, Z+21	; 0x15
     890:	89 2b       	or	r24, r25
     892:	21 f0       	breq	.+8      	; 0x89c <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     894:	c7 01       	movw	r24, r14
     896:	0c 96       	adiw	r24, 0x0c	; 12
     898:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     89c:	d7 01       	movw	r26, r14
     89e:	56 96       	adiw	r26, 0x16	; 22
     8a0:	8c 91       	ld	r24, X
     8a2:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     8a6:	98 17       	cp	r25, r24
     8a8:	10 f4       	brcc	.+4      	; 0x8ae <xTaskIncrementTick+0xe6>
     8aa:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     8ae:	d8 9f       	mul	r29, r24
     8b0:	c0 01       	movw	r24, r0
     8b2:	11 24       	eor	r1, r1
     8b4:	b6 01       	movw	r22, r12
     8b6:	89 59       	subi	r24, 0x99	; 153
     8b8:	9e 4f       	sbci	r25, 0xFE	; 254
     8ba:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     8be:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     8c2:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     8c6:	d7 01       	movw	r26, r14
     8c8:	56 96       	adiw	r26, 0x16	; 22
     8ca:	9c 91       	ld	r25, X
     8cc:	86 89       	ldd	r24, Z+22	; 0x16
     8ce:	98 17       	cp	r25, r24
     8d0:	08 f4       	brcc	.+2      	; 0x8d4 <xTaskIncrementTick+0x10c>
     8d2:	b4 cf       	rjmp	.-152    	; 0x83c <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     8d4:	c1 e0       	ldi	r28, 0x01	; 1
     8d6:	b2 cf       	rjmp	.-156    	; 0x83c <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     8d8:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     8dc:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     8e0:	e6 89       	ldd	r30, Z+22	; 0x16
     8e2:	b9 e0       	ldi	r27, 0x09	; 9
     8e4:	eb 9f       	mul	r30, r27
     8e6:	f0 01       	movw	r30, r0
     8e8:	11 24       	eor	r1, r1
     8ea:	e9 59       	subi	r30, 0x99	; 153
     8ec:	fe 4f       	sbci	r31, 0xFE	; 254
     8ee:	80 81       	ld	r24, Z
     8f0:	82 30       	cpi	r24, 0x02	; 2
     8f2:	40 f0       	brcs	.+16     	; 0x904 <__stack+0x5>
			{
				xSwitchRequired = pdTRUE;
     8f4:	c1 e0       	ldi	r28, 0x01	; 1
     8f6:	06 c0       	rjmp	.+12     	; 0x904 <__stack+0x5>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     8f8:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxPendedTicks>
     8fc:	8f 5f       	subi	r24, 0xFF	; 255
     8fe:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     902:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     904:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xYieldPending>
     908:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     90a:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     90c:	8c 2f       	mov	r24, r28
     90e:	df 91       	pop	r29
     910:	cf 91       	pop	r28
     912:	1f 91       	pop	r17
     914:	0f 91       	pop	r16
     916:	ff 90       	pop	r15
     918:	ef 90       	pop	r14
     91a:	df 90       	pop	r13
     91c:	cf 90       	pop	r12
     91e:	08 95       	ret

00000920 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     920:	ef 92       	push	r14
     922:	ff 92       	push	r15
     924:	0f 93       	push	r16
     926:	1f 93       	push	r17
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     932:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     936:	81 50       	subi	r24, 0x01	; 1
     938:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     93c:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     940:	88 23       	and	r24, r24
     942:	11 f0       	breq	.+4      	; 0x948 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     944:	80 e0       	ldi	r24, 0x00	; 0
     946:	52 c0       	rjmp	.+164    	; 0x9ec <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     948:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     94c:	88 23       	and	r24, r24
     94e:	d1 f3       	breq	.-12     	; 0x944 <xTaskResumeAll+0x24>
     950:	c0 e0       	ldi	r28, 0x00	; 0
     952:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     954:	89 e0       	ldi	r24, 0x09	; 9
     956:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     958:	ee 24       	eor	r14, r14
     95a:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     95c:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <xPendingReadyList>
     960:	88 23       	and	r24, r24
     962:	51 f1       	breq	.+84     	; 0x9b8 <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     964:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <xPendingReadyList+0x5>
     968:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <xPendingReadyList+0x6>
     96c:	c6 81       	ldd	r28, Z+6	; 0x06
     96e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     970:	ce 01       	movw	r24, r28
     972:	0c 96       	adiw	r24, 0x0c	; 12
     974:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     978:	8e 01       	movw	r16, r28
     97a:	0e 5f       	subi	r16, 0xFE	; 254
     97c:	1f 4f       	sbci	r17, 0xFF	; 255
     97e:	c8 01       	movw	r24, r16
     980:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     984:	8e 89       	ldd	r24, Y+22	; 0x16
     986:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     98a:	98 17       	cp	r25, r24
     98c:	10 f4       	brcc	.+4      	; 0x992 <xTaskResumeAll+0x72>
     98e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     992:	f8 9e       	mul	r15, r24
     994:	c0 01       	movw	r24, r0
     996:	11 24       	eor	r1, r1
     998:	b8 01       	movw	r22, r16
     99a:	89 59       	subi	r24, 0x99	; 153
     99c:	9e 4f       	sbci	r25, 0xFE	; 254
     99e:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9a2:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     9a6:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     9aa:	9e 89       	ldd	r25, Y+22	; 0x16
     9ac:	86 89       	ldd	r24, Z+22	; 0x16
     9ae:	98 17       	cp	r25, r24
     9b0:	a8 f2       	brcs	.-86     	; 0x95c <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     9b2:	e0 92 2e 01 	sts	0x012E, r14	; 0x80012e <xYieldPending>
     9b6:	d2 cf       	rjmp	.-92     	; 0x95c <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     9b8:	cd 2b       	or	r28, r29
     9ba:	11 f0       	breq	.+4      	; 0x9c0 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     9bc:	0e 94 09 01 	call	0x212	; 0x212 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     9c0:	c0 91 2f 01 	lds	r28, 0x012F	; 0x80012f <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     9c4:	cc 23       	and	r28, r28
     9c6:	51 f0       	breq	.+20     	; 0x9dc <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     9c8:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     9ca:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <xTaskIncrementTick>
     9ce:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     9d0:	d0 93 2e 01 	sts	0x012E, r29	; 0x80012e <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     9d4:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     9d6:	c9 f7       	brne	.-14     	; 0x9ca <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     9d8:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     9dc:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xYieldPending>
     9e0:	88 23       	and	r24, r24
     9e2:	09 f4       	brne	.+2      	; 0x9e6 <xTaskResumeAll+0xc6>
     9e4:	af cf       	rjmp	.-162    	; 0x944 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     9e6:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     9ea:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     9ec:	0f 90       	pop	r0
     9ee:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	ff 90       	pop	r15
     9fa:	ef 90       	pop	r14
     9fc:	08 95       	ret

000009fe <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     9fe:	0f 93       	push	r16
     a00:	1f 93       	push	r17
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	8c 01       	movw	r16, r24
     a08:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     a0a:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     a0e:	40 91 32 01 	lds	r20, 0x0132	; 0x800132 <xTickCount>
     a12:	50 91 33 01 	lds	r21, 0x0133	; 0x800133 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     a16:	f8 01       	movw	r30, r16
     a18:	20 81       	ld	r18, Z
     a1a:	31 81       	ldd	r19, Z+1	; 0x01
     a1c:	c9 01       	movw	r24, r18
     a1e:	8c 0f       	add	r24, r28
     a20:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     a22:	42 17       	cp	r20, r18
     a24:	53 07       	cpc	r21, r19
     a26:	20 f4       	brcc	.+8      	; 0xa30 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     a28:	82 17       	cp	r24, r18
     a2a:	93 07       	cpc	r25, r19
     a2c:	40 f4       	brcc	.+16     	; 0xa3e <vTaskDelayUntil+0x40>
     a2e:	03 c0       	rjmp	.+6      	; 0xa36 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     a30:	82 17       	cp	r24, r18
     a32:	93 07       	cpc	r25, r19
     a34:	30 f0       	brcs	.+12     	; 0xa42 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     a36:	21 e0       	ldi	r18, 0x01	; 1
     a38:	48 17       	cp	r20, r24
     a3a:	59 07       	cpc	r21, r25
     a3c:	18 f0       	brcs	.+6      	; 0xa44 <vTaskDelayUntil+0x46>
     a3e:	20 e0       	ldi	r18, 0x00	; 0
     a40:	01 c0       	rjmp	.+2      	; 0xa44 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     a42:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     a44:	f8 01       	movw	r30, r16
     a46:	91 83       	std	Z+1, r25	; 0x01
     a48:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     a4a:	22 23       	and	r18, r18
     a4c:	29 f0       	breq	.+10     	; 0xa58 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     a4e:	60 e0       	ldi	r22, 0x00	; 0
     a50:	84 1b       	sub	r24, r20
     a52:	95 0b       	sbc	r25, r21
     a54:	0e 94 24 01 	call	0x248	; 0x248 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a58:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a5c:	81 11       	cpse	r24, r1
     a5e:	02 c0       	rjmp	.+4      	; 0xa64 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a60:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	1f 91       	pop	r17
     a6a:	0f 91       	pop	r16
     a6c:	08 95       	ret

00000a6e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     a74:	89 2b       	or	r24, r25
     a76:	19 f4       	brne	.+6      	; 0xa7e <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     a78:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
     a7c:	0a c0       	rjmp	.+20     	; 0xa92 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     a7e:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     a82:	60 e0       	ldi	r22, 0x00	; 0
     a84:	ce 01       	movw	r24, r28
     a86:	0e 94 24 01 	call	0x248	; 0x248 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a8a:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a8e:	88 23       	and	r24, r24
     a90:	99 f3       	breq	.-26     	; 0xa78 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	08 95       	ret

00000a98 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a98:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     a9c:	88 23       	and	r24, r24
     a9e:	21 f0       	breq	.+8      	; 0xaa8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
     aa6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     aa8:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     aac:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <uxTopReadyPriority>
     ab0:	69 e0       	ldi	r22, 0x09	; 9
     ab2:	48 2f       	mov	r20, r24
     ab4:	50 e0       	ldi	r21, 0x00	; 0
     ab6:	64 9f       	mul	r22, r20
     ab8:	90 01       	movw	r18, r0
     aba:	65 9f       	mul	r22, r21
     abc:	30 0d       	add	r19, r0
     abe:	11 24       	eor	r1, r1
     ac0:	f9 01       	movw	r30, r18
     ac2:	e9 59       	subi	r30, 0x99	; 153
     ac4:	fe 4f       	sbci	r31, 0xFE	; 254
     ac6:	90 81       	ld	r25, Z
     ac8:	91 11       	cpse	r25, r1
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <vTaskSwitchContext+0x38>
     acc:	81 50       	subi	r24, 0x01	; 1
     ace:	f1 cf       	rjmp	.-30     	; 0xab2 <vTaskSwitchContext+0x1a>
     ad0:	a1 81       	ldd	r26, Z+1	; 0x01
     ad2:	b2 81       	ldd	r27, Z+2	; 0x02
     ad4:	12 96       	adiw	r26, 0x02	; 2
     ad6:	0d 90       	ld	r0, X+
     ad8:	bc 91       	ld	r27, X
     ada:	a0 2d       	mov	r26, r0
     adc:	b2 83       	std	Z+2, r27	; 0x02
     ade:	a1 83       	std	Z+1, r26	; 0x01
     ae0:	26 59       	subi	r18, 0x96	; 150
     ae2:	3e 4f       	sbci	r19, 0xFE	; 254
     ae4:	a2 17       	cp	r26, r18
     ae6:	b3 07       	cpc	r27, r19
     ae8:	31 f4       	brne	.+12     	; 0xaf6 <vTaskSwitchContext+0x5e>
     aea:	12 96       	adiw	r26, 0x02	; 2
     aec:	2d 91       	ld	r18, X+
     aee:	3c 91       	ld	r19, X
     af0:	13 97       	sbiw	r26, 0x03	; 3
     af2:	32 83       	std	Z+2, r19	; 0x02
     af4:	21 83       	std	Z+1, r18	; 0x01
     af6:	99 e0       	ldi	r25, 0x09	; 9
     af8:	94 9f       	mul	r25, r20
     afa:	f0 01       	movw	r30, r0
     afc:	95 9f       	mul	r25, r21
     afe:	f0 0d       	add	r31, r0
     b00:	11 24       	eor	r1, r1
     b02:	e9 59       	subi	r30, 0x99	; 153
     b04:	fe 4f       	sbci	r31, 0xFE	; 254
     b06:	01 80       	ldd	r0, Z+1	; 0x01
     b08:	f2 81       	ldd	r31, Z+2	; 0x02
     b0a:	e0 2d       	mov	r30, r0
     b0c:	26 81       	ldd	r18, Z+6	; 0x06
     b0e:	37 81       	ldd	r19, Z+7	; 0x07
     b10:	30 93 26 01 	sts	0x0126, r19	; 0x800126 <pxCurrentTCB+0x1>
     b14:	20 93 25 01 	sts	0x0125, r18	; 0x800125 <pxCurrentTCB>
     b18:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     b1c:	08 95       	ret

00000b1e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     b1e:	0f 93       	push	r16
     b20:	1f 93       	push	r17
     b22:	cf 93       	push	r28
     b24:	df 93       	push	r29
     b26:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     b28:	0f b6       	in	r0, 0x3f	; 63
     b2a:	f8 94       	cli
     b2c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     b2e:	89 2b       	or	r24, r25
     b30:	21 f4       	brne	.+8      	; 0xb3a <vTaskSuspend+0x1c>
     b32:	c0 91 25 01 	lds	r28, 0x0125	; 0x800125 <pxCurrentTCB>
     b36:	d0 91 26 01 	lds	r29, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     b3a:	8e 01       	movw	r16, r28
     b3c:	0e 5f       	subi	r16, 0xFE	; 254
     b3e:	1f 4f       	sbci	r17, 0xFF	; 255
     b40:	c8 01       	movw	r24, r16
     b42:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b46:	8c 89       	ldd	r24, Y+20	; 0x14
     b48:	9d 89       	ldd	r25, Y+21	; 0x15
     b4a:	89 2b       	or	r24, r25
     b4c:	21 f0       	breq	.+8      	; 0xb56 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b4e:	ce 01       	movw	r24, r28
     b50:	0c 96       	adiw	r24, 0x0c	; 12
     b52:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     b56:	b8 01       	movw	r22, r16
     b58:	85 e3       	ldi	r24, 0x35	; 53
     b5a:	91 e0       	ldi	r25, 0x01	; 1
     b5c:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b60:	8f a1       	ldd	r24, Y+39	; 0x27
     b62:	81 30       	cpi	r24, 0x01	; 1
     b64:	09 f4       	brne	.+2      	; 0xb68 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b66:	1f a2       	std	Y+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b68:	0f 90       	pop	r0
     b6a:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b6c:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     b70:	88 23       	and	r24, r24
     b72:	39 f0       	breq	.+14     	; 0xb82 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     b74:	0f b6       	in	r0, 0x3f	; 63
     b76:	f8 94       	cli
     b78:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     b7a:	0e 94 09 01 	call	0x212	; 0x212 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     b82:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     b86:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     b8a:	c8 17       	cp	r28, r24
     b8c:	d9 07       	cpc	r29, r25
     b8e:	c1 f4       	brne	.+48     	; 0xbc0 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b90:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     b94:	88 23       	and	r24, r24
     b96:	19 f0       	breq	.+6      	; 0xb9e <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b98:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
     b9c:	11 c0       	rjmp	.+34     	; 0xbc0 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b9e:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <xSuspendedTaskList>
     ba2:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     ba6:	98 13       	cpse	r25, r24
     ba8:	05 c0       	rjmp	.+10     	; 0xbb4 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     baa:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <pxCurrentTCB+0x1>
     bae:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <pxCurrentTCB>
     bb2:	06 c0       	rjmp	.+12     	; 0xbc0 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	1f 91       	pop	r17
     bba:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     bbc:	0c 94 4c 05 	jmp	0xa98	; 0xa98 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	1f 91       	pop	r17
     bc6:	0f 91       	pop	r16
     bc8:	08 95       	ret

00000bca <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     bd0:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     bd4:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     bd8:	64 5f       	subi	r22, 0xF4	; 244
     bda:	7f 4f       	sbci	r23, 0xFF	; 255
     bdc:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     be0:	61 e0       	ldi	r22, 0x01	; 1
     be2:	ce 01       	movw	r24, r28
}
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     be8:	0c 94 24 01 	jmp	0x248	; 0x248 <prvAddCurrentTaskToDelayedList>

00000bec <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     bf2:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     bf6:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     bfa:	70 68       	ori	r23, 0x80	; 128
     bfc:	75 87       	std	Z+13, r23	; 0x0d
     bfe:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c00:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     c04:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     c08:	64 5f       	subi	r22, 0xF4	; 244
     c0a:	7f 4f       	sbci	r23, 0xFF	; 255
     c0c:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c10:	61 e0       	ldi	r22, 0x01	; 1
     c12:	ce 01       	movw	r24, r28
}
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c18:	0c 94 24 01 	jmp	0x248	; 0x248 <prvAddCurrentTaskToDelayedList>

00000c1c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     c1c:	0f 93       	push	r16
     c1e:	1f 93       	push	r17
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c24:	dc 01       	movw	r26, r24
     c26:	15 96       	adiw	r26, 0x05	; 5
     c28:	ed 91       	ld	r30, X+
     c2a:	fc 91       	ld	r31, X
     c2c:	16 97       	sbiw	r26, 0x06	; 6
     c2e:	c6 81       	ldd	r28, Z+6	; 0x06
     c30:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c32:	8e 01       	movw	r16, r28
     c34:	04 5f       	subi	r16, 0xF4	; 244
     c36:	1f 4f       	sbci	r17, 0xFF	; 255
     c38:	c8 01       	movw	r24, r16
     c3a:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c3e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     c42:	81 11       	cpse	r24, r1
     c44:	14 c0       	rjmp	.+40     	; 0xc6e <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c46:	0a 50       	subi	r16, 0x0A	; 10
     c48:	11 09       	sbc	r17, r1
     c4a:	c8 01       	movw	r24, r16
     c4c:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c50:	8e 89       	ldd	r24, Y+22	; 0x16
     c52:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     c56:	98 17       	cp	r25, r24
     c58:	10 f4       	brcc	.+4      	; 0xc5e <xTaskRemoveFromEventList+0x42>
     c5a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     c5e:	b9 e0       	ldi	r27, 0x09	; 9
     c60:	8b 9f       	mul	r24, r27
     c62:	c0 01       	movw	r24, r0
     c64:	11 24       	eor	r1, r1
     c66:	b8 01       	movw	r22, r16
     c68:	89 59       	subi	r24, 0x99	; 153
     c6a:	9e 4f       	sbci	r25, 0xFE	; 254
     c6c:	03 c0       	rjmp	.+6      	; 0xc74 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c6e:	b8 01       	movw	r22, r16
     c70:	88 e4       	ldi	r24, 0x48	; 72
     c72:	91 e0       	ldi	r25, 0x01	; 1
     c74:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c78:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     c7c:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     c80:	9e 89       	ldd	r25, Y+22	; 0x16
     c82:	86 89       	ldd	r24, Z+22	; 0x16
     c84:	89 17       	cp	r24, r25
     c86:	20 f4       	brcc	.+8      	; 0xc90 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
     c8e:	01 c0       	rjmp	.+2      	; 0xc92 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c90:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	08 95       	ret

00000c9c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c9c:	0f 93       	push	r16
     c9e:	1f 93       	push	r17
     ca0:	cf 93       	push	r28
     ca2:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     ca4:	70 68       	ori	r23, 0x80	; 128
     ca6:	fc 01       	movw	r30, r24
     ca8:	71 83       	std	Z+1, r23	; 0x01
     caa:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     cac:	c6 81       	ldd	r28, Z+6	; 0x06
     cae:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     cb0:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     cb4:	8e 01       	movw	r16, r28
     cb6:	0e 5f       	subi	r16, 0xFE	; 254
     cb8:	1f 4f       	sbci	r17, 0xFF	; 255
     cba:	c8 01       	movw	r24, r16
     cbc:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     cc0:	8e 89       	ldd	r24, Y+22	; 0x16
     cc2:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     cc6:	98 17       	cp	r25, r24
     cc8:	10 f4       	brcc	.+4      	; 0xcce <vTaskRemoveFromUnorderedEventList+0x32>
     cca:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     cce:	f9 e0       	ldi	r31, 0x09	; 9
     cd0:	8f 9f       	mul	r24, r31
     cd2:	c0 01       	movw	r24, r0
     cd4:	11 24       	eor	r1, r1
     cd6:	b8 01       	movw	r22, r16
     cd8:	89 59       	subi	r24, 0x99	; 153
     cda:	9e 4f       	sbci	r25, 0xFE	; 254
     cdc:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     ce0:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     ce4:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     ce8:	9e 89       	ldd	r25, Y+22	; 0x16
     cea:	86 89       	ldd	r24, Z+22	; 0x16
     cec:	89 17       	cp	r24, r25
     cee:	18 f4       	brcc	.+6      	; 0xcf6 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     cf0:	81 e0       	ldi	r24, 0x01	; 1
     cf2:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
	}
}
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	08 95       	ret

00000d00 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     d00:	0f b6       	in	r0, 0x3f	; 63
     d02:	f8 94       	cli
     d04:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     d06:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xNumOfOverflows>
     d0a:	fc 01       	movw	r30, r24
     d0c:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     d0e:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <xTickCount>
     d12:	30 91 33 01 	lds	r19, 0x0133	; 0x800133 <xTickCount+0x1>
     d16:	32 83       	std	Z+2, r19	; 0x02
     d18:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     d1a:	0f 90       	pop	r0
     d1c:	0f be       	out	0x3f, r0	; 63
     d1e:	08 95       	ret

00000d20 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     d20:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xNumOfOverflows>
     d24:	fc 01       	movw	r30, r24
     d26:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     d28:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <xTickCount>
     d2c:	30 91 33 01 	lds	r19, 0x0133	; 0x800133 <xTickCount+0x1>
     d30:	32 83       	std	Z+2, r19	; 0x02
     d32:	21 83       	std	Z+1, r18	; 0x01
     d34:	08 95       	ret

00000d36 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     d3a:	0f b6       	in	r0, 0x3f	; 63
     d3c:	f8 94       	cli
     d3e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     d40:	40 91 32 01 	lds	r20, 0x0132	; 0x800132 <xTickCount>
     d44:	50 91 33 01 	lds	r21, 0x0133	; 0x800133 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     d48:	db 01       	movw	r26, r22
     d4a:	2d 91       	ld	r18, X+
     d4c:	3c 91       	ld	r19, X
     d4e:	2f 3f       	cpi	r18, 0xFF	; 255
     d50:	bf ef       	ldi	r27, 0xFF	; 255
     d52:	3b 07       	cpc	r19, r27
     d54:	d9 f0       	breq	.+54     	; 0xd8c <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d56:	ec 01       	movw	r28, r24
     d58:	e9 81       	ldd	r30, Y+1	; 0x01
     d5a:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d5c:	a0 91 2d 01 	lds	r26, 0x012D	; 0x80012d <xNumOfOverflows>
     d60:	b8 81       	ld	r27, Y
     d62:	ba 17       	cp	r27, r26
     d64:	19 f0       	breq	.+6      	; 0xd6c <xTaskCheckForTimeOut+0x36>
     d66:	4e 17       	cp	r20, r30
     d68:	5f 07       	cpc	r21, r31
     d6a:	90 f4       	brcc	.+36     	; 0xd90 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d6c:	4e 1b       	sub	r20, r30
     d6e:	5f 0b       	sbc	r21, r31
     d70:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     d72:	42 17       	cp	r20, r18
     d74:	53 07       	cpc	r21, r19
     d76:	38 f4       	brcc	.+14     	; 0xd86 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     d78:	24 1b       	sub	r18, r20
     d7a:	35 0b       	sbc	r19, r21
     d7c:	31 83       	std	Z+1, r19	; 0x01
     d7e:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     d80:	0e 94 90 06 	call	0xd20	; 0xd20 <vTaskInternalSetTimeOutState>
     d84:	03 c0       	rjmp	.+6      	; 0xd8c <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     d86:	11 82       	std	Z+1, r1	; 0x01
     d88:	10 82       	st	Z, r1
     d8a:	02 c0       	rjmp	.+4      	; 0xd90 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     d8c:	80 e0       	ldi	r24, 0x00	; 0
     d8e:	01 c0       	rjmp	.+2      	; 0xd92 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d90:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d92:	0f 90       	pop	r0
     d94:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d96:	df 91       	pop	r29
     d98:	cf 91       	pop	r28
     d9a:	08 95       	ret

00000d9c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
     da2:	08 95       	ret

00000da4 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
     da4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     da8:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

		return xReturn;
	}
     dac:	08 95       	ret

00000dae <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
     dae:	0f 93       	push	r16
     db0:	1f 93       	push	r17
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
     db8:	89 2b       	or	r24, r25
     dba:	09 f4       	brne	.+2      	; 0xdbe <xTaskPriorityInherit+0x10>
     dbc:	55 c0       	rjmp	.+170    	; 0xe68 <xTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
     dbe:	86 89       	ldd	r24, Z+22	; 0x16
     dc0:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     dc4:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     dc8:	56 96       	adiw	r26, 0x16	; 22
     dca:	9c 91       	ld	r25, X
     dcc:	89 17       	cp	r24, r25
     dce:	08 f0       	brcs	.+2      	; 0xdd2 <xTaskPriorityInherit+0x24>
     dd0:	41 c0       	rjmp	.+130    	; 0xe54 <xTaskPriorityInherit+0xa6>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
     dd2:	24 85       	ldd	r18, Z+12	; 0x0c
     dd4:	35 85       	ldd	r19, Z+13	; 0x0d
     dd6:	37 fd       	sbrc	r19, 7
     dd8:	0c c0       	rjmp	.+24     	; 0xdf2 <xTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dda:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     dde:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     de2:	56 96       	adiw	r26, 0x16	; 22
     de4:	9c 91       	ld	r25, X
     de6:	24 e0       	ldi	r18, 0x04	; 4
     de8:	30 e0       	ldi	r19, 0x00	; 0
     dea:	29 1b       	sub	r18, r25
     dec:	31 09       	sbc	r19, r1
     dee:	35 87       	std	Z+13, r19	; 0x0d
     df0:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
     df2:	29 e0       	ldi	r18, 0x09	; 9
     df4:	82 9f       	mul	r24, r18
     df6:	c0 01       	movw	r24, r0
     df8:	11 24       	eor	r1, r1
     dfa:	89 59       	subi	r24, 0x99	; 153
     dfc:	9e 4f       	sbci	r25, 0xFE	; 254
     dfe:	22 85       	ldd	r18, Z+10	; 0x0a
     e00:	33 85       	ldd	r19, Z+11	; 0x0b
     e02:	28 17       	cp	r18, r24
     e04:	39 07       	cpc	r19, r25
     e06:	e9 f4       	brne	.+58     	; 0xe42 <xTaskPriorityInherit+0x94>
     e08:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     e0a:	ef 01       	movw	r28, r30
     e0c:	22 96       	adiw	r28, 0x02	; 2
     e0e:	ce 01       	movw	r24, r28
     e10:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
     e14:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     e18:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     e1c:	86 89       	ldd	r24, Z+22	; 0x16
     e1e:	f8 01       	movw	r30, r16
     e20:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
     e22:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     e26:	98 17       	cp	r25, r24
     e28:	10 f4       	brcc	.+4      	; 0xe2e <xTaskPriorityInherit+0x80>
     e2a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     e2e:	f9 e0       	ldi	r31, 0x09	; 9
     e30:	8f 9f       	mul	r24, r31
     e32:	c0 01       	movw	r24, r0
     e34:	11 24       	eor	r1, r1
     e36:	be 01       	movw	r22, r28
     e38:	89 59       	subi	r24, 0x99	; 153
     e3a:	9e 4f       	sbci	r25, 0xFE	; 254
     e3c:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
     e40:	07 c0       	rjmp	.+14     	; 0xe50 <xTaskPriorityInherit+0xa2>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
     e42:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     e46:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     e4a:	56 96       	adiw	r26, 0x16	; 22
     e4c:	8c 91       	ld	r24, X
     e4e:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
     e50:	81 e0       	ldi	r24, 0x01	; 1
     e52:	0b c0       	rjmp	.+22     	; 0xe6a <xTaskPriorityInherit+0xbc>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
     e54:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     e58:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	21 a1       	ldd	r18, Z+33	; 0x21
     e60:	56 96       	adiw	r26, 0x16	; 22
     e62:	9c 91       	ld	r25, X
     e64:	29 17       	cp	r18, r25
     e66:	08 f0       	brcs	.+2      	; 0xe6a <xTaskPriorityInherit+0xbc>
     e68:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	1f 91       	pop	r17
     e70:	0f 91       	pop	r16
     e72:	08 95       	ret

00000e74 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	cf 93       	push	r28
     e7a:	df 93       	push	r29
     e7c:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
     e7e:	89 2b       	or	r24, r25
     e80:	11 f4       	brne	.+4      	; 0xe86 <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
     e82:	80 e0       	ldi	r24, 0x00	; 0
     e84:	2c c0       	rjmp	.+88     	; 0xede <xTaskPriorityDisinherit+0x6a>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
     e86:	82 a1       	ldd	r24, Z+34	; 0x22
     e88:	81 50       	subi	r24, 0x01	; 1
     e8a:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
     e8c:	26 89       	ldd	r18, Z+22	; 0x16
     e8e:	91 a1       	ldd	r25, Z+33	; 0x21
     e90:	29 17       	cp	r18, r25
     e92:	b9 f3       	breq	.-18     	; 0xe82 <xTaskPriorityDisinherit+0xe>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
     e94:	81 11       	cpse	r24, r1
     e96:	f5 cf       	rjmp	.-22     	; 0xe82 <xTaskPriorityDisinherit+0xe>
     e98:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     e9a:	8f 01       	movw	r16, r30
     e9c:	0e 5f       	subi	r16, 0xFE	; 254
     e9e:	1f 4f       	sbci	r17, 0xFF	; 255
     ea0:	c8 01       	movw	r24, r16
     ea2:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
     ea6:	89 a1       	ldd	r24, Y+33	; 0x21
     ea8:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     eaa:	48 2f       	mov	r20, r24
     eac:	50 e0       	ldi	r21, 0x00	; 0
     eae:	24 e0       	ldi	r18, 0x04	; 4
     eb0:	30 e0       	ldi	r19, 0x00	; 0
     eb2:	24 1b       	sub	r18, r20
     eb4:	35 0b       	sbc	r19, r21
     eb6:	3d 87       	std	Y+13, r19	; 0x0d
     eb8:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
     eba:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     ebe:	98 17       	cp	r25, r24
     ec0:	10 f4       	brcc	.+4      	; 0xec6 <xTaskPriorityDisinherit+0x52>
     ec2:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     ec6:	29 e0       	ldi	r18, 0x09	; 9
     ec8:	24 9f       	mul	r18, r20
     eca:	c0 01       	movw	r24, r0
     ecc:	25 9f       	mul	r18, r21
     ece:	90 0d       	add	r25, r0
     ed0:	11 24       	eor	r1, r1
     ed2:	b8 01       	movw	r22, r16
     ed4:	89 59       	subi	r24, 0x99	; 153
     ed6:	9e 4f       	sbci	r25, 0xFE	; 254
     ed8:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
     edc:	81 e0       	ldi	r24, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     ede:	df 91       	pop	r29
     ee0:	cf 91       	pop	r28
     ee2:	1f 91       	pop	r17
     ee4:	0f 91       	pop	r16
     ee6:	08 95       	ret

00000ee8 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
     ee8:	0f 93       	push	r16
     eea:	1f 93       	push	r17
     eec:	cf 93       	push	r28
     eee:	df 93       	push	r29
     ef0:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = pxMutexHolder;
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

		if( pxMutexHolder != NULL )
     ef2:	89 2b       	or	r24, r25
     ef4:	d9 f1       	breq	.+118    	; 0xf6c <vTaskPriorityDisinheritAfterTimeout+0x84>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
     ef6:	91 a1       	ldd	r25, Z+33	; 0x21
     ef8:	96 17       	cp	r25, r22
     efa:	08 f4       	brcc	.+2      	; 0xefe <vTaskPriorityDisinheritAfterTimeout+0x16>
     efc:	96 2f       	mov	r25, r22
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
     efe:	86 89       	ldd	r24, Z+22	; 0x16
     f00:	89 17       	cp	r24, r25
     f02:	a1 f1       	breq	.+104    	; 0xf6c <vTaskPriorityDisinheritAfterTimeout+0x84>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
     f04:	22 a1       	ldd	r18, Z+34	; 0x22
     f06:	21 30       	cpi	r18, 0x01	; 1
     f08:	89 f5       	brne	.+98     	; 0xf6c <vTaskPriorityDisinheritAfterTimeout+0x84>
					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
					pxTCB->uxPriority = uxPriorityToUse;
     f0a:	96 8b       	std	Z+22, r25	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
     f0c:	24 85       	ldd	r18, Z+12	; 0x0c
     f0e:	35 85       	ldd	r19, Z+13	; 0x0d
     f10:	37 fd       	sbrc	r19, 7
     f12:	06 c0       	rjmp	.+12     	; 0xf20 <vTaskPriorityDisinheritAfterTimeout+0x38>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f14:	24 e0       	ldi	r18, 0x04	; 4
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	29 1b       	sub	r18, r25
     f1a:	31 09       	sbc	r19, r1
     f1c:	35 87       	std	Z+13, r19	; 0x0d
     f1e:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
     f20:	29 e0       	ldi	r18, 0x09	; 9
     f22:	82 9f       	mul	r24, r18
     f24:	c0 01       	movw	r24, r0
     f26:	11 24       	eor	r1, r1
     f28:	89 59       	subi	r24, 0x99	; 153
     f2a:	9e 4f       	sbci	r25, 0xFE	; 254
     f2c:	22 85       	ldd	r18, Z+10	; 0x0a
     f2e:	33 85       	ldd	r19, Z+11	; 0x0b
     f30:	28 17       	cp	r18, r24
     f32:	39 07       	cpc	r19, r25
     f34:	d9 f4       	brne	.+54     	; 0xf6c <vTaskPriorityDisinheritAfterTimeout+0x84>
     f36:	ef 01       	movw	r28, r30
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     f38:	8f 01       	movw	r16, r30
     f3a:	0e 5f       	subi	r16, 0xFE	; 254
     f3c:	1f 4f       	sbci	r17, 0xFF	; 255
     f3e:	c8 01       	movw	r24, r16
     f40:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
     f44:	8e 89       	ldd	r24, Y+22	; 0x16
     f46:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     f4a:	98 17       	cp	r25, r24
     f4c:	10 f4       	brcc	.+4      	; 0xf52 <vTaskPriorityDisinheritAfterTimeout+0x6a>
     f4e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     f52:	29 e0       	ldi	r18, 0x09	; 9
     f54:	82 9f       	mul	r24, r18
     f56:	c0 01       	movw	r24, r0
     f58:	11 24       	eor	r1, r1
     f5a:	b8 01       	movw	r22, r16
     f5c:	89 59       	subi	r24, 0x99	; 153
     f5e:	9e 4f       	sbci	r25, 0xFE	; 254
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f60:	df 91       	pop	r29
     f62:	cf 91       	pop	r28
     f64:	1f 91       	pop	r17
     f66:	0f 91       	pop	r16
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
     f68:	0c 94 65 0f 	jmp	0x1eca	; 0x1eca <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f6c:	df 91       	pop	r29
     f6e:	cf 91       	pop	r28
     f70:	1f 91       	pop	r17
     f72:	0f 91       	pop	r16
     f74:	08 95       	ret

00000f76 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     f76:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     f7a:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     f7e:	84 85       	ldd	r24, Z+12	; 0x0c
     f80:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f82:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     f86:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     f8a:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     f8e:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     f92:	56 96       	adiw	r26, 0x16	; 22
     f94:	4c 91       	ld	r20, X
     f96:	24 e0       	ldi	r18, 0x04	; 4
     f98:	30 e0       	ldi	r19, 0x00	; 0
     f9a:	24 1b       	sub	r18, r20
     f9c:	31 09       	sbc	r19, r1
     f9e:	35 87       	std	Z+13, r19	; 0x0d
     fa0:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     fa2:	08 95       	ret

00000fa4 <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
     fa4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     fa8:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fac:	89 2b       	or	r24, r25
     fae:	39 f0       	breq	.+14     	; 0xfbe <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
     fb0:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     fb4:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fb8:	82 a1       	ldd	r24, Z+34	; 0x22
     fba:	8f 5f       	subi	r24, 0xFF	; 255
     fbc:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
     fbe:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     fc2:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
	}
     fc6:	08 95       	ret

00000fc8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     fc8:	0f 93       	push	r16
     fca:	1f 93       	push	r17
     fcc:	18 2f       	mov	r17, r24
     fce:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     fd0:	0f b6       	in	r0, 0x3f	; 63
     fd2:	f8 94       	cli
     fd4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     fd6:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     fda:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fde:	43 a1       	ldd	r20, Z+35	; 0x23
     fe0:	54 a1       	ldd	r21, Z+36	; 0x24
     fe2:	65 a1       	ldd	r22, Z+37	; 0x25
     fe4:	76 a1       	ldd	r23, Z+38	; 0x26
     fe6:	45 2b       	or	r20, r21
     fe8:	46 2b       	or	r20, r22
     fea:	47 2b       	or	r20, r23
     fec:	69 f4       	brne	.+26     	; 0x1008 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     fee:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     ff2:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     ff6:	21 e0       	ldi	r18, 0x01	; 1
     ff8:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
     ffa:	00 97       	sbiw	r24, 0x00	; 0
     ffc:	29 f0       	breq	.+10     	; 0x1008 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ffe:	61 e0       	ldi	r22, 0x01	; 1
    1000:	0e 94 24 01 	call	0x248	; 0x248 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1004:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1008:	0f 90       	pop	r0
    100a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    100c:	0f b6       	in	r0, 0x3f	; 63
    100e:	f8 94       	cli
    1010:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1012:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1016:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    101a:	63 a1       	ldd	r22, Z+35	; 0x23
    101c:	74 a1       	ldd	r23, Z+36	; 0x24
    101e:	85 a1       	ldd	r24, Z+37	; 0x25
    1020:	96 a1       	ldd	r25, Z+38	; 0x26

			if( ulReturn != 0UL )
    1022:	61 15       	cp	r22, r1
    1024:	71 05       	cpc	r23, r1
    1026:	81 05       	cpc	r24, r1
    1028:	91 05       	cpc	r25, r1
    102a:	a9 f0       	breq	.+42     	; 0x1056 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    102c:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1030:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    1034:	11 23       	and	r17, r17
    1036:	29 f0       	breq	.+10     	; 0x1042 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1038:	13 a2       	std	Z+35, r1	; 0x23
    103a:	14 a2       	std	Z+36, r1	; 0x24
    103c:	15 a2       	std	Z+37, r1	; 0x25
    103e:	16 a2       	std	Z+38, r1	; 0x26
    1040:	0a c0       	rjmp	.+20     	; 0x1056 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    1042:	8b 01       	movw	r16, r22
    1044:	9c 01       	movw	r18, r24
    1046:	01 50       	subi	r16, 0x01	; 1
    1048:	11 09       	sbc	r17, r1
    104a:	21 09       	sbc	r18, r1
    104c:	31 09       	sbc	r19, r1
    104e:	03 a3       	std	Z+35, r16	; 0x23
    1050:	14 a3       	std	Z+36, r17	; 0x24
    1052:	25 a3       	std	Z+37, r18	; 0x25
    1054:	36 a3       	std	Z+38, r19	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1056:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    105a:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    105e:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1064:	1f 91       	pop	r17
    1066:	0f 91       	pop	r16
    1068:	08 95       	ret

0000106a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    106a:	4f 92       	push	r4
    106c:	5f 92       	push	r5
    106e:	6f 92       	push	r6
    1070:	7f 92       	push	r7
    1072:	8f 92       	push	r8
    1074:	9f 92       	push	r9
    1076:	af 92       	push	r10
    1078:	bf 92       	push	r11
    107a:	ef 92       	push	r14
    107c:	ff 92       	push	r15
    107e:	0f 93       	push	r16
    1080:	1f 93       	push	r17
    1082:	49 01       	movw	r8, r18
    1084:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1086:	0f b6       	in	r0, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    108c:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1090:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1094:	27 a1       	ldd	r18, Z+39	; 0x27
    1096:	22 30       	cpi	r18, 0x02	; 2
    1098:	39 f1       	breq	.+78     	; 0x10e8 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    109a:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    109e:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    10a2:	23 a1       	ldd	r18, Z+35	; 0x23
    10a4:	34 a1       	ldd	r19, Z+36	; 0x24
    10a6:	45 a1       	ldd	r20, Z+37	; 0x25
    10a8:	56 a1       	ldd	r21, Z+38	; 0x26
    10aa:	2b 01       	movw	r4, r22
    10ac:	3c 01       	movw	r6, r24
    10ae:	40 94       	com	r4
    10b0:	50 94       	com	r5
    10b2:	60 94       	com	r6
    10b4:	70 94       	com	r7
    10b6:	d3 01       	movw	r26, r6
    10b8:	c2 01       	movw	r24, r4
    10ba:	82 23       	and	r24, r18
    10bc:	93 23       	and	r25, r19
    10be:	a4 23       	and	r26, r20
    10c0:	b5 23       	and	r27, r21
    10c2:	83 a3       	std	Z+35, r24	; 0x23
    10c4:	94 a3       	std	Z+36, r25	; 0x24
    10c6:	a5 a3       	std	Z+37, r26	; 0x25
    10c8:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    10ca:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    10ce:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    10d6:	e1 14       	cp	r14, r1
    10d8:	f1 04       	cpc	r15, r1
    10da:	31 f0       	breq	.+12     	; 0x10e8 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    10dc:	61 e0       	ldi	r22, 0x01	; 1
    10de:	c7 01       	movw	r24, r14
    10e0:	0e 94 24 01 	call	0x248	; 0x248 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    10e4:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    10e8:	0f 90       	pop	r0
    10ea:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	f8 94       	cli
    10f0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    10f2:	01 15       	cp	r16, r1
    10f4:	11 05       	cpc	r17, r1
    10f6:	69 f0       	breq	.+26     	; 0x1112 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    10f8:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    10fc:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1100:	83 a1       	ldd	r24, Z+35	; 0x23
    1102:	94 a1       	ldd	r25, Z+36	; 0x24
    1104:	a5 a1       	ldd	r26, Z+37	; 0x25
    1106:	b6 a1       	ldd	r27, Z+38	; 0x26
    1108:	f8 01       	movw	r30, r16
    110a:	80 83       	st	Z, r24
    110c:	91 83       	std	Z+1, r25	; 0x01
    110e:	a2 83       	std	Z+2, r26	; 0x02
    1110:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1112:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1116:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    111a:	87 a1       	ldd	r24, Z+39	; 0x27
    111c:	82 30       	cpi	r24, 0x02	; 2
    111e:	c1 f4       	brne	.+48     	; 0x1150 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1120:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1124:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1128:	43 a1       	ldd	r20, Z+35	; 0x23
    112a:	54 a1       	ldd	r21, Z+36	; 0x24
    112c:	65 a1       	ldd	r22, Z+37	; 0x25
    112e:	76 a1       	ldd	r23, Z+38	; 0x26
    1130:	d5 01       	movw	r26, r10
    1132:	c4 01       	movw	r24, r8
    1134:	80 95       	com	r24
    1136:	90 95       	com	r25
    1138:	a0 95       	com	r26
    113a:	b0 95       	com	r27
    113c:	84 23       	and	r24, r20
    113e:	95 23       	and	r25, r21
    1140:	a6 23       	and	r26, r22
    1142:	b7 23       	and	r27, r23
    1144:	83 a3       	std	Z+35, r24	; 0x23
    1146:	94 a3       	std	Z+36, r25	; 0x24
    1148:	a5 a3       	std	Z+37, r26	; 0x25
    114a:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    114c:	81 e0       	ldi	r24, 0x01	; 1
    114e:	01 c0       	rjmp	.+2      	; 0x1152 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1150:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1152:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1156:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    115a:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1160:	1f 91       	pop	r17
    1162:	0f 91       	pop	r16
    1164:	ff 90       	pop	r15
    1166:	ef 90       	pop	r14
    1168:	bf 90       	pop	r11
    116a:	af 90       	pop	r10
    116c:	9f 90       	pop	r9
    116e:	8f 90       	pop	r8
    1170:	7f 90       	pop	r7
    1172:	6f 90       	pop	r6
    1174:	5f 90       	pop	r5
    1176:	4f 90       	pop	r4
    1178:	08 95       	ret

0000117a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1184:	0f b6       	in	r0, 0x3f	; 63
    1186:	f8 94       	cli
    1188:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    118a:	01 15       	cp	r16, r1
    118c:	11 05       	cpc	r17, r1
    118e:	49 f0       	breq	.+18     	; 0x11a2 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1190:	83 a1       	ldd	r24, Z+35	; 0x23
    1192:	94 a1       	ldd	r25, Z+36	; 0x24
    1194:	a5 a1       	ldd	r26, Z+37	; 0x25
    1196:	b6 a1       	ldd	r27, Z+38	; 0x26
    1198:	e8 01       	movw	r28, r16
    119a:	88 83       	st	Y, r24
    119c:	99 83       	std	Y+1, r25	; 0x01
    119e:	aa 83       	std	Y+2, r26	; 0x02
    11a0:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    11a2:	37 a1       	ldd	r19, Z+39	; 0x27

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    11a4:	82 e0       	ldi	r24, 0x02	; 2
    11a6:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    11a8:	22 30       	cpi	r18, 0x02	; 2
    11aa:	89 f0       	breq	.+34     	; 0x11ce <xTaskGenericNotify+0x54>
    11ac:	58 f4       	brcc	.+22     	; 0x11c4 <xTaskGenericNotify+0x4a>
    11ae:	21 30       	cpi	r18, 0x01	; 1
    11b0:	01 f5       	brne	.+64     	; 0x11f2 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    11b2:	83 a1       	ldd	r24, Z+35	; 0x23
    11b4:	94 a1       	ldd	r25, Z+36	; 0x24
    11b6:	a5 a1       	ldd	r26, Z+37	; 0x25
    11b8:	b6 a1       	ldd	r27, Z+38	; 0x26
    11ba:	48 2b       	or	r20, r24
    11bc:	59 2b       	or	r21, r25
    11be:	6a 2b       	or	r22, r26
    11c0:	7b 2b       	or	r23, r27
    11c2:	13 c0       	rjmp	.+38     	; 0x11ea <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    11c4:	23 30       	cpi	r18, 0x03	; 3
    11c6:	89 f0       	breq	.+34     	; 0x11ea <xTaskGenericNotify+0x70>
    11c8:	24 30       	cpi	r18, 0x04	; 4
    11ca:	69 f0       	breq	.+26     	; 0x11e6 <xTaskGenericNotify+0x6c>
    11cc:	12 c0       	rjmp	.+36     	; 0x11f2 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    11ce:	83 a1       	ldd	r24, Z+35	; 0x23
    11d0:	94 a1       	ldd	r25, Z+36	; 0x24
    11d2:	a5 a1       	ldd	r26, Z+37	; 0x25
    11d4:	b6 a1       	ldd	r27, Z+38	; 0x26
    11d6:	01 96       	adiw	r24, 0x01	; 1
    11d8:	a1 1d       	adc	r26, r1
    11da:	b1 1d       	adc	r27, r1
    11dc:	83 a3       	std	Z+35, r24	; 0x23
    11de:	94 a3       	std	Z+36, r25	; 0x24
    11e0:	a5 a3       	std	Z+37, r26	; 0x25
    11e2:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    11e4:	06 c0       	rjmp	.+12     	; 0x11f2 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    11e6:	32 30       	cpi	r19, 0x02	; 2
    11e8:	49 f1       	breq	.+82     	; 0x123c <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    11ea:	43 a3       	std	Z+35, r20	; 0x23
    11ec:	54 a3       	std	Z+36, r21	; 0x24
    11ee:	65 a3       	std	Z+37, r22	; 0x25
    11f0:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    11f2:	31 30       	cpi	r19, 0x01	; 1
    11f4:	09 f5       	brne	.+66     	; 0x1238 <xTaskGenericNotify+0xbe>
    11f6:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    11f8:	8f 01       	movw	r16, r30
    11fa:	0e 5f       	subi	r16, 0xFE	; 254
    11fc:	1f 4f       	sbci	r17, 0xFF	; 255
    11fe:	c8 01       	movw	r24, r16
    1200:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1204:	8e 89       	ldd	r24, Y+22	; 0x16
    1206:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
    120a:	98 17       	cp	r25, r24
    120c:	10 f4       	brcc	.+4      	; 0x1212 <xTaskGenericNotify+0x98>
    120e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
    1212:	29 e0       	ldi	r18, 0x09	; 9
    1214:	82 9f       	mul	r24, r18
    1216:	c0 01       	movw	r24, r0
    1218:	11 24       	eor	r1, r1
    121a:	b8 01       	movw	r22, r16
    121c:	89 59       	subi	r24, 0x99	; 153
    121e:	9e 4f       	sbci	r25, 0xFE	; 254
    1220:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1224:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1228:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    122c:	9e 89       	ldd	r25, Y+22	; 0x16
    122e:	86 89       	ldd	r24, Z+22	; 0x16
    1230:	89 17       	cp	r24, r25
    1232:	10 f4       	brcc	.+4      	; 0x1238 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    1234:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    1238:	81 e0       	ldi	r24, 0x01	; 1
    123a:	01 c0       	rjmp	.+2      	; 0x123e <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    123c:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    123e:	0f 90       	pop	r0
    1240:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	08 95       	ret

0000124c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    124c:	ef 92       	push	r14
    124e:	ff 92       	push	r15
    1250:	0f 93       	push	r16
    1252:	1f 93       	push	r17
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    125a:	01 15       	cp	r16, r1
    125c:	11 05       	cpc	r17, r1
    125e:	49 f0       	breq	.+18     	; 0x1272 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1260:	83 a1       	ldd	r24, Z+35	; 0x23
    1262:	94 a1       	ldd	r25, Z+36	; 0x24
    1264:	a5 a1       	ldd	r26, Z+37	; 0x25
    1266:	b6 a1       	ldd	r27, Z+38	; 0x26
    1268:	e8 01       	movw	r28, r16
    126a:	88 83       	st	Y, r24
    126c:	99 83       	std	Y+1, r25	; 0x01
    126e:	aa 83       	std	Y+2, r26	; 0x02
    1270:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1272:	37 a1       	ldd	r19, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1274:	82 e0       	ldi	r24, 0x02	; 2
    1276:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    1278:	22 30       	cpi	r18, 0x02	; 2
    127a:	89 f0       	breq	.+34     	; 0x129e <xTaskGenericNotifyFromISR+0x52>
    127c:	58 f4       	brcc	.+22     	; 0x1294 <xTaskGenericNotifyFromISR+0x48>
    127e:	21 30       	cpi	r18, 0x01	; 1
    1280:	01 f5       	brne	.+64     	; 0x12c2 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1282:	83 a1       	ldd	r24, Z+35	; 0x23
    1284:	94 a1       	ldd	r25, Z+36	; 0x24
    1286:	a5 a1       	ldd	r26, Z+37	; 0x25
    1288:	b6 a1       	ldd	r27, Z+38	; 0x26
    128a:	48 2b       	or	r20, r24
    128c:	59 2b       	or	r21, r25
    128e:	6a 2b       	or	r22, r26
    1290:	7b 2b       	or	r23, r27
    1292:	13 c0       	rjmp	.+38     	; 0x12ba <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1294:	23 30       	cpi	r18, 0x03	; 3
    1296:	89 f0       	breq	.+34     	; 0x12ba <xTaskGenericNotifyFromISR+0x6e>
    1298:	24 30       	cpi	r18, 0x04	; 4
    129a:	69 f0       	breq	.+26     	; 0x12b6 <xTaskGenericNotifyFromISR+0x6a>
    129c:	12 c0       	rjmp	.+36     	; 0x12c2 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    129e:	83 a1       	ldd	r24, Z+35	; 0x23
    12a0:	94 a1       	ldd	r25, Z+36	; 0x24
    12a2:	a5 a1       	ldd	r26, Z+37	; 0x25
    12a4:	b6 a1       	ldd	r27, Z+38	; 0x26
    12a6:	01 96       	adiw	r24, 0x01	; 1
    12a8:	a1 1d       	adc	r26, r1
    12aa:	b1 1d       	adc	r27, r1
    12ac:	83 a3       	std	Z+35, r24	; 0x23
    12ae:	94 a3       	std	Z+36, r25	; 0x24
    12b0:	a5 a3       	std	Z+37, r26	; 0x25
    12b2:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    12b4:	06 c0       	rjmp	.+12     	; 0x12c2 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    12b6:	32 30       	cpi	r19, 0x02	; 2
    12b8:	d9 f1       	breq	.+118    	; 0x1330 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    12ba:	43 a3       	std	Z+35, r20	; 0x23
    12bc:	54 a3       	std	Z+36, r21	; 0x24
    12be:	65 a3       	std	Z+37, r22	; 0x25
    12c0:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    12c2:	31 30       	cpi	r19, 0x01	; 1
    12c4:	11 f0       	breq	.+4      	; 0x12ca <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	34 c0       	rjmp	.+104    	; 0x1332 <xTaskGenericNotifyFromISR+0xe6>
    12ca:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    12cc:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
    12d0:	81 11       	cpse	r24, r1
    12d2:	15 c0       	rjmp	.+42     	; 0x12fe <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    12d4:	8f 01       	movw	r16, r30
    12d6:	0e 5f       	subi	r16, 0xFE	; 254
    12d8:	1f 4f       	sbci	r17, 0xFF	; 255
    12da:	c8 01       	movw	r24, r16
    12dc:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    12e0:	8e 89       	ldd	r24, Y+22	; 0x16
    12e2:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
    12e6:	98 17       	cp	r25, r24
    12e8:	10 f4       	brcc	.+4      	; 0x12ee <xTaskGenericNotifyFromISR+0xa2>
    12ea:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
    12ee:	e9 e0       	ldi	r30, 0x09	; 9
    12f0:	8e 9f       	mul	r24, r30
    12f2:	c0 01       	movw	r24, r0
    12f4:	11 24       	eor	r1, r1
    12f6:	b8 01       	movw	r22, r16
    12f8:	89 59       	subi	r24, 0x99	; 153
    12fa:	9e 4f       	sbci	r25, 0xFE	; 254
    12fc:	05 c0       	rjmp	.+10     	; 0x1308 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    12fe:	bf 01       	movw	r22, r30
    1300:	64 5f       	subi	r22, 0xF4	; 244
    1302:	7f 4f       	sbci	r23, 0xFF	; 255
    1304:	88 e4       	ldi	r24, 0x48	; 72
    1306:	91 e0       	ldi	r25, 0x01	; 1
    1308:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    130c:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1310:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1314:	9e 89       	ldd	r25, Y+22	; 0x16
    1316:	86 89       	ldd	r24, Z+22	; 0x16
    1318:	89 17       	cp	r24, r25
    131a:	a8 f6       	brcc	.-86     	; 0x12c6 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    131c:	e1 14       	cp	r14, r1
    131e:	f1 04       	cpc	r15, r1
    1320:	19 f0       	breq	.+6      	; 0x1328 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	e7 01       	movw	r28, r14
    1326:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
    132e:	01 c0       	rjmp	.+2      	; 0x1332 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1330:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	ff 90       	pop	r15
    133c:	ef 90       	pop	r14
    133e:	08 95       	ret

00001340 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1340:	ef 92       	push	r14
    1342:	ff 92       	push	r15
    1344:	0f 93       	push	r16
    1346:	1f 93       	push	r17
    1348:	cf 93       	push	r28
    134a:	df 93       	push	r29
    134c:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    134e:	27 a1       	ldd	r18, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1350:	82 e0       	ldi	r24, 0x02	; 2
    1352:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1354:	83 a1       	ldd	r24, Z+35	; 0x23
    1356:	94 a1       	ldd	r25, Z+36	; 0x24
    1358:	a5 a1       	ldd	r26, Z+37	; 0x25
    135a:	b6 a1       	ldd	r27, Z+38	; 0x26
    135c:	01 96       	adiw	r24, 0x01	; 1
    135e:	a1 1d       	adc	r26, r1
    1360:	b1 1d       	adc	r27, r1
    1362:	83 a3       	std	Z+35, r24	; 0x23
    1364:	94 a3       	std	Z+36, r25	; 0x24
    1366:	a5 a3       	std	Z+37, r26	; 0x25
    1368:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    136a:	21 30       	cpi	r18, 0x01	; 1
    136c:	a1 f5       	brne	.+104    	; 0x13d6 <vTaskNotifyGiveFromISR+0x96>
    136e:	8b 01       	movw	r16, r22
    1370:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1372:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
    1376:	81 11       	cpse	r24, r1
    1378:	16 c0       	rjmp	.+44     	; 0x13a6 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    137a:	7f 01       	movw	r14, r30
    137c:	22 e0       	ldi	r18, 0x02	; 2
    137e:	e2 0e       	add	r14, r18
    1380:	f1 1c       	adc	r15, r1
    1382:	c7 01       	movw	r24, r14
    1384:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1388:	8e 89       	ldd	r24, Y+22	; 0x16
    138a:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
    138e:	98 17       	cp	r25, r24
    1390:	10 f4       	brcc	.+4      	; 0x1396 <vTaskNotifyGiveFromISR+0x56>
    1392:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
    1396:	e9 e0       	ldi	r30, 0x09	; 9
    1398:	8e 9f       	mul	r24, r30
    139a:	c0 01       	movw	r24, r0
    139c:	11 24       	eor	r1, r1
    139e:	b7 01       	movw	r22, r14
    13a0:	89 59       	subi	r24, 0x99	; 153
    13a2:	9e 4f       	sbci	r25, 0xFE	; 254
    13a4:	05 c0       	rjmp	.+10     	; 0x13b0 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    13a6:	bf 01       	movw	r22, r30
    13a8:	64 5f       	subi	r22, 0xF4	; 244
    13aa:	7f 4f       	sbci	r23, 0xFF	; 255
    13ac:	88 e4       	ldi	r24, 0x48	; 72
    13ae:	91 e0       	ldi	r25, 0x01	; 1
    13b0:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    13b4:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    13b8:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    13bc:	9e 89       	ldd	r25, Y+22	; 0x16
    13be:	86 89       	ldd	r24, Z+22	; 0x16
    13c0:	89 17       	cp	r24, r25
    13c2:	48 f4       	brcc	.+18     	; 0x13d6 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    13c4:	01 15       	cp	r16, r1
    13c6:	11 05       	cpc	r17, r1
    13c8:	19 f0       	breq	.+6      	; 0x13d0 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    13ca:	81 e0       	ldi	r24, 0x01	; 1
    13cc:	f8 01       	movw	r30, r16
    13ce:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	1f 91       	pop	r17
    13dc:	0f 91       	pop	r16
    13de:	ff 90       	pop	r15
    13e0:	ef 90       	pop	r14
    13e2:	08 95       	ret

000013e4 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    13e4:	00 97       	sbiw	r24, 0x00	; 0
    13e6:	21 f4       	brne	.+8      	; 0x13f0 <xTaskNotifyStateClear+0xc>
    13e8:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
    13ec:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    13f6:	fc 01       	movw	r30, r24
    13f8:	27 a1       	ldd	r18, Z+39	; 0x27
    13fa:	22 30       	cpi	r18, 0x02	; 2
    13fc:	19 f4       	brne	.+6      	; 0x1404 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    13fe:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	01 c0       	rjmp	.+2      	; 0x1406 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1404:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1406:	0f 90       	pop	r0
    1408:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    140a:	08 95       	ret

0000140c <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    140c:	0f b6       	in	r0, 0x3f	; 63
    140e:	f8 94       	cli
    1410:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1412:	fc 01       	movw	r30, r24
    1414:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1416:	0f 90       	pop	r0
    1418:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	91 11       	cpse	r25, r1
    141e:	80 e0       	ldi	r24, 0x00	; 0
}
    1420:	08 95       	ret

00001422 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1422:	0f 93       	push	r16
    1424:	1f 93       	push	r17
    1426:	cf 93       	push	r28
    1428:	df 93       	push	r29
    142a:	ec 01       	movw	r28, r24
    142c:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    142e:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1430:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1432:	41 11       	cpse	r20, r1
    1434:	0b c0       	rjmp	.+22     	; 0x144c <prvCopyDataToQueue+0x2a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1436:	88 81       	ld	r24, Y
    1438:	99 81       	ldd	r25, Y+1	; 0x01
    143a:	89 2b       	or	r24, r25
    143c:	e9 f5       	brne	.+122    	; 0x14b8 <prvCopyDataToQueue+0x96>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    143e:	8c 81       	ldd	r24, Y+4	; 0x04
    1440:	9d 81       	ldd	r25, Y+5	; 0x05
    1442:	0e 94 3a 07 	call	0xe74	; 0xe74 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1446:	1d 82       	std	Y+5, r1	; 0x05
    1448:	1c 82       	std	Y+4, r1	; 0x04
    144a:	37 c0       	rjmp	.+110    	; 0x14ba <prvCopyDataToQueue+0x98>
    144c:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    144e:	01 11       	cpse	r16, r1
    1450:	15 c0       	rjmp	.+42     	; 0x147c <prvCopyDataToQueue+0x5a>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1452:	8a 81       	ldd	r24, Y+2	; 0x02
    1454:	9b 81       	ldd	r25, Y+3	; 0x03
    1456:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    145a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    145c:	8a 81       	ldd	r24, Y+2	; 0x02
    145e:	9b 81       	ldd	r25, Y+3	; 0x03
    1460:	82 0f       	add	r24, r18
    1462:	91 1d       	adc	r25, r1
    1464:	9b 83       	std	Y+3, r25	; 0x03
    1466:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1468:	2c 81       	ldd	r18, Y+4	; 0x04
    146a:	3d 81       	ldd	r19, Y+5	; 0x05
    146c:	82 17       	cp	r24, r18
    146e:	93 07       	cpc	r25, r19
    1470:	18 f1       	brcs	.+70     	; 0x14b8 <prvCopyDataToQueue+0x96>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1472:	88 81       	ld	r24, Y
    1474:	99 81       	ldd	r25, Y+1	; 0x01
    1476:	9b 83       	std	Y+3, r25	; 0x03
    1478:	8a 83       	std	Y+2, r24	; 0x02
    147a:	1e c0       	rjmp	.+60     	; 0x14b8 <prvCopyDataToQueue+0x96>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    147c:	8e 81       	ldd	r24, Y+6	; 0x06
    147e:	9f 81       	ldd	r25, Y+7	; 0x07
    1480:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1484:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	91 95       	neg	r25
    148a:	81 95       	neg	r24
    148c:	91 09       	sbc	r25, r1
    148e:	2e 81       	ldd	r18, Y+6	; 0x06
    1490:	3f 81       	ldd	r19, Y+7	; 0x07
    1492:	28 0f       	add	r18, r24
    1494:	39 1f       	adc	r19, r25
    1496:	3f 83       	std	Y+7, r19	; 0x07
    1498:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    149a:	48 81       	ld	r20, Y
    149c:	59 81       	ldd	r21, Y+1	; 0x01
    149e:	24 17       	cp	r18, r20
    14a0:	35 07       	cpc	r19, r21
    14a2:	30 f4       	brcc	.+12     	; 0x14b0 <prvCopyDataToQueue+0x8e>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    14a4:	2c 81       	ldd	r18, Y+4	; 0x04
    14a6:	3d 81       	ldd	r19, Y+5	; 0x05
    14a8:	82 0f       	add	r24, r18
    14aa:	93 1f       	adc	r25, r19
    14ac:	9f 83       	std	Y+7, r25	; 0x07
    14ae:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    14b0:	02 30       	cpi	r16, 0x02	; 2
    14b2:	11 f4       	brne	.+4      	; 0x14b8 <prvCopyDataToQueue+0x96>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    14b4:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    14b6:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    14b8:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    14ba:	1f 5f       	subi	r17, 0xFF	; 255
    14bc:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	1f 91       	pop	r17
    14c4:	0f 91       	pop	r16
    14c6:	08 95       	ret

000014c8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    14c8:	fc 01       	movw	r30, r24
    14ca:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    14cc:	44 8d       	ldd	r20, Z+28	; 0x1c
    14ce:	44 23       	and	r20, r20
    14d0:	a1 f0       	breq	.+40     	; 0x14fa <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    14d2:	50 e0       	ldi	r21, 0x00	; 0
    14d4:	26 81       	ldd	r18, Z+6	; 0x06
    14d6:	37 81       	ldd	r19, Z+7	; 0x07
    14d8:	24 0f       	add	r18, r20
    14da:	35 1f       	adc	r19, r21
    14dc:	37 83       	std	Z+7, r19	; 0x07
    14de:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    14e0:	64 81       	ldd	r22, Z+4	; 0x04
    14e2:	75 81       	ldd	r23, Z+5	; 0x05
    14e4:	26 17       	cp	r18, r22
    14e6:	37 07       	cpc	r19, r23
    14e8:	20 f0       	brcs	.+8      	; 0x14f2 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    14ea:	20 81       	ld	r18, Z
    14ec:	31 81       	ldd	r19, Z+1	; 0x01
    14ee:	37 83       	std	Z+7, r19	; 0x07
    14f0:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    14f2:	66 81       	ldd	r22, Z+6	; 0x06
    14f4:	77 81       	ldd	r23, Z+7	; 0x07
    14f6:	0c 94 d4 13 	jmp	0x27a8	; 0x27a8 <memcpy>
    14fa:	08 95       	ret

000014fc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    14fc:	ef 92       	push	r14
    14fe:	ff 92       	push	r15
    1500:	1f 93       	push	r17
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
    1506:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1508:	0f b6       	in	r0, 0x3f	; 63
    150a:	f8 94       	cli
    150c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    150e:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1510:	7c 01       	movw	r14, r24
    1512:	81 e1       	ldi	r24, 0x11	; 17
    1514:	e8 0e       	add	r14, r24
    1516:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1518:	11 16       	cp	r1, r17
    151a:	5c f4       	brge	.+22     	; 0x1532 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    151c:	89 89       	ldd	r24, Y+17	; 0x11
    151e:	88 23       	and	r24, r24
    1520:	41 f0       	breq	.+16     	; 0x1532 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1522:	c7 01       	movw	r24, r14
    1524:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    1528:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    152a:	0e 94 ce 06 	call	0xd9c	; 0xd9c <vTaskMissedYield>
    152e:	11 50       	subi	r17, 0x01	; 1
    1530:	f3 cf       	rjmp	.-26     	; 0x1518 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1532:	8f ef       	ldi	r24, 0xFF	; 255
    1534:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1536:	0f 90       	pop	r0
    1538:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    153a:	0f b6       	in	r0, 0x3f	; 63
    153c:	f8 94       	cli
    153e:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1540:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1542:	7e 01       	movw	r14, r28
    1544:	88 e0       	ldi	r24, 0x08	; 8
    1546:	e8 0e       	add	r14, r24
    1548:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    154a:	11 16       	cp	r1, r17
    154c:	5c f4       	brge	.+22     	; 0x1564 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    154e:	88 85       	ldd	r24, Y+8	; 0x08
    1550:	88 23       	and	r24, r24
    1552:	41 f0       	breq	.+16     	; 0x1564 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1554:	c7 01       	movw	r24, r14
    1556:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    155a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    155c:	0e 94 ce 06 	call	0xd9c	; 0xd9c <vTaskMissedYield>
    1560:	11 50       	subi	r17, 0x01	; 1
    1562:	f3 cf       	rjmp	.-26     	; 0x154a <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1564:	8f ef       	ldi	r24, 0xFF	; 255
    1566:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63
}
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	1f 91       	pop	r17
    1572:	ff 90       	pop	r15
    1574:	ef 90       	pop	r14
    1576:	08 95       	ret

00001578 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    157e:	0f b6       	in	r0, 0x3f	; 63
    1580:	f8 94       	cli
    1582:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1584:	48 81       	ld	r20, Y
    1586:	59 81       	ldd	r21, Y+1	; 0x01
    1588:	8b 8d       	ldd	r24, Y+27	; 0x1b
    158a:	7c 8d       	ldd	r23, Y+28	; 0x1c
    158c:	9a 01       	movw	r18, r20
    158e:	87 9f       	mul	r24, r23
    1590:	20 0d       	add	r18, r0
    1592:	31 1d       	adc	r19, r1
    1594:	11 24       	eor	r1, r1
    1596:	3d 83       	std	Y+5, r19	; 0x05
    1598:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    159a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    159c:	5b 83       	std	Y+3, r21	; 0x03
    159e:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    15a0:	90 e0       	ldi	r25, 0x00	; 0
    15a2:	01 97       	sbiw	r24, 0x01	; 1
    15a4:	78 9f       	mul	r23, r24
    15a6:	90 01       	movw	r18, r0
    15a8:	79 9f       	mul	r23, r25
    15aa:	30 0d       	add	r19, r0
    15ac:	11 24       	eor	r1, r1
    15ae:	ca 01       	movw	r24, r20
    15b0:	82 0f       	add	r24, r18
    15b2:	93 1f       	adc	r25, r19
    15b4:	9f 83       	std	Y+7, r25	; 0x07
    15b6:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    15b8:	8f ef       	ldi	r24, 0xFF	; 255
    15ba:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    15bc:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    15be:	61 11       	cpse	r22, r1
    15c0:	0c c0       	rjmp	.+24     	; 0x15da <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15c2:	88 85       	ldd	r24, Y+8	; 0x08
    15c4:	88 23       	and	r24, r24
    15c6:	89 f0       	breq	.+34     	; 0x15ea <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15c8:	ce 01       	movw	r24, r28
    15ca:	08 96       	adiw	r24, 0x08	; 8
    15cc:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    15d0:	88 23       	and	r24, r24
    15d2:	59 f0       	breq	.+22     	; 0x15ea <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    15d4:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    15d8:	08 c0       	rjmp	.+16     	; 0x15ea <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    15da:	ce 01       	movw	r24, r28
    15dc:	08 96       	adiw	r24, 0x08	; 8
    15de:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    15e2:	ce 01       	movw	r24, r28
    15e4:	41 96       	adiw	r24, 0x11	; 17
    15e6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    15ea:	0f 90       	pop	r0
    15ec:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    15ee:	81 e0       	ldi	r24, 0x01	; 1
    15f0:	df 91       	pop	r29
    15f2:	cf 91       	pop	r28
    15f4:	08 95       	ret

000015f6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    15f6:	0f 93       	push	r16
    15f8:	1f 93       	push	r17
    15fa:	cf 93       	push	r28
    15fc:	df 93       	push	r29
    15fe:	08 2f       	mov	r16, r24
    1600:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1602:	66 23       	and	r22, r22
    1604:	21 f0       	breq	.+8      	; 0x160e <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1606:	86 9f       	mul	r24, r22
    1608:	c0 01       	movw	r24, r0
    160a:	11 24       	eor	r1, r1
    160c:	02 c0       	rjmp	.+4      	; 0x1612 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    160e:	80 e0       	ldi	r24, 0x00	; 0
    1610:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1612:	4f 96       	adiw	r24, 0x1f	; 31
    1614:	0e 94 a8 11 	call	0x2350	; 0x2350 <pvPortMalloc>
    1618:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    161a:	00 97       	sbiw	r24, 0x00	; 0
    161c:	71 f0       	breq	.+28     	; 0x163a <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    161e:	11 11       	cpse	r17, r1
    1620:	03 c0       	rjmp	.+6      	; 0x1628 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1622:	99 83       	std	Y+1, r25	; 0x01
    1624:	88 83       	st	Y, r24
    1626:	03 c0       	rjmp	.+6      	; 0x162e <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1628:	4f 96       	adiw	r24, 0x1f	; 31
    162a:	99 83       	std	Y+1, r25	; 0x01
    162c:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    162e:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1630:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1632:	61 e0       	ldi	r22, 0x01	; 1
    1634:	ce 01       	movw	r24, r28
    1636:	0e 94 bc 0a 	call	0x1578	; 0x1578 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    163a:	ce 01       	movw	r24, r28
    163c:	df 91       	pop	r29
    163e:	cf 91       	pop	r28
    1640:	1f 91       	pop	r17
    1642:	0f 91       	pop	r16
    1644:	08 95       	ret

00001646 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1646:	af 92       	push	r10
    1648:	bf 92       	push	r11
    164a:	cf 92       	push	r12
    164c:	df 92       	push	r13
    164e:	ff 92       	push	r15
    1650:	0f 93       	push	r16
    1652:	1f 93       	push	r17
    1654:	cf 93       	push	r28
    1656:	df 93       	push	r29
    1658:	00 d0       	rcall	.+0      	; 0x165a <xQueueGenericSend+0x14>
    165a:	00 d0       	rcall	.+0      	; 0x165c <xQueueGenericSend+0x16>
    165c:	1f 92       	push	r1
    165e:	cd b7       	in	r28, 0x3d	; 61
    1660:	de b7       	in	r29, 0x3e	; 62
    1662:	8c 01       	movw	r16, r24
    1664:	6b 01       	movw	r12, r22
    1666:	5d 83       	std	Y+5, r21	; 0x05
    1668:	4c 83       	std	Y+4, r20	; 0x04
    166a:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    166c:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    166e:	58 01       	movw	r10, r16
    1670:	98 e0       	ldi	r25, 0x08	; 8
    1672:	a9 0e       	add	r10, r25
    1674:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1676:	0f b6       	in	r0, 0x3f	; 63
    1678:	f8 94       	cli
    167a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    167c:	f8 01       	movw	r30, r16
    167e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1680:	93 8d       	ldd	r25, Z+27	; 0x1b
    1682:	29 17       	cp	r18, r25
    1684:	18 f0       	brcs	.+6      	; 0x168c <xQueueGenericSend+0x46>
    1686:	f2 e0       	ldi	r31, 0x02	; 2
    1688:	ff 12       	cpse	r15, r31
    168a:	14 c0       	rjmp	.+40     	; 0x16b4 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    168c:	4f 2d       	mov	r20, r15
    168e:	b6 01       	movw	r22, r12
    1690:	c8 01       	movw	r24, r16
    1692:	0e 94 11 0a 	call	0x1422	; 0x1422 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1696:	f8 01       	movw	r30, r16
    1698:	91 89       	ldd	r25, Z+17	; 0x11
    169a:	99 23       	and	r25, r25
    169c:	21 f0       	breq	.+8      	; 0x16a6 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    169e:	c8 01       	movw	r24, r16
    16a0:	41 96       	adiw	r24, 0x11	; 17
    16a2:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    16a6:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    16a8:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	50 c0       	rjmp	.+160    	; 0x1754 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16b4:	2c 81       	ldd	r18, Y+4	; 0x04
    16b6:	3d 81       	ldd	r19, Y+5	; 0x05
    16b8:	23 2b       	or	r18, r19
    16ba:	19 f4       	brne	.+6      	; 0x16c2 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	48 c0       	rjmp	.+144    	; 0x1752 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    16c2:	81 11       	cpse	r24, r1
    16c4:	04 c0       	rjmp	.+8      	; 0x16ce <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16c6:	ce 01       	movw	r24, r28
    16c8:	01 96       	adiw	r24, 0x01	; 1
    16ca:	0e 94 90 06 	call	0xd20	; 0xd20 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16ce:	0f 90       	pop	r0
    16d0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16d2:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16d6:	0f b6       	in	r0, 0x3f	; 63
    16d8:	f8 94       	cli
    16da:	0f 92       	push	r0
    16dc:	f8 01       	movw	r30, r16
    16de:	85 8d       	ldd	r24, Z+29	; 0x1d
    16e0:	8f 3f       	cpi	r24, 0xFF	; 255
    16e2:	09 f4       	brne	.+2      	; 0x16e6 <xQueueGenericSend+0xa0>
    16e4:	15 8e       	std	Z+29, r1	; 0x1d
    16e6:	f8 01       	movw	r30, r16
    16e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    16ea:	8f 3f       	cpi	r24, 0xFF	; 255
    16ec:	09 f4       	brne	.+2      	; 0x16f0 <xQueueGenericSend+0xaa>
    16ee:	16 8e       	std	Z+30, r1	; 0x1e
    16f0:	0f 90       	pop	r0
    16f2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16f4:	be 01       	movw	r22, r28
    16f6:	6c 5f       	subi	r22, 0xFC	; 252
    16f8:	7f 4f       	sbci	r23, 0xFF	; 255
    16fa:	ce 01       	movw	r24, r28
    16fc:	01 96       	adiw	r24, 0x01	; 1
    16fe:	0e 94 9b 06 	call	0xd36	; 0xd36 <xTaskCheckForTimeOut>
    1702:	81 11       	cpse	r24, r1
    1704:	21 c0       	rjmp	.+66     	; 0x1748 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1706:	0f b6       	in	r0, 0x3f	; 63
    1708:	f8 94       	cli
    170a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    170c:	f8 01       	movw	r30, r16
    170e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1710:	0f 90       	pop	r0
    1712:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1714:	83 8d       	ldd	r24, Z+27	; 0x1b
    1716:	98 13       	cpse	r25, r24
    1718:	11 c0       	rjmp	.+34     	; 0x173c <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    171a:	6c 81       	ldd	r22, Y+4	; 0x04
    171c:	7d 81       	ldd	r23, Y+5	; 0x05
    171e:	c5 01       	movw	r24, r10
    1720:	0e 94 e5 05 	call	0xbca	; 0xbca <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1724:	c8 01       	movw	r24, r16
    1726:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    172a:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    172e:	88 23       	and	r24, r24
    1730:	11 f0       	breq	.+4      	; 0x1736 <xQueueGenericSend+0xf0>
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	a0 cf       	rjmp	.-192    	; 0x1676 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1736:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    173a:	fb cf       	rjmp	.-10     	; 0x1732 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    173c:	c8 01       	movw	r24, r16
    173e:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1742:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1746:	f5 cf       	rjmp	.-22     	; 0x1732 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1748:	c8 01       	movw	r24, r16
    174a:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    174e:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1752:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1754:	0f 90       	pop	r0
    1756:	0f 90       	pop	r0
    1758:	0f 90       	pop	r0
    175a:	0f 90       	pop	r0
    175c:	0f 90       	pop	r0
    175e:	df 91       	pop	r29
    1760:	cf 91       	pop	r28
    1762:	1f 91       	pop	r17
    1764:	0f 91       	pop	r16
    1766:	ff 90       	pop	r15
    1768:	df 90       	pop	r13
    176a:	cf 90       	pop	r12
    176c:	bf 90       	pop	r11
    176e:	af 90       	pop	r10
    1770:	08 95       	ret

00001772 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1776:	48 2f       	mov	r20, r24
    1778:	60 e0       	ldi	r22, 0x00	; 0
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <xQueueGenericCreate>
    1780:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    1782:	00 97       	sbiw	r24, 0x00	; 0
    1784:	61 f0       	breq	.+24     	; 0x179e <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    1786:	1d 82       	std	Y+5, r1	; 0x05
    1788:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    178a:	19 82       	std	Y+1, r1	; 0x01
    178c:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    178e:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	40 e0       	ldi	r20, 0x00	; 0
    1794:	50 e0       	ldi	r21, 0x00	; 0
    1796:	60 e0       	ldi	r22, 0x00	; 0
    1798:	70 e0       	ldi	r23, 0x00	; 0
    179a:	0e 94 23 0b 	call	0x1646	; 0x1646 <xQueueGenericSend>

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );

		return xNewQueue;
	}
    179e:	ce 01       	movw	r24, r28
    17a0:	df 91       	pop	r29
    17a2:	cf 91       	pop	r28
    17a4:	08 95       	ret

000017a6 <xQueueGenericSendFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    17a6:	ef 92       	push	r14
    17a8:	ff 92       	push	r15
    17aa:	1f 93       	push	r17
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
    17b0:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    17b2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    17b4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    17b6:	98 17       	cp	r25, r24
    17b8:	10 f0       	brcs	.+4      	; 0x17be <xQueueGenericSendFromISR+0x18>
    17ba:	22 30       	cpi	r18, 0x02	; 2
    17bc:	e1 f4       	brne	.+56     	; 0x17f6 <xQueueGenericSendFromISR+0x50>
    17be:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    17c0:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17c2:	42 2f       	mov	r20, r18
    17c4:	ce 01       	movw	r24, r28
    17c6:	0e 94 11 0a 	call	0x1422	; 0x1422 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    17ca:	1f 3f       	cpi	r17, 0xFF	; 255
    17cc:	81 f4       	brne	.+32     	; 0x17ee <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ce:	89 89       	ldd	r24, Y+17	; 0x11
    17d0:	88 23       	and	r24, r24
    17d2:	79 f0       	breq	.+30     	; 0x17f2 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17d4:	ce 01       	movw	r24, r28
    17d6:	41 96       	adiw	r24, 0x11	; 17
    17d8:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    17dc:	88 23       	and	r24, r24
    17de:	49 f0       	breq	.+18     	; 0x17f2 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    17e0:	e1 14       	cp	r14, r1
    17e2:	f1 04       	cpc	r15, r1
    17e4:	31 f0       	breq	.+12     	; 0x17f2 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	f7 01       	movw	r30, r14
    17ea:	80 83       	st	Z, r24
    17ec:	05 c0       	rjmp	.+10     	; 0x17f8 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    17ee:	1f 5f       	subi	r17, 0xFF	; 255
    17f0:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	01 c0       	rjmp	.+2      	; 0x17f8 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17f6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17f8:	df 91       	pop	r29
    17fa:	cf 91       	pop	r28
    17fc:	1f 91       	pop	r17
    17fe:	ff 90       	pop	r15
    1800:	ef 90       	pop	r14
    1802:	08 95       	ret

00001804 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1804:	cf 93       	push	r28
    1806:	df 93       	push	r29
    1808:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    180a:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    180c:	83 8d       	ldd	r24, Z+27	; 0x1b
    180e:	98 17       	cp	r25, r24
    1810:	c0 f4       	brcc	.+48     	; 0x1842 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1812:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1814:	9f 5f       	subi	r25, 0xFF	; 255
    1816:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1818:	8f 3f       	cpi	r24, 0xFF	; 255
    181a:	79 f4       	brne	.+30     	; 0x183a <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    181c:	81 89       	ldd	r24, Z+17	; 0x11
    181e:	88 23       	and	r24, r24
    1820:	71 f0       	breq	.+28     	; 0x183e <xQueueGiveFromISR+0x3a>
    1822:	eb 01       	movw	r28, r22
    1824:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1826:	41 96       	adiw	r24, 0x11	; 17
    1828:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    182c:	88 23       	and	r24, r24
    182e:	39 f0       	breq	.+14     	; 0x183e <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1830:	20 97       	sbiw	r28, 0x00	; 0
    1832:	29 f0       	breq	.+10     	; 0x183e <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1834:	81 e0       	ldi	r24, 0x01	; 1
    1836:	88 83       	st	Y, r24
    1838:	05 c0       	rjmp	.+10     	; 0x1844 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    183a:	8f 5f       	subi	r24, 0xFF	; 255
    183c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	01 c0       	rjmp	.+2      	; 0x1844 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1842:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	08 95       	ret

0000184a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    184a:	af 92       	push	r10
    184c:	bf 92       	push	r11
    184e:	cf 92       	push	r12
    1850:	df 92       	push	r13
    1852:	ff 92       	push	r15
    1854:	0f 93       	push	r16
    1856:	1f 93       	push	r17
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	00 d0       	rcall	.+0      	; 0x185e <xQueueReceive+0x14>
    185e:	00 d0       	rcall	.+0      	; 0x1860 <xQueueReceive+0x16>
    1860:	1f 92       	push	r1
    1862:	cd b7       	in	r28, 0x3d	; 61
    1864:	de b7       	in	r29, 0x3e	; 62
    1866:	8c 01       	movw	r16, r24
    1868:	6b 01       	movw	r12, r22
    186a:	5d 83       	std	Y+5, r21	; 0x05
    186c:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    186e:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1870:	58 01       	movw	r10, r16
    1872:	91 e1       	ldi	r25, 0x11	; 17
    1874:	a9 0e       	add	r10, r25
    1876:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    187e:	f8 01       	movw	r30, r16
    1880:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1882:	ff 20       	and	r15, r15
    1884:	a9 f0       	breq	.+42     	; 0x18b0 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1886:	b6 01       	movw	r22, r12
    1888:	c8 01       	movw	r24, r16
    188a:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    188e:	fa 94       	dec	r15
    1890:	f8 01       	movw	r30, r16
    1892:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1894:	80 85       	ldd	r24, Z+8	; 0x08
    1896:	88 23       	and	r24, r24
    1898:	39 f0       	breq	.+14     	; 0x18a8 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    189a:	c8 01       	movw	r24, r16
    189c:	08 96       	adiw	r24, 0x08	; 8
    189e:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    18a2:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    18a4:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    18a8:	0f 90       	pop	r0
    18aa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18ac:	81 e0       	ldi	r24, 0x01	; 1
    18ae:	50 c0       	rjmp	.+160    	; 0x1950 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    18b0:	2c 81       	ldd	r18, Y+4	; 0x04
    18b2:	3d 81       	ldd	r19, Y+5	; 0x05
    18b4:	23 2b       	or	r18, r19
    18b6:	19 f4       	brne	.+6      	; 0x18be <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18b8:	0f 90       	pop	r0
    18ba:	0f be       	out	0x3f, r0	; 63
    18bc:	48 c0       	rjmp	.+144    	; 0x194e <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    18be:	81 11       	cpse	r24, r1
    18c0:	04 c0       	rjmp	.+8      	; 0x18ca <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    18c2:	ce 01       	movw	r24, r28
    18c4:	01 96       	adiw	r24, 0x01	; 1
    18c6:	0e 94 90 06 	call	0xd20	; 0xd20 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18ca:	0f 90       	pop	r0
    18cc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18ce:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18d2:	0f b6       	in	r0, 0x3f	; 63
    18d4:	f8 94       	cli
    18d6:	0f 92       	push	r0
    18d8:	f8 01       	movw	r30, r16
    18da:	85 8d       	ldd	r24, Z+29	; 0x1d
    18dc:	8f 3f       	cpi	r24, 0xFF	; 255
    18de:	09 f4       	brne	.+2      	; 0x18e2 <xQueueReceive+0x98>
    18e0:	15 8e       	std	Z+29, r1	; 0x1d
    18e2:	f8 01       	movw	r30, r16
    18e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    18e6:	8f 3f       	cpi	r24, 0xFF	; 255
    18e8:	09 f4       	brne	.+2      	; 0x18ec <xQueueReceive+0xa2>
    18ea:	16 8e       	std	Z+30, r1	; 0x1e
    18ec:	0f 90       	pop	r0
    18ee:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18f0:	be 01       	movw	r22, r28
    18f2:	6c 5f       	subi	r22, 0xFC	; 252
    18f4:	7f 4f       	sbci	r23, 0xFF	; 255
    18f6:	ce 01       	movw	r24, r28
    18f8:	01 96       	adiw	r24, 0x01	; 1
    18fa:	0e 94 9b 06 	call	0xd36	; 0xd36 <xTaskCheckForTimeOut>
    18fe:	81 11       	cpse	r24, r1
    1900:	1c c0       	rjmp	.+56     	; 0x193a <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1902:	c8 01       	movw	r24, r16
    1904:	0e 94 06 0a 	call	0x140c	; 0x140c <prvIsQueueEmpty>
    1908:	88 23       	and	r24, r24
    190a:	89 f0       	breq	.+34     	; 0x192e <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    190c:	6c 81       	ldd	r22, Y+4	; 0x04
    190e:	7d 81       	ldd	r23, Y+5	; 0x05
    1910:	c5 01       	movw	r24, r10
    1912:	0e 94 e5 05 	call	0xbca	; 0xbca <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1916:	c8 01       	movw	r24, r16
    1918:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    191c:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1920:	88 23       	and	r24, r24
    1922:	11 f0       	breq	.+4      	; 0x1928 <xQueueReceive+0xde>
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	a8 cf       	rjmp	.-176    	; 0x1878 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1928:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    192c:	fb cf       	rjmp	.-10     	; 0x1924 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    192e:	c8 01       	movw	r24, r16
    1930:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1934:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1938:	f5 cf       	rjmp	.-22     	; 0x1924 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    193a:	c8 01       	movw	r24, r16
    193c:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1940:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1944:	c8 01       	movw	r24, r16
    1946:	0e 94 06 0a 	call	0x140c	; 0x140c <prvIsQueueEmpty>
    194a:	88 23       	and	r24, r24
    194c:	59 f3       	breq	.-42     	; 0x1924 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    194e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1950:	0f 90       	pop	r0
    1952:	0f 90       	pop	r0
    1954:	0f 90       	pop	r0
    1956:	0f 90       	pop	r0
    1958:	0f 90       	pop	r0
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	1f 91       	pop	r17
    1960:	0f 91       	pop	r16
    1962:	ff 90       	pop	r15
    1964:	df 90       	pop	r13
    1966:	cf 90       	pop	r12
    1968:	bf 90       	pop	r11
    196a:	af 90       	pop	r10
    196c:	08 95       	ret

0000196e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    196e:	cf 92       	push	r12
    1970:	df 92       	push	r13
    1972:	ff 92       	push	r15
    1974:	0f 93       	push	r16
    1976:	1f 93       	push	r17
    1978:	cf 93       	push	r28
    197a:	df 93       	push	r29
    197c:	00 d0       	rcall	.+0      	; 0x197e <xQueueSemaphoreTake+0x10>
    197e:	00 d0       	rcall	.+0      	; 0x1980 <xQueueSemaphoreTake+0x12>
    1980:	1f 92       	push	r1
    1982:	cd b7       	in	r28, 0x3d	; 61
    1984:	de b7       	in	r29, 0x3e	; 62
    1986:	8c 01       	movw	r16, r24
    1988:	7d 83       	std	Y+5, r23	; 0x05
    198a:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    198c:	f1 2c       	mov	r15, r1
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
BaseType_t xEntryTimeSet = pdFALSE;
    198e:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1990:	68 01       	movw	r12, r16
    1992:	81 e1       	ldi	r24, 0x11	; 17
    1994:	c8 0e       	add	r12, r24
    1996:	d1 1c       	adc	r13, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1998:	0f b6       	in	r0, 0x3f	; 63
    199a:	f8 94       	cli
    199c:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    199e:	d8 01       	movw	r26, r16
    19a0:	5a 96       	adiw	r26, 0x1a	; 26
    19a2:	8c 91       	ld	r24, X
    19a4:	5a 97       	sbiw	r26, 0x1a	; 26

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    19a6:	88 23       	and	r24, r24
    19a8:	e9 f0       	breq	.+58     	; 0x19e4 <xQueueSemaphoreTake+0x76>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    19aa:	81 50       	subi	r24, 0x01	; 1
    19ac:	5a 96       	adiw	r26, 0x1a	; 26
    19ae:	8c 93       	st	X, r24
    19b0:	5a 97       	sbiw	r26, 0x1a	; 26

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    19b2:	8d 91       	ld	r24, X+
    19b4:	9c 91       	ld	r25, X
    19b6:	89 2b       	or	r24, r25
    19b8:	29 f4       	brne	.+10     	; 0x19c4 <xQueueSemaphoreTake+0x56>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    19ba:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <pvTaskIncrementMutexHeldCount>
    19be:	f8 01       	movw	r30, r16
    19c0:	95 83       	std	Z+5, r25	; 0x05
    19c2:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19c4:	d8 01       	movw	r26, r16
    19c6:	18 96       	adiw	r26, 0x08	; 8
    19c8:	8c 91       	ld	r24, X
    19ca:	88 23       	and	r24, r24
    19cc:	39 f0       	breq	.+14     	; 0x19dc <xQueueSemaphoreTake+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19ce:	c8 01       	movw	r24, r16
    19d0:	08 96       	adiw	r24, 0x08	; 8
    19d2:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    19d6:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    19d8:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    19dc:	0f 90       	pop	r0
    19de:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	7a c0       	rjmp	.+244    	; 0x1ad8 <xQueueSemaphoreTake+0x16a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    19e4:	2c 81       	ldd	r18, Y+4	; 0x04
    19e6:	3d 81       	ldd	r19, Y+5	; 0x05
    19e8:	23 2b       	or	r18, r19
    19ea:	09 f4       	brne	.+2      	; 0x19ee <xQueueSemaphoreTake+0x80>
    19ec:	72 c0       	rjmp	.+228    	; 0x1ad2 <xQueueSemaphoreTake+0x164>
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    19ee:	91 11       	cpse	r25, r1
    19f0:	04 c0       	rjmp	.+8      	; 0x19fa <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    19f2:	ce 01       	movw	r24, r28
    19f4:	01 96       	adiw	r24, 0x01	; 1
    19f6:	0e 94 90 06 	call	0xd20	; 0xd20 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    19fa:	0f 90       	pop	r0
    19fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    19fe:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a02:	0f b6       	in	r0, 0x3f	; 63
    1a04:	f8 94       	cli
    1a06:	0f 92       	push	r0
    1a08:	f8 01       	movw	r30, r16
    1a0a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a0c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a0e:	09 f4       	brne	.+2      	; 0x1a12 <xQueueSemaphoreTake+0xa4>
    1a10:	15 8e       	std	Z+29, r1	; 0x1d
    1a12:	d8 01       	movw	r26, r16
    1a14:	5e 96       	adiw	r26, 0x1e	; 30
    1a16:	8c 91       	ld	r24, X
    1a18:	5e 97       	sbiw	r26, 0x1e	; 30
    1a1a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a1c:	11 f4       	brne	.+4      	; 0x1a22 <xQueueSemaphoreTake+0xb4>
    1a1e:	5e 96       	adiw	r26, 0x1e	; 30
    1a20:	1c 92       	st	X, r1
    1a22:	0f 90       	pop	r0
    1a24:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a26:	be 01       	movw	r22, r28
    1a28:	6c 5f       	subi	r22, 0xFC	; 252
    1a2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a2c:	ce 01       	movw	r24, r28
    1a2e:	01 96       	adiw	r24, 0x01	; 1
    1a30:	0e 94 9b 06 	call	0xd36	; 0xd36 <xTaskCheckForTimeOut>
    1a34:	81 11       	cpse	r24, r1
    1a36:	2b c0       	rjmp	.+86     	; 0x1a8e <xQueueSemaphoreTake+0x120>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a38:	c8 01       	movw	r24, r16
    1a3a:	0e 94 06 0a 	call	0x140c	; 0x140c <prvIsQueueEmpty>
    1a3e:	88 23       	and	r24, r24
    1a40:	01 f1       	breq	.+64     	; 0x1a82 <xQueueSemaphoreTake+0x114>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a42:	f8 01       	movw	r30, r16
    1a44:	80 81       	ld	r24, Z
    1a46:	91 81       	ldd	r25, Z+1	; 0x01
    1a48:	89 2b       	or	r24, r25
    1a4a:	51 f4       	brne	.+20     	; 0x1a60 <xQueueSemaphoreTake+0xf2>
					{
						taskENTER_CRITICAL();
    1a4c:	0f b6       	in	r0, 0x3f	; 63
    1a4e:	f8 94       	cli
    1a50:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    1a52:	84 81       	ldd	r24, Z+4	; 0x04
    1a54:	95 81       	ldd	r25, Z+5	; 0x05
    1a56:	0e 94 d7 06 	call	0xdae	; 0xdae <xTaskPriorityInherit>
    1a5a:	f8 2e       	mov	r15, r24
						}
						taskEXIT_CRITICAL();
    1a5c:	0f 90       	pop	r0
    1a5e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a60:	6c 81       	ldd	r22, Y+4	; 0x04
    1a62:	7d 81       	ldd	r23, Y+5	; 0x05
    1a64:	c6 01       	movw	r24, r12
    1a66:	0e 94 e5 05 	call	0xbca	; 0xbca <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1a6a:	c8 01       	movw	r24, r16
    1a6c:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1a70:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1a74:	88 23       	and	r24, r24
    1a76:	11 f0       	breq	.+4      	; 0x1a7c <xQueueSemaphoreTake+0x10e>
    1a78:	91 e0       	ldi	r25, 0x01	; 1
    1a7a:	8e cf       	rjmp	.-228    	; 0x1998 <xQueueSemaphoreTake+0x2a>
				{
					portYIELD_WITHIN_API();
    1a7c:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    1a80:	fb cf       	rjmp	.-10     	; 0x1a78 <xQueueSemaphoreTake+0x10a>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1a82:	c8 01       	movw	r24, r16
    1a84:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a88:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1a8c:	f5 cf       	rjmp	.-22     	; 0x1a78 <xQueueSemaphoreTake+0x10a>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1a8e:	c8 01       	movw	r24, r16
    1a90:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a94:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a98:	c8 01       	movw	r24, r16
    1a9a:	0e 94 06 0a 	call	0x140c	; 0x140c <prvIsQueueEmpty>
    1a9e:	88 23       	and	r24, r24
    1aa0:	59 f3       	breq	.-42     	; 0x1a78 <xQueueSemaphoreTake+0x10a>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    1aa2:	ff 20       	and	r15, r15
    1aa4:	c1 f0       	breq	.+48     	; 0x1ad6 <xQueueSemaphoreTake+0x168>
					{
						taskENTER_CRITICAL();
    1aa6:	0f b6       	in	r0, 0x3f	; 63
    1aa8:	f8 94       	cli
    1aaa:	0f 92       	push	r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    1aac:	f8 01       	movw	r30, r16
    1aae:	81 89       	ldd	r24, Z+17	; 0x11
    1ab0:	88 23       	and	r24, r24
    1ab2:	39 f0       	breq	.+14     	; 0x1ac2 <xQueueSemaphoreTake+0x154>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    1ab4:	06 88       	ldd	r0, Z+22	; 0x16
    1ab6:	f7 89       	ldd	r31, Z+23	; 0x17
    1ab8:	e0 2d       	mov	r30, r0
    1aba:	80 81       	ld	r24, Z
    1abc:	64 e0       	ldi	r22, 0x04	; 4
    1abe:	68 1b       	sub	r22, r24
    1ac0:	01 c0       	rjmp	.+2      	; 0x1ac4 <xQueueSemaphoreTake+0x156>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1ac2:	60 e0       	ldi	r22, 0x00	; 0
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    1ac4:	d8 01       	movw	r26, r16
    1ac6:	14 96       	adiw	r26, 0x04	; 4
    1ac8:	8d 91       	ld	r24, X+
    1aca:	9c 91       	ld	r25, X
    1acc:	15 97       	sbiw	r26, 0x05	; 5
    1ace:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    1ad2:	0f 90       	pop	r0
    1ad4:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ad6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1ad8:	0f 90       	pop	r0
    1ada:	0f 90       	pop	r0
    1adc:	0f 90       	pop	r0
    1ade:	0f 90       	pop	r0
    1ae0:	0f 90       	pop	r0
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	1f 91       	pop	r17
    1ae8:	0f 91       	pop	r16
    1aea:	ff 90       	pop	r15
    1aec:	df 90       	pop	r13
    1aee:	cf 90       	pop	r12
    1af0:	08 95       	ret

00001af2 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1af2:	cf 92       	push	r12
    1af4:	df 92       	push	r13
    1af6:	ef 92       	push	r14
    1af8:	ff 92       	push	r15
    1afa:	0f 93       	push	r16
    1afc:	1f 93       	push	r17
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	00 d0       	rcall	.+0      	; 0x1b04 <xQueuePeek+0x12>
    1b04:	00 d0       	rcall	.+0      	; 0x1b06 <xQueuePeek+0x14>
    1b06:	1f 92       	push	r1
    1b08:	cd b7       	in	r28, 0x3d	; 61
    1b0a:	de b7       	in	r29, 0x3e	; 62
    1b0c:	8c 01       	movw	r16, r24
    1b0e:	7b 01       	movw	r14, r22
    1b10:	5d 83       	std	Y+5, r21	; 0x05
    1b12:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1b14:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b16:	68 01       	movw	r12, r16
    1b18:	91 e1       	ldi	r25, 0x11	; 17
    1b1a:	c9 0e       	add	r12, r25
    1b1c:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b1e:	0f b6       	in	r0, 0x3f	; 63
    1b20:	f8 94       	cli
    1b22:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b24:	f8 01       	movw	r30, r16
    1b26:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b28:	99 23       	and	r25, r25
    1b2a:	b9 f0       	breq	.+46     	; 0x1b5a <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1b2c:	c6 80       	ldd	r12, Z+6	; 0x06
    1b2e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b30:	b7 01       	movw	r22, r14
    1b32:	c8 01       	movw	r24, r16
    1b34:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1b38:	f8 01       	movw	r30, r16
    1b3a:	d7 82       	std	Z+7, r13	; 0x07
    1b3c:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b3e:	81 89       	ldd	r24, Z+17	; 0x11
    1b40:	88 23       	and	r24, r24
    1b42:	39 f0       	breq	.+14     	; 0x1b52 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b44:	c8 01       	movw	r24, r16
    1b46:	41 96       	adiw	r24, 0x11	; 17
    1b48:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    1b4c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1b4e:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1b52:	0f 90       	pop	r0
    1b54:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	50 c0       	rjmp	.+160    	; 0x1bfa <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b5a:	2c 81       	ldd	r18, Y+4	; 0x04
    1b5c:	3d 81       	ldd	r19, Y+5	; 0x05
    1b5e:	23 2b       	or	r18, r19
    1b60:	19 f4       	brne	.+6      	; 0x1b68 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b62:	0f 90       	pop	r0
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	48 c0       	rjmp	.+144    	; 0x1bf8 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1b68:	81 11       	cpse	r24, r1
    1b6a:	04 c0       	rjmp	.+8      	; 0x1b74 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1b6c:	ce 01       	movw	r24, r28
    1b6e:	01 96       	adiw	r24, 0x01	; 1
    1b70:	0e 94 90 06 	call	0xd20	; 0xd20 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b74:	0f 90       	pop	r0
    1b76:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b78:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b7c:	0f b6       	in	r0, 0x3f	; 63
    1b7e:	f8 94       	cli
    1b80:	0f 92       	push	r0
    1b82:	f8 01       	movw	r30, r16
    1b84:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b86:	8f 3f       	cpi	r24, 0xFF	; 255
    1b88:	09 f4       	brne	.+2      	; 0x1b8c <xQueuePeek+0x9a>
    1b8a:	15 8e       	std	Z+29, r1	; 0x1d
    1b8c:	f8 01       	movw	r30, r16
    1b8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b90:	8f 3f       	cpi	r24, 0xFF	; 255
    1b92:	09 f4       	brne	.+2      	; 0x1b96 <xQueuePeek+0xa4>
    1b94:	16 8e       	std	Z+30, r1	; 0x1e
    1b96:	0f 90       	pop	r0
    1b98:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b9a:	be 01       	movw	r22, r28
    1b9c:	6c 5f       	subi	r22, 0xFC	; 252
    1b9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba0:	ce 01       	movw	r24, r28
    1ba2:	01 96       	adiw	r24, 0x01	; 1
    1ba4:	0e 94 9b 06 	call	0xd36	; 0xd36 <xTaskCheckForTimeOut>
    1ba8:	81 11       	cpse	r24, r1
    1baa:	1c c0       	rjmp	.+56     	; 0x1be4 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bac:	c8 01       	movw	r24, r16
    1bae:	0e 94 06 0a 	call	0x140c	; 0x140c <prvIsQueueEmpty>
    1bb2:	88 23       	and	r24, r24
    1bb4:	89 f0       	breq	.+34     	; 0x1bd8 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bb6:	6c 81       	ldd	r22, Y+4	; 0x04
    1bb8:	7d 81       	ldd	r23, Y+5	; 0x05
    1bba:	c6 01       	movw	r24, r12
    1bbc:	0e 94 e5 05 	call	0xbca	; 0xbca <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1bc0:	c8 01       	movw	r24, r16
    1bc2:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1bc6:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1bca:	88 23       	and	r24, r24
    1bcc:	11 f0       	breq	.+4      	; 0x1bd2 <xQueuePeek+0xe0>
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	a6 cf       	rjmp	.-180    	; 0x1b1e <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1bd2:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    1bd6:	fb cf       	rjmp	.-10     	; 0x1bce <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1bd8:	c8 01       	movw	r24, r16
    1bda:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bde:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
    1be2:	f5 cf       	rjmp	.-22     	; 0x1bce <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1be4:	c8 01       	movw	r24, r16
    1be6:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bea:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bee:	c8 01       	movw	r24, r16
    1bf0:	0e 94 06 0a 	call	0x140c	; 0x140c <prvIsQueueEmpty>
    1bf4:	88 23       	and	r24, r24
    1bf6:	59 f3       	breq	.-42     	; 0x1bce <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1bf8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1bfa:	0f 90       	pop	r0
    1bfc:	0f 90       	pop	r0
    1bfe:	0f 90       	pop	r0
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	df 91       	pop	r29
    1c06:	cf 91       	pop	r28
    1c08:	1f 91       	pop	r17
    1c0a:	0f 91       	pop	r16
    1c0c:	ff 90       	pop	r15
    1c0e:	ef 90       	pop	r14
    1c10:	df 90       	pop	r13
    1c12:	cf 90       	pop	r12
    1c14:	08 95       	ret

00001c16 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c16:	ef 92       	push	r14
    1c18:	ff 92       	push	r15
    1c1a:	0f 93       	push	r16
    1c1c:	1f 93       	push	r17
    1c1e:	cf 93       	push	r28
    1c20:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c22:	fc 01       	movw	r30, r24
    1c24:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c26:	00 23       	and	r16, r16
    1c28:	e9 f0       	breq	.+58     	; 0x1c64 <xQueueReceiveFromISR+0x4e>
    1c2a:	7a 01       	movw	r14, r20
    1c2c:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1c2e:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c30:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1c34:	01 50       	subi	r16, 0x01	; 1
    1c36:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1c38:	1f 3f       	cpi	r17, 0xFF	; 255
    1c3a:	81 f4       	brne	.+32     	; 0x1c5c <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c3c:	88 85       	ldd	r24, Y+8	; 0x08
    1c3e:	88 23       	and	r24, r24
    1c40:	79 f0       	breq	.+30     	; 0x1c60 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c42:	ce 01       	movw	r24, r28
    1c44:	08 96       	adiw	r24, 0x08	; 8
    1c46:	0e 94 0e 06 	call	0xc1c	; 0xc1c <xTaskRemoveFromEventList>
    1c4a:	88 23       	and	r24, r24
    1c4c:	49 f0       	breq	.+18     	; 0x1c60 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1c4e:	e1 14       	cp	r14, r1
    1c50:	f1 04       	cpc	r15, r1
    1c52:	31 f0       	breq	.+12     	; 0x1c60 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	f7 01       	movw	r30, r14
    1c58:	80 83       	st	Z, r24
    1c5a:	05 c0       	rjmp	.+10     	; 0x1c66 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1c5c:	1f 5f       	subi	r17, 0xFF	; 255
    1c5e:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	01 c0       	rjmp	.+2      	; 0x1c66 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1c64:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c66:	df 91       	pop	r29
    1c68:	cf 91       	pop	r28
    1c6a:	1f 91       	pop	r17
    1c6c:	0f 91       	pop	r16
    1c6e:	ff 90       	pop	r15
    1c70:	ef 90       	pop	r14
    1c72:	08 95       	ret

00001c74 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1c74:	0f 93       	push	r16
    1c76:	1f 93       	push	r17
    1c78:	cf 93       	push	r28
    1c7a:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1c80:	22 23       	and	r18, r18
    1c82:	49 f0       	breq	.+18     	; 0x1c96 <xQueuePeekFromISR+0x22>
    1c84:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1c86:	06 81       	ldd	r16, Z+6	; 0x06
    1c88:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c8a:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1c8e:	1f 83       	std	Y+7, r17	; 0x07
    1c90:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	01 c0       	rjmp	.+2      	; 0x1c98 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1c96:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c98:	df 91       	pop	r29
    1c9a:	cf 91       	pop	r28
    1c9c:	1f 91       	pop	r17
    1c9e:	0f 91       	pop	r16
    1ca0:	08 95       	ret

00001ca2 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1ca8:	fc 01       	movw	r30, r24
    1caa:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1cac:	0f 90       	pop	r0
    1cae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cb0:	08 95       	ret

00001cb2 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1cb8:	fc 01       	movw	r30, r24
    1cba:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1cbc:	0f 90       	pop	r0
    1cbe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1cc0:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cc2:	82 1b       	sub	r24, r18
    1cc4:	08 95       	ret

00001cc6 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cca:	08 95       	ret

00001ccc <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ccc:	0c 94 da 11 	jmp	0x23b4	; 0x23b4 <vPortFree>

00001cd0 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	91 11       	cpse	r25, r1
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1cda:	08 95       	ret

00001cdc <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1cdc:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1cde:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1ce0:	81 e0       	ldi	r24, 0x01	; 1
    1ce2:	23 8d       	ldd	r18, Z+27	; 0x1b
    1ce4:	29 13       	cpse	r18, r25
    1ce6:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ce8:	08 95       	ret

00001cea <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1cea:	cf 93       	push	r28
    1cec:	df 93       	push	r29
    1cee:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1cf0:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1cf8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cfa:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d00:	89 13       	cpse	r24, r25
    1d02:	0f c0       	rjmp	.+30     	; 0x1d22 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d04:	41 15       	cp	r20, r1
    1d06:	51 05       	cpc	r21, r1
    1d08:	49 f0       	breq	.+18     	; 0x1d1c <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1d0a:	be 01       	movw	r22, r28
    1d0c:	68 5f       	subi	r22, 0xF8	; 248
    1d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d10:	ca 01       	movw	r24, r20
    1d12:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1d16:	78 94       	sei
					return errQUEUE_BLOCKED;
    1d18:	8c ef       	ldi	r24, 0xFC	; 252
    1d1a:	1b c0       	rjmp	.+54     	; 0x1d52 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1d1c:	78 94       	sei
					return errQUEUE_FULL;
    1d1e:	80 e0       	ldi	r24, 0x00	; 0
    1d20:	18 c0       	rjmp	.+48     	; 0x1d52 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1d22:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d24:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d26:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d28:	89 17       	cp	r24, r25
    1d2a:	88 f4       	brcc	.+34     	; 0x1d4e <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1d2c:	40 e0       	ldi	r20, 0x00	; 0
    1d2e:	ce 01       	movw	r24, r28
    1d30:	0e 94 11 0a 	call	0x1422	; 0x1422 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d34:	89 89       	ldd	r24, Y+17	; 0x11
    1d36:	81 11       	cpse	r24, r1
    1d38:	02 c0       	rjmp	.+4      	; 0x1d3e <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1d3a:	81 e0       	ldi	r24, 0x01	; 1
    1d3c:	09 c0       	rjmp	.+18     	; 0x1d50 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d3e:	ce 01       	movw	r24, r28
    1d40:	41 96       	adiw	r24, 0x11	; 17
    1d42:	0e 94 83 11 	call	0x2306	; 0x2306 <xCoRoutineRemoveFromEventList>
    1d46:	88 23       	and	r24, r24
    1d48:	c1 f3       	breq	.-16     	; 0x1d3a <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1d4a:	8b ef       	ldi	r24, 0xFB	; 251
    1d4c:	01 c0       	rjmp	.+2      	; 0x1d50 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1d4e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1d50:	78 94       	sei

		return xReturn;
	}
    1d52:	df 91       	pop	r29
    1d54:	cf 91       	pop	r28
    1d56:	08 95       	ret

00001d58 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
    1d5c:	ec 01       	movw	r28, r24
    1d5e:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1d60:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d62:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d64:	81 11       	cpse	r24, r1
    1d66:	0f c0       	rjmp	.+30     	; 0x1d86 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d68:	41 15       	cp	r20, r1
    1d6a:	51 05       	cpc	r21, r1
    1d6c:	49 f0       	breq	.+18     	; 0x1d80 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1d6e:	be 01       	movw	r22, r28
    1d70:	6f 5e       	subi	r22, 0xEF	; 239
    1d72:	7f 4f       	sbci	r23, 0xFF	; 255
    1d74:	ca 01       	movw	r24, r20
    1d76:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1d7a:	78 94       	sei
					return errQUEUE_BLOCKED;
    1d7c:	8c ef       	ldi	r24, 0xFC	; 252
    1d7e:	30 c0       	rjmp	.+96     	; 0x1de0 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1d80:	78 94       	sei
					return errQUEUE_FULL;
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	2d c0       	rjmp	.+90     	; 0x1de0 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1d86:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d88:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d8a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d8c:	88 23       	and	r24, r24
    1d8e:	31 f1       	breq	.+76     	; 0x1ddc <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1d90:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d92:	50 e0       	ldi	r21, 0x00	; 0
    1d94:	2e 81       	ldd	r18, Y+6	; 0x06
    1d96:	3f 81       	ldd	r19, Y+7	; 0x07
    1d98:	24 0f       	add	r18, r20
    1d9a:	35 1f       	adc	r19, r21
    1d9c:	3f 83       	std	Y+7, r19	; 0x07
    1d9e:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1da0:	8c 81       	ldd	r24, Y+4	; 0x04
    1da2:	9d 81       	ldd	r25, Y+5	; 0x05
    1da4:	28 17       	cp	r18, r24
    1da6:	39 07       	cpc	r19, r25
    1da8:	20 f0       	brcs	.+8      	; 0x1db2 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1daa:	88 81       	ld	r24, Y
    1dac:	99 81       	ldd	r25, Y+1	; 0x01
    1dae:	9f 83       	std	Y+7, r25	; 0x07
    1db0:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1db2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1db4:	91 50       	subi	r25, 0x01	; 1
    1db6:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1db8:	6e 81       	ldd	r22, Y+6	; 0x06
    1dba:	7f 81       	ldd	r23, Y+7	; 0x07
    1dbc:	cf 01       	movw	r24, r30
    1dbe:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dc2:	88 85       	ldd	r24, Y+8	; 0x08
    1dc4:	81 11       	cpse	r24, r1
    1dc6:	02 c0       	rjmp	.+4      	; 0x1dcc <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	09 c0       	rjmp	.+18     	; 0x1dde <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1dcc:	ce 01       	movw	r24, r28
    1dce:	08 96       	adiw	r24, 0x08	; 8
    1dd0:	0e 94 83 11 	call	0x2306	; 0x2306 <xCoRoutineRemoveFromEventList>
    1dd4:	88 23       	and	r24, r24
    1dd6:	c1 f3       	breq	.-16     	; 0x1dc8 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1dd8:	8b ef       	ldi	r24, 0xFB	; 251
    1dda:	01 c0       	rjmp	.+2      	; 0x1dde <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1ddc:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1dde:	78 94       	sei

		return xReturn;
	}
    1de0:	df 91       	pop	r29
    1de2:	cf 91       	pop	r28
    1de4:	08 95       	ret

00001de6 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	8c 01       	movw	r16, r24
    1dee:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1df0:	fc 01       	movw	r30, r24
    1df2:	92 8d       	ldd	r25, Z+26	; 0x1a
    1df4:	83 8d       	ldd	r24, Z+27	; 0x1b
    1df6:	98 17       	cp	r25, r24
    1df8:	10 f0       	brcs	.+4      	; 0x1dfe <xQueueCRSendFromISR+0x18>
    1dfa:	4c 2f       	mov	r20, r28
    1dfc:	12 c0       	rjmp	.+36     	; 0x1e22 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1dfe:	40 e0       	ldi	r20, 0x00	; 0
    1e00:	c8 01       	movw	r24, r16
    1e02:	0e 94 11 0a 	call	0x1422	; 0x1422 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1e06:	c1 11       	cpse	r28, r1
    1e08:	f8 cf       	rjmp	.-16     	; 0x1dfa <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e0a:	f8 01       	movw	r30, r16
    1e0c:	81 89       	ldd	r24, Z+17	; 0x11
    1e0e:	88 23       	and	r24, r24
    1e10:	39 f0       	breq	.+14     	; 0x1e20 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e12:	c8 01       	movw	r24, r16
    1e14:	41 96       	adiw	r24, 0x11	; 17
    1e16:	0e 94 83 11 	call	0x2306	; 0x2306 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1e1a:	41 e0       	ldi	r20, 0x01	; 1
    1e1c:	81 11       	cpse	r24, r1
    1e1e:	01 c0       	rjmp	.+2      	; 0x1e22 <xQueueCRSendFromISR+0x3c>
    1e20:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1e22:	84 2f       	mov	r24, r20
    1e24:	cf 91       	pop	r28
    1e26:	1f 91       	pop	r17
    1e28:	0f 91       	pop	r16
    1e2a:	08 95       	ret

00001e2c <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1e2c:	0f 93       	push	r16
    1e2e:	1f 93       	push	r17
    1e30:	cf 93       	push	r28
    1e32:	df 93       	push	r29
    1e34:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e38:	88 23       	and	r24, r24
    1e3a:	79 f1       	breq	.+94     	; 0x1e9a <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1e3c:	24 8d       	ldd	r18, Z+28	; 0x1c
    1e3e:	30 e0       	ldi	r19, 0x00	; 0
    1e40:	a6 81       	ldd	r26, Z+6	; 0x06
    1e42:	b7 81       	ldd	r27, Z+7	; 0x07
    1e44:	a2 0f       	add	r26, r18
    1e46:	b3 1f       	adc	r27, r19
    1e48:	b7 83       	std	Z+7, r27	; 0x07
    1e4a:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1e4c:	84 81       	ldd	r24, Z+4	; 0x04
    1e4e:	95 81       	ldd	r25, Z+5	; 0x05
    1e50:	a8 17       	cp	r26, r24
    1e52:	b9 07       	cpc	r27, r25
    1e54:	20 f0       	brcs	.+8      	; 0x1e5e <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1e56:	80 81       	ld	r24, Z
    1e58:	91 81       	ldd	r25, Z+1	; 0x01
    1e5a:	97 83       	std	Z+7, r25	; 0x07
    1e5c:	86 83       	std	Z+6, r24	; 0x06
    1e5e:	8a 01       	movw	r16, r20
    1e60:	cb 01       	movw	r24, r22
    1e62:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1e64:	42 8d       	ldd	r20, Z+26	; 0x1a
    1e66:	41 50       	subi	r20, 0x01	; 1
    1e68:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1e6a:	66 81       	ldd	r22, Z+6	; 0x06
    1e6c:	77 81       	ldd	r23, Z+7	; 0x07
    1e6e:	a9 01       	movw	r20, r18
    1e70:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1e74:	f8 01       	movw	r30, r16
    1e76:	80 81       	ld	r24, Z
    1e78:	88 23       	and	r24, r24
    1e7a:	11 f0       	breq	.+4      	; 0x1e80 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	0e c0       	rjmp	.+28     	; 0x1e9c <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e80:	88 85       	ldd	r24, Y+8	; 0x08
    1e82:	88 23       	and	r24, r24
    1e84:	d9 f3       	breq	.-10     	; 0x1e7c <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e86:	ce 01       	movw	r24, r28
    1e88:	08 96       	adiw	r24, 0x08	; 8
    1e8a:	0e 94 83 11 	call	0x2306	; 0x2306 <xCoRoutineRemoveFromEventList>
    1e8e:	88 23       	and	r24, r24
    1e90:	a9 f3       	breq	.-22     	; 0x1e7c <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	f8 01       	movw	r30, r16
    1e96:	80 83       	st	Z, r24
    1e98:	01 c0       	rjmp	.+2      	; 0x1e9c <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1e9a:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1e9c:	df 91       	pop	r29
    1e9e:	cf 91       	pop	r28
    1ea0:	1f 91       	pop	r17
    1ea2:	0f 91       	pop	r16
    1ea4:	08 95       	ret

00001ea6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ea6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ea8:	03 96       	adiw	r24, 0x03	; 3
    1eaa:	92 83       	std	Z+2, r25	; 0x02
    1eac:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1eae:	2f ef       	ldi	r18, 0xFF	; 255
    1eb0:	3f ef       	ldi	r19, 0xFF	; 255
    1eb2:	34 83       	std	Z+4, r19	; 0x04
    1eb4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eb6:	96 83       	std	Z+6, r25	; 0x06
    1eb8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eba:	90 87       	std	Z+8, r25	; 0x08
    1ebc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ebe:	10 82       	st	Z, r1
    1ec0:	08 95       	ret

00001ec2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1ec2:	fc 01       	movw	r30, r24
    1ec4:	11 86       	std	Z+9, r1	; 0x09
    1ec6:	10 86       	std	Z+8, r1	; 0x08
    1ec8:	08 95       	ret

00001eca <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1eca:	cf 93       	push	r28
    1ecc:	df 93       	push	r29
    1ece:	9c 01       	movw	r18, r24
    1ed0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1ed2:	dc 01       	movw	r26, r24
    1ed4:	11 96       	adiw	r26, 0x01	; 1
    1ed6:	cd 91       	ld	r28, X+
    1ed8:	dc 91       	ld	r29, X
    1eda:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1edc:	d3 83       	std	Z+3, r29	; 0x03
    1ede:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1ee0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ee2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ee4:	95 83       	std	Z+5, r25	; 0x05
    1ee6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ee8:	8c 81       	ldd	r24, Y+4	; 0x04
    1eea:	9d 81       	ldd	r25, Y+5	; 0x05
    1eec:	dc 01       	movw	r26, r24
    1eee:	13 96       	adiw	r26, 0x03	; 3
    1ef0:	7c 93       	st	X, r23
    1ef2:	6e 93       	st	-X, r22
    1ef4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1ef6:	7d 83       	std	Y+5, r23	; 0x05
    1ef8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1efa:	31 87       	std	Z+9, r19	; 0x09
    1efc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1efe:	f9 01       	movw	r30, r18
    1f00:	80 81       	ld	r24, Z
    1f02:	8f 5f       	subi	r24, 0xFF	; 255
    1f04:	80 83       	st	Z, r24
}
    1f06:	df 91       	pop	r29
    1f08:	cf 91       	pop	r28
    1f0a:	08 95       	ret

00001f0c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f0c:	0f 93       	push	r16
    1f0e:	1f 93       	push	r17
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	8c 01       	movw	r16, r24
    1f16:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1f18:	80 81       	ld	r24, Z
    1f1a:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1f1c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f1e:	2f ef       	ldi	r18, 0xFF	; 255
    1f20:	92 07       	cpc	r25, r18
    1f22:	21 f4       	brne	.+8      	; 0x1f2c <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f24:	e8 01       	movw	r28, r16
    1f26:	af 81       	ldd	r26, Y+7	; 0x07
    1f28:	b8 85       	ldd	r27, Y+8	; 0x08
    1f2a:	0e c0       	rjmp	.+28     	; 0x1f48 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1f2c:	d8 01       	movw	r26, r16
    1f2e:	13 96       	adiw	r26, 0x03	; 3
    1f30:	12 96       	adiw	r26, 0x02	; 2
    1f32:	2d 91       	ld	r18, X+
    1f34:	3c 91       	ld	r19, X
    1f36:	13 97       	sbiw	r26, 0x03	; 3
    1f38:	e9 01       	movw	r28, r18
    1f3a:	48 81       	ld	r20, Y
    1f3c:	59 81       	ldd	r21, Y+1	; 0x01
    1f3e:	84 17       	cp	r24, r20
    1f40:	95 07       	cpc	r25, r21
    1f42:	10 f0       	brcs	.+4      	; 0x1f48 <vListInsert+0x3c>
    1f44:	d9 01       	movw	r26, r18
    1f46:	f4 cf       	rjmp	.-24     	; 0x1f30 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1f48:	12 96       	adiw	r26, 0x02	; 2
    1f4a:	8d 91       	ld	r24, X+
    1f4c:	9c 91       	ld	r25, X
    1f4e:	13 97       	sbiw	r26, 0x03	; 3
    1f50:	93 83       	std	Z+3, r25	; 0x03
    1f52:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1f54:	ec 01       	movw	r28, r24
    1f56:	fd 83       	std	Y+5, r31	; 0x05
    1f58:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1f5a:	b5 83       	std	Z+5, r27	; 0x05
    1f5c:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1f5e:	13 96       	adiw	r26, 0x03	; 3
    1f60:	fc 93       	st	X, r31
    1f62:	ee 93       	st	-X, r30
    1f64:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1f66:	11 87       	std	Z+9, r17	; 0x09
    1f68:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1f6a:	f8 01       	movw	r30, r16
    1f6c:	80 81       	ld	r24, Z
    1f6e:	8f 5f       	subi	r24, 0xFF	; 255
    1f70:	80 83       	st	Z, r24
}
    1f72:	df 91       	pop	r29
    1f74:	cf 91       	pop	r28
    1f76:	1f 91       	pop	r17
    1f78:	0f 91       	pop	r16
    1f7a:	08 95       	ret

00001f7c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1f7c:	cf 93       	push	r28
    1f7e:	df 93       	push	r29
    1f80:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1f82:	a0 85       	ldd	r26, Z+8	; 0x08
    1f84:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1f86:	82 81       	ldd	r24, Z+2	; 0x02
    1f88:	93 81       	ldd	r25, Z+3	; 0x03
    1f8a:	24 81       	ldd	r18, Z+4	; 0x04
    1f8c:	35 81       	ldd	r19, Z+5	; 0x05
    1f8e:	ec 01       	movw	r28, r24
    1f90:	3d 83       	std	Y+5, r19	; 0x05
    1f92:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f94:	c4 81       	ldd	r28, Z+4	; 0x04
    1f96:	d5 81       	ldd	r29, Z+5	; 0x05
    1f98:	9b 83       	std	Y+3, r25	; 0x03
    1f9a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1f9c:	11 96       	adiw	r26, 0x01	; 1
    1f9e:	8d 91       	ld	r24, X+
    1fa0:	9c 91       	ld	r25, X
    1fa2:	12 97       	sbiw	r26, 0x02	; 2
    1fa4:	e8 17       	cp	r30, r24
    1fa6:	f9 07       	cpc	r31, r25
    1fa8:	21 f4       	brne	.+8      	; 0x1fb2 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1faa:	12 96       	adiw	r26, 0x02	; 2
    1fac:	dc 93       	st	X, r29
    1fae:	ce 93       	st	-X, r28
    1fb0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1fb2:	11 86       	std	Z+9, r1	; 0x09
    1fb4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1fb6:	8c 91       	ld	r24, X
    1fb8:	81 50       	subi	r24, 0x01	; 1
    1fba:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1fbc:	8c 91       	ld	r24, X
}
    1fbe:	df 91       	pop	r29
    1fc0:	cf 91       	pop	r28
    1fc2:	08 95       	ret

00001fc4 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1fc4:	cf 92       	push	r12
    1fc6:	df 92       	push	r13
    1fc8:	ef 92       	push	r14
    1fca:	ff 92       	push	r15
    1fcc:	1f 93       	push	r17
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
    1fd2:	6c 01       	movw	r12, r24
    1fd4:	16 2f       	mov	r17, r22
    1fd6:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1fd8:	8a e1       	ldi	r24, 0x1A	; 26
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	0e 94 a8 11 	call	0x2350	; 0x2350 <pvPortMalloc>
    1fe0:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1fe2:	89 2b       	or	r24, r25
    1fe4:	09 f4       	brne	.+2      	; 0x1fe8 <xCoRoutineCreate+0x24>
    1fe6:	57 c0       	rjmp	.+174    	; 0x2096 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1fe8:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    1fec:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    1ff0:	89 2b       	or	r24, r25
    1ff2:	21 f5       	brne	.+72     	; 0x203c <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1ff4:	d0 93 8c 01 	sts	0x018C, r29	; 0x80018c <pxCurrentCoRoutine+0x1>
    1ff8:	c0 93 8b 01 	sts	0x018B, r28	; 0x80018b <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1ffc:	83 eb       	ldi	r24, 0xB3	; 179
    1ffe:	91 e0       	ldi	r25, 0x01	; 1
    2000:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
    2004:	8c eb       	ldi	r24, 0xBC	; 188
    2006:	91 e0       	ldi	r25, 0x01	; 1
    2008:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    200c:	8a ea       	ldi	r24, 0xAA	; 170
    200e:	91 e0       	ldi	r25, 0x01	; 1
    2010:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2014:	81 ea       	ldi	r24, 0xA1	; 161
    2016:	91 e0       	ldi	r25, 0x01	; 1
    2018:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    201c:	84 e9       	ldi	r24, 0x94	; 148
    201e:	91 e0       	ldi	r25, 0x01	; 1
    2020:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2024:	8a ea       	ldi	r24, 0xAA	; 170
    2026:	91 e0       	ldi	r25, 0x01	; 1
    2028:	90 93 a0 01 	sts	0x01A0, r25	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    202c:	80 93 9f 01 	sts	0x019F, r24	; 0x80019f <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2030:	81 ea       	ldi	r24, 0xA1	; 161
    2032:	91 e0       	ldi	r25, 0x01	; 1
    2034:	90 93 9e 01 	sts	0x019E, r25	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    2038:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <pxOverflowDelayedCoRoutineList>
    203c:	11 11       	cpse	r17, r1
    203e:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2040:	19 8e       	std	Y+25, r1	; 0x19
    2042:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2044:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2046:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2048:	fe 01       	movw	r30, r28
    204a:	c1 92       	st	Z+, r12
    204c:	d1 92       	st	Z+, r13
    204e:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2050:	cf 01       	movw	r24, r30
    2052:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2056:	ce 01       	movw	r24, r28
    2058:	0c 96       	adiw	r24, 0x0c	; 12
    205a:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    205e:	d9 87       	std	Y+9, r29	; 0x09
    2060:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2062:	db 8b       	std	Y+19, r29	; 0x13
    2064:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2066:	82 e0       	ldi	r24, 0x02	; 2
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	81 1b       	sub	r24, r17
    206c:	91 09       	sbc	r25, r1
    206e:	9d 87       	std	Y+13, r25	; 0x0d
    2070:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2072:	8e 89       	ldd	r24, Y+22	; 0x16
    2074:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>
    2078:	98 17       	cp	r25, r24
    207a:	10 f4       	brcc	.+4      	; 0x2080 <xCoRoutineCreate+0xbc>
    207c:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
    2080:	f9 e0       	ldi	r31, 0x09	; 9
    2082:	8f 9f       	mul	r24, r31
    2084:	c0 01       	movw	r24, r0
    2086:	11 24       	eor	r1, r1
    2088:	b7 01       	movw	r22, r14
    208a:	8d 54       	subi	r24, 0x4D	; 77
    208c:	9e 4f       	sbci	r25, 0xFE	; 254
    208e:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

		xReturn = pdPASS;
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	01 c0       	rjmp	.+2      	; 0x2098 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2096:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	1f 91       	pop	r17
    209e:	ff 90       	pop	r15
    20a0:	ef 90       	pop	r14
    20a2:	df 90       	pop	r13
    20a4:	cf 90       	pop	r12
    20a6:	08 95       	ret

000020a8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    20a8:	0f 93       	push	r16
    20aa:	1f 93       	push	r17
    20ac:	cf 93       	push	r28
    20ae:	df 93       	push	r29
    20b0:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    20b2:	c0 91 91 01 	lds	r28, 0x0191	; 0x800191 <xCoRoutineTickCount>
    20b6:	d0 91 92 01 	lds	r29, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    20ba:	c8 0f       	add	r28, r24
    20bc:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20be:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    20c2:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    20c6:	02 96       	adiw	r24, 0x02	; 2
    20c8:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    20cc:	e0 91 8b 01 	lds	r30, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    20d0:	f0 91 8c 01 	lds	r31, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    20d4:	d3 83       	std	Z+3, r29	; 0x03
    20d6:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    20d8:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <xCoRoutineTickCount>
    20dc:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    20e0:	bf 01       	movw	r22, r30
    20e2:	6e 5f       	subi	r22, 0xFE	; 254
    20e4:	7f 4f       	sbci	r23, 0xFF	; 255
    20e6:	c8 17       	cp	r28, r24
    20e8:	d9 07       	cpc	r29, r25
    20ea:	28 f4       	brcc	.+10     	; 0x20f6 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20ec:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <pxOverflowDelayedCoRoutineList>
    20f0:	90 91 9e 01 	lds	r25, 0x019E	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    20f4:	04 c0       	rjmp	.+8      	; 0x20fe <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20f6:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <pxDelayedCoRoutineList>
    20fa:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    20fe:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <vListInsert>
	}

	if( pxEventList )
    2102:	01 15       	cp	r16, r1
    2104:	11 05       	cpc	r17, r1
    2106:	69 f0       	breq	.+26     	; 0x2122 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2108:	60 91 8b 01 	lds	r22, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    210c:	70 91 8c 01 	lds	r23, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    2110:	64 5f       	subi	r22, 0xF4	; 244
    2112:	7f 4f       	sbci	r23, 0xFF	; 255
    2114:	c8 01       	movw	r24, r16
	}
}
    2116:	df 91       	pop	r29
    2118:	cf 91       	pop	r28
    211a:	1f 91       	pop	r17
    211c:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    211e:	0c 94 86 0f 	jmp	0x1f0c	; 0x1f0c <vListInsert>
	}
}
    2122:	df 91       	pop	r29
    2124:	cf 91       	pop	r28
    2126:	1f 91       	pop	r17
    2128:	0f 91       	pop	r16
    212a:	08 95       	ret

0000212c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    212c:	ff 92       	push	r15
    212e:	0f 93       	push	r16
    2130:	1f 93       	push	r17
    2132:	cf 93       	push	r28
    2134:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2136:	99 e0       	ldi	r25, 0x09	; 9
    2138:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    213a:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xPendingReadyCoRoutineList>
    213e:	88 23       	and	r24, r24
    2140:	11 f1       	breq	.+68     	; 0x2186 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2142:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2144:	e0 91 99 01 	lds	r30, 0x0199	; 0x800199 <xPendingReadyCoRoutineList+0x5>
    2148:	f0 91 9a 01 	lds	r31, 0x019A	; 0x80019a <xPendingReadyCoRoutineList+0x6>
    214c:	c6 81       	ldd	r28, Z+6	; 0x06
    214e:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2150:	ce 01       	movw	r24, r28
    2152:	0c 96       	adiw	r24, 0x0c	; 12
    2154:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2158:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    215a:	8e 01       	movw	r16, r28
    215c:	0e 5f       	subi	r16, 0xFE	; 254
    215e:	1f 4f       	sbci	r17, 0xFF	; 255
    2160:	c8 01       	movw	r24, r16
    2162:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2166:	8e 89       	ldd	r24, Y+22	; 0x16
    2168:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>
    216c:	98 17       	cp	r25, r24
    216e:	10 f4       	brcc	.+4      	; 0x2174 <vCoRoutineSchedule+0x48>
    2170:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
    2174:	f8 9e       	mul	r15, r24
    2176:	c0 01       	movw	r24, r0
    2178:	11 24       	eor	r1, r1
    217a:	b8 01       	movw	r22, r16
    217c:	8d 54       	subi	r24, 0x4D	; 77
    217e:	9e 4f       	sbci	r25, 0xFE	; 254
    2180:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
    2184:	da cf       	rjmp	.-76     	; 0x213a <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2186:	0e 94 ca 03 	call	0x794	; 0x794 <xTaskGetTickCount>
    218a:	20 91 8f 01 	lds	r18, 0x018F	; 0x80018f <xLastTickCount>
    218e:	30 91 90 01 	lds	r19, 0x0190	; 0x800190 <xLastTickCount+0x1>
    2192:	82 1b       	sub	r24, r18
    2194:	93 0b       	sbc	r25, r19
    2196:	90 93 8e 01 	sts	0x018E, r25	; 0x80018e <xPassedTicks+0x1>
    219a:	80 93 8d 01 	sts	0x018D, r24	; 0x80018d <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    219e:	89 e0       	ldi	r24, 0x09	; 9
    21a0:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    21a2:	20 91 8d 01 	lds	r18, 0x018D	; 0x80018d <xPassedTicks>
    21a6:	30 91 8e 01 	lds	r19, 0x018E	; 0x80018e <xPassedTicks+0x1>
    21aa:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <xCoRoutineTickCount>
    21ae:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    21b2:	21 15       	cp	r18, r1
    21b4:	31 05       	cpc	r19, r1
    21b6:	09 f4       	brne	.+2      	; 0x21ba <vCoRoutineSchedule+0x8e>
    21b8:	54 c0       	rjmp	.+168    	; 0x2262 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    21ba:	01 96       	adiw	r24, 0x01	; 1
    21bc:	90 93 92 01 	sts	0x0192, r25	; 0x800192 <xCoRoutineTickCount+0x1>
    21c0:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <xCoRoutineTickCount>
		xPassedTicks--;
    21c4:	21 50       	subi	r18, 0x01	; 1
    21c6:	31 09       	sbc	r19, r1
    21c8:	30 93 8e 01 	sts	0x018E, r19	; 0x80018e <xPassedTicks+0x1>
    21cc:	20 93 8d 01 	sts	0x018D, r18	; 0x80018d <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    21d0:	89 2b       	or	r24, r25
    21d2:	09 f0       	breq	.+2      	; 0x21d6 <vCoRoutineSchedule+0xaa>
    21d4:	3e c0       	rjmp	.+124    	; 0x2252 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    21d6:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <pxDelayedCoRoutineList>
    21da:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    21de:	20 91 9d 01 	lds	r18, 0x019D	; 0x80019d <pxOverflowDelayedCoRoutineList>
    21e2:	30 91 9e 01 	lds	r19, 0x019E	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    21e6:	30 93 a0 01 	sts	0x01A0, r19	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    21ea:	20 93 9f 01 	sts	0x019F, r18	; 0x80019f <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    21ee:	90 93 9e 01 	sts	0x019E, r25	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    21f2:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <pxOverflowDelayedCoRoutineList>
    21f6:	2d c0       	rjmp	.+90     	; 0x2252 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    21f8:	05 80       	ldd	r0, Z+5	; 0x05
    21fa:	f6 81       	ldd	r31, Z+6	; 0x06
    21fc:	e0 2d       	mov	r30, r0
    21fe:	c6 81       	ldd	r28, Z+6	; 0x06
    2200:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2202:	2a 81       	ldd	r18, Y+2	; 0x02
    2204:	3b 81       	ldd	r19, Y+3	; 0x03
    2206:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <xCoRoutineTickCount>
    220a:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    220e:	82 17       	cp	r24, r18
    2210:	93 07       	cpc	r25, r19
    2212:	38 f2       	brcs	.-114    	; 0x21a2 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2214:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2216:	8e 01       	movw	r16, r28
    2218:	0e 5f       	subi	r16, 0xFE	; 254
    221a:	1f 4f       	sbci	r17, 0xFF	; 255
    221c:	c8 01       	movw	r24, r16
    221e:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    2222:	8c 89       	ldd	r24, Y+20	; 0x14
    2224:	9d 89       	ldd	r25, Y+21	; 0x15
    2226:	89 2b       	or	r24, r25
    2228:	21 f0       	breq	.+8      	; 0x2232 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    222a:	ce 01       	movw	r24, r28
    222c:	0c 96       	adiw	r24, 0x0c	; 12
    222e:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2232:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2234:	8e 89       	ldd	r24, Y+22	; 0x16
    2236:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>
    223a:	98 17       	cp	r25, r24
    223c:	10 f4       	brcc	.+4      	; 0x2242 <vCoRoutineSchedule+0x116>
    223e:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
    2242:	f8 9e       	mul	r15, r24
    2244:	c0 01       	movw	r24, r0
    2246:	11 24       	eor	r1, r1
    2248:	b8 01       	movw	r22, r16
    224a:	8d 54       	subi	r24, 0x4D	; 77
    224c:	9e 4f       	sbci	r25, 0xFE	; 254
    224e:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2252:	e0 91 9f 01 	lds	r30, 0x019F	; 0x80019f <pxDelayedCoRoutineList>
    2256:	f0 91 a0 01 	lds	r31, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    225a:	80 81       	ld	r24, Z
    225c:	81 11       	cpse	r24, r1
    225e:	cc cf       	rjmp	.-104    	; 0x21f8 <vCoRoutineSchedule+0xcc>
    2260:	a0 cf       	rjmp	.-192    	; 0x21a2 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2262:	90 93 90 01 	sts	0x0190, r25	; 0x800190 <xLastTickCount+0x1>
    2266:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <xLastTickCount>
    226a:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    226e:	69 e0       	ldi	r22, 0x09	; 9
    2270:	48 2f       	mov	r20, r24
    2272:	50 e0       	ldi	r21, 0x00	; 0
    2274:	64 9f       	mul	r22, r20
    2276:	90 01       	movw	r18, r0
    2278:	65 9f       	mul	r22, r21
    227a:	30 0d       	add	r19, r0
    227c:	11 24       	eor	r1, r1
    227e:	f9 01       	movw	r30, r18
    2280:	ed 54       	subi	r30, 0x4D	; 77
    2282:	fe 4f       	sbci	r31, 0xFE	; 254
    2284:	90 81       	ld	r25, Z
    2286:	91 11       	cpse	r25, r1
    2288:	0c c0       	rjmp	.+24     	; 0x22a2 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    228a:	81 11       	cpse	r24, r1
    228c:	08 c0       	rjmp	.+16     	; 0x229e <vCoRoutineSchedule+0x172>
    228e:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    2292:	df 91       	pop	r29
    2294:	cf 91       	pop	r28
    2296:	1f 91       	pop	r17
    2298:	0f 91       	pop	r16
    229a:	ff 90       	pop	r15
    229c:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    229e:	81 50       	subi	r24, 0x01	; 1
    22a0:	e7 cf       	rjmp	.-50     	; 0x2270 <vCoRoutineSchedule+0x144>
    22a2:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    22a6:	a1 81       	ldd	r26, Z+1	; 0x01
    22a8:	b2 81       	ldd	r27, Z+2	; 0x02
    22aa:	12 96       	adiw	r26, 0x02	; 2
    22ac:	0d 90       	ld	r0, X+
    22ae:	bc 91       	ld	r27, X
    22b0:	a0 2d       	mov	r26, r0
    22b2:	b2 83       	std	Z+2, r27	; 0x02
    22b4:	a1 83       	std	Z+1, r26	; 0x01
    22b6:	2a 54       	subi	r18, 0x4A	; 74
    22b8:	3e 4f       	sbci	r19, 0xFE	; 254
    22ba:	a2 17       	cp	r26, r18
    22bc:	b3 07       	cpc	r27, r19
    22be:	31 f4       	brne	.+12     	; 0x22cc <vCoRoutineSchedule+0x1a0>
    22c0:	12 96       	adiw	r26, 0x02	; 2
    22c2:	8d 91       	ld	r24, X+
    22c4:	9c 91       	ld	r25, X
    22c6:	13 97       	sbiw	r26, 0x03	; 3
    22c8:	92 83       	std	Z+2, r25	; 0x02
    22ca:	81 83       	std	Z+1, r24	; 0x01
    22cc:	89 e0       	ldi	r24, 0x09	; 9
    22ce:	84 9f       	mul	r24, r20
    22d0:	f0 01       	movw	r30, r0
    22d2:	85 9f       	mul	r24, r21
    22d4:	f0 0d       	add	r31, r0
    22d6:	11 24       	eor	r1, r1
    22d8:	ed 54       	subi	r30, 0x4D	; 77
    22da:	fe 4f       	sbci	r31, 0xFE	; 254
    22dc:	01 80       	ldd	r0, Z+1	; 0x01
    22de:	f2 81       	ldd	r31, Z+2	; 0x02
    22e0:	e0 2d       	mov	r30, r0
    22e2:	86 81       	ldd	r24, Z+6	; 0x06
    22e4:	97 81       	ldd	r25, Z+7	; 0x07
    22e6:	90 93 8c 01 	sts	0x018C, r25	; 0x80018c <pxCurrentCoRoutine+0x1>
    22ea:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    22ee:	dc 01       	movw	r26, r24
    22f0:	ed 91       	ld	r30, X+
    22f2:	fc 91       	ld	r31, X
    22f4:	11 97       	sbiw	r26, 0x01	; 1
    22f6:	57 96       	adiw	r26, 0x17	; 23
    22f8:	6c 91       	ld	r22, X

	return;
}
    22fa:	df 91       	pop	r29
    22fc:	cf 91       	pop	r28
    22fe:	1f 91       	pop	r17
    2300:	0f 91       	pop	r16
    2302:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2304:	09 94       	ijmp

00002306 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2306:	0f 93       	push	r16
    2308:	1f 93       	push	r17
    230a:	cf 93       	push	r28
    230c:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    230e:	dc 01       	movw	r26, r24
    2310:	15 96       	adiw	r26, 0x05	; 5
    2312:	ed 91       	ld	r30, X+
    2314:	fc 91       	ld	r31, X
    2316:	16 97       	sbiw	r26, 0x06	; 6
    2318:	c6 81       	ldd	r28, Z+6	; 0x06
    231a:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    231c:	8e 01       	movw	r16, r28
    231e:	04 5f       	subi	r16, 0xF4	; 244
    2320:	1f 4f       	sbci	r17, 0xFF	; 255
    2322:	c8 01       	movw	r24, r16
    2324:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2328:	b8 01       	movw	r22, r16
    232a:	84 e9       	ldi	r24, 0x94	; 148
    232c:	91 e0       	ldi	r25, 0x01	; 1
    232e:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2332:	e0 91 8b 01 	lds	r30, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    2336:	f0 91 8c 01 	lds	r31, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	2e 89       	ldd	r18, Y+22	; 0x16
    233e:	96 89       	ldd	r25, Z+22	; 0x16
    2340:	29 17       	cp	r18, r25
    2342:	08 f4       	brcc	.+2      	; 0x2346 <xCoRoutineRemoveFromEventList+0x40>
    2344:	80 e0       	ldi	r24, 0x00	; 0
}
    2346:	df 91       	pop	r29
    2348:	cf 91       	pop	r28
    234a:	1f 91       	pop	r17
    234c:	0f 91       	pop	r16
    234e:	08 95       	ret

00002350 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2350:	cf 93       	push	r28
    2352:	df 93       	push	r29
    2354:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2356:	0e 94 c4 03 	call	0x788	; 0x788 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    235a:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <pucAlignedHeap.2082>
    235e:	90 91 c6 01 	lds	r25, 0x01C6	; 0x8001c6 <pucAlignedHeap.2082+0x1>
    2362:	89 2b       	or	r24, r25
    2364:	31 f4       	brne	.+12     	; 0x2372 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2366:	8a ec       	ldi	r24, 0xCA	; 202
    2368:	91 e0       	ldi	r25, 0x01	; 1
    236a:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <pucAlignedHeap.2082+0x1>
    236e:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <pucAlignedHeap.2082>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2372:	20 91 c7 01 	lds	r18, 0x01C7	; 0x8001c7 <xNextFreeByte>
    2376:	30 91 c8 01 	lds	r19, 0x01C8	; 0x8001c8 <xNextFreeByte+0x1>
    237a:	c9 01       	movw	r24, r18
    237c:	8c 0f       	add	r24, r28
    237e:	9d 1f       	adc	r25, r29
    2380:	8b 3d       	cpi	r24, 0xDB	; 219
    2382:	45 e0       	ldi	r20, 0x05	; 5
    2384:	94 07       	cpc	r25, r20
    2386:	70 f4       	brcc	.+28     	; 0x23a4 <pvPortMalloc+0x54>
    2388:	28 17       	cp	r18, r24
    238a:	39 07       	cpc	r19, r25
    238c:	58 f4       	brcc	.+22     	; 0x23a4 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    238e:	c0 91 c5 01 	lds	r28, 0x01C5	; 0x8001c5 <pucAlignedHeap.2082>
    2392:	d0 91 c6 01 	lds	r29, 0x01C6	; 0x8001c6 <pucAlignedHeap.2082+0x1>
    2396:	c2 0f       	add	r28, r18
    2398:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    239a:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <xNextFreeByte+0x1>
    239e:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <xNextFreeByte>
    23a2:	02 c0       	rjmp	.+4      	; 0x23a8 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    23a4:	c0 e0       	ldi	r28, 0x00	; 0
    23a6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    23a8:	0e 94 90 04 	call	0x920	; 0x920 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    23ac:	ce 01       	movw	r24, r28
    23ae:	df 91       	pop	r29
    23b0:	cf 91       	pop	r28
    23b2:	08 95       	ret

000023b4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    23b4:	08 95       	ret

000023b6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    23b6:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <xNextFreeByte+0x1>
    23ba:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <xNextFreeByte>
    23be:	08 95       	ret

000023c0 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    23c0:	20 91 c7 01 	lds	r18, 0x01C7	; 0x8001c7 <xNextFreeByte>
    23c4:	30 91 c8 01 	lds	r19, 0x01C8	; 0x8001c8 <xNextFreeByte+0x1>
}
    23c8:	8b ed       	ldi	r24, 0xDB	; 219
    23ca:	95 e0       	ldi	r25, 0x05	; 5
    23cc:	82 1b       	sub	r24, r18
    23ce:	93 0b       	sbc	r25, r19
    23d0:	08 95       	ret

000023d2 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    23d2:	31 e1       	ldi	r19, 0x11	; 17
    23d4:	fc 01       	movw	r30, r24
    23d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    23d8:	31 97       	sbiw	r30, 0x01	; 1
    23da:	22 e2       	ldi	r18, 0x22	; 34
    23dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    23de:	31 97       	sbiw	r30, 0x01	; 1
    23e0:	a3 e3       	ldi	r26, 0x33	; 51
    23e2:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23e4:	31 97       	sbiw	r30, 0x01	; 1
    23e6:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23e8:	31 97       	sbiw	r30, 0x01	; 1
    23ea:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    23ec:	31 97       	sbiw	r30, 0x01	; 1
    23ee:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    23f0:	31 97       	sbiw	r30, 0x01	; 1
    23f2:	60 e8       	ldi	r22, 0x80	; 128
    23f4:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    23f6:	31 97       	sbiw	r30, 0x01	; 1
    23f8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    23fa:	31 97       	sbiw	r30, 0x01	; 1
    23fc:	62 e0       	ldi	r22, 0x02	; 2
    23fe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2400:	31 97       	sbiw	r30, 0x01	; 1
    2402:	63 e0       	ldi	r22, 0x03	; 3
    2404:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2406:	31 97       	sbiw	r30, 0x01	; 1
    2408:	64 e0       	ldi	r22, 0x04	; 4
    240a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    240c:	31 97       	sbiw	r30, 0x01	; 1
    240e:	65 e0       	ldi	r22, 0x05	; 5
    2410:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2412:	31 97       	sbiw	r30, 0x01	; 1
    2414:	66 e0       	ldi	r22, 0x06	; 6
    2416:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2418:	31 97       	sbiw	r30, 0x01	; 1
    241a:	67 e0       	ldi	r22, 0x07	; 7
    241c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    241e:	31 97       	sbiw	r30, 0x01	; 1
    2420:	68 e0       	ldi	r22, 0x08	; 8
    2422:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2424:	31 97       	sbiw	r30, 0x01	; 1
    2426:	69 e0       	ldi	r22, 0x09	; 9
    2428:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    242a:	31 97       	sbiw	r30, 0x01	; 1
    242c:	60 e1       	ldi	r22, 0x10	; 16
    242e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2430:	31 97       	sbiw	r30, 0x01	; 1
    2432:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2434:	31 97       	sbiw	r30, 0x01	; 1
    2436:	32 e1       	ldi	r19, 0x12	; 18
    2438:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    243a:	31 97       	sbiw	r30, 0x01	; 1
    243c:	33 e1       	ldi	r19, 0x13	; 19
    243e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2440:	31 97       	sbiw	r30, 0x01	; 1
    2442:	34 e1       	ldi	r19, 0x14	; 20
    2444:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2446:	31 97       	sbiw	r30, 0x01	; 1
    2448:	35 e1       	ldi	r19, 0x15	; 21
    244a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    244c:	31 97       	sbiw	r30, 0x01	; 1
    244e:	36 e1       	ldi	r19, 0x16	; 22
    2450:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2452:	31 97       	sbiw	r30, 0x01	; 1
    2454:	37 e1       	ldi	r19, 0x17	; 23
    2456:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2458:	31 97       	sbiw	r30, 0x01	; 1
    245a:	38 e1       	ldi	r19, 0x18	; 24
    245c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    245e:	31 97       	sbiw	r30, 0x01	; 1
    2460:	39 e1       	ldi	r19, 0x19	; 25
    2462:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2464:	31 97       	sbiw	r30, 0x01	; 1
    2466:	30 e2       	ldi	r19, 0x20	; 32
    2468:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    246a:	31 97       	sbiw	r30, 0x01	; 1
    246c:	31 e2       	ldi	r19, 0x21	; 33
    246e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2470:	31 97       	sbiw	r30, 0x01	; 1
    2472:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2474:	31 97       	sbiw	r30, 0x01	; 1
    2476:	23 e2       	ldi	r18, 0x23	; 35
    2478:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    247a:	31 97       	sbiw	r30, 0x01	; 1
    247c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    247e:	31 97       	sbiw	r30, 0x01	; 1
    2480:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2482:	31 97       	sbiw	r30, 0x01	; 1
    2484:	26 e2       	ldi	r18, 0x26	; 38
    2486:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2488:	31 97       	sbiw	r30, 0x01	; 1
    248a:	27 e2       	ldi	r18, 0x27	; 39
    248c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    248e:	31 97       	sbiw	r30, 0x01	; 1
    2490:	28 e2       	ldi	r18, 0x28	; 40
    2492:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2494:	31 97       	sbiw	r30, 0x01	; 1
    2496:	29 e2       	ldi	r18, 0x29	; 41
    2498:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    249a:	31 97       	sbiw	r30, 0x01	; 1
    249c:	20 e3       	ldi	r18, 0x30	; 48
    249e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    24a0:	31 97       	sbiw	r30, 0x01	; 1
    24a2:	21 e3       	ldi	r18, 0x31	; 49
    24a4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    24a6:	86 97       	sbiw	r24, 0x26	; 38
    24a8:	08 95       	ret

000024aa <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    24aa:	89 ef       	ldi	r24, 0xF9	; 249
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    24ae:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    24b2:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    24b6:	e0 e8       	ldi	r30, 0x80	; 128
    24b8:	f0 e0       	ldi	r31, 0x00	; 0
    24ba:	80 81       	ld	r24, Z
    24bc:	8c 7f       	andi	r24, 0xFC	; 252
    24be:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    24c0:	8b e0       	ldi	r24, 0x0B	; 11
    24c2:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    24c6:	ef e6       	ldi	r30, 0x6F	; 111
    24c8:	f0 e0       	ldi	r31, 0x00	; 0
    24ca:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    24cc:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    24ce:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    24d0:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    24d4:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    24d8:	cd 91       	ld	r28, X+
    24da:	cd bf       	out	0x3d, r28	; 61
    24dc:	dd 91       	ld	r29, X+
    24de:	de bf       	out	0x3e, r29	; 62
    24e0:	ff 91       	pop	r31
    24e2:	ef 91       	pop	r30
    24e4:	df 91       	pop	r29
    24e6:	cf 91       	pop	r28
    24e8:	bf 91       	pop	r27
    24ea:	af 91       	pop	r26
    24ec:	9f 91       	pop	r25
    24ee:	8f 91       	pop	r24
    24f0:	7f 91       	pop	r23
    24f2:	6f 91       	pop	r22
    24f4:	5f 91       	pop	r21
    24f6:	4f 91       	pop	r20
    24f8:	3f 91       	pop	r19
    24fa:	2f 91       	pop	r18
    24fc:	1f 91       	pop	r17
    24fe:	0f 91       	pop	r16
    2500:	ff 90       	pop	r15
    2502:	ef 90       	pop	r14
    2504:	df 90       	pop	r13
    2506:	cf 90       	pop	r12
    2508:	bf 90       	pop	r11
    250a:	af 90       	pop	r10
    250c:	9f 90       	pop	r9
    250e:	8f 90       	pop	r8
    2510:	7f 90       	pop	r7
    2512:	6f 90       	pop	r6
    2514:	5f 90       	pop	r5
    2516:	4f 90       	pop	r4
    2518:	3f 90       	pop	r3
    251a:	2f 90       	pop	r2
    251c:	1f 90       	pop	r1
    251e:	0f 90       	pop	r0
    2520:	0f be       	out	0x3f, r0	; 63
    2522:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2524:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	08 95       	ret

0000252a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    252a:	08 95       	ret

0000252c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    252c:	0f 92       	push	r0
    252e:	0f b6       	in	r0, 0x3f	; 63
    2530:	f8 94       	cli
    2532:	0f 92       	push	r0
    2534:	1f 92       	push	r1
    2536:	11 24       	eor	r1, r1
    2538:	2f 92       	push	r2
    253a:	3f 92       	push	r3
    253c:	4f 92       	push	r4
    253e:	5f 92       	push	r5
    2540:	6f 92       	push	r6
    2542:	7f 92       	push	r7
    2544:	8f 92       	push	r8
    2546:	9f 92       	push	r9
    2548:	af 92       	push	r10
    254a:	bf 92       	push	r11
    254c:	cf 92       	push	r12
    254e:	df 92       	push	r13
    2550:	ef 92       	push	r14
    2552:	ff 92       	push	r15
    2554:	0f 93       	push	r16
    2556:	1f 93       	push	r17
    2558:	2f 93       	push	r18
    255a:	3f 93       	push	r19
    255c:	4f 93       	push	r20
    255e:	5f 93       	push	r21
    2560:	6f 93       	push	r22
    2562:	7f 93       	push	r23
    2564:	8f 93       	push	r24
    2566:	9f 93       	push	r25
    2568:	af 93       	push	r26
    256a:	bf 93       	push	r27
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
    2570:	ef 93       	push	r30
    2572:	ff 93       	push	r31
    2574:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    2578:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    257c:	0d b6       	in	r0, 0x3d	; 61
    257e:	0d 92       	st	X+, r0
    2580:	0e b6       	in	r0, 0x3e	; 62
    2582:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2584:	0e 94 4c 05 	call	0xa98	; 0xa98 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2588:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    258c:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    2590:	cd 91       	ld	r28, X+
    2592:	cd bf       	out	0x3d, r28	; 61
    2594:	dd 91       	ld	r29, X+
    2596:	de bf       	out	0x3e, r29	; 62
    2598:	ff 91       	pop	r31
    259a:	ef 91       	pop	r30
    259c:	df 91       	pop	r29
    259e:	cf 91       	pop	r28
    25a0:	bf 91       	pop	r27
    25a2:	af 91       	pop	r26
    25a4:	9f 91       	pop	r25
    25a6:	8f 91       	pop	r24
    25a8:	7f 91       	pop	r23
    25aa:	6f 91       	pop	r22
    25ac:	5f 91       	pop	r21
    25ae:	4f 91       	pop	r20
    25b0:	3f 91       	pop	r19
    25b2:	2f 91       	pop	r18
    25b4:	1f 91       	pop	r17
    25b6:	0f 91       	pop	r16
    25b8:	ff 90       	pop	r15
    25ba:	ef 90       	pop	r14
    25bc:	df 90       	pop	r13
    25be:	cf 90       	pop	r12
    25c0:	bf 90       	pop	r11
    25c2:	af 90       	pop	r10
    25c4:	9f 90       	pop	r9
    25c6:	8f 90       	pop	r8
    25c8:	7f 90       	pop	r7
    25ca:	6f 90       	pop	r6
    25cc:	5f 90       	pop	r5
    25ce:	4f 90       	pop	r4
    25d0:	3f 90       	pop	r3
    25d2:	2f 90       	pop	r2
    25d4:	1f 90       	pop	r1
    25d6:	0f 90       	pop	r0
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	0f 90       	pop	r0

	asm volatile ( "ret" );
    25dc:	08 95       	ret

000025de <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    25de:	0f 92       	push	r0
    25e0:	0f b6       	in	r0, 0x3f	; 63
    25e2:	f8 94       	cli
    25e4:	0f 92       	push	r0
    25e6:	1f 92       	push	r1
    25e8:	11 24       	eor	r1, r1
    25ea:	2f 92       	push	r2
    25ec:	3f 92       	push	r3
    25ee:	4f 92       	push	r4
    25f0:	5f 92       	push	r5
    25f2:	6f 92       	push	r6
    25f4:	7f 92       	push	r7
    25f6:	8f 92       	push	r8
    25f8:	9f 92       	push	r9
    25fa:	af 92       	push	r10
    25fc:	bf 92       	push	r11
    25fe:	cf 92       	push	r12
    2600:	df 92       	push	r13
    2602:	ef 92       	push	r14
    2604:	ff 92       	push	r15
    2606:	0f 93       	push	r16
    2608:	1f 93       	push	r17
    260a:	2f 93       	push	r18
    260c:	3f 93       	push	r19
    260e:	4f 93       	push	r20
    2610:	5f 93       	push	r21
    2612:	6f 93       	push	r22
    2614:	7f 93       	push	r23
    2616:	8f 93       	push	r24
    2618:	9f 93       	push	r25
    261a:	af 93       	push	r26
    261c:	bf 93       	push	r27
    261e:	cf 93       	push	r28
    2620:	df 93       	push	r29
    2622:	ef 93       	push	r30
    2624:	ff 93       	push	r31
    2626:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    262a:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    262e:	0d b6       	in	r0, 0x3d	; 61
    2630:	0d 92       	st	X+, r0
    2632:	0e b6       	in	r0, 0x3e	; 62
    2634:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2636:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <xTaskIncrementTick>
    263a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    263c:	0e 94 4c 05 	call	0xa98	; 0xa98 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2640:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    2644:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    2648:	cd 91       	ld	r28, X+
    264a:	cd bf       	out	0x3d, r28	; 61
    264c:	dd 91       	ld	r29, X+
    264e:	de bf       	out	0x3e, r29	; 62
    2650:	ff 91       	pop	r31
    2652:	ef 91       	pop	r30
    2654:	df 91       	pop	r29
    2656:	cf 91       	pop	r28
    2658:	bf 91       	pop	r27
    265a:	af 91       	pop	r26
    265c:	9f 91       	pop	r25
    265e:	8f 91       	pop	r24
    2660:	7f 91       	pop	r23
    2662:	6f 91       	pop	r22
    2664:	5f 91       	pop	r21
    2666:	4f 91       	pop	r20
    2668:	3f 91       	pop	r19
    266a:	2f 91       	pop	r18
    266c:	1f 91       	pop	r17
    266e:	0f 91       	pop	r16
    2670:	ff 90       	pop	r15
    2672:	ef 90       	pop	r14
    2674:	df 90       	pop	r13
    2676:	cf 90       	pop	r12
    2678:	bf 90       	pop	r11
    267a:	af 90       	pop	r10
    267c:	9f 90       	pop	r9
    267e:	8f 90       	pop	r8
    2680:	7f 90       	pop	r7
    2682:	6f 90       	pop	r6
    2684:	5f 90       	pop	r5
    2686:	4f 90       	pop	r4
    2688:	3f 90       	pop	r3
    268a:	2f 90       	pop	r2
    268c:	1f 90       	pop	r1
    268e:	0f 90       	pop	r0
    2690:	0f be       	out	0x3f, r0	; 63
    2692:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2694:	08 95       	ret

00002696 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2696:	0e 94 ef 12 	call	0x25de	; 0x25de <vPortYieldFromTick>
		asm volatile ( "reti" );
    269a:	18 95       	reti

0000269c <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
}

int uart_transmit(char c, FILE *stream) {
    269c:	cf 93       	push	r28
    269e:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
    26a0:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    26a4:	85 fd       	sbrc	r24, 5
    26a6:	03 c0       	rjmp	.+6      	; 0x26ae <uart_transmit+0x12>
    26a8:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    26ac:	f9 cf       	rjmp	.-14     	; 0x26a0 <uart_transmit+0x4>
  UDR0 = c;
    26ae:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  return 0;
}
    26b2:	80 e0       	ldi	r24, 0x00	; 0
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	cf 91       	pop	r28
    26b8:	08 95       	ret

000026ba <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
    26ba:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    26be:	87 fd       	sbrc	r24, 7
    26c0:	03 c0       	rjmp	.+6      	; 0x26c8 <uart_receive+0xe>
    26c2:	0e 94 96 12 	call	0x252c	; 0x252c <vPortYield>
    26c6:	f9 cf       	rjmp	.-14     	; 0x26ba <uart_receive>
  return UDR0;
    26c8:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
    26cc:	90 e0       	ldi	r25, 0x00	; 0
    26ce:	08 95       	ret

000026d0 <uart_init>:
    26d0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    26d4:	87 e6       	ldi	r24, 0x67	; 103
    26d6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    26da:	e0 ec       	ldi	r30, 0xC0	; 192
    26dc:	f0 e0       	ldi	r31, 0x00	; 0
    26de:	80 81       	ld	r24, Z
    26e0:	8d 7f       	andi	r24, 0xFD	; 253
    26e2:	80 83       	st	Z, r24
    26e4:	86 e0       	ldi	r24, 0x06	; 6
    26e6:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    26ea:	88 e1       	ldi	r24, 0x18	; 24
    26ec:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    26f0:	08 95       	ret

000026f2 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    26f2:	ef 92       	push	r14
    26f4:	ff 92       	push	r15
    26f6:	0f 93       	push	r16
    26f8:	cf 93       	push	r28
    26fa:	df 93       	push	r29
    26fc:	00 d0       	rcall	.+0      	; 0x26fe <main+0xc>
    26fe:	00 d0       	rcall	.+0      	; 0x2700 <main+0xe>
    2700:	00 d0       	rcall	.+0      	; 0x2702 <main+0x10>
    2702:	cd b7       	in	r28, 0x3d	; 61
    2704:	de b7       	in	r29, 0x3e	; 62
  adc_init();
    2706:	0e 94 53 00 	call	0xa6	; 0xa6 <adc_init>
  sei();
    270a:	78 94       	sei
  // Create task.
  xTaskHandle adc0_handle;
  xTaskHandle adc1_handle;
  xTaskHandle adc2_handle;
  mutex_a = xSemaphoreCreateMutex();
    270c:	81 e0       	ldi	r24, 0x01	; 1
    270e:	0e 94 b9 0b 	call	0x1772	; 0x1772 <xQueueCreateMutex>
    2712:	90 93 a6 07 	sts	0x07A6, r25	; 0x8007a6 <mutex_a+0x1>
    2716:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <mutex_a>
  mutex_r = xSemaphoreCreateMutex();
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	0e 94 b9 0b 	call	0x1772	; 0x1772 <xQueueCreateMutex>
    2720:	90 93 a8 07 	sts	0x07A8, r25	; 0x8007a8 <mutex_r+0x1>
    2724:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <mutex_r>
  xSemaphoreTake(mutex_a, portMAX_DELAY);
    2728:	6f ef       	ldi	r22, 0xFF	; 255
    272a:	7f ef       	ldi	r23, 0xFF	; 255
    272c:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <mutex_a>
    2730:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <mutex_a+0x1>
    2734:	0e 94 b7 0c 	call	0x196e	; 0x196e <xQueueSemaphoreTake>

    xTaskCreate
    2738:	ce 01       	movw	r24, r28
    273a:	05 96       	adiw	r24, 0x05	; 5
    273c:	7c 01       	movw	r14, r24
    273e:	01 e0       	ldi	r16, 0x01	; 1
    2740:	20 e0       	ldi	r18, 0x00	; 0
    2742:	30 e0       	ldi	r19, 0x00	; 0
    2744:	45 e5       	ldi	r20, 0x55	; 85
    2746:	50 e0       	ldi	r21, 0x00	; 0
    2748:	60 e1       	ldi	r22, 0x10	; 16
    274a:	71 e0       	ldi	r23, 0x01	; 1
    274c:	88 e7       	ldi	r24, 0x78	; 120
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	0e 94 ae 01 	call	0x35c	; 0x35c <xTaskCreate>
         0,
         vADC_TASK_PRIORITY,
         &adc0_handle
        );

    xTaskCreate
    2754:	ce 01       	movw	r24, r28
    2756:	03 96       	adiw	r24, 0x03	; 3
    2758:	7c 01       	movw	r14, r24
    275a:	21 e0       	ldi	r18, 0x01	; 1
    275c:	30 e0       	ldi	r19, 0x00	; 0
    275e:	45 e5       	ldi	r20, 0x55	; 85
    2760:	50 e0       	ldi	r21, 0x00	; 0
    2762:	65 e1       	ldi	r22, 0x15	; 21
    2764:	71 e0       	ldi	r23, 0x01	; 1
    2766:	88 e7       	ldi	r24, 0x78	; 120
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	0e 94 ae 01 	call	0x35c	; 0x35c <xTaskCreate>
         1,
         vADC_TASK_PRIORITY,
         &adc1_handle
        );

    xTaskCreate
    276e:	ce 01       	movw	r24, r28
    2770:	01 96       	adiw	r24, 0x01	; 1
    2772:	7c 01       	movw	r14, r24
    2774:	22 e0       	ldi	r18, 0x02	; 2
    2776:	30 e0       	ldi	r19, 0x00	; 0
    2778:	45 e5       	ldi	r20, 0x55	; 85
    277a:	50 e0       	ldi	r21, 0x00	; 0
    277c:	6a e1       	ldi	r22, 0x1A	; 26
    277e:	71 e0       	ldi	r23, 0x01	; 1
    2780:	88 e7       	ldi	r24, 0x78	; 120
    2782:	90 e0       	ldi	r25, 0x00	; 0
    2784:	0e 94 ae 01 	call	0x35c	; 0x35c <xTaskCreate>
         vADC_TASK_PRIORITY,
         &adc2_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    2788:	0e 94 95 03 	call	0x72a	; 0x72a <vTaskStartScheduler>

    return 0;
}
    278c:	80 e0       	ldi	r24, 0x00	; 0
    278e:	90 e0       	ldi	r25, 0x00	; 0
    2790:	26 96       	adiw	r28, 0x06	; 6
    2792:	0f b6       	in	r0, 0x3f	; 63
    2794:	f8 94       	cli
    2796:	de bf       	out	0x3e, r29	; 62
    2798:	0f be       	out	0x3f, r0	; 63
    279a:	cd bf       	out	0x3d, r28	; 61
    279c:	df 91       	pop	r29
    279e:	cf 91       	pop	r28
    27a0:	0f 91       	pop	r16
    27a2:	ff 90       	pop	r15
    27a4:	ef 90       	pop	r14
    27a6:	08 95       	ret

000027a8 <memcpy>:
    27a8:	fb 01       	movw	r30, r22
    27aa:	dc 01       	movw	r26, r24
    27ac:	02 c0       	rjmp	.+4      	; 0x27b2 <memcpy+0xa>
    27ae:	01 90       	ld	r0, Z+
    27b0:	0d 92       	st	X+, r0
    27b2:	41 50       	subi	r20, 0x01	; 1
    27b4:	50 40       	sbci	r21, 0x00	; 0
    27b6:	d8 f7       	brcc	.-10     	; 0x27ae <memcpy+0x6>
    27b8:	08 95       	ret

000027ba <utoa>:
    27ba:	45 32       	cpi	r20, 0x25	; 37
    27bc:	51 05       	cpc	r21, r1
    27be:	20 f4       	brcc	.+8      	; 0x27c8 <utoa+0xe>
    27c0:	42 30       	cpi	r20, 0x02	; 2
    27c2:	10 f0       	brcs	.+4      	; 0x27c8 <utoa+0xe>
    27c4:	0c 94 e8 13 	jmp	0x27d0	; 0x27d0 <__utoa_ncheck>
    27c8:	fb 01       	movw	r30, r22
    27ca:	10 82       	st	Z, r1
    27cc:	cb 01       	movw	r24, r22
    27ce:	08 95       	ret

000027d0 <__utoa_ncheck>:
    27d0:	bb 27       	eor	r27, r27

000027d2 <__utoa_common>:
    27d2:	fb 01       	movw	r30, r22
    27d4:	55 27       	eor	r21, r21
    27d6:	aa 27       	eor	r26, r26
    27d8:	88 0f       	add	r24, r24
    27da:	99 1f       	adc	r25, r25
    27dc:	aa 1f       	adc	r26, r26
    27de:	a4 17       	cp	r26, r20
    27e0:	10 f0       	brcs	.+4      	; 0x27e6 <__utoa_common+0x14>
    27e2:	a4 1b       	sub	r26, r20
    27e4:	83 95       	inc	r24
    27e6:	50 51       	subi	r21, 0x10	; 16
    27e8:	b9 f7       	brne	.-18     	; 0x27d8 <__utoa_common+0x6>
    27ea:	a0 5d       	subi	r26, 0xD0	; 208
    27ec:	aa 33       	cpi	r26, 0x3A	; 58
    27ee:	08 f0       	brcs	.+2      	; 0x27f2 <__utoa_common+0x20>
    27f0:	a9 5d       	subi	r26, 0xD9	; 217
    27f2:	a1 93       	st	Z+, r26
    27f4:	00 97       	sbiw	r24, 0x00	; 0
    27f6:	79 f7       	brne	.-34     	; 0x27d6 <__utoa_common+0x4>
    27f8:	b1 11       	cpse	r27, r1
    27fa:	b1 93       	st	Z+, r27
    27fc:	11 92       	st	Z+, r1
    27fe:	cb 01       	movw	r24, r22
    2800:	0c 94 6e 14 	jmp	0x28dc	; 0x28dc <strrev>

00002804 <fputc>:
    2804:	0f 93       	push	r16
    2806:	1f 93       	push	r17
    2808:	cf 93       	push	r28
    280a:	df 93       	push	r29
    280c:	fb 01       	movw	r30, r22
    280e:	23 81       	ldd	r18, Z+3	; 0x03
    2810:	21 fd       	sbrc	r18, 1
    2812:	03 c0       	rjmp	.+6      	; 0x281a <fputc+0x16>
    2814:	8f ef       	ldi	r24, 0xFF	; 255
    2816:	9f ef       	ldi	r25, 0xFF	; 255
    2818:	2c c0       	rjmp	.+88     	; 0x2872 <fputc+0x6e>
    281a:	22 ff       	sbrs	r18, 2
    281c:	16 c0       	rjmp	.+44     	; 0x284a <fputc+0x46>
    281e:	46 81       	ldd	r20, Z+6	; 0x06
    2820:	57 81       	ldd	r21, Z+7	; 0x07
    2822:	24 81       	ldd	r18, Z+4	; 0x04
    2824:	35 81       	ldd	r19, Z+5	; 0x05
    2826:	42 17       	cp	r20, r18
    2828:	53 07       	cpc	r21, r19
    282a:	44 f4       	brge	.+16     	; 0x283c <fputc+0x38>
    282c:	a0 81       	ld	r26, Z
    282e:	b1 81       	ldd	r27, Z+1	; 0x01
    2830:	9d 01       	movw	r18, r26
    2832:	2f 5f       	subi	r18, 0xFF	; 255
    2834:	3f 4f       	sbci	r19, 0xFF	; 255
    2836:	31 83       	std	Z+1, r19	; 0x01
    2838:	20 83       	st	Z, r18
    283a:	8c 93       	st	X, r24
    283c:	26 81       	ldd	r18, Z+6	; 0x06
    283e:	37 81       	ldd	r19, Z+7	; 0x07
    2840:	2f 5f       	subi	r18, 0xFF	; 255
    2842:	3f 4f       	sbci	r19, 0xFF	; 255
    2844:	37 83       	std	Z+7, r19	; 0x07
    2846:	26 83       	std	Z+6, r18	; 0x06
    2848:	14 c0       	rjmp	.+40     	; 0x2872 <fputc+0x6e>
    284a:	8b 01       	movw	r16, r22
    284c:	ec 01       	movw	r28, r24
    284e:	fb 01       	movw	r30, r22
    2850:	00 84       	ldd	r0, Z+8	; 0x08
    2852:	f1 85       	ldd	r31, Z+9	; 0x09
    2854:	e0 2d       	mov	r30, r0
    2856:	09 95       	icall
    2858:	89 2b       	or	r24, r25
    285a:	e1 f6       	brne	.-72     	; 0x2814 <fputc+0x10>
    285c:	d8 01       	movw	r26, r16
    285e:	16 96       	adiw	r26, 0x06	; 6
    2860:	8d 91       	ld	r24, X+
    2862:	9c 91       	ld	r25, X
    2864:	17 97       	sbiw	r26, 0x07	; 7
    2866:	01 96       	adiw	r24, 0x01	; 1
    2868:	17 96       	adiw	r26, 0x07	; 7
    286a:	9c 93       	st	X, r25
    286c:	8e 93       	st	-X, r24
    286e:	16 97       	sbiw	r26, 0x06	; 6
    2870:	ce 01       	movw	r24, r28
    2872:	df 91       	pop	r29
    2874:	cf 91       	pop	r28
    2876:	1f 91       	pop	r17
    2878:	0f 91       	pop	r16
    287a:	08 95       	ret

0000287c <puts>:
    287c:	0f 93       	push	r16
    287e:	1f 93       	push	r17
    2880:	cf 93       	push	r28
    2882:	df 93       	push	r29
    2884:	e0 91 ab 07 	lds	r30, 0x07AB	; 0x8007ab <__iob+0x2>
    2888:	f0 91 ac 07 	lds	r31, 0x07AC	; 0x8007ac <__iob+0x3>
    288c:	23 81       	ldd	r18, Z+3	; 0x03
    288e:	21 ff       	sbrs	r18, 1
    2890:	1b c0       	rjmp	.+54     	; 0x28c8 <puts+0x4c>
    2892:	8c 01       	movw	r16, r24
    2894:	d0 e0       	ldi	r29, 0x00	; 0
    2896:	c0 e0       	ldi	r28, 0x00	; 0
    2898:	f8 01       	movw	r30, r16
    289a:	81 91       	ld	r24, Z+
    289c:	8f 01       	movw	r16, r30
    289e:	60 91 ab 07 	lds	r22, 0x07AB	; 0x8007ab <__iob+0x2>
    28a2:	70 91 ac 07 	lds	r23, 0x07AC	; 0x8007ac <__iob+0x3>
    28a6:	db 01       	movw	r26, r22
    28a8:	18 96       	adiw	r26, 0x08	; 8
    28aa:	ed 91       	ld	r30, X+
    28ac:	fc 91       	ld	r31, X
    28ae:	19 97       	sbiw	r26, 0x09	; 9
    28b0:	88 23       	and	r24, r24
    28b2:	31 f0       	breq	.+12     	; 0x28c0 <puts+0x44>
    28b4:	09 95       	icall
    28b6:	89 2b       	or	r24, r25
    28b8:	79 f3       	breq	.-34     	; 0x2898 <puts+0x1c>
    28ba:	df ef       	ldi	r29, 0xFF	; 255
    28bc:	cf ef       	ldi	r28, 0xFF	; 255
    28be:	ec cf       	rjmp	.-40     	; 0x2898 <puts+0x1c>
    28c0:	8a e0       	ldi	r24, 0x0A	; 10
    28c2:	09 95       	icall
    28c4:	89 2b       	or	r24, r25
    28c6:	19 f0       	breq	.+6      	; 0x28ce <puts+0x52>
    28c8:	8f ef       	ldi	r24, 0xFF	; 255
    28ca:	9f ef       	ldi	r25, 0xFF	; 255
    28cc:	02 c0       	rjmp	.+4      	; 0x28d2 <puts+0x56>
    28ce:	8d 2f       	mov	r24, r29
    28d0:	9c 2f       	mov	r25, r28
    28d2:	df 91       	pop	r29
    28d4:	cf 91       	pop	r28
    28d6:	1f 91       	pop	r17
    28d8:	0f 91       	pop	r16
    28da:	08 95       	ret

000028dc <strrev>:
    28dc:	dc 01       	movw	r26, r24
    28de:	fc 01       	movw	r30, r24
    28e0:	67 2f       	mov	r22, r23
    28e2:	71 91       	ld	r23, Z+
    28e4:	77 23       	and	r23, r23
    28e6:	e1 f7       	brne	.-8      	; 0x28e0 <strrev+0x4>
    28e8:	32 97       	sbiw	r30, 0x02	; 2
    28ea:	04 c0       	rjmp	.+8      	; 0x28f4 <strrev+0x18>
    28ec:	7c 91       	ld	r23, X
    28ee:	6d 93       	st	X+, r22
    28f0:	70 83       	st	Z, r23
    28f2:	62 91       	ld	r22, -Z
    28f4:	ae 17       	cp	r26, r30
    28f6:	bf 07       	cpc	r27, r31
    28f8:	c8 f3       	brcs	.-14     	; 0x28ec <strrev+0x10>
    28fa:	08 95       	ret

000028fc <_exit>:
    28fc:	f8 94       	cli

000028fe <__stop_program>:
    28fe:	ff cf       	rjmp	.-2      	; 0x28fe <__stop_program>
