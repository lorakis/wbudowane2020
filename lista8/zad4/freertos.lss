
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00002930  000029c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002930  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068d  00800124  00800124  000029e8  2**0
                  ALLOC
  3 .stab         00007dd0  00000000  00000000  000029e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004677  00000000  00000000  0000a7b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000ee2f  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000ee40  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000ee80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000f474  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000fa16  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000fa30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 64 13 	jmp	0x26c8	; 0x26c8 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 f7 00 	jmp	0x1ee	; 0x1ee <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e3       	ldi	r30, 0x30	; 48
      7c:	f9 e2       	ldi	r31, 0x29	; 41
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a4 32       	cpi	r26, 0x24	; 36
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a4 e2       	ldi	r26, 0x24	; 36
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a1 3b       	cpi	r26, 0xB1	; 177
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 92 13 	call	0x2724	; 0x2724 <main>
      9e:	0c 94 96 14 	jmp	0x292c	; 0x292c <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <adc_init>:
SemaphoreHandle_t mutex_r, mutex_a, mutex_z;
uint8_t i = 0;

void adc_init()
{
  ADMUX = _BV(REFS0); // ref wyjscia na ADC0
      a6:	80 e4       	ldi	r24, 0x40	; 64
      a8:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
  DIDR0 = _BV(ADC0D) | _BV(ADC1D) | _BV(ADC2D); // włączamy A0 A1 A2
      ac:	87 e0       	ldi	r24, 0x07	; 7
      ae:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
  ADCSRA  = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2); // preskaler 128
      b2:	ea e7       	ldi	r30, 0x7A	; 122
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 83       	st	Z, r24
  ADCSRA |= _BV(ADIE); // ADC interrupt enable
      b8:	80 81       	ld	r24, Z
      ba:	88 60       	ori	r24, 0x08	; 8
      bc:	80 83       	st	Z, r24
  ADCSRA |= _BV(ADEN); // włącz ADC
      be:	80 81       	ld	r24, Z
      c0:	80 68       	ori	r24, 0x80	; 128
      c2:	80 83       	st	Z, r24
      c4:	08 95       	ret

000000c6 <readADC>:
}

uint16_t readADC(uint8_t mux)
{
      c6:	cf 93       	push	r28
      c8:	df 93       	push	r29
      ca:	c8 2f       	mov	r28, r24
  xSemaphoreTake(mutex_z, portMAX_DELAY);
      cc:	6f ef       	ldi	r22, 0xFF	; 255
      ce:	7f ef       	ldi	r23, 0xFF	; 255
      d0:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <mutex_z>
      d4:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <mutex_z+0x1>
      d8:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueSemaphoreTake>
  ADMUX = _BV(REFS0) | mux;
      dc:	c0 64       	ori	r28, 0x40	; 64
      de:	c0 93 7c 00 	sts	0x007C, r28	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
  ADCSRA |= _BV(ADSC);
      e2:	ea e7       	ldi	r30, 0x7A	; 122
      e4:	f0 e0       	ldi	r31, 0x00	; 0
      e6:	80 81       	ld	r24, Z
      e8:	80 64       	ori	r24, 0x40	; 64
      ea:	80 83       	st	Z, r24
  xSemaphoreTake(mutex_a, portMAX_DELAY); // blokada na mutex a
      ec:	6f ef       	ldi	r22, 0xFF	; 255
      ee:	7f ef       	ldi	r23, 0xFF	; 255
      f0:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <mutex_a>
      f4:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <mutex_a+0x1>
      f8:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueSemaphoreTake>
  uint16_t w = ADC;
      fc:	c0 91 78 00 	lds	r28, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     100:	d0 91 79 00 	lds	r29, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
  xSemaphoreGive(mutex_z);
     104:	20 e0       	ldi	r18, 0x00	; 0
     106:	40 e0       	ldi	r20, 0x00	; 0
     108:	50 e0       	ldi	r21, 0x00	; 0
     10a:	60 e0       	ldi	r22, 0x00	; 0
     10c:	70 e0       	ldi	r23, 0x00	; 0
     10e:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <mutex_z>
     112:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <mutex_z+0x1>
     116:	0e 94 3c 0b 	call	0x1678	; 0x1678 <xQueueGenericSend>
  return w;
}
     11a:	ce 01       	movw	r24, r28
     11c:	df 91       	pop	r29
     11e:	cf 91       	pop	r28
     120:	08 95       	ret

00000122 <vADC>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vADC(void* pvParameters)
{
     122:	cf 93       	push	r28
     124:	df 93       	push	r29
     126:	00 d0       	rcall	.+0      	; 0x128 <vADC+0x6>
     128:	00 d0       	rcall	.+0      	; 0x12a <vADC+0x8>
     12a:	1f 92       	push	r1
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62
     130:	8c 01       	movw	r16, r24
  uart_init();
     132:	0e 94 81 13 	call	0x2702	; 0x2702 <uart_init>
  stdin = stdout = stderr = &uart_file;
     136:	80 e0       	ldi	r24, 0x00	; 0
     138:	91 e0       	ldi	r25, 0x01	; 1
     13a:	90 93 b0 07 	sts	0x07B0, r25	; 0x8007b0 <__iob+0x5>
     13e:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <__iob+0x4>
     142:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <__iob+0x3>
     146:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <__iob+0x2>
     14a:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <__iob+0x1>
     14e:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <__iob>
  uint8_t port = (uint8_t)pvParameters;
     152:	b0 2e       	mov	r11, r16
    utoa(value, result, 10);
    putchar(':');
    puts(result);
    puts("\r");
    xSemaphoreGive(mutex_r); // zwolnienie r
    vTaskDelay(((port*100)+3000) / portTICK_PERIOD_MS);
     154:	78 01       	movw	r14, r16
     156:	ff 24       	eor	r15, r15
     158:	84 e6       	ldi	r24, 0x64	; 100
     15a:	08 9f       	mul	r16, r24
     15c:	80 01       	movw	r16, r0
     15e:	11 24       	eor	r1, r1
     160:	08 54       	subi	r16, 0x48	; 72
     162:	14 4f       	sbci	r17, 0xF4	; 244
  while (1)
  {
    xSemaphoreTake(mutex_r, portMAX_DELAY); // blokada mutexu r
    value = readADC(port);
    putchar('A');
    putchar('0'+port);
     164:	80 e3       	ldi	r24, 0x30	; 48
     166:	e8 0e       	add	r14, r24
     168:	f1 1c       	adc	r15, r1
  uint8_t port = (uint8_t)pvParameters;
  uint16_t value;
  char result[5];
  while (1)
  {
    xSemaphoreTake(mutex_r, portMAX_DELAY); // blokada mutexu r
     16a:	6f ef       	ldi	r22, 0xFF	; 255
     16c:	7f ef       	ldi	r23, 0xFF	; 255
     16e:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <mutex_r>
     172:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <mutex_r+0x1>
     176:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueSemaphoreTake>
    value = readADC(port);
     17a:	8b 2d       	mov	r24, r11
     17c:	0e 94 63 00 	call	0xc6	; 0xc6 <readADC>
     180:	6c 01       	movw	r12, r24
    putchar('A');
     182:	60 91 ad 07 	lds	r22, 0x07AD	; 0x8007ad <__iob+0x2>
     186:	70 91 ae 07 	lds	r23, 0x07AE	; 0x8007ae <__iob+0x3>
     18a:	81 e4       	ldi	r24, 0x41	; 65
     18c:	90 e0       	ldi	r25, 0x00	; 0
     18e:	0e 94 1a 14 	call	0x2834	; 0x2834 <fputc>
    putchar('0'+port);
     192:	60 91 ad 07 	lds	r22, 0x07AD	; 0x8007ad <__iob+0x2>
     196:	70 91 ae 07 	lds	r23, 0x07AE	; 0x8007ae <__iob+0x3>
     19a:	c7 01       	movw	r24, r14
     19c:	0e 94 1a 14 	call	0x2834	; 0x2834 <fputc>
    utoa(value, result, 10);
     1a0:	4a e0       	ldi	r20, 0x0A	; 10
     1a2:	50 e0       	ldi	r21, 0x00	; 0
     1a4:	be 01       	movw	r22, r28
     1a6:	6f 5f       	subi	r22, 0xFF	; 255
     1a8:	7f 4f       	sbci	r23, 0xFF	; 255
     1aa:	c6 01       	movw	r24, r12
     1ac:	0e 94 f5 13 	call	0x27ea	; 0x27ea <utoa>
    putchar(':');
     1b0:	60 91 ad 07 	lds	r22, 0x07AD	; 0x8007ad <__iob+0x2>
     1b4:	70 91 ae 07 	lds	r23, 0x07AE	; 0x8007ae <__iob+0x3>
     1b8:	8a e3       	ldi	r24, 0x3A	; 58
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	0e 94 1a 14 	call	0x2834	; 0x2834 <fputc>
    puts(result);
     1c0:	ce 01       	movw	r24, r28
     1c2:	01 96       	adiw	r24, 0x01	; 1
     1c4:	0e 94 56 14 	call	0x28ac	; 0x28ac <puts>
    puts("\r");
     1c8:	8e e0       	ldi	r24, 0x0E	; 14
     1ca:	91 e0       	ldi	r25, 0x01	; 1
     1cc:	0e 94 56 14 	call	0x28ac	; 0x28ac <puts>
    xSemaphoreGive(mutex_r); // zwolnienie r
     1d0:	20 e0       	ldi	r18, 0x00	; 0
     1d2:	40 e0       	ldi	r20, 0x00	; 0
     1d4:	50 e0       	ldi	r21, 0x00	; 0
     1d6:	60 e0       	ldi	r22, 0x00	; 0
     1d8:	70 e0       	ldi	r23, 0x00	; 0
     1da:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <mutex_r>
     1de:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <mutex_r+0x1>
     1e2:	0e 94 3c 0b 	call	0x1678	; 0x1678 <xQueueGenericSend>
    vTaskDelay(((port*100)+3000) / portTICK_PERIOD_MS);
     1e6:	c8 01       	movw	r24, r16
     1e8:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vTaskDelay>
     1ec:	be cf       	rjmp	.-132    	; 0x16a <vADC+0x48>

000001ee <__vector_21>:
  xSemaphoreGive(mutex_z);
  return w;
}

ISR(ADC_vect)
{
     1ee:	1f 92       	push	r1
     1f0:	0f 92       	push	r0
     1f2:	0f b6       	in	r0, 0x3f	; 63
     1f4:	0f 92       	push	r0
     1f6:	11 24       	eor	r1, r1
     1f8:	2f 93       	push	r18
     1fa:	3f 93       	push	r19
     1fc:	4f 93       	push	r20
     1fe:	5f 93       	push	r21
     200:	6f 93       	push	r22
     202:	7f 93       	push	r23
     204:	8f 93       	push	r24
     206:	9f 93       	push	r25
     208:	af 93       	push	r26
     20a:	bf 93       	push	r27
     20c:	ef 93       	push	r30
     20e:	ff 93       	push	r31
  xSemaphoreGiveFromISR(mutex_a, NULL); // odblokuj mutex a
     210:	60 e0       	ldi	r22, 0x00	; 0
     212:	70 e0       	ldi	r23, 0x00	; 0
     214:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <mutex_a>
     218:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <mutex_a+0x1>
     21c:	0e 94 1b 0c 	call	0x1836	; 0x1836 <xQueueGiveFromISR>
}
     220:	ff 91       	pop	r31
     222:	ef 91       	pop	r30
     224:	bf 91       	pop	r27
     226:	af 91       	pop	r26
     228:	9f 91       	pop	r25
     22a:	8f 91       	pop	r24
     22c:	7f 91       	pop	r23
     22e:	6f 91       	pop	r22
     230:	5f 91       	pop	r21
     232:	4f 91       	pop	r20
     234:	3f 91       	pop	r19
     236:	2f 91       	pop	r18
     238:	0f 90       	pop	r0
     23a:	0f be       	out	0x3f, r0	; 63
     23c:	0f 90       	pop	r0
     23e:	1f 90       	pop	r1
     240:	18 95       	reti

00000242 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     242:	08 95       	ret

00000244 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     244:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     248:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     24c:	80 81       	ld	r24, Z
     24e:	81 11       	cpse	r24, r1
     250:	03 c0       	rjmp	.+6      	; 0x258 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     252:	8f ef       	ldi	r24, 0xFF	; 255
     254:	9f ef       	ldi	r25, 0xFF	; 255
     256:	0c c0       	rjmp	.+24     	; 0x270 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     258:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     25c:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     260:	05 80       	ldd	r0, Z+5	; 0x05
     262:	f6 81       	ldd	r31, Z+6	; 0x06
     264:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     266:	06 80       	ldd	r0, Z+6	; 0x06
     268:	f7 81       	ldd	r31, Z+7	; 0x07
     26a:	e0 2d       	mov	r30, r0
     26c:	82 81       	ldd	r24, Z+2	; 0x02
     26e:	93 81       	ldd	r25, Z+3	; 0x03
     270:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <xNextTaskUnblockTime+0x1>
     274:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <xNextTaskUnblockTime>
     278:	08 95       	ret

0000027a <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	ec 01       	movw	r28, r24
     286:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     288:	00 91 32 01 	lds	r16, 0x0132	; 0x800132 <xTickCount>
     28c:	10 91 33 01 	lds	r17, 0x0133	; 0x800133 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     290:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     294:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     298:	02 96       	adiw	r24, 0x02	; 2
     29a:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     29e:	cf 3f       	cpi	r28, 0xFF	; 255
     2a0:	8f ef       	ldi	r24, 0xFF	; 255
     2a2:	d8 07       	cpc	r29, r24
     2a4:	89 f4       	brne	.+34     	; 0x2c8 <prvAddCurrentTaskToDelayedList+0x4e>
     2a6:	ff 20       	and	r15, r15
     2a8:	79 f0       	breq	.+30     	; 0x2c8 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2aa:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     2ae:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     2b2:	6e 5f       	subi	r22, 0xFE	; 254
     2b4:	7f 4f       	sbci	r23, 0xFF	; 255
     2b6:	85 e3       	ldi	r24, 0x35	; 53
     2b8:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	1f 91       	pop	r17
     2c0:	0f 91       	pop	r16
     2c2:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2c4:	0c 94 7e 0f 	jmp	0x1efc	; 0x1efc <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     2c8:	c0 0f       	add	r28, r16
     2ca:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     2cc:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     2d0:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     2d4:	d3 83       	std	Z+3, r29	; 0x03
     2d6:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2d8:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     2dc:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     2e0:	c0 17       	cp	r28, r16
     2e2:	d1 07       	cpc	r29, r17
     2e4:	68 f4       	brcc	.+26     	; 0x300 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2e6:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <pxOverflowDelayedTaskList>
     2ea:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     2ee:	6e 5f       	subi	r22, 0xFE	; 254
     2f0:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2f2:	df 91       	pop	r29
     2f4:	cf 91       	pop	r28
     2f6:	1f 91       	pop	r17
     2f8:	0f 91       	pop	r16
     2fa:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2fc:	0c 94 9f 0f 	jmp	0x1f3e	; 0x1f3e <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     300:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <pxDelayedTaskList>
     304:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     308:	6e 5f       	subi	r22, 0xFE	; 254
     30a:	7f 4f       	sbci	r23, 0xFF	; 255
     30c:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     310:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <xNextTaskUnblockTime>
     314:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <xNextTaskUnblockTime+0x1>
     318:	c8 17       	cp	r28, r24
     31a:	d9 07       	cpc	r29, r25
     31c:	20 f4       	brcc	.+8      	; 0x326 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     31e:	d0 93 2b 01 	sts	0x012B, r29	; 0x80012b <xNextTaskUnblockTime+0x1>
     322:	c0 93 2a 01 	sts	0x012A, r28	; 0x80012a <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     326:	df 91       	pop	r29
     328:	cf 91       	pop	r28
     32a:	1f 91       	pop	r17
     32c:	0f 91       	pop	r16
     32e:	ff 90       	pop	r15
     330:	08 95       	ret

00000332 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     332:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     336:	88 23       	and	r24, r24
     338:	09 f1       	breq	.+66     	; 0x37c <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     33a:	0f b6       	in	r0, 0x3f	; 63
     33c:	f8 94       	cli
     33e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     340:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <xTasksWaitingTermination+0x5>
     344:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <xTasksWaitingTermination+0x6>
     348:	c6 81       	ldd	r28, Z+6	; 0x06
     34a:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     34c:	ce 01       	movw	r24, r28
     34e:	02 96       	adiw	r24, 0x02	; 2
     350:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
				--uxCurrentNumberOfTasks;
     354:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     358:	81 50       	subi	r24, 0x01	; 1
     35a:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     35e:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     362:	81 50       	subi	r24, 0x01	; 1
     364:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     368:	0f 90       	pop	r0
     36a:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     36c:	8f 89       	ldd	r24, Y+23	; 0x17
     36e:	98 8d       	ldd	r25, Y+24	; 0x18
     370:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vPortFree>
			vPortFree( pxTCB );
     374:	ce 01       	movw	r24, r28
     376:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vPortFree>
     37a:	db cf       	rjmp	.-74     	; 0x332 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     37c:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <pxReadyTasksLists>
     380:	82 30       	cpi	r24, 0x02	; 2
     382:	10 f0       	brcs	.+4      	; 0x388 <prvIdleTask+0x56>
			{
				taskYIELD();
     384:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     388:	0e 94 21 01 	call	0x242	; 0x242 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     38c:	d2 cf       	rjmp	.-92     	; 0x332 <prvIdleTask>

0000038e <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     38e:	3f 92       	push	r3
     390:	4f 92       	push	r4
     392:	5f 92       	push	r5
     394:	6f 92       	push	r6
     396:	7f 92       	push	r7
     398:	8f 92       	push	r8
     39a:	9f 92       	push	r9
     39c:	af 92       	push	r10
     39e:	bf 92       	push	r11
     3a0:	cf 92       	push	r12
     3a2:	df 92       	push	r13
     3a4:	ef 92       	push	r14
     3a6:	ff 92       	push	r15
     3a8:	0f 93       	push	r16
     3aa:	1f 93       	push	r17
     3ac:	cf 93       	push	r28
     3ae:	df 93       	push	r29
     3b0:	4c 01       	movw	r8, r24
     3b2:	16 2f       	mov	r17, r22
     3b4:	37 2e       	mov	r3, r23
     3b6:	6a 01       	movw	r12, r20
     3b8:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     3ba:	ca 01       	movw	r24, r20
     3bc:	0e 94 c1 11 	call	0x2382	; 0x2382 <pvPortMalloc>
     3c0:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     3c2:	89 2b       	or	r24, r25
     3c4:	09 f4       	brne	.+2      	; 0x3c8 <xTaskCreate+0x3a>
     3c6:	d3 c0       	rjmp	.+422    	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     3c8:	88 e2       	ldi	r24, 0x28	; 40
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	0e 94 c1 11 	call	0x2382	; 0x2382 <pvPortMalloc>
     3d0:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     3d2:	89 2b       	or	r24, r25
     3d4:	79 f0       	breq	.+30     	; 0x3f4 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     3d6:	58 8e       	std	Y+24, r5	; 0x18
     3d8:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     3da:	c6 01       	movw	r24, r12
     3dc:	01 97       	sbiw	r24, 0x01	; 1
     3de:	32 01       	movw	r6, r4
     3e0:	68 0e       	add	r6, r24
     3e2:	79 1e       	adc	r7, r25
     3e4:	be 01       	movw	r22, r28
     3e6:	67 5e       	subi	r22, 0xE7	; 231
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	e1 2f       	mov	r30, r17
     3ec:	f3 2d       	mov	r31, r3
     3ee:	cf 01       	movw	r24, r30
     3f0:	08 96       	adiw	r24, 0x08	; 8
     3f2:	07 c0       	rjmp	.+14     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     3f4:	c2 01       	movw	r24, r4
     3f6:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vPortFree>
     3fa:	b9 c0       	rjmp	.+370    	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     3fc:	e8 17       	cp	r30, r24
     3fe:	f9 07       	cpc	r31, r25
     400:	49 f0       	breq	.+18     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     402:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     404:	41 91       	ld	r20, Z+
     406:	db 01       	movw	r26, r22
     408:	4d 93       	st	X+, r20
     40a:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     40c:	d9 01       	movw	r26, r18
     40e:	2c 91       	ld	r18, X
     410:	21 11       	cpse	r18, r1
     412:	f4 cf       	rjmp	.-24     	; 0x3fc <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     414:	18 a2       	std	Y+32, r1	; 0x20
     416:	04 30       	cpi	r16, 0x04	; 4
     418:	08 f0       	brcs	.+2      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
     41a:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     41c:	0e 8b       	std	Y+22, r16	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
     41e:	09 a3       	std	Y+33, r16	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
     420:	1a a2       	std	Y+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     422:	6e 01       	movw	r12, r28
     424:	b2 e0       	ldi	r27, 0x02	; 2
     426:	cb 0e       	add	r12, r27
     428:	d1 1c       	adc	r13, r1
     42a:	c6 01       	movw	r24, r12
     42c:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     430:	ce 01       	movw	r24, r28
     432:	0c 96       	adiw	r24, 0x0c	; 12
     434:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     438:	d9 87       	std	Y+9, r29	; 0x09
     43a:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     43c:	84 e0       	ldi	r24, 0x04	; 4
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	80 1b       	sub	r24, r16
     442:	91 09       	sbc	r25, r1
     444:	9d 87       	std	Y+13, r25	; 0x0d
     446:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     448:	db 8b       	std	Y+19, r29	; 0x13
     44a:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     44c:	1b a2       	std	Y+35, r1	; 0x23
     44e:	1c a2       	std	Y+36, r1	; 0x24
     450:	1d a2       	std	Y+37, r1	; 0x25
     452:	1e a2       	std	Y+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     454:	1f a2       	std	Y+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     456:	a5 01       	movw	r20, r10
     458:	b4 01       	movw	r22, r8
     45a:	c3 01       	movw	r24, r6
     45c:	0e 94 02 12 	call	0x2404	; 0x2404 <pxPortInitialiseStack>
     460:	99 83       	std	Y+1, r25	; 0x01
     462:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     464:	e1 14       	cp	r14, r1
     466:	f1 04       	cpc	r15, r1
     468:	19 f0       	breq	.+6      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     46a:	f7 01       	movw	r30, r14
     46c:	d1 83       	std	Z+1, r29	; 0x01
     46e:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     470:	0f b6       	in	r0, 0x3f	; 63
     472:	f8 94       	cli
     474:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     476:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     47a:	8f 5f       	subi	r24, 0xFF	; 255
     47c:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     480:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     484:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     488:	89 2b       	or	r24, r25
     48a:	d1 f5       	brne	.+116    	; 0x500 <__LOCK_REGION_LENGTH__+0x100>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     48c:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <pxCurrentTCB+0x1>
     490:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     494:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     498:	81 30       	cpi	r24, 0x01	; 1
     49a:	09 f0       	breq	.+2      	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
     49c:	41 c0       	rjmp	.+130    	; 0x520 <__LOCK_REGION_LENGTH__+0x120>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     49e:	87 e6       	ldi	r24, 0x67	; 103
     4a0:	91 e0       	ldi	r25, 0x01	; 1
     4a2:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
     4a6:	80 e7       	ldi	r24, 0x70	; 112
     4a8:	91 e0       	ldi	r25, 0x01	; 1
     4aa:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
     4ae:	89 e7       	ldi	r24, 0x79	; 121
     4b0:	91 e0       	ldi	r25, 0x01	; 1
     4b2:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
     4b6:	82 e8       	ldi	r24, 0x82	; 130
     4b8:	91 e0       	ldi	r25, 0x01	; 1
     4ba:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     4be:	8e e5       	ldi	r24, 0x5E	; 94
     4c0:	91 e0       	ldi	r25, 0x01	; 1
     4c2:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     4c6:	85 e5       	ldi	r24, 0x55	; 85
     4c8:	91 e0       	ldi	r25, 0x01	; 1
     4ca:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     4ce:	88 e4       	ldi	r24, 0x48	; 72
     4d0:	91 e0       	ldi	r25, 0x01	; 1
     4d2:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     4d6:	8f e3       	ldi	r24, 0x3F	; 63
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     4de:	85 e3       	ldi	r24, 0x35	; 53
     4e0:	91 e0       	ldi	r25, 0x01	; 1
     4e2:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     4e6:	8e e5       	ldi	r24, 0x5E	; 94
     4e8:	91 e0       	ldi	r25, 0x01	; 1
     4ea:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <pxDelayedTaskList+0x1>
     4ee:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     4f2:	85 e5       	ldi	r24, 0x55	; 85
     4f4:	91 e0       	ldi	r25, 0x01	; 1
     4f6:	90 93 52 01 	sts	0x0152, r25	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     4fa:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <pxOverflowDelayedTaskList>
     4fe:	10 c0       	rjmp	.+32     	; 0x520 <__LOCK_REGION_LENGTH__+0x120>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     500:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     504:	81 11       	cpse	r24, r1
     506:	0c c0       	rjmp	.+24     	; 0x520 <__LOCK_REGION_LENGTH__+0x120>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     508:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     50c:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     510:	96 89       	ldd	r25, Z+22	; 0x16
     512:	8e 89       	ldd	r24, Y+22	; 0x16
     514:	89 17       	cp	r24, r25
     516:	20 f0       	brcs	.+8      	; 0x520 <__LOCK_REGION_LENGTH__+0x120>
				{
					pxCurrentTCB = pxNewTCB;
     518:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <pxCurrentTCB+0x1>
     51c:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     520:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTaskNumber>
     524:	8f 5f       	subi	r24, 0xFF	; 255
     526:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     52a:	8e 89       	ldd	r24, Y+22	; 0x16
     52c:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     530:	98 17       	cp	r25, r24
     532:	10 f4       	brcc	.+4      	; 0x538 <__LOCK_REGION_LENGTH__+0x138>
     534:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     538:	f9 e0       	ldi	r31, 0x09	; 9
     53a:	8f 9f       	mul	r24, r31
     53c:	c0 01       	movw	r24, r0
     53e:	11 24       	eor	r1, r1
     540:	b6 01       	movw	r22, r12
     542:	89 59       	subi	r24, 0x99	; 153
     544:	9e 4f       	sbci	r25, 0xFE	; 254
     546:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     54a:	0f 90       	pop	r0
     54c:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     54e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     552:	88 23       	and	r24, r24
     554:	51 f0       	breq	.+20     	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     556:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     55a:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     55e:	96 89       	ldd	r25, Z+22	; 0x16
     560:	8e 89       	ldd	r24, Y+22	; 0x16
     562:	98 17       	cp	r25, r24
     564:	10 f4       	brcc	.+4      	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
		{
			taskYIELD_IF_USING_PREEMPTION();
     566:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     56a:	81 e0       	ldi	r24, 0x01	; 1
     56c:	01 c0       	rjmp	.+2      	; 0x570 <__LOCK_REGION_LENGTH__+0x170>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     56e:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	1f 91       	pop	r17
     576:	0f 91       	pop	r16
     578:	ff 90       	pop	r15
     57a:	ef 90       	pop	r14
     57c:	df 90       	pop	r13
     57e:	cf 90       	pop	r12
     580:	bf 90       	pop	r11
     582:	af 90       	pop	r10
     584:	9f 90       	pop	r9
     586:	8f 90       	pop	r8
     588:	7f 90       	pop	r7
     58a:	6f 90       	pop	r6
     58c:	5f 90       	pop	r5
     58e:	4f 90       	pop	r4
     590:	3f 90       	pop	r3
     592:	08 95       	ret

00000594 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     594:	0f 93       	push	r16
     596:	1f 93       	push	r17
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     59e:	0f b6       	in	r0, 0x3f	; 63
     5a0:	f8 94       	cli
     5a2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     5a4:	89 2b       	or	r24, r25
     5a6:	21 f4       	brne	.+8      	; 0x5b0 <vTaskDelete+0x1c>
     5a8:	c0 91 25 01 	lds	r28, 0x0125	; 0x800125 <pxCurrentTCB>
     5ac:	d0 91 26 01 	lds	r29, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     5b0:	8e 01       	movw	r16, r28
     5b2:	0e 5f       	subi	r16, 0xFE	; 254
     5b4:	1f 4f       	sbci	r17, 0xFF	; 255
     5b6:	c8 01       	movw	r24, r16
     5b8:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     5bc:	8c 89       	ldd	r24, Y+20	; 0x14
     5be:	9d 89       	ldd	r25, Y+21	; 0x15
     5c0:	89 2b       	or	r24, r25
     5c2:	21 f0       	breq	.+8      	; 0x5cc <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     5c4:	ce 01       	movw	r24, r28
     5c6:	0c 96       	adiw	r24, 0x0c	; 12
     5c8:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     5cc:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTaskNumber>
     5d0:	8f 5f       	subi	r24, 0xFF	; 255
     5d2:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     5d6:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     5da:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     5de:	c8 17       	cp	r28, r24
     5e0:	d9 07       	cpc	r29, r25
     5e2:	59 f4       	brne	.+22     	; 0x5fa <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     5e4:	b8 01       	movw	r22, r16
     5e6:	8f e3       	ldi	r24, 0x3F	; 63
     5e8:	91 e0       	ldi	r25, 0x01	; 1
     5ea:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     5ee:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     5f2:	8f 5f       	subi	r24, 0xFF	; 255
     5f4:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxDeletedTasksWaitingCleanUp>
     5f8:	0e c0       	rjmp	.+28     	; 0x616 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     5fa:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     5fe:	81 50       	subi	r24, 0x01	; 1
     600:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     604:	8f 89       	ldd	r24, Y+23	; 0x17
     606:	98 8d       	ldd	r25, Y+24	; 0x18
     608:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vPortFree>
			vPortFree( pxTCB );
     60c:	ce 01       	movw	r24, r28
     60e:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     612:	0e 94 22 01 	call	0x244	; 0x244 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     61a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     61e:	88 23       	and	r24, r24
     620:	49 f0       	breq	.+18     	; 0x634 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     622:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     626:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     62a:	c8 17       	cp	r28, r24
     62c:	d9 07       	cpc	r29, r25
     62e:	11 f4       	brne	.+4      	; 0x634 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     630:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     634:	df 91       	pop	r29
     636:	cf 91       	pop	r28
     638:	1f 91       	pop	r17
     63a:	0f 91       	pop	r16
     63c:	08 95       	ret

0000063e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     63e:	0f 93       	push	r16
     640:	1f 93       	push	r17
     642:	cf 93       	push	r28
     644:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     646:	20 91 25 01 	lds	r18, 0x0125	; 0x800125 <pxCurrentTCB>
     64a:	30 91 26 01 	lds	r19, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     64e:	82 17       	cp	r24, r18
     650:	93 07       	cpc	r25, r19
     652:	b9 f1       	breq	.+110    	; 0x6c2 <vTaskResume+0x84>
     654:	00 97       	sbiw	r24, 0x00	; 0
     656:	a9 f1       	breq	.+106    	; 0x6c2 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     658:	0f b6       	in	r0, 0x3f	; 63
     65a:	f8 94       	cli
     65c:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     65e:	fc 01       	movw	r30, r24
     660:	22 85       	ldd	r18, Z+10	; 0x0a
     662:	33 85       	ldd	r19, Z+11	; 0x0b
     664:	25 53       	subi	r18, 0x35	; 53
     666:	31 40       	sbci	r19, 0x01	; 1
     668:	51 f5       	brne	.+84     	; 0x6be <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     66a:	fc 01       	movw	r30, r24
     66c:	24 89       	ldd	r18, Z+20	; 0x14
     66e:	35 89       	ldd	r19, Z+21	; 0x15
     670:	f1 e0       	ldi	r31, 0x01	; 1
     672:	28 34       	cpi	r18, 0x48	; 72
     674:	3f 07       	cpc	r19, r31
     676:	19 f1       	breq	.+70     	; 0x6be <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     678:	23 2b       	or	r18, r19
     67a:	09 f5       	brne	.+66     	; 0x6be <vTaskResume+0x80>
     67c:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     67e:	8c 01       	movw	r16, r24
     680:	0e 5f       	subi	r16, 0xFE	; 254
     682:	1f 4f       	sbci	r17, 0xFF	; 255
     684:	c8 01       	movw	r24, r16
     686:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     68a:	8e 89       	ldd	r24, Y+22	; 0x16
     68c:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     690:	98 17       	cp	r25, r24
     692:	10 f4       	brcc	.+4      	; 0x698 <vTaskResume+0x5a>
     694:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     698:	29 e0       	ldi	r18, 0x09	; 9
     69a:	82 9f       	mul	r24, r18
     69c:	c0 01       	movw	r24, r0
     69e:	11 24       	eor	r1, r1
     6a0:	b8 01       	movw	r22, r16
     6a2:	89 59       	subi	r24, 0x99	; 153
     6a4:	9e 4f       	sbci	r25, 0xFE	; 254
     6a6:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     6aa:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     6ae:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     6b2:	9e 89       	ldd	r25, Y+22	; 0x16
     6b4:	86 89       	ldd	r24, Z+22	; 0x16
     6b6:	98 17       	cp	r25, r24
     6b8:	10 f0       	brcs	.+4      	; 0x6be <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     6ba:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     6be:	0f 90       	pop	r0
     6c0:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	1f 91       	pop	r17
     6c8:	0f 91       	pop	r16
     6ca:	08 95       	ret

000006cc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	1f 93       	push	r17
     6d2:	cf 93       	push	r28
     6d4:	df 93       	push	r29
     6d6:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     6d8:	8a 85       	ldd	r24, Y+10	; 0x0a
     6da:	9b 85       	ldd	r25, Y+11	; 0x0b
     6dc:	85 53       	subi	r24, 0x35	; 53
     6de:	91 40       	sbci	r25, 0x01	; 1
     6e0:	99 f4       	brne	.+38     	; 0x708 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     6e2:	8c 89       	ldd	r24, Y+20	; 0x14
     6e4:	9d 89       	ldd	r25, Y+21	; 0x15
     6e6:	21 e0       	ldi	r18, 0x01	; 1
     6e8:	88 34       	cpi	r24, 0x48	; 72
     6ea:	92 07       	cpc	r25, r18
     6ec:	69 f0       	breq	.+26     	; 0x708 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     6ee:	89 2b       	or	r24, r25
     6f0:	59 f4       	brne	.+22     	; 0x708 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     6f2:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     6f6:	88 23       	and	r24, r24
     6f8:	49 f0       	breq	.+18     	; 0x70c <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     6fa:	be 01       	movw	r22, r28
     6fc:	64 5f       	subi	r22, 0xF4	; 244
     6fe:	7f 4f       	sbci	r23, 0xFF	; 255
     700:	88 e4       	ldi	r24, 0x48	; 72
     702:	91 e0       	ldi	r25, 0x01	; 1
     704:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     708:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     70a:	21 c0       	rjmp	.+66     	; 0x74e <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     70c:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     710:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     714:	11 e0       	ldi	r17, 0x01	; 1
     716:	9e 89       	ldd	r25, Y+22	; 0x16
     718:	86 89       	ldd	r24, Z+22	; 0x16
     71a:	98 17       	cp	r25, r24
     71c:	08 f4       	brcc	.+2      	; 0x720 <xTaskResumeFromISR+0x54>
     71e:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     720:	7e 01       	movw	r14, r28
     722:	82 e0       	ldi	r24, 0x02	; 2
     724:	e8 0e       	add	r14, r24
     726:	f1 1c       	adc	r15, r1
     728:	c7 01       	movw	r24, r14
     72a:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     72e:	8e 89       	ldd	r24, Y+22	; 0x16
     730:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     734:	98 17       	cp	r25, r24
     736:	10 f4       	brcc	.+4      	; 0x73c <xTaskResumeFromISR+0x70>
     738:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     73c:	29 e0       	ldi	r18, 0x09	; 9
     73e:	82 9f       	mul	r24, r18
     740:	c0 01       	movw	r24, r0
     742:	11 24       	eor	r1, r1
     744:	b7 01       	movw	r22, r14
     746:	89 59       	subi	r24, 0x99	; 153
     748:	9e 4f       	sbci	r25, 0xFE	; 254
     74a:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     74e:	81 2f       	mov	r24, r17
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	1f 91       	pop	r17
     756:	ff 90       	pop	r15
     758:	ef 90       	pop	r14
     75a:	08 95       	ret

0000075c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     75c:	ef 92       	push	r14
     75e:	ff 92       	push	r15
     760:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     762:	88 e2       	ldi	r24, 0x28	; 40
     764:	e8 2e       	mov	r14, r24
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	f8 2e       	mov	r15, r24
     76a:	00 e0       	ldi	r16, 0x00	; 0
     76c:	20 e0       	ldi	r18, 0x00	; 0
     76e:	30 e0       	ldi	r19, 0x00	; 0
     770:	45 e5       	ldi	r20, 0x55	; 85
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	6f e1       	ldi	r22, 0x1F	; 31
     776:	71 e0       	ldi	r23, 0x01	; 1
     778:	89 e9       	ldi	r24, 0x99	; 153
     77a:	91 e0       	ldi	r25, 0x01	; 1
     77c:	0e 94 c7 01 	call	0x38e	; 0x38e <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     780:	81 30       	cpi	r24, 0x01	; 1
     782:	91 f4       	brne	.+36     	; 0x7a8 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     784:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     786:	2f ef       	ldi	r18, 0xFF	; 255
     788:	3f ef       	ldi	r19, 0xFF	; 255
     78a:	30 93 2b 01 	sts	0x012B, r19	; 0x80012b <xNextTaskUnblockTime+0x1>
     78e:	20 93 2a 01 	sts	0x012A, r18	; 0x80012a <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     792:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     796:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <xTickCount+0x1>
     79a:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     79e:	0f 91       	pop	r16
     7a0:	ff 90       	pop	r15
     7a2:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     7a4:	0c 94 6e 12 	jmp	0x24dc	; 0x24dc <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     7a8:	0f 91       	pop	r16
     7aa:	ff 90       	pop	r15
     7ac:	ef 90       	pop	r14
     7ae:	08 95       	ret

000007b0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     7b0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     7b2:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <xSchedulerRunning>
	vPortEndScheduler();
     7b6:	0c 94 ae 12 	jmp	0x255c	; 0x255c <vPortEndScheduler>

000007ba <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     7ba:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     7be:	8f 5f       	subi	r24, 0xFF	; 255
     7c0:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxSchedulerSuspended>
     7c4:	08 95       	ret

000007c6 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     7c6:	0f b6       	in	r0, 0x3f	; 63
     7c8:	f8 94       	cli
     7ca:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     7cc:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xTickCount>
     7d0:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     7d4:	0f 90       	pop	r0
     7d6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     7d8:	08 95       	ret

000007da <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     7da:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xTickCount>
     7de:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7e2:	08 95       	ret

000007e4 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     7e4:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
}
     7e8:	08 95       	ret

000007ea <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     7ea:	00 97       	sbiw	r24, 0x00	; 0
     7ec:	21 f4       	brne	.+8      	; 0x7f6 <pcTaskGetName+0xc>
     7ee:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     7f2:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     7f6:	49 96       	adiw	r24, 0x19	; 25
     7f8:	08 95       	ret

000007fa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     7fa:	cf 92       	push	r12
     7fc:	df 92       	push	r13
     7fe:	ef 92       	push	r14
     800:	ff 92       	push	r15
     802:	0f 93       	push	r16
     804:	1f 93       	push	r17
     806:	cf 93       	push	r28
     808:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     80a:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     80e:	81 11       	cpse	r24, r1
     810:	8c c0       	rjmp	.+280    	; 0x92a <__stack+0x2b>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     812:	00 91 32 01 	lds	r16, 0x0132	; 0x800132 <xTickCount>
     816:	10 91 33 01 	lds	r17, 0x0133	; 0x800133 <xTickCount+0x1>
     81a:	0f 5f       	subi	r16, 0xFF	; 255
     81c:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     81e:	10 93 33 01 	sts	0x0133, r17	; 0x800133 <xTickCount+0x1>
     822:	00 93 32 01 	sts	0x0132, r16	; 0x800132 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     826:	01 15       	cp	r16, r1
     828:	11 05       	cpc	r17, r1
     82a:	b9 f4       	brne	.+46     	; 0x85a <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     82c:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <pxDelayedTaskList>
     830:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     834:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <pxOverflowDelayedTaskList>
     838:	30 91 52 01 	lds	r19, 0x0152	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     83c:	30 93 54 01 	sts	0x0154, r19	; 0x800154 <pxDelayedTaskList+0x1>
     840:	20 93 53 01 	sts	0x0153, r18	; 0x800153 <pxDelayedTaskList>
     844:	90 93 52 01 	sts	0x0152, r25	; 0x800152 <pxOverflowDelayedTaskList+0x1>
     848:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <pxOverflowDelayedTaskList>
     84c:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xNumOfOverflows>
     850:	8f 5f       	subi	r24, 0xFF	; 255
     852:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <xNumOfOverflows>
     856:	0e 94 22 01 	call	0x244	; 0x244 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     85a:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <xNextTaskUnblockTime>
     85e:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <xNextTaskUnblockTime+0x1>
     862:	c0 e0       	ldi	r28, 0x00	; 0
     864:	08 17       	cp	r16, r24
     866:	19 07       	cpc	r17, r25
     868:	08 f4       	brcc	.+2      	; 0x86c <xTaskIncrementTick+0x72>
     86a:	4f c0       	rjmp	.+158    	; 0x90a <__stack+0xb>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     86c:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     86e:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     872:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     876:	80 81       	ld	r24, Z
     878:	81 11       	cpse	r24, r1
     87a:	03 c0       	rjmp	.+6      	; 0x882 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     87c:	8f ef       	ldi	r24, 0xFF	; 255
     87e:	9f ef       	ldi	r25, 0xFF	; 255
     880:	11 c0       	rjmp	.+34     	; 0x8a4 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     882:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <pxDelayedTaskList>
     886:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <pxDelayedTaskList+0x1>
     88a:	05 80       	ldd	r0, Z+5	; 0x05
     88c:	f6 81       	ldd	r31, Z+6	; 0x06
     88e:	e0 2d       	mov	r30, r0
     890:	e6 80       	ldd	r14, Z+6	; 0x06
     892:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     894:	d7 01       	movw	r26, r14
     896:	12 96       	adiw	r26, 0x02	; 2
     898:	8d 91       	ld	r24, X+
     89a:	9c 91       	ld	r25, X
     89c:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     89e:	08 17       	cp	r16, r24
     8a0:	19 07       	cpc	r17, r25
     8a2:	28 f4       	brcc	.+10     	; 0x8ae <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     8a4:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <xNextTaskUnblockTime+0x1>
     8a8:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     8ac:	2e c0       	rjmp	.+92     	; 0x90a <__stack+0xb>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     8ae:	67 01       	movw	r12, r14
     8b0:	b2 e0       	ldi	r27, 0x02	; 2
     8b2:	cb 0e       	add	r12, r27
     8b4:	d1 1c       	adc	r13, r1
     8b6:	c6 01       	movw	r24, r12
     8b8:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     8bc:	f7 01       	movw	r30, r14
     8be:	84 89       	ldd	r24, Z+20	; 0x14
     8c0:	95 89       	ldd	r25, Z+21	; 0x15
     8c2:	89 2b       	or	r24, r25
     8c4:	21 f0       	breq	.+8      	; 0x8ce <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     8c6:	c7 01       	movw	r24, r14
     8c8:	0c 96       	adiw	r24, 0x0c	; 12
     8ca:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     8ce:	d7 01       	movw	r26, r14
     8d0:	56 96       	adiw	r26, 0x16	; 22
     8d2:	8c 91       	ld	r24, X
     8d4:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     8d8:	98 17       	cp	r25, r24
     8da:	10 f4       	brcc	.+4      	; 0x8e0 <xTaskIncrementTick+0xe6>
     8dc:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     8e0:	d8 9f       	mul	r29, r24
     8e2:	c0 01       	movw	r24, r0
     8e4:	11 24       	eor	r1, r1
     8e6:	b6 01       	movw	r22, r12
     8e8:	89 59       	subi	r24, 0x99	; 153
     8ea:	9e 4f       	sbci	r25, 0xFE	; 254
     8ec:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     8f0:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     8f4:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     8f8:	d7 01       	movw	r26, r14
     8fa:	56 96       	adiw	r26, 0x16	; 22
     8fc:	9c 91       	ld	r25, X
     8fe:	86 89       	ldd	r24, Z+22	; 0x16
     900:	98 17       	cp	r25, r24
     902:	08 f4       	brcc	.+2      	; 0x906 <__stack+0x7>
     904:	b4 cf       	rjmp	.-152    	; 0x86e <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     906:	c1 e0       	ldi	r28, 0x01	; 1
     908:	b2 cf       	rjmp	.-156    	; 0x86e <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     90a:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     90e:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     912:	e6 89       	ldd	r30, Z+22	; 0x16
     914:	b9 e0       	ldi	r27, 0x09	; 9
     916:	eb 9f       	mul	r30, r27
     918:	f0 01       	movw	r30, r0
     91a:	11 24       	eor	r1, r1
     91c:	e9 59       	subi	r30, 0x99	; 153
     91e:	fe 4f       	sbci	r31, 0xFE	; 254
     920:	80 81       	ld	r24, Z
     922:	82 30       	cpi	r24, 0x02	; 2
     924:	40 f0       	brcs	.+16     	; 0x936 <__stack+0x37>
			{
				xSwitchRequired = pdTRUE;
     926:	c1 e0       	ldi	r28, 0x01	; 1
     928:	06 c0       	rjmp	.+12     	; 0x936 <__stack+0x37>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     92a:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxPendedTicks>
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     934:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     936:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xYieldPending>
     93a:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     93c:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     93e:	8c 2f       	mov	r24, r28
     940:	df 91       	pop	r29
     942:	cf 91       	pop	r28
     944:	1f 91       	pop	r17
     946:	0f 91       	pop	r16
     948:	ff 90       	pop	r15
     94a:	ef 90       	pop	r14
     94c:	df 90       	pop	r13
     94e:	cf 90       	pop	r12
     950:	08 95       	ret

00000952 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     952:	ef 92       	push	r14
     954:	ff 92       	push	r15
     956:	0f 93       	push	r16
     958:	1f 93       	push	r17
     95a:	cf 93       	push	r28
     95c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     95e:	0f b6       	in	r0, 0x3f	; 63
     960:	f8 94       	cli
     962:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     964:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     968:	81 50       	subi	r24, 0x01	; 1
     96a:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     96e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     972:	88 23       	and	r24, r24
     974:	11 f0       	breq	.+4      	; 0x97a <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	52 c0       	rjmp	.+164    	; 0xa1e <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     97a:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     97e:	88 23       	and	r24, r24
     980:	d1 f3       	breq	.-12     	; 0x976 <xTaskResumeAll+0x24>
     982:	c0 e0       	ldi	r28, 0x00	; 0
     984:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     986:	89 e0       	ldi	r24, 0x09	; 9
     988:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     98a:	ee 24       	eor	r14, r14
     98c:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     98e:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <xPendingReadyList>
     992:	88 23       	and	r24, r24
     994:	51 f1       	breq	.+84     	; 0x9ea <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     996:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <xPendingReadyList+0x5>
     99a:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <xPendingReadyList+0x6>
     99e:	c6 81       	ldd	r28, Z+6	; 0x06
     9a0:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9a2:	ce 01       	movw	r24, r28
     9a4:	0c 96       	adiw	r24, 0x0c	; 12
     9a6:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     9aa:	8e 01       	movw	r16, r28
     9ac:	0e 5f       	subi	r16, 0xFE	; 254
     9ae:	1f 4f       	sbci	r17, 0xFF	; 255
     9b0:	c8 01       	movw	r24, r16
     9b2:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     9b6:	8e 89       	ldd	r24, Y+22	; 0x16
     9b8:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     9bc:	98 17       	cp	r25, r24
     9be:	10 f4       	brcc	.+4      	; 0x9c4 <xTaskResumeAll+0x72>
     9c0:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     9c4:	f8 9e       	mul	r15, r24
     9c6:	c0 01       	movw	r24, r0
     9c8:	11 24       	eor	r1, r1
     9ca:	b8 01       	movw	r22, r16
     9cc:	89 59       	subi	r24, 0x99	; 153
     9ce:	9e 4f       	sbci	r25, 0xFE	; 254
     9d0:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9d4:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     9d8:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     9dc:	9e 89       	ldd	r25, Y+22	; 0x16
     9de:	86 89       	ldd	r24, Z+22	; 0x16
     9e0:	98 17       	cp	r25, r24
     9e2:	a8 f2       	brcs	.-86     	; 0x98e <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     9e4:	e0 92 2e 01 	sts	0x012E, r14	; 0x80012e <xYieldPending>
     9e8:	d2 cf       	rjmp	.-92     	; 0x98e <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     9ea:	cd 2b       	or	r28, r29
     9ec:	11 f0       	breq	.+4      	; 0x9f2 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     9ee:	0e 94 22 01 	call	0x244	; 0x244 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     9f2:	c0 91 2f 01 	lds	r28, 0x012F	; 0x80012f <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     9f6:	cc 23       	and	r28, r28
     9f8:	51 f0       	breq	.+20     	; 0xa0e <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     9fa:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     9fc:	0e 94 fd 03 	call	0x7fa	; 0x7fa <xTaskIncrementTick>
     a00:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     a02:	d0 93 2e 01 	sts	0x012E, r29	; 0x80012e <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     a06:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     a08:	c9 f7       	brne	.-14     	; 0x9fc <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     a0a:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     a0e:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xYieldPending>
     a12:	88 23       	and	r24, r24
     a14:	09 f4       	brne	.+2      	; 0xa18 <xTaskResumeAll+0xc6>
     a16:	af cf       	rjmp	.-162    	; 0x976 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     a18:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     a1c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     a1e:	0f 90       	pop	r0
     a20:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	0f 91       	pop	r16
     a2a:	ff 90       	pop	r15
     a2c:	ef 90       	pop	r14
     a2e:	08 95       	ret

00000a30 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     a30:	0f 93       	push	r16
     a32:	1f 93       	push	r17
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
     a38:	8c 01       	movw	r16, r24
     a3a:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     a3c:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     a40:	40 91 32 01 	lds	r20, 0x0132	; 0x800132 <xTickCount>
     a44:	50 91 33 01 	lds	r21, 0x0133	; 0x800133 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     a48:	f8 01       	movw	r30, r16
     a4a:	20 81       	ld	r18, Z
     a4c:	31 81       	ldd	r19, Z+1	; 0x01
     a4e:	c9 01       	movw	r24, r18
     a50:	8c 0f       	add	r24, r28
     a52:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     a54:	42 17       	cp	r20, r18
     a56:	53 07       	cpc	r21, r19
     a58:	20 f4       	brcc	.+8      	; 0xa62 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     a5a:	82 17       	cp	r24, r18
     a5c:	93 07       	cpc	r25, r19
     a5e:	40 f4       	brcc	.+16     	; 0xa70 <vTaskDelayUntil+0x40>
     a60:	03 c0       	rjmp	.+6      	; 0xa68 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     a62:	82 17       	cp	r24, r18
     a64:	93 07       	cpc	r25, r19
     a66:	30 f0       	brcs	.+12     	; 0xa74 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     a68:	21 e0       	ldi	r18, 0x01	; 1
     a6a:	48 17       	cp	r20, r24
     a6c:	59 07       	cpc	r21, r25
     a6e:	18 f0       	brcs	.+6      	; 0xa76 <vTaskDelayUntil+0x46>
     a70:	20 e0       	ldi	r18, 0x00	; 0
     a72:	01 c0       	rjmp	.+2      	; 0xa76 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     a74:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     a76:	f8 01       	movw	r30, r16
     a78:	91 83       	std	Z+1, r25	; 0x01
     a7a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     a7c:	22 23       	and	r18, r18
     a7e:	29 f0       	breq	.+10     	; 0xa8a <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     a80:	60 e0       	ldi	r22, 0x00	; 0
     a82:	84 1b       	sub	r24, r20
     a84:	95 0b       	sbc	r25, r21
     a86:	0e 94 3d 01 	call	0x27a	; 0x27a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a8a:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a8e:	81 11       	cpse	r24, r1
     a90:	02 c0       	rjmp	.+4      	; 0xa96 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a92:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a96:	df 91       	pop	r29
     a98:	cf 91       	pop	r28
     a9a:	1f 91       	pop	r17
     a9c:	0f 91       	pop	r16
     a9e:	08 95       	ret

00000aa0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
     aa4:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     aa6:	89 2b       	or	r24, r25
     aa8:	19 f4       	brne	.+6      	; 0xab0 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     aaa:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
     aae:	0a c0       	rjmp	.+20     	; 0xac4 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     ab0:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     ab4:	60 e0       	ldi	r22, 0x00	; 0
     ab6:	ce 01       	movw	r24, r28
     ab8:	0e 94 3d 01 	call	0x27a	; 0x27a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     abc:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     ac0:	88 23       	and	r24, r24
     ac2:	99 f3       	breq	.-26     	; 0xaaa <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ac4:	df 91       	pop	r29
     ac6:	cf 91       	pop	r28
     ac8:	08 95       	ret

00000aca <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     aca:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     ace:	88 23       	and	r24, r24
     ad0:	21 f0       	breq	.+8      	; 0xada <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
     ad8:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     ada:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     ade:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <uxTopReadyPriority>
     ae2:	69 e0       	ldi	r22, 0x09	; 9
     ae4:	48 2f       	mov	r20, r24
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	64 9f       	mul	r22, r20
     aea:	90 01       	movw	r18, r0
     aec:	65 9f       	mul	r22, r21
     aee:	30 0d       	add	r19, r0
     af0:	11 24       	eor	r1, r1
     af2:	f9 01       	movw	r30, r18
     af4:	e9 59       	subi	r30, 0x99	; 153
     af6:	fe 4f       	sbci	r31, 0xFE	; 254
     af8:	90 81       	ld	r25, Z
     afa:	91 11       	cpse	r25, r1
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <vTaskSwitchContext+0x38>
     afe:	81 50       	subi	r24, 0x01	; 1
     b00:	f1 cf       	rjmp	.-30     	; 0xae4 <vTaskSwitchContext+0x1a>
     b02:	a1 81       	ldd	r26, Z+1	; 0x01
     b04:	b2 81       	ldd	r27, Z+2	; 0x02
     b06:	12 96       	adiw	r26, 0x02	; 2
     b08:	0d 90       	ld	r0, X+
     b0a:	bc 91       	ld	r27, X
     b0c:	a0 2d       	mov	r26, r0
     b0e:	b2 83       	std	Z+2, r27	; 0x02
     b10:	a1 83       	std	Z+1, r26	; 0x01
     b12:	26 59       	subi	r18, 0x96	; 150
     b14:	3e 4f       	sbci	r19, 0xFE	; 254
     b16:	a2 17       	cp	r26, r18
     b18:	b3 07       	cpc	r27, r19
     b1a:	31 f4       	brne	.+12     	; 0xb28 <vTaskSwitchContext+0x5e>
     b1c:	12 96       	adiw	r26, 0x02	; 2
     b1e:	2d 91       	ld	r18, X+
     b20:	3c 91       	ld	r19, X
     b22:	13 97       	sbiw	r26, 0x03	; 3
     b24:	32 83       	std	Z+2, r19	; 0x02
     b26:	21 83       	std	Z+1, r18	; 0x01
     b28:	99 e0       	ldi	r25, 0x09	; 9
     b2a:	94 9f       	mul	r25, r20
     b2c:	f0 01       	movw	r30, r0
     b2e:	95 9f       	mul	r25, r21
     b30:	f0 0d       	add	r31, r0
     b32:	11 24       	eor	r1, r1
     b34:	e9 59       	subi	r30, 0x99	; 153
     b36:	fe 4f       	sbci	r31, 0xFE	; 254
     b38:	01 80       	ldd	r0, Z+1	; 0x01
     b3a:	f2 81       	ldd	r31, Z+2	; 0x02
     b3c:	e0 2d       	mov	r30, r0
     b3e:	26 81       	ldd	r18, Z+6	; 0x06
     b40:	37 81       	ldd	r19, Z+7	; 0x07
     b42:	30 93 26 01 	sts	0x0126, r19	; 0x800126 <pxCurrentTCB+0x1>
     b46:	20 93 25 01 	sts	0x0125, r18	; 0x800125 <pxCurrentTCB>
     b4a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     b4e:	08 95       	ret

00000b50 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     b50:	0f 93       	push	r16
     b52:	1f 93       	push	r17
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
     b58:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     b60:	89 2b       	or	r24, r25
     b62:	21 f4       	brne	.+8      	; 0xb6c <vTaskSuspend+0x1c>
     b64:	c0 91 25 01 	lds	r28, 0x0125	; 0x800125 <pxCurrentTCB>
     b68:	d0 91 26 01 	lds	r29, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     b6c:	8e 01       	movw	r16, r28
     b6e:	0e 5f       	subi	r16, 0xFE	; 254
     b70:	1f 4f       	sbci	r17, 0xFF	; 255
     b72:	c8 01       	movw	r24, r16
     b74:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b78:	8c 89       	ldd	r24, Y+20	; 0x14
     b7a:	9d 89       	ldd	r25, Y+21	; 0x15
     b7c:	89 2b       	or	r24, r25
     b7e:	21 f0       	breq	.+8      	; 0xb88 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b80:	ce 01       	movw	r24, r28
     b82:	0c 96       	adiw	r24, 0x0c	; 12
     b84:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     b88:	b8 01       	movw	r22, r16
     b8a:	85 e3       	ldi	r24, 0x35	; 53
     b8c:	91 e0       	ldi	r25, 0x01	; 1
     b8e:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b92:	8f a1       	ldd	r24, Y+39	; 0x27
     b94:	81 30       	cpi	r24, 0x01	; 1
     b96:	09 f4       	brne	.+2      	; 0xb9a <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b98:	1f a2       	std	Y+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b9e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     ba2:	88 23       	and	r24, r24
     ba4:	39 f0       	breq	.+14     	; 0xbb4 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	f8 94       	cli
     baa:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     bac:	0e 94 22 01 	call	0x244	; 0x244 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     bb0:	0f 90       	pop	r0
     bb2:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     bb4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     bb8:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     bbc:	c8 17       	cp	r28, r24
     bbe:	d9 07       	cpc	r29, r25
     bc0:	c1 f4       	brne	.+48     	; 0xbf2 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     bc2:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xSchedulerRunning>
     bc6:	88 23       	and	r24, r24
     bc8:	19 f0       	breq	.+6      	; 0xbd0 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     bca:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
     bce:	11 c0       	rjmp	.+34     	; 0xbf2 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     bd0:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <xSuspendedTaskList>
     bd4:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxCurrentNumberOfTasks>
     bd8:	98 13       	cpse	r25, r24
     bda:	05 c0       	rjmp	.+10     	; 0xbe6 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     bdc:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <pxCurrentTCB+0x1>
     be0:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <pxCurrentTCB>
     be4:	06 c0       	rjmp	.+12     	; 0xbf2 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	1f 91       	pop	r17
     bec:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     bee:	0c 94 65 05 	jmp	0xaca	; 0xaca <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	1f 91       	pop	r17
     bf8:	0f 91       	pop	r16
     bfa:	08 95       	ret

00000bfc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c02:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     c06:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     c0a:	64 5f       	subi	r22, 0xF4	; 244
     c0c:	7f 4f       	sbci	r23, 0xFF	; 255
     c0e:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c12:	61 e0       	ldi	r22, 0x01	; 1
     c14:	ce 01       	movw	r24, r28
}
     c16:	df 91       	pop	r29
     c18:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c1a:	0c 94 3d 01 	jmp	0x27a	; 0x27a <prvAddCurrentTaskToDelayedList>

00000c1e <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     c1e:	cf 93       	push	r28
     c20:	df 93       	push	r29
     c22:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c24:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     c28:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     c2c:	70 68       	ori	r23, 0x80	; 128
     c2e:	75 87       	std	Z+13, r23	; 0x0d
     c30:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c32:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentTCB>
     c36:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     c3a:	64 5f       	subi	r22, 0xF4	; 244
     c3c:	7f 4f       	sbci	r23, 0xFF	; 255
     c3e:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c42:	61 e0       	ldi	r22, 0x01	; 1
     c44:	ce 01       	movw	r24, r28
}
     c46:	df 91       	pop	r29
     c48:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c4a:	0c 94 3d 01 	jmp	0x27a	; 0x27a <prvAddCurrentTaskToDelayedList>

00000c4e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     c4e:	0f 93       	push	r16
     c50:	1f 93       	push	r17
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c56:	dc 01       	movw	r26, r24
     c58:	15 96       	adiw	r26, 0x05	; 5
     c5a:	ed 91       	ld	r30, X+
     c5c:	fc 91       	ld	r31, X
     c5e:	16 97       	sbiw	r26, 0x06	; 6
     c60:	c6 81       	ldd	r28, Z+6	; 0x06
     c62:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c64:	8e 01       	movw	r16, r28
     c66:	04 5f       	subi	r16, 0xF4	; 244
     c68:	1f 4f       	sbci	r17, 0xFF	; 255
     c6a:	c8 01       	movw	r24, r16
     c6c:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c70:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
     c74:	81 11       	cpse	r24, r1
     c76:	14 c0       	rjmp	.+40     	; 0xca0 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c78:	0a 50       	subi	r16, 0x0A	; 10
     c7a:	11 09       	sbc	r17, r1
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c82:	8e 89       	ldd	r24, Y+22	; 0x16
     c84:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     c88:	98 17       	cp	r25, r24
     c8a:	10 f4       	brcc	.+4      	; 0xc90 <xTaskRemoveFromEventList+0x42>
     c8c:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     c90:	b9 e0       	ldi	r27, 0x09	; 9
     c92:	8b 9f       	mul	r24, r27
     c94:	c0 01       	movw	r24, r0
     c96:	11 24       	eor	r1, r1
     c98:	b8 01       	movw	r22, r16
     c9a:	89 59       	subi	r24, 0x99	; 153
     c9c:	9e 4f       	sbci	r25, 0xFE	; 254
     c9e:	03 c0       	rjmp	.+6      	; 0xca6 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     ca0:	b8 01       	movw	r22, r16
     ca2:	88 e4       	ldi	r24, 0x48	; 72
     ca4:	91 e0       	ldi	r25, 0x01	; 1
     ca6:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     caa:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     cae:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     cb2:	9e 89       	ldd	r25, Y+22	; 0x16
     cb4:	86 89       	ldd	r24, Z+22	; 0x16
     cb6:	89 17       	cp	r24, r25
     cb8:	20 f4       	brcc	.+8      	; 0xcc2 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     cba:	81 e0       	ldi	r24, 0x01	; 1
     cbc:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
     cc0:	01 c0       	rjmp	.+2      	; 0xcc4 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     cc2:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	1f 91       	pop	r17
     cca:	0f 91       	pop	r16
     ccc:	08 95       	ret

00000cce <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     cce:	0f 93       	push	r16
     cd0:	1f 93       	push	r17
     cd2:	cf 93       	push	r28
     cd4:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     cd6:	70 68       	ori	r23, 0x80	; 128
     cd8:	fc 01       	movw	r30, r24
     cda:	71 83       	std	Z+1, r23	; 0x01
     cdc:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     cde:	c6 81       	ldd	r28, Z+6	; 0x06
     ce0:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     ce2:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     ce6:	8e 01       	movw	r16, r28
     ce8:	0e 5f       	subi	r16, 0xFE	; 254
     cea:	1f 4f       	sbci	r17, 0xFF	; 255
     cec:	c8 01       	movw	r24, r16
     cee:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     cf2:	8e 89       	ldd	r24, Y+22	; 0x16
     cf4:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     cf8:	98 17       	cp	r25, r24
     cfa:	10 f4       	brcc	.+4      	; 0xd00 <vTaskRemoveFromUnorderedEventList+0x32>
     cfc:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     d00:	f9 e0       	ldi	r31, 0x09	; 9
     d02:	8f 9f       	mul	r24, r31
     d04:	c0 01       	movw	r24, r0
     d06:	11 24       	eor	r1, r1
     d08:	b8 01       	movw	r22, r16
     d0a:	89 59       	subi	r24, 0x99	; 153
     d0c:	9e 4f       	sbci	r25, 0xFE	; 254
     d0e:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d12:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     d16:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     d1a:	9e 89       	ldd	r25, Y+22	; 0x16
     d1c:	86 89       	ldd	r24, Z+22	; 0x16
     d1e:	89 17       	cp	r24, r25
     d20:	18 f4       	brcc	.+6      	; 0xd28 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
	}
}
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	08 95       	ret

00000d32 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     d32:	0f b6       	in	r0, 0x3f	; 63
     d34:	f8 94       	cli
     d36:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     d38:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xNumOfOverflows>
     d3c:	fc 01       	movw	r30, r24
     d3e:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     d40:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <xTickCount>
     d44:	30 91 33 01 	lds	r19, 0x0133	; 0x800133 <xTickCount+0x1>
     d48:	32 83       	std	Z+2, r19	; 0x02
     d4a:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63
     d50:	08 95       	ret

00000d52 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     d52:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xNumOfOverflows>
     d56:	fc 01       	movw	r30, r24
     d58:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     d5a:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <xTickCount>
     d5e:	30 91 33 01 	lds	r19, 0x0133	; 0x800133 <xTickCount+0x1>
     d62:	32 83       	std	Z+2, r19	; 0x02
     d64:	21 83       	std	Z+1, r18	; 0x01
     d66:	08 95       	ret

00000d68 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     d68:	cf 93       	push	r28
     d6a:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     d6c:	0f b6       	in	r0, 0x3f	; 63
     d6e:	f8 94       	cli
     d70:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     d72:	40 91 32 01 	lds	r20, 0x0132	; 0x800132 <xTickCount>
     d76:	50 91 33 01 	lds	r21, 0x0133	; 0x800133 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     d7a:	db 01       	movw	r26, r22
     d7c:	2d 91       	ld	r18, X+
     d7e:	3c 91       	ld	r19, X
     d80:	2f 3f       	cpi	r18, 0xFF	; 255
     d82:	bf ef       	ldi	r27, 0xFF	; 255
     d84:	3b 07       	cpc	r19, r27
     d86:	d9 f0       	breq	.+54     	; 0xdbe <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d88:	ec 01       	movw	r28, r24
     d8a:	e9 81       	ldd	r30, Y+1	; 0x01
     d8c:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d8e:	a0 91 2d 01 	lds	r26, 0x012D	; 0x80012d <xNumOfOverflows>
     d92:	b8 81       	ld	r27, Y
     d94:	ba 17       	cp	r27, r26
     d96:	19 f0       	breq	.+6      	; 0xd9e <xTaskCheckForTimeOut+0x36>
     d98:	4e 17       	cp	r20, r30
     d9a:	5f 07       	cpc	r21, r31
     d9c:	90 f4       	brcc	.+36     	; 0xdc2 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d9e:	4e 1b       	sub	r20, r30
     da0:	5f 0b       	sbc	r21, r31
     da2:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     da4:	42 17       	cp	r20, r18
     da6:	53 07       	cpc	r21, r19
     da8:	38 f4       	brcc	.+14     	; 0xdb8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     daa:	24 1b       	sub	r18, r20
     dac:	35 0b       	sbc	r19, r21
     dae:	31 83       	std	Z+1, r19	; 0x01
     db0:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     db2:	0e 94 a9 06 	call	0xd52	; 0xd52 <vTaskInternalSetTimeOutState>
     db6:	03 c0       	rjmp	.+6      	; 0xdbe <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     db8:	11 82       	std	Z+1, r1	; 0x01
     dba:	10 82       	st	Z, r1
     dbc:	02 c0       	rjmp	.+4      	; 0xdc2 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	01 c0       	rjmp	.+2      	; 0xdc4 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     dc2:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     dc4:	0f 90       	pop	r0
     dc6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	08 95       	ret

00000dce <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
     dd4:	08 95       	ret

00000dd6 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
     dd6:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     dda:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

		return xReturn;
	}
     dde:	08 95       	ret

00000de0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
     de0:	0f 93       	push	r16
     de2:	1f 93       	push	r17
     de4:	cf 93       	push	r28
     de6:	df 93       	push	r29
     de8:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
     dea:	89 2b       	or	r24, r25
     dec:	09 f4       	brne	.+2      	; 0xdf0 <xTaskPriorityInherit+0x10>
     dee:	55 c0       	rjmp	.+170    	; 0xe9a <xTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
     df0:	86 89       	ldd	r24, Z+22	; 0x16
     df2:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     df6:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     dfa:	56 96       	adiw	r26, 0x16	; 22
     dfc:	9c 91       	ld	r25, X
     dfe:	89 17       	cp	r24, r25
     e00:	08 f0       	brcs	.+2      	; 0xe04 <xTaskPriorityInherit+0x24>
     e02:	41 c0       	rjmp	.+130    	; 0xe86 <xTaskPriorityInherit+0xa6>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
     e04:	24 85       	ldd	r18, Z+12	; 0x0c
     e06:	35 85       	ldd	r19, Z+13	; 0x0d
     e08:	37 fd       	sbrc	r19, 7
     e0a:	0c c0       	rjmp	.+24     	; 0xe24 <xTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e0c:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     e10:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     e14:	56 96       	adiw	r26, 0x16	; 22
     e16:	9c 91       	ld	r25, X
     e18:	24 e0       	ldi	r18, 0x04	; 4
     e1a:	30 e0       	ldi	r19, 0x00	; 0
     e1c:	29 1b       	sub	r18, r25
     e1e:	31 09       	sbc	r19, r1
     e20:	35 87       	std	Z+13, r19	; 0x0d
     e22:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
     e24:	29 e0       	ldi	r18, 0x09	; 9
     e26:	82 9f       	mul	r24, r18
     e28:	c0 01       	movw	r24, r0
     e2a:	11 24       	eor	r1, r1
     e2c:	89 59       	subi	r24, 0x99	; 153
     e2e:	9e 4f       	sbci	r25, 0xFE	; 254
     e30:	22 85       	ldd	r18, Z+10	; 0x0a
     e32:	33 85       	ldd	r19, Z+11	; 0x0b
     e34:	28 17       	cp	r18, r24
     e36:	39 07       	cpc	r19, r25
     e38:	e9 f4       	brne	.+58     	; 0xe74 <xTaskPriorityInherit+0x94>
     e3a:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     e3c:	ef 01       	movw	r28, r30
     e3e:	22 96       	adiw	r28, 0x02	; 2
     e40:	ce 01       	movw	r24, r28
     e42:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
     e46:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     e4a:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     e4e:	86 89       	ldd	r24, Z+22	; 0x16
     e50:	f8 01       	movw	r30, r16
     e52:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
     e54:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     e58:	98 17       	cp	r25, r24
     e5a:	10 f4       	brcc	.+4      	; 0xe60 <xTaskPriorityInherit+0x80>
     e5c:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     e60:	f9 e0       	ldi	r31, 0x09	; 9
     e62:	8f 9f       	mul	r24, r31
     e64:	c0 01       	movw	r24, r0
     e66:	11 24       	eor	r1, r1
     e68:	be 01       	movw	r22, r28
     e6a:	89 59       	subi	r24, 0x99	; 153
     e6c:	9e 4f       	sbci	r25, 0xFE	; 254
     e6e:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
     e72:	07 c0       	rjmp	.+14     	; 0xe82 <xTaskPriorityInherit+0xa2>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
     e74:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     e78:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     e7c:	56 96       	adiw	r26, 0x16	; 22
     e7e:	8c 91       	ld	r24, X
     e80:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	0b c0       	rjmp	.+22     	; 0xe9c <xTaskPriorityInherit+0xbc>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
     e86:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     e8a:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	21 a1       	ldd	r18, Z+33	; 0x21
     e92:	56 96       	adiw	r26, 0x16	; 22
     e94:	9c 91       	ld	r25, X
     e96:	29 17       	cp	r18, r25
     e98:	08 f0       	brcs	.+2      	; 0xe9c <xTaskPriorityInherit+0xbc>
     e9a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     e9c:	df 91       	pop	r29
     e9e:	cf 91       	pop	r28
     ea0:	1f 91       	pop	r17
     ea2:	0f 91       	pop	r16
     ea4:	08 95       	ret

00000ea6 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	cf 93       	push	r28
     eac:	df 93       	push	r29
     eae:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
     eb0:	89 2b       	or	r24, r25
     eb2:	11 f4       	brne	.+4      	; 0xeb8 <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
     eb4:	80 e0       	ldi	r24, 0x00	; 0
     eb6:	2c c0       	rjmp	.+88     	; 0xf10 <xTaskPriorityDisinherit+0x6a>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
     eb8:	82 a1       	ldd	r24, Z+34	; 0x22
     eba:	81 50       	subi	r24, 0x01	; 1
     ebc:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
     ebe:	26 89       	ldd	r18, Z+22	; 0x16
     ec0:	91 a1       	ldd	r25, Z+33	; 0x21
     ec2:	29 17       	cp	r18, r25
     ec4:	b9 f3       	breq	.-18     	; 0xeb4 <xTaskPriorityDisinherit+0xe>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
     ec6:	81 11       	cpse	r24, r1
     ec8:	f5 cf       	rjmp	.-22     	; 0xeb4 <xTaskPriorityDisinherit+0xe>
     eca:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     ecc:	8f 01       	movw	r16, r30
     ece:	0e 5f       	subi	r16, 0xFE	; 254
     ed0:	1f 4f       	sbci	r17, 0xFF	; 255
     ed2:	c8 01       	movw	r24, r16
     ed4:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
     ed8:	89 a1       	ldd	r24, Y+33	; 0x21
     eda:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     edc:	48 2f       	mov	r20, r24
     ede:	50 e0       	ldi	r21, 0x00	; 0
     ee0:	24 e0       	ldi	r18, 0x04	; 4
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	24 1b       	sub	r18, r20
     ee6:	35 0b       	sbc	r19, r21
     ee8:	3d 87       	std	Y+13, r19	; 0x0d
     eea:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
     eec:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     ef0:	98 17       	cp	r25, r24
     ef2:	10 f4       	brcc	.+4      	; 0xef8 <xTaskPriorityDisinherit+0x52>
     ef4:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     ef8:	29 e0       	ldi	r18, 0x09	; 9
     efa:	24 9f       	mul	r18, r20
     efc:	c0 01       	movw	r24, r0
     efe:	25 9f       	mul	r18, r21
     f00:	90 0d       	add	r25, r0
     f02:	11 24       	eor	r1, r1
     f04:	b8 01       	movw	r22, r16
     f06:	89 59       	subi	r24, 0x99	; 153
     f08:	9e 4f       	sbci	r25, 0xFE	; 254
     f0a:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
     f0e:	81 e0       	ldi	r24, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	1f 91       	pop	r17
     f16:	0f 91       	pop	r16
     f18:	08 95       	ret

00000f1a <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = pxMutexHolder;
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

		if( pxMutexHolder != NULL )
     f24:	89 2b       	or	r24, r25
     f26:	d9 f1       	breq	.+118    	; 0xf9e <vTaskPriorityDisinheritAfterTimeout+0x84>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
     f28:	91 a1       	ldd	r25, Z+33	; 0x21
     f2a:	96 17       	cp	r25, r22
     f2c:	08 f4       	brcc	.+2      	; 0xf30 <vTaskPriorityDisinheritAfterTimeout+0x16>
     f2e:	96 2f       	mov	r25, r22
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
     f30:	86 89       	ldd	r24, Z+22	; 0x16
     f32:	89 17       	cp	r24, r25
     f34:	a1 f1       	breq	.+104    	; 0xf9e <vTaskPriorityDisinheritAfterTimeout+0x84>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
     f36:	22 a1       	ldd	r18, Z+34	; 0x22
     f38:	21 30       	cpi	r18, 0x01	; 1
     f3a:	89 f5       	brne	.+98     	; 0xf9e <vTaskPriorityDisinheritAfterTimeout+0x84>
					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
					pxTCB->uxPriority = uxPriorityToUse;
     f3c:	96 8b       	std	Z+22, r25	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
     f3e:	24 85       	ldd	r18, Z+12	; 0x0c
     f40:	35 85       	ldd	r19, Z+13	; 0x0d
     f42:	37 fd       	sbrc	r19, 7
     f44:	06 c0       	rjmp	.+12     	; 0xf52 <vTaskPriorityDisinheritAfterTimeout+0x38>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f46:	24 e0       	ldi	r18, 0x04	; 4
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	29 1b       	sub	r18, r25
     f4c:	31 09       	sbc	r19, r1
     f4e:	35 87       	std	Z+13, r19	; 0x0d
     f50:	24 87       	std	Z+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
     f52:	29 e0       	ldi	r18, 0x09	; 9
     f54:	82 9f       	mul	r24, r18
     f56:	c0 01       	movw	r24, r0
     f58:	11 24       	eor	r1, r1
     f5a:	89 59       	subi	r24, 0x99	; 153
     f5c:	9e 4f       	sbci	r25, 0xFE	; 254
     f5e:	22 85       	ldd	r18, Z+10	; 0x0a
     f60:	33 85       	ldd	r19, Z+11	; 0x0b
     f62:	28 17       	cp	r18, r24
     f64:	39 07       	cpc	r19, r25
     f66:	d9 f4       	brne	.+54     	; 0xf9e <vTaskPriorityDisinheritAfterTimeout+0x84>
     f68:	ef 01       	movw	r28, r30
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     f6a:	8f 01       	movw	r16, r30
     f6c:	0e 5f       	subi	r16, 0xFE	; 254
     f6e:	1f 4f       	sbci	r17, 0xFF	; 255
     f70:	c8 01       	movw	r24, r16
     f72:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
     f76:	8e 89       	ldd	r24, Y+22	; 0x16
     f78:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
     f7c:	98 17       	cp	r25, r24
     f7e:	10 f4       	brcc	.+4      	; 0xf84 <vTaskPriorityDisinheritAfterTimeout+0x6a>
     f80:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
     f84:	29 e0       	ldi	r18, 0x09	; 9
     f86:	82 9f       	mul	r24, r18
     f88:	c0 01       	movw	r24, r0
     f8a:	11 24       	eor	r1, r1
     f8c:	b8 01       	movw	r22, r16
     f8e:	89 59       	subi	r24, 0x99	; 153
     f90:	9e 4f       	sbci	r25, 0xFE	; 254
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f92:	df 91       	pop	r29
     f94:	cf 91       	pop	r28
     f96:	1f 91       	pop	r17
     f98:	0f 91       	pop	r16
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
     f9a:	0c 94 7e 0f 	jmp	0x1efc	; 0x1efc <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	1f 91       	pop	r17
     fa4:	0f 91       	pop	r16
     fa6:	08 95       	ret

00000fa8 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     fa8:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     fac:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fb0:	84 85       	ldd	r24, Z+12	; 0x0c
     fb2:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     fb4:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     fb8:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fbc:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
     fc0:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fc4:	56 96       	adiw	r26, 0x16	; 22
     fc6:	4c 91       	ld	r20, X
     fc8:	24 e0       	ldi	r18, 0x04	; 4
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	24 1b       	sub	r18, r20
     fce:	31 09       	sbc	r19, r1
     fd0:	35 87       	std	Z+13, r19	; 0x0d
     fd2:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     fd4:	08 95       	ret

00000fd6 <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
     fd6:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     fda:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fde:	89 2b       	or	r24, r25
     fe0:	39 f0       	breq	.+14     	; 0xff0 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
     fe2:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
     fe6:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
     fea:	82 a1       	ldd	r24, Z+34	; 0x22
     fec:	8f 5f       	subi	r24, 0xFF	; 255
     fee:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
     ff0:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
     ff4:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
	}
     ff8:	08 95       	ret

00000ffa <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     ffa:	0f 93       	push	r16
     ffc:	1f 93       	push	r17
     ffe:	18 2f       	mov	r17, r24
    1000:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	f8 94       	cli
    1006:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1008:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    100c:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1010:	43 a1       	ldd	r20, Z+35	; 0x23
    1012:	54 a1       	ldd	r21, Z+36	; 0x24
    1014:	65 a1       	ldd	r22, Z+37	; 0x25
    1016:	76 a1       	ldd	r23, Z+38	; 0x26
    1018:	45 2b       	or	r20, r21
    101a:	46 2b       	or	r20, r22
    101c:	47 2b       	or	r20, r23
    101e:	69 f4       	brne	.+26     	; 0x103a <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1020:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1024:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1028:	21 e0       	ldi	r18, 0x01	; 1
    102a:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    102c:	00 97       	sbiw	r24, 0x00	; 0
    102e:	29 f0       	breq	.+10     	; 0x103a <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1030:	61 e0       	ldi	r22, 0x01	; 1
    1032:	0e 94 3d 01 	call	0x27a	; 0x27a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1036:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    103a:	0f 90       	pop	r0
    103c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    103e:	0f b6       	in	r0, 0x3f	; 63
    1040:	f8 94       	cli
    1042:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1044:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1048:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    104c:	63 a1       	ldd	r22, Z+35	; 0x23
    104e:	74 a1       	ldd	r23, Z+36	; 0x24
    1050:	85 a1       	ldd	r24, Z+37	; 0x25
    1052:	96 a1       	ldd	r25, Z+38	; 0x26

			if( ulReturn != 0UL )
    1054:	61 15       	cp	r22, r1
    1056:	71 05       	cpc	r23, r1
    1058:	81 05       	cpc	r24, r1
    105a:	91 05       	cpc	r25, r1
    105c:	a9 f0       	breq	.+42     	; 0x1088 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    105e:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1062:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    1066:	11 23       	and	r17, r17
    1068:	29 f0       	breq	.+10     	; 0x1074 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    106a:	13 a2       	std	Z+35, r1	; 0x23
    106c:	14 a2       	std	Z+36, r1	; 0x24
    106e:	15 a2       	std	Z+37, r1	; 0x25
    1070:	16 a2       	std	Z+38, r1	; 0x26
    1072:	0a c0       	rjmp	.+20     	; 0x1088 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    1074:	8b 01       	movw	r16, r22
    1076:	9c 01       	movw	r18, r24
    1078:	01 50       	subi	r16, 0x01	; 1
    107a:	11 09       	sbc	r17, r1
    107c:	21 09       	sbc	r18, r1
    107e:	31 09       	sbc	r19, r1
    1080:	03 a3       	std	Z+35, r16	; 0x23
    1082:	14 a3       	std	Z+36, r17	; 0x24
    1084:	25 a3       	std	Z+37, r18	; 0x25
    1086:	36 a3       	std	Z+38, r19	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1088:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    108c:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1090:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    1092:	0f 90       	pop	r0
    1094:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1096:	1f 91       	pop	r17
    1098:	0f 91       	pop	r16
    109a:	08 95       	ret

0000109c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    109c:	4f 92       	push	r4
    109e:	5f 92       	push	r5
    10a0:	6f 92       	push	r6
    10a2:	7f 92       	push	r7
    10a4:	8f 92       	push	r8
    10a6:	9f 92       	push	r9
    10a8:	af 92       	push	r10
    10aa:	bf 92       	push	r11
    10ac:	ef 92       	push	r14
    10ae:	ff 92       	push	r15
    10b0:	0f 93       	push	r16
    10b2:	1f 93       	push	r17
    10b4:	49 01       	movw	r8, r18
    10b6:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    10b8:	0f b6       	in	r0, 0x3f	; 63
    10ba:	f8 94       	cli
    10bc:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    10be:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    10c2:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    10c6:	27 a1       	ldd	r18, Z+39	; 0x27
    10c8:	22 30       	cpi	r18, 0x02	; 2
    10ca:	39 f1       	breq	.+78     	; 0x111a <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    10cc:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    10d0:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    10d4:	23 a1       	ldd	r18, Z+35	; 0x23
    10d6:	34 a1       	ldd	r19, Z+36	; 0x24
    10d8:	45 a1       	ldd	r20, Z+37	; 0x25
    10da:	56 a1       	ldd	r21, Z+38	; 0x26
    10dc:	2b 01       	movw	r4, r22
    10de:	3c 01       	movw	r6, r24
    10e0:	40 94       	com	r4
    10e2:	50 94       	com	r5
    10e4:	60 94       	com	r6
    10e6:	70 94       	com	r7
    10e8:	d3 01       	movw	r26, r6
    10ea:	c2 01       	movw	r24, r4
    10ec:	82 23       	and	r24, r18
    10ee:	93 23       	and	r25, r19
    10f0:	a4 23       	and	r26, r20
    10f2:	b5 23       	and	r27, r21
    10f4:	83 a3       	std	Z+35, r24	; 0x23
    10f6:	94 a3       	std	Z+36, r25	; 0x24
    10f8:	a5 a3       	std	Z+37, r26	; 0x25
    10fa:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    10fc:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1100:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    1108:	e1 14       	cp	r14, r1
    110a:	f1 04       	cpc	r15, r1
    110c:	31 f0       	breq	.+12     	; 0x111a <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    110e:	61 e0       	ldi	r22, 0x01	; 1
    1110:	c7 01       	movw	r24, r14
    1112:	0e 94 3d 01 	call	0x27a	; 0x27a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1116:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    111a:	0f 90       	pop	r0
    111c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	f8 94       	cli
    1122:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1124:	01 15       	cp	r16, r1
    1126:	11 05       	cpc	r17, r1
    1128:	69 f0       	breq	.+26     	; 0x1144 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    112a:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    112e:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1132:	83 a1       	ldd	r24, Z+35	; 0x23
    1134:	94 a1       	ldd	r25, Z+36	; 0x24
    1136:	a5 a1       	ldd	r26, Z+37	; 0x25
    1138:	b6 a1       	ldd	r27, Z+38	; 0x26
    113a:	f8 01       	movw	r30, r16
    113c:	80 83       	st	Z, r24
    113e:	91 83       	std	Z+1, r25	; 0x01
    1140:	a2 83       	std	Z+2, r26	; 0x02
    1142:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1144:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1148:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    114c:	87 a1       	ldd	r24, Z+39	; 0x27
    114e:	82 30       	cpi	r24, 0x02	; 2
    1150:	c1 f4       	brne	.+48     	; 0x1182 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1152:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1156:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    115a:	43 a1       	ldd	r20, Z+35	; 0x23
    115c:	54 a1       	ldd	r21, Z+36	; 0x24
    115e:	65 a1       	ldd	r22, Z+37	; 0x25
    1160:	76 a1       	ldd	r23, Z+38	; 0x26
    1162:	d5 01       	movw	r26, r10
    1164:	c4 01       	movw	r24, r8
    1166:	80 95       	com	r24
    1168:	90 95       	com	r25
    116a:	a0 95       	com	r26
    116c:	b0 95       	com	r27
    116e:	84 23       	and	r24, r20
    1170:	95 23       	and	r25, r21
    1172:	a6 23       	and	r26, r22
    1174:	b7 23       	and	r27, r23
    1176:	83 a3       	std	Z+35, r24	; 0x23
    1178:	94 a3       	std	Z+36, r25	; 0x24
    117a:	a5 a3       	std	Z+37, r26	; 0x25
    117c:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	01 c0       	rjmp	.+2      	; 0x1184 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1182:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1184:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1188:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    118c:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    118e:	0f 90       	pop	r0
    1190:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1192:	1f 91       	pop	r17
    1194:	0f 91       	pop	r16
    1196:	ff 90       	pop	r15
    1198:	ef 90       	pop	r14
    119a:	bf 90       	pop	r11
    119c:	af 90       	pop	r10
    119e:	9f 90       	pop	r9
    11a0:	8f 90       	pop	r8
    11a2:	7f 90       	pop	r7
    11a4:	6f 90       	pop	r6
    11a6:	5f 90       	pop	r5
    11a8:	4f 90       	pop	r4
    11aa:	08 95       	ret

000011ac <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    11ac:	0f 93       	push	r16
    11ae:	1f 93       	push	r17
    11b0:	cf 93       	push	r28
    11b2:	df 93       	push	r29
    11b4:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    11b6:	0f b6       	in	r0, 0x3f	; 63
    11b8:	f8 94       	cli
    11ba:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    11bc:	01 15       	cp	r16, r1
    11be:	11 05       	cpc	r17, r1
    11c0:	49 f0       	breq	.+18     	; 0x11d4 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    11c2:	83 a1       	ldd	r24, Z+35	; 0x23
    11c4:	94 a1       	ldd	r25, Z+36	; 0x24
    11c6:	a5 a1       	ldd	r26, Z+37	; 0x25
    11c8:	b6 a1       	ldd	r27, Z+38	; 0x26
    11ca:	e8 01       	movw	r28, r16
    11cc:	88 83       	st	Y, r24
    11ce:	99 83       	std	Y+1, r25	; 0x01
    11d0:	aa 83       	std	Y+2, r26	; 0x02
    11d2:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    11d4:	37 a1       	ldd	r19, Z+39	; 0x27

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    11d6:	82 e0       	ldi	r24, 0x02	; 2
    11d8:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    11da:	22 30       	cpi	r18, 0x02	; 2
    11dc:	89 f0       	breq	.+34     	; 0x1200 <xTaskGenericNotify+0x54>
    11de:	58 f4       	brcc	.+22     	; 0x11f6 <xTaskGenericNotify+0x4a>
    11e0:	21 30       	cpi	r18, 0x01	; 1
    11e2:	01 f5       	brne	.+64     	; 0x1224 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    11e4:	83 a1       	ldd	r24, Z+35	; 0x23
    11e6:	94 a1       	ldd	r25, Z+36	; 0x24
    11e8:	a5 a1       	ldd	r26, Z+37	; 0x25
    11ea:	b6 a1       	ldd	r27, Z+38	; 0x26
    11ec:	48 2b       	or	r20, r24
    11ee:	59 2b       	or	r21, r25
    11f0:	6a 2b       	or	r22, r26
    11f2:	7b 2b       	or	r23, r27
    11f4:	13 c0       	rjmp	.+38     	; 0x121c <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    11f6:	23 30       	cpi	r18, 0x03	; 3
    11f8:	89 f0       	breq	.+34     	; 0x121c <xTaskGenericNotify+0x70>
    11fa:	24 30       	cpi	r18, 0x04	; 4
    11fc:	69 f0       	breq	.+26     	; 0x1218 <xTaskGenericNotify+0x6c>
    11fe:	12 c0       	rjmp	.+36     	; 0x1224 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1200:	83 a1       	ldd	r24, Z+35	; 0x23
    1202:	94 a1       	ldd	r25, Z+36	; 0x24
    1204:	a5 a1       	ldd	r26, Z+37	; 0x25
    1206:	b6 a1       	ldd	r27, Z+38	; 0x26
    1208:	01 96       	adiw	r24, 0x01	; 1
    120a:	a1 1d       	adc	r26, r1
    120c:	b1 1d       	adc	r27, r1
    120e:	83 a3       	std	Z+35, r24	; 0x23
    1210:	94 a3       	std	Z+36, r25	; 0x24
    1212:	a5 a3       	std	Z+37, r26	; 0x25
    1214:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    1216:	06 c0       	rjmp	.+12     	; 0x1224 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1218:	32 30       	cpi	r19, 0x02	; 2
    121a:	49 f1       	breq	.+82     	; 0x126e <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    121c:	43 a3       	std	Z+35, r20	; 0x23
    121e:	54 a3       	std	Z+36, r21	; 0x24
    1220:	65 a3       	std	Z+37, r22	; 0x25
    1222:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1224:	31 30       	cpi	r19, 0x01	; 1
    1226:	09 f5       	brne	.+66     	; 0x126a <xTaskGenericNotify+0xbe>
    1228:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    122a:	8f 01       	movw	r16, r30
    122c:	0e 5f       	subi	r16, 0xFE	; 254
    122e:	1f 4f       	sbci	r17, 0xFF	; 255
    1230:	c8 01       	movw	r24, r16
    1232:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1236:	8e 89       	ldd	r24, Y+22	; 0x16
    1238:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
    123c:	98 17       	cp	r25, r24
    123e:	10 f4       	brcc	.+4      	; 0x1244 <xTaskGenericNotify+0x98>
    1240:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
    1244:	29 e0       	ldi	r18, 0x09	; 9
    1246:	82 9f       	mul	r24, r18
    1248:	c0 01       	movw	r24, r0
    124a:	11 24       	eor	r1, r1
    124c:	b8 01       	movw	r22, r16
    124e:	89 59       	subi	r24, 0x99	; 153
    1250:	9e 4f       	sbci	r25, 0xFE	; 254
    1252:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1256:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    125a:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    125e:	9e 89       	ldd	r25, Y+22	; 0x16
    1260:	86 89       	ldd	r24, Z+22	; 0x16
    1262:	89 17       	cp	r24, r25
    1264:	10 f4       	brcc	.+4      	; 0x126a <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    1266:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	01 c0       	rjmp	.+2      	; 0x1270 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    126e:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1270:	0f 90       	pop	r0
    1272:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	1f 91       	pop	r17
    127a:	0f 91       	pop	r16
    127c:	08 95       	ret

0000127e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    127e:	ef 92       	push	r14
    1280:	ff 92       	push	r15
    1282:	0f 93       	push	r16
    1284:	1f 93       	push	r17
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    128c:	01 15       	cp	r16, r1
    128e:	11 05       	cpc	r17, r1
    1290:	49 f0       	breq	.+18     	; 0x12a4 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1292:	83 a1       	ldd	r24, Z+35	; 0x23
    1294:	94 a1       	ldd	r25, Z+36	; 0x24
    1296:	a5 a1       	ldd	r26, Z+37	; 0x25
    1298:	b6 a1       	ldd	r27, Z+38	; 0x26
    129a:	e8 01       	movw	r28, r16
    129c:	88 83       	st	Y, r24
    129e:	99 83       	std	Y+1, r25	; 0x01
    12a0:	aa 83       	std	Y+2, r26	; 0x02
    12a2:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    12a4:	37 a1       	ldd	r19, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    12a6:	82 e0       	ldi	r24, 0x02	; 2
    12a8:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    12aa:	22 30       	cpi	r18, 0x02	; 2
    12ac:	89 f0       	breq	.+34     	; 0x12d0 <xTaskGenericNotifyFromISR+0x52>
    12ae:	58 f4       	brcc	.+22     	; 0x12c6 <xTaskGenericNotifyFromISR+0x48>
    12b0:	21 30       	cpi	r18, 0x01	; 1
    12b2:	01 f5       	brne	.+64     	; 0x12f4 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    12b4:	83 a1       	ldd	r24, Z+35	; 0x23
    12b6:	94 a1       	ldd	r25, Z+36	; 0x24
    12b8:	a5 a1       	ldd	r26, Z+37	; 0x25
    12ba:	b6 a1       	ldd	r27, Z+38	; 0x26
    12bc:	48 2b       	or	r20, r24
    12be:	59 2b       	or	r21, r25
    12c0:	6a 2b       	or	r22, r26
    12c2:	7b 2b       	or	r23, r27
    12c4:	13 c0       	rjmp	.+38     	; 0x12ec <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    12c6:	23 30       	cpi	r18, 0x03	; 3
    12c8:	89 f0       	breq	.+34     	; 0x12ec <xTaskGenericNotifyFromISR+0x6e>
    12ca:	24 30       	cpi	r18, 0x04	; 4
    12cc:	69 f0       	breq	.+26     	; 0x12e8 <xTaskGenericNotifyFromISR+0x6a>
    12ce:	12 c0       	rjmp	.+36     	; 0x12f4 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    12d0:	83 a1       	ldd	r24, Z+35	; 0x23
    12d2:	94 a1       	ldd	r25, Z+36	; 0x24
    12d4:	a5 a1       	ldd	r26, Z+37	; 0x25
    12d6:	b6 a1       	ldd	r27, Z+38	; 0x26
    12d8:	01 96       	adiw	r24, 0x01	; 1
    12da:	a1 1d       	adc	r26, r1
    12dc:	b1 1d       	adc	r27, r1
    12de:	83 a3       	std	Z+35, r24	; 0x23
    12e0:	94 a3       	std	Z+36, r25	; 0x24
    12e2:	a5 a3       	std	Z+37, r26	; 0x25
    12e4:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    12e6:	06 c0       	rjmp	.+12     	; 0x12f4 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    12e8:	32 30       	cpi	r19, 0x02	; 2
    12ea:	d9 f1       	breq	.+118    	; 0x1362 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    12ec:	43 a3       	std	Z+35, r20	; 0x23
    12ee:	54 a3       	std	Z+36, r21	; 0x24
    12f0:	65 a3       	std	Z+37, r22	; 0x25
    12f2:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    12f4:	31 30       	cpi	r19, 0x01	; 1
    12f6:	11 f0       	breq	.+4      	; 0x12fc <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	34 c0       	rjmp	.+104    	; 0x1364 <xTaskGenericNotifyFromISR+0xe6>
    12fc:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    12fe:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
    1302:	81 11       	cpse	r24, r1
    1304:	15 c0       	rjmp	.+42     	; 0x1330 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1306:	8f 01       	movw	r16, r30
    1308:	0e 5f       	subi	r16, 0xFE	; 254
    130a:	1f 4f       	sbci	r17, 0xFF	; 255
    130c:	c8 01       	movw	r24, r16
    130e:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1312:	8e 89       	ldd	r24, Y+22	; 0x16
    1314:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
    1318:	98 17       	cp	r25, r24
    131a:	10 f4       	brcc	.+4      	; 0x1320 <xTaskGenericNotifyFromISR+0xa2>
    131c:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
    1320:	e9 e0       	ldi	r30, 0x09	; 9
    1322:	8e 9f       	mul	r24, r30
    1324:	c0 01       	movw	r24, r0
    1326:	11 24       	eor	r1, r1
    1328:	b8 01       	movw	r22, r16
    132a:	89 59       	subi	r24, 0x99	; 153
    132c:	9e 4f       	sbci	r25, 0xFE	; 254
    132e:	05 c0       	rjmp	.+10     	; 0x133a <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1330:	bf 01       	movw	r22, r30
    1332:	64 5f       	subi	r22, 0xF4	; 244
    1334:	7f 4f       	sbci	r23, 0xFF	; 255
    1336:	88 e4       	ldi	r24, 0x48	; 72
    1338:	91 e0       	ldi	r25, 0x01	; 1
    133a:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    133e:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    1342:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    1346:	9e 89       	ldd	r25, Y+22	; 0x16
    1348:	86 89       	ldd	r24, Z+22	; 0x16
    134a:	89 17       	cp	r24, r25
    134c:	a8 f6       	brcc	.-86     	; 0x12f8 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    134e:	e1 14       	cp	r14, r1
    1350:	f1 04       	cpc	r15, r1
    1352:	19 f0       	breq	.+6      	; 0x135a <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	e7 01       	movw	r28, r14
    1358:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
    1360:	01 c0       	rjmp	.+2      	; 0x1364 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1362:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	1f 91       	pop	r17
    136a:	0f 91       	pop	r16
    136c:	ff 90       	pop	r15
    136e:	ef 90       	pop	r14
    1370:	08 95       	ret

00001372 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1372:	ef 92       	push	r14
    1374:	ff 92       	push	r15
    1376:	0f 93       	push	r16
    1378:	1f 93       	push	r17
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
    137e:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1380:	27 a1       	ldd	r18, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1382:	82 e0       	ldi	r24, 0x02	; 2
    1384:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1386:	83 a1       	ldd	r24, Z+35	; 0x23
    1388:	94 a1       	ldd	r25, Z+36	; 0x24
    138a:	a5 a1       	ldd	r26, Z+37	; 0x25
    138c:	b6 a1       	ldd	r27, Z+38	; 0x26
    138e:	01 96       	adiw	r24, 0x01	; 1
    1390:	a1 1d       	adc	r26, r1
    1392:	b1 1d       	adc	r27, r1
    1394:	83 a3       	std	Z+35, r24	; 0x23
    1396:	94 a3       	std	Z+36, r25	; 0x24
    1398:	a5 a3       	std	Z+37, r26	; 0x25
    139a:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    139c:	21 30       	cpi	r18, 0x01	; 1
    139e:	a1 f5       	brne	.+104    	; 0x1408 <vTaskNotifyGiveFromISR+0x96>
    13a0:	8b 01       	movw	r16, r22
    13a2:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    13a4:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxSchedulerSuspended>
    13a8:	81 11       	cpse	r24, r1
    13aa:	16 c0       	rjmp	.+44     	; 0x13d8 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    13ac:	7f 01       	movw	r14, r30
    13ae:	22 e0       	ldi	r18, 0x02	; 2
    13b0:	e2 0e       	add	r14, r18
    13b2:	f1 1c       	adc	r15, r1
    13b4:	c7 01       	movw	r24, r14
    13b6:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    13ba:	8e 89       	ldd	r24, Y+22	; 0x16
    13bc:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <uxTopReadyPriority>
    13c0:	98 17       	cp	r25, r24
    13c2:	10 f4       	brcc	.+4      	; 0x13c8 <vTaskNotifyGiveFromISR+0x56>
    13c4:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTopReadyPriority>
    13c8:	e9 e0       	ldi	r30, 0x09	; 9
    13ca:	8e 9f       	mul	r24, r30
    13cc:	c0 01       	movw	r24, r0
    13ce:	11 24       	eor	r1, r1
    13d0:	b7 01       	movw	r22, r14
    13d2:	89 59       	subi	r24, 0x99	; 153
    13d4:	9e 4f       	sbci	r25, 0xFE	; 254
    13d6:	05 c0       	rjmp	.+10     	; 0x13e2 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    13d8:	bf 01       	movw	r22, r30
    13da:	64 5f       	subi	r22, 0xF4	; 244
    13dc:	7f 4f       	sbci	r23, 0xFF	; 255
    13de:	88 e4       	ldi	r24, 0x48	; 72
    13e0:	91 e0       	ldi	r25, 0x01	; 1
    13e2:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    13e6:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentTCB>
    13ea:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    13ee:	9e 89       	ldd	r25, Y+22	; 0x16
    13f0:	86 89       	ldd	r24, Z+22	; 0x16
    13f2:	89 17       	cp	r24, r25
    13f4:	48 f4       	brcc	.+18     	; 0x1408 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    13f6:	01 15       	cp	r16, r1
    13f8:	11 05       	cpc	r17, r1
    13fa:	19 f0       	breq	.+6      	; 0x1402 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	f8 01       	movw	r30, r16
    1400:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	1f 91       	pop	r17
    140e:	0f 91       	pop	r16
    1410:	ff 90       	pop	r15
    1412:	ef 90       	pop	r14
    1414:	08 95       	ret

00001416 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1416:	00 97       	sbiw	r24, 0x00	; 0
    1418:	21 f4       	brne	.+8      	; 0x1422 <xTaskNotifyStateClear+0xc>
    141a:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentTCB>
    141e:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1428:	fc 01       	movw	r30, r24
    142a:	27 a1       	ldd	r18, Z+39	; 0x27
    142c:	22 30       	cpi	r18, 0x02	; 2
    142e:	19 f4       	brne	.+6      	; 0x1436 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1430:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	01 c0       	rjmp	.+2      	; 0x1438 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1436:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1438:	0f 90       	pop	r0
    143a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    143c:	08 95       	ret

0000143e <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1444:	fc 01       	movw	r30, r24
    1446:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1448:	0f 90       	pop	r0
    144a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    144c:	81 e0       	ldi	r24, 0x01	; 1
    144e:	91 11       	cpse	r25, r1
    1450:	80 e0       	ldi	r24, 0x00	; 0
}
    1452:	08 95       	ret

00001454 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1454:	0f 93       	push	r16
    1456:	1f 93       	push	r17
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	ec 01       	movw	r28, r24
    145e:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1460:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1462:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1464:	41 11       	cpse	r20, r1
    1466:	0b c0       	rjmp	.+22     	; 0x147e <prvCopyDataToQueue+0x2a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1468:	88 81       	ld	r24, Y
    146a:	99 81       	ldd	r25, Y+1	; 0x01
    146c:	89 2b       	or	r24, r25
    146e:	e9 f5       	brne	.+122    	; 0x14ea <prvCopyDataToQueue+0x96>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    1470:	8c 81       	ldd	r24, Y+4	; 0x04
    1472:	9d 81       	ldd	r25, Y+5	; 0x05
    1474:	0e 94 53 07 	call	0xea6	; 0xea6 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1478:	1d 82       	std	Y+5, r1	; 0x05
    147a:	1c 82       	std	Y+4, r1	; 0x04
    147c:	37 c0       	rjmp	.+110    	; 0x14ec <prvCopyDataToQueue+0x98>
    147e:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1480:	01 11       	cpse	r16, r1
    1482:	15 c0       	rjmp	.+42     	; 0x14ae <prvCopyDataToQueue+0x5a>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1484:	8a 81       	ldd	r24, Y+2	; 0x02
    1486:	9b 81       	ldd	r25, Y+3	; 0x03
    1488:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    148c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    148e:	8a 81       	ldd	r24, Y+2	; 0x02
    1490:	9b 81       	ldd	r25, Y+3	; 0x03
    1492:	82 0f       	add	r24, r18
    1494:	91 1d       	adc	r25, r1
    1496:	9b 83       	std	Y+3, r25	; 0x03
    1498:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    149a:	2c 81       	ldd	r18, Y+4	; 0x04
    149c:	3d 81       	ldd	r19, Y+5	; 0x05
    149e:	82 17       	cp	r24, r18
    14a0:	93 07       	cpc	r25, r19
    14a2:	18 f1       	brcs	.+70     	; 0x14ea <prvCopyDataToQueue+0x96>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    14a4:	88 81       	ld	r24, Y
    14a6:	99 81       	ldd	r25, Y+1	; 0x01
    14a8:	9b 83       	std	Y+3, r25	; 0x03
    14aa:	8a 83       	std	Y+2, r24	; 0x02
    14ac:	1e c0       	rjmp	.+60     	; 0x14ea <prvCopyDataToQueue+0x96>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    14ae:	8e 81       	ldd	r24, Y+6	; 0x06
    14b0:	9f 81       	ldd	r25, Y+7	; 0x07
    14b2:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    14b6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	91 95       	neg	r25
    14bc:	81 95       	neg	r24
    14be:	91 09       	sbc	r25, r1
    14c0:	2e 81       	ldd	r18, Y+6	; 0x06
    14c2:	3f 81       	ldd	r19, Y+7	; 0x07
    14c4:	28 0f       	add	r18, r24
    14c6:	39 1f       	adc	r19, r25
    14c8:	3f 83       	std	Y+7, r19	; 0x07
    14ca:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    14cc:	48 81       	ld	r20, Y
    14ce:	59 81       	ldd	r21, Y+1	; 0x01
    14d0:	24 17       	cp	r18, r20
    14d2:	35 07       	cpc	r19, r21
    14d4:	30 f4       	brcc	.+12     	; 0x14e2 <prvCopyDataToQueue+0x8e>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    14d6:	2c 81       	ldd	r18, Y+4	; 0x04
    14d8:	3d 81       	ldd	r19, Y+5	; 0x05
    14da:	82 0f       	add	r24, r18
    14dc:	93 1f       	adc	r25, r19
    14de:	9f 83       	std	Y+7, r25	; 0x07
    14e0:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    14e2:	02 30       	cpi	r16, 0x02	; 2
    14e4:	11 f4       	brne	.+4      	; 0x14ea <prvCopyDataToQueue+0x96>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    14e6:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    14e8:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    14ea:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    14ec:	1f 5f       	subi	r17, 0xFF	; 255
    14ee:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    14f0:	df 91       	pop	r29
    14f2:	cf 91       	pop	r28
    14f4:	1f 91       	pop	r17
    14f6:	0f 91       	pop	r16
    14f8:	08 95       	ret

000014fa <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    14fa:	fc 01       	movw	r30, r24
    14fc:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    14fe:	44 8d       	ldd	r20, Z+28	; 0x1c
    1500:	44 23       	and	r20, r20
    1502:	a1 f0       	breq	.+40     	; 0x152c <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1504:	50 e0       	ldi	r21, 0x00	; 0
    1506:	26 81       	ldd	r18, Z+6	; 0x06
    1508:	37 81       	ldd	r19, Z+7	; 0x07
    150a:	24 0f       	add	r18, r20
    150c:	35 1f       	adc	r19, r21
    150e:	37 83       	std	Z+7, r19	; 0x07
    1510:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1512:	64 81       	ldd	r22, Z+4	; 0x04
    1514:	75 81       	ldd	r23, Z+5	; 0x05
    1516:	26 17       	cp	r18, r22
    1518:	37 07       	cpc	r19, r23
    151a:	20 f0       	brcs	.+8      	; 0x1524 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    151c:	20 81       	ld	r18, Z
    151e:	31 81       	ldd	r19, Z+1	; 0x01
    1520:	37 83       	std	Z+7, r19	; 0x07
    1522:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1524:	66 81       	ldd	r22, Z+6	; 0x06
    1526:	77 81       	ldd	r23, Z+7	; 0x07
    1528:	0c 94 ec 13 	jmp	0x27d8	; 0x27d8 <memcpy>
    152c:	08 95       	ret

0000152e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    152e:	ef 92       	push	r14
    1530:	ff 92       	push	r15
    1532:	1f 93       	push	r17
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    153a:	0f b6       	in	r0, 0x3f	; 63
    153c:	f8 94       	cli
    153e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1540:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1542:	7c 01       	movw	r14, r24
    1544:	81 e1       	ldi	r24, 0x11	; 17
    1546:	e8 0e       	add	r14, r24
    1548:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    154a:	11 16       	cp	r1, r17
    154c:	5c f4       	brge	.+22     	; 0x1564 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    154e:	89 89       	ldd	r24, Y+17	; 0x11
    1550:	88 23       	and	r24, r24
    1552:	41 f0       	breq	.+16     	; 0x1564 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1554:	c7 01       	movw	r24, r14
    1556:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    155a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    155c:	0e 94 e7 06 	call	0xdce	; 0xdce <vTaskMissedYield>
    1560:	11 50       	subi	r17, 0x01	; 1
    1562:	f3 cf       	rjmp	.-26     	; 0x154a <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1564:	8f ef       	ldi	r24, 0xFF	; 255
    1566:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1572:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1574:	7e 01       	movw	r14, r28
    1576:	88 e0       	ldi	r24, 0x08	; 8
    1578:	e8 0e       	add	r14, r24
    157a:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    157c:	11 16       	cp	r1, r17
    157e:	5c f4       	brge	.+22     	; 0x1596 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1580:	88 85       	ldd	r24, Y+8	; 0x08
    1582:	88 23       	and	r24, r24
    1584:	41 f0       	breq	.+16     	; 0x1596 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1586:	c7 01       	movw	r24, r14
    1588:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    158c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    158e:	0e 94 e7 06 	call	0xdce	; 0xdce <vTaskMissedYield>
    1592:	11 50       	subi	r17, 0x01	; 1
    1594:	f3 cf       	rjmp	.-26     	; 0x157c <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1596:	8f ef       	ldi	r24, 0xFF	; 255
    1598:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    159a:	0f 90       	pop	r0
    159c:	0f be       	out	0x3f, r0	; 63
}
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	ff 90       	pop	r15
    15a6:	ef 90       	pop	r14
    15a8:	08 95       	ret

000015aa <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    15aa:	cf 93       	push	r28
    15ac:	df 93       	push	r29
    15ae:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    15b6:	48 81       	ld	r20, Y
    15b8:	59 81       	ldd	r21, Y+1	; 0x01
    15ba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    15bc:	7c 8d       	ldd	r23, Y+28	; 0x1c
    15be:	9a 01       	movw	r18, r20
    15c0:	87 9f       	mul	r24, r23
    15c2:	20 0d       	add	r18, r0
    15c4:	31 1d       	adc	r19, r1
    15c6:	11 24       	eor	r1, r1
    15c8:	3d 83       	std	Y+5, r19	; 0x05
    15ca:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    15cc:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    15ce:	5b 83       	std	Y+3, r21	; 0x03
    15d0:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	01 97       	sbiw	r24, 0x01	; 1
    15d6:	78 9f       	mul	r23, r24
    15d8:	90 01       	movw	r18, r0
    15da:	79 9f       	mul	r23, r25
    15dc:	30 0d       	add	r19, r0
    15de:	11 24       	eor	r1, r1
    15e0:	ca 01       	movw	r24, r20
    15e2:	82 0f       	add	r24, r18
    15e4:	93 1f       	adc	r25, r19
    15e6:	9f 83       	std	Y+7, r25	; 0x07
    15e8:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    15ea:	8f ef       	ldi	r24, 0xFF	; 255
    15ec:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    15ee:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    15f0:	61 11       	cpse	r22, r1
    15f2:	0c c0       	rjmp	.+24     	; 0x160c <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15f4:	88 85       	ldd	r24, Y+8	; 0x08
    15f6:	88 23       	and	r24, r24
    15f8:	89 f0       	breq	.+34     	; 0x161c <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15fa:	ce 01       	movw	r24, r28
    15fc:	08 96       	adiw	r24, 0x08	; 8
    15fe:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    1602:	88 23       	and	r24, r24
    1604:	59 f0       	breq	.+22     	; 0x161c <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1606:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    160a:	08 c0       	rjmp	.+16     	; 0x161c <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    160c:	ce 01       	movw	r24, r28
    160e:	08 96       	adiw	r24, 0x08	; 8
    1610:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1614:	ce 01       	movw	r24, r28
    1616:	41 96       	adiw	r24, 0x11	; 17
    1618:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    161c:	0f 90       	pop	r0
    161e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	df 91       	pop	r29
    1624:	cf 91       	pop	r28
    1626:	08 95       	ret

00001628 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	08 2f       	mov	r16, r24
    1632:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1634:	66 23       	and	r22, r22
    1636:	21 f0       	breq	.+8      	; 0x1640 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1638:	86 9f       	mul	r24, r22
    163a:	c0 01       	movw	r24, r0
    163c:	11 24       	eor	r1, r1
    163e:	02 c0       	rjmp	.+4      	; 0x1644 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1644:	4f 96       	adiw	r24, 0x1f	; 31
    1646:	0e 94 c1 11 	call	0x2382	; 0x2382 <pvPortMalloc>
    164a:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    164c:	00 97       	sbiw	r24, 0x00	; 0
    164e:	71 f0       	breq	.+28     	; 0x166c <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1650:	11 11       	cpse	r17, r1
    1652:	03 c0       	rjmp	.+6      	; 0x165a <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1654:	99 83       	std	Y+1, r25	; 0x01
    1656:	88 83       	st	Y, r24
    1658:	03 c0       	rjmp	.+6      	; 0x1660 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    165a:	4f 96       	adiw	r24, 0x1f	; 31
    165c:	99 83       	std	Y+1, r25	; 0x01
    165e:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1660:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1662:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1664:	61 e0       	ldi	r22, 0x01	; 1
    1666:	ce 01       	movw	r24, r28
    1668:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    166c:	ce 01       	movw	r24, r28
    166e:	df 91       	pop	r29
    1670:	cf 91       	pop	r28
    1672:	1f 91       	pop	r17
    1674:	0f 91       	pop	r16
    1676:	08 95       	ret

00001678 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1678:	af 92       	push	r10
    167a:	bf 92       	push	r11
    167c:	cf 92       	push	r12
    167e:	df 92       	push	r13
    1680:	ff 92       	push	r15
    1682:	0f 93       	push	r16
    1684:	1f 93       	push	r17
    1686:	cf 93       	push	r28
    1688:	df 93       	push	r29
    168a:	00 d0       	rcall	.+0      	; 0x168c <xQueueGenericSend+0x14>
    168c:	00 d0       	rcall	.+0      	; 0x168e <xQueueGenericSend+0x16>
    168e:	1f 92       	push	r1
    1690:	cd b7       	in	r28, 0x3d	; 61
    1692:	de b7       	in	r29, 0x3e	; 62
    1694:	8c 01       	movw	r16, r24
    1696:	6b 01       	movw	r12, r22
    1698:	5d 83       	std	Y+5, r21	; 0x05
    169a:	4c 83       	std	Y+4, r20	; 0x04
    169c:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    169e:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16a0:	58 01       	movw	r10, r16
    16a2:	98 e0       	ldi	r25, 0x08	; 8
    16a4:	a9 0e       	add	r10, r25
    16a6:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16a8:	0f b6       	in	r0, 0x3f	; 63
    16aa:	f8 94       	cli
    16ac:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    16ae:	f8 01       	movw	r30, r16
    16b0:	22 8d       	ldd	r18, Z+26	; 0x1a
    16b2:	93 8d       	ldd	r25, Z+27	; 0x1b
    16b4:	29 17       	cp	r18, r25
    16b6:	18 f0       	brcs	.+6      	; 0x16be <xQueueGenericSend+0x46>
    16b8:	f2 e0       	ldi	r31, 0x02	; 2
    16ba:	ff 12       	cpse	r15, r31
    16bc:	14 c0       	rjmp	.+40     	; 0x16e6 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    16be:	4f 2d       	mov	r20, r15
    16c0:	b6 01       	movw	r22, r12
    16c2:	c8 01       	movw	r24, r16
    16c4:	0e 94 2a 0a 	call	0x1454	; 0x1454 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16c8:	f8 01       	movw	r30, r16
    16ca:	91 89       	ldd	r25, Z+17	; 0x11
    16cc:	99 23       	and	r25, r25
    16ce:	21 f0       	breq	.+8      	; 0x16d8 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16d0:	c8 01       	movw	r24, r16
    16d2:	41 96       	adiw	r24, 0x11	; 17
    16d4:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    16d8:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    16da:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16e2:	81 e0       	ldi	r24, 0x01	; 1
    16e4:	50 c0       	rjmp	.+160    	; 0x1786 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16e6:	2c 81       	ldd	r18, Y+4	; 0x04
    16e8:	3d 81       	ldd	r19, Y+5	; 0x05
    16ea:	23 2b       	or	r18, r19
    16ec:	19 f4       	brne	.+6      	; 0x16f4 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16ee:	0f 90       	pop	r0
    16f0:	0f be       	out	0x3f, r0	; 63
    16f2:	48 c0       	rjmp	.+144    	; 0x1784 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    16f4:	81 11       	cpse	r24, r1
    16f6:	04 c0       	rjmp	.+8      	; 0x1700 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16f8:	ce 01       	movw	r24, r28
    16fa:	01 96       	adiw	r24, 0x01	; 1
    16fc:	0e 94 a9 06 	call	0xd52	; 0xd52 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1704:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
    170e:	f8 01       	movw	r30, r16
    1710:	85 8d       	ldd	r24, Z+29	; 0x1d
    1712:	8f 3f       	cpi	r24, 0xFF	; 255
    1714:	09 f4       	brne	.+2      	; 0x1718 <xQueueGenericSend+0xa0>
    1716:	15 8e       	std	Z+29, r1	; 0x1d
    1718:	f8 01       	movw	r30, r16
    171a:	86 8d       	ldd	r24, Z+30	; 0x1e
    171c:	8f 3f       	cpi	r24, 0xFF	; 255
    171e:	09 f4       	brne	.+2      	; 0x1722 <xQueueGenericSend+0xaa>
    1720:	16 8e       	std	Z+30, r1	; 0x1e
    1722:	0f 90       	pop	r0
    1724:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1726:	be 01       	movw	r22, r28
    1728:	6c 5f       	subi	r22, 0xFC	; 252
    172a:	7f 4f       	sbci	r23, 0xFF	; 255
    172c:	ce 01       	movw	r24, r28
    172e:	01 96       	adiw	r24, 0x01	; 1
    1730:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskCheckForTimeOut>
    1734:	81 11       	cpse	r24, r1
    1736:	21 c0       	rjmp	.+66     	; 0x177a <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	f8 94       	cli
    173c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    173e:	f8 01       	movw	r30, r16
    1740:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1742:	0f 90       	pop	r0
    1744:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1746:	83 8d       	ldd	r24, Z+27	; 0x1b
    1748:	98 13       	cpse	r25, r24
    174a:	11 c0       	rjmp	.+34     	; 0x176e <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    174c:	6c 81       	ldd	r22, Y+4	; 0x04
    174e:	7d 81       	ldd	r23, Y+5	; 0x05
    1750:	c5 01       	movw	r24, r10
    1752:	0e 94 fe 05 	call	0xbfc	; 0xbfc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1756:	c8 01       	movw	r24, r16
    1758:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    175c:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1760:	88 23       	and	r24, r24
    1762:	11 f0       	breq	.+4      	; 0x1768 <xQueueGenericSend+0xf0>
    1764:	81 e0       	ldi	r24, 0x01	; 1
    1766:	a0 cf       	rjmp	.-192    	; 0x16a8 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1768:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    176c:	fb cf       	rjmp	.-10     	; 0x1764 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    176e:	c8 01       	movw	r24, r16
    1770:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1774:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1778:	f5 cf       	rjmp	.-22     	; 0x1764 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    177a:	c8 01       	movw	r24, r16
    177c:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1780:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1784:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1786:	0f 90       	pop	r0
    1788:	0f 90       	pop	r0
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	0f 90       	pop	r0
    1790:	df 91       	pop	r29
    1792:	cf 91       	pop	r28
    1794:	1f 91       	pop	r17
    1796:	0f 91       	pop	r16
    1798:	ff 90       	pop	r15
    179a:	df 90       	pop	r13
    179c:	cf 90       	pop	r12
    179e:	bf 90       	pop	r11
    17a0:	af 90       	pop	r10
    17a2:	08 95       	ret

000017a4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    17a8:	48 2f       	mov	r20, r24
    17aa:	60 e0       	ldi	r22, 0x00	; 0
    17ac:	81 e0       	ldi	r24, 0x01	; 1
    17ae:	0e 94 14 0b 	call	0x1628	; 0x1628 <xQueueGenericCreate>
    17b2:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    17b4:	00 97       	sbiw	r24, 0x00	; 0
    17b6:	61 f0       	breq	.+24     	; 0x17d0 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    17b8:	1d 82       	std	Y+5, r1	; 0x05
    17ba:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    17bc:	19 82       	std	Y+1, r1	; 0x01
    17be:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    17c0:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    17c2:	20 e0       	ldi	r18, 0x00	; 0
    17c4:	40 e0       	ldi	r20, 0x00	; 0
    17c6:	50 e0       	ldi	r21, 0x00	; 0
    17c8:	60 e0       	ldi	r22, 0x00	; 0
    17ca:	70 e0       	ldi	r23, 0x00	; 0
    17cc:	0e 94 3c 0b 	call	0x1678	; 0x1678 <xQueueGenericSend>

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );

		return xNewQueue;
	}
    17d0:	ce 01       	movw	r24, r28
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	08 95       	ret

000017d8 <xQueueGenericSendFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    17d8:	ef 92       	push	r14
    17da:	ff 92       	push	r15
    17dc:	1f 93       	push	r17
    17de:	cf 93       	push	r28
    17e0:	df 93       	push	r29
    17e2:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    17e4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    17e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    17e8:	98 17       	cp	r25, r24
    17ea:	10 f0       	brcs	.+4      	; 0x17f0 <xQueueGenericSendFromISR+0x18>
    17ec:	22 30       	cpi	r18, 0x02	; 2
    17ee:	e1 f4       	brne	.+56     	; 0x1828 <xQueueGenericSendFromISR+0x50>
    17f0:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    17f2:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17f4:	42 2f       	mov	r20, r18
    17f6:	ce 01       	movw	r24, r28
    17f8:	0e 94 2a 0a 	call	0x1454	; 0x1454 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    17fc:	1f 3f       	cpi	r17, 0xFF	; 255
    17fe:	81 f4       	brne	.+32     	; 0x1820 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1800:	89 89       	ldd	r24, Y+17	; 0x11
    1802:	88 23       	and	r24, r24
    1804:	79 f0       	breq	.+30     	; 0x1824 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1806:	ce 01       	movw	r24, r28
    1808:	41 96       	adiw	r24, 0x11	; 17
    180a:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    180e:	88 23       	and	r24, r24
    1810:	49 f0       	breq	.+18     	; 0x1824 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1812:	e1 14       	cp	r14, r1
    1814:	f1 04       	cpc	r15, r1
    1816:	31 f0       	breq	.+12     	; 0x1824 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1818:	81 e0       	ldi	r24, 0x01	; 1
    181a:	f7 01       	movw	r30, r14
    181c:	80 83       	st	Z, r24
    181e:	05 c0       	rjmp	.+10     	; 0x182a <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1820:	1f 5f       	subi	r17, 0xFF	; 255
    1822:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	01 c0       	rjmp	.+2      	; 0x182a <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1828:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    182a:	df 91       	pop	r29
    182c:	cf 91       	pop	r28
    182e:	1f 91       	pop	r17
    1830:	ff 90       	pop	r15
    1832:	ef 90       	pop	r14
    1834:	08 95       	ret

00001836 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1836:	cf 93       	push	r28
    1838:	df 93       	push	r29
    183a:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    183c:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    183e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1840:	98 17       	cp	r25, r24
    1842:	c0 f4       	brcc	.+48     	; 0x1874 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1844:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1846:	9f 5f       	subi	r25, 0xFF	; 255
    1848:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    184a:	8f 3f       	cpi	r24, 0xFF	; 255
    184c:	79 f4       	brne	.+30     	; 0x186c <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    184e:	81 89       	ldd	r24, Z+17	; 0x11
    1850:	88 23       	and	r24, r24
    1852:	71 f0       	breq	.+28     	; 0x1870 <xQueueGiveFromISR+0x3a>
    1854:	eb 01       	movw	r28, r22
    1856:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1858:	41 96       	adiw	r24, 0x11	; 17
    185a:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    185e:	88 23       	and	r24, r24
    1860:	39 f0       	breq	.+14     	; 0x1870 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1862:	20 97       	sbiw	r28, 0x00	; 0
    1864:	29 f0       	breq	.+10     	; 0x1870 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	88 83       	st	Y, r24
    186a:	05 c0       	rjmp	.+10     	; 0x1876 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    186c:	8f 5f       	subi	r24, 0xFF	; 255
    186e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	01 c0       	rjmp	.+2      	; 0x1876 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1874:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	08 95       	ret

0000187c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    187c:	af 92       	push	r10
    187e:	bf 92       	push	r11
    1880:	cf 92       	push	r12
    1882:	df 92       	push	r13
    1884:	ff 92       	push	r15
    1886:	0f 93       	push	r16
    1888:	1f 93       	push	r17
    188a:	cf 93       	push	r28
    188c:	df 93       	push	r29
    188e:	00 d0       	rcall	.+0      	; 0x1890 <xQueueReceive+0x14>
    1890:	00 d0       	rcall	.+0      	; 0x1892 <xQueueReceive+0x16>
    1892:	1f 92       	push	r1
    1894:	cd b7       	in	r28, 0x3d	; 61
    1896:	de b7       	in	r29, 0x3e	; 62
    1898:	8c 01       	movw	r16, r24
    189a:	6b 01       	movw	r12, r22
    189c:	5d 83       	std	Y+5, r21	; 0x05
    189e:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    18a0:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18a2:	58 01       	movw	r10, r16
    18a4:	91 e1       	ldi	r25, 0x11	; 17
    18a6:	a9 0e       	add	r10, r25
    18a8:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18aa:	0f b6       	in	r0, 0x3f	; 63
    18ac:	f8 94       	cli
    18ae:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18b0:	f8 01       	movw	r30, r16
    18b2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18b4:	ff 20       	and	r15, r15
    18b6:	a9 f0       	breq	.+42     	; 0x18e2 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18b8:	b6 01       	movw	r22, r12
    18ba:	c8 01       	movw	r24, r16
    18bc:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    18c0:	fa 94       	dec	r15
    18c2:	f8 01       	movw	r30, r16
    18c4:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18c6:	80 85       	ldd	r24, Z+8	; 0x08
    18c8:	88 23       	and	r24, r24
    18ca:	39 f0       	breq	.+14     	; 0x18da <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18cc:	c8 01       	movw	r24, r16
    18ce:	08 96       	adiw	r24, 0x08	; 8
    18d0:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    18d4:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    18d6:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    18da:	0f 90       	pop	r0
    18dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18de:	81 e0       	ldi	r24, 0x01	; 1
    18e0:	50 c0       	rjmp	.+160    	; 0x1982 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    18e2:	2c 81       	ldd	r18, Y+4	; 0x04
    18e4:	3d 81       	ldd	r19, Y+5	; 0x05
    18e6:	23 2b       	or	r18, r19
    18e8:	19 f4       	brne	.+6      	; 0x18f0 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18ea:	0f 90       	pop	r0
    18ec:	0f be       	out	0x3f, r0	; 63
    18ee:	48 c0       	rjmp	.+144    	; 0x1980 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    18f0:	81 11       	cpse	r24, r1
    18f2:	04 c0       	rjmp	.+8      	; 0x18fc <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    18f4:	ce 01       	movw	r24, r28
    18f6:	01 96       	adiw	r24, 0x01	; 1
    18f8:	0e 94 a9 06 	call	0xd52	; 0xd52 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18fc:	0f 90       	pop	r0
    18fe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1900:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	f8 94       	cli
    1908:	0f 92       	push	r0
    190a:	f8 01       	movw	r30, r16
    190c:	85 8d       	ldd	r24, Z+29	; 0x1d
    190e:	8f 3f       	cpi	r24, 0xFF	; 255
    1910:	09 f4       	brne	.+2      	; 0x1914 <xQueueReceive+0x98>
    1912:	15 8e       	std	Z+29, r1	; 0x1d
    1914:	f8 01       	movw	r30, r16
    1916:	86 8d       	ldd	r24, Z+30	; 0x1e
    1918:	8f 3f       	cpi	r24, 0xFF	; 255
    191a:	09 f4       	brne	.+2      	; 0x191e <xQueueReceive+0xa2>
    191c:	16 8e       	std	Z+30, r1	; 0x1e
    191e:	0f 90       	pop	r0
    1920:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1922:	be 01       	movw	r22, r28
    1924:	6c 5f       	subi	r22, 0xFC	; 252
    1926:	7f 4f       	sbci	r23, 0xFF	; 255
    1928:	ce 01       	movw	r24, r28
    192a:	01 96       	adiw	r24, 0x01	; 1
    192c:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskCheckForTimeOut>
    1930:	81 11       	cpse	r24, r1
    1932:	1c c0       	rjmp	.+56     	; 0x196c <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1934:	c8 01       	movw	r24, r16
    1936:	0e 94 1f 0a 	call	0x143e	; 0x143e <prvIsQueueEmpty>
    193a:	88 23       	and	r24, r24
    193c:	89 f0       	breq	.+34     	; 0x1960 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    193e:	6c 81       	ldd	r22, Y+4	; 0x04
    1940:	7d 81       	ldd	r23, Y+5	; 0x05
    1942:	c5 01       	movw	r24, r10
    1944:	0e 94 fe 05 	call	0xbfc	; 0xbfc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1948:	c8 01       	movw	r24, r16
    194a:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    194e:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1952:	88 23       	and	r24, r24
    1954:	11 f0       	breq	.+4      	; 0x195a <xQueueReceive+0xde>
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	a8 cf       	rjmp	.-176    	; 0x18aa <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    195a:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    195e:	fb cf       	rjmp	.-10     	; 0x1956 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1960:	c8 01       	movw	r24, r16
    1962:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1966:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    196a:	f5 cf       	rjmp	.-22     	; 0x1956 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    196c:	c8 01       	movw	r24, r16
    196e:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1972:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1976:	c8 01       	movw	r24, r16
    1978:	0e 94 1f 0a 	call	0x143e	; 0x143e <prvIsQueueEmpty>
    197c:	88 23       	and	r24, r24
    197e:	59 f3       	breq	.-42     	; 0x1956 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1980:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1982:	0f 90       	pop	r0
    1984:	0f 90       	pop	r0
    1986:	0f 90       	pop	r0
    1988:	0f 90       	pop	r0
    198a:	0f 90       	pop	r0
    198c:	df 91       	pop	r29
    198e:	cf 91       	pop	r28
    1990:	1f 91       	pop	r17
    1992:	0f 91       	pop	r16
    1994:	ff 90       	pop	r15
    1996:	df 90       	pop	r13
    1998:	cf 90       	pop	r12
    199a:	bf 90       	pop	r11
    199c:	af 90       	pop	r10
    199e:	08 95       	ret

000019a0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    19a0:	cf 92       	push	r12
    19a2:	df 92       	push	r13
    19a4:	ff 92       	push	r15
    19a6:	0f 93       	push	r16
    19a8:	1f 93       	push	r17
    19aa:	cf 93       	push	r28
    19ac:	df 93       	push	r29
    19ae:	00 d0       	rcall	.+0      	; 0x19b0 <xQueueSemaphoreTake+0x10>
    19b0:	00 d0       	rcall	.+0      	; 0x19b2 <xQueueSemaphoreTake+0x12>
    19b2:	1f 92       	push	r1
    19b4:	cd b7       	in	r28, 0x3d	; 61
    19b6:	de b7       	in	r29, 0x3e	; 62
    19b8:	8c 01       	movw	r16, r24
    19ba:	7d 83       	std	Y+5, r23	; 0x05
    19bc:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    19be:	f1 2c       	mov	r15, r1
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
BaseType_t xEntryTimeSet = pdFALSE;
    19c0:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19c2:	68 01       	movw	r12, r16
    19c4:	81 e1       	ldi	r24, 0x11	; 17
    19c6:	c8 0e       	add	r12, r24
    19c8:	d1 1c       	adc	r13, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19ca:	0f b6       	in	r0, 0x3f	; 63
    19cc:	f8 94       	cli
    19ce:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    19d0:	d8 01       	movw	r26, r16
    19d2:	5a 96       	adiw	r26, 0x1a	; 26
    19d4:	8c 91       	ld	r24, X
    19d6:	5a 97       	sbiw	r26, 0x1a	; 26

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    19d8:	88 23       	and	r24, r24
    19da:	e9 f0       	breq	.+58     	; 0x1a16 <xQueueSemaphoreTake+0x76>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    19dc:	81 50       	subi	r24, 0x01	; 1
    19de:	5a 96       	adiw	r26, 0x1a	; 26
    19e0:	8c 93       	st	X, r24
    19e2:	5a 97       	sbiw	r26, 0x1a	; 26

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    19e4:	8d 91       	ld	r24, X+
    19e6:	9c 91       	ld	r25, X
    19e8:	89 2b       	or	r24, r25
    19ea:	29 f4       	brne	.+10     	; 0x19f6 <xQueueSemaphoreTake+0x56>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    19ec:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <pvTaskIncrementMutexHeldCount>
    19f0:	f8 01       	movw	r30, r16
    19f2:	95 83       	std	Z+5, r25	; 0x05
    19f4:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19f6:	d8 01       	movw	r26, r16
    19f8:	18 96       	adiw	r26, 0x08	; 8
    19fa:	8c 91       	ld	r24, X
    19fc:	88 23       	and	r24, r24
    19fe:	39 f0       	breq	.+14     	; 0x1a0e <xQueueSemaphoreTake+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a00:	c8 01       	movw	r24, r16
    1a02:	08 96       	adiw	r24, 0x08	; 8
    1a04:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    1a08:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1a0a:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1a0e:	0f 90       	pop	r0
    1a10:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	7a c0       	rjmp	.+244    	; 0x1b0a <xQueueSemaphoreTake+0x16a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a16:	2c 81       	ldd	r18, Y+4	; 0x04
    1a18:	3d 81       	ldd	r19, Y+5	; 0x05
    1a1a:	23 2b       	or	r18, r19
    1a1c:	09 f4       	brne	.+2      	; 0x1a20 <xQueueSemaphoreTake+0x80>
    1a1e:	72 c0       	rjmp	.+228    	; 0x1b04 <xQueueSemaphoreTake+0x164>
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1a20:	91 11       	cpse	r25, r1
    1a22:	04 c0       	rjmp	.+8      	; 0x1a2c <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a24:	ce 01       	movw	r24, r28
    1a26:	01 96       	adiw	r24, 0x01	; 1
    1a28:	0e 94 a9 06 	call	0xd52	; 0xd52 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a2c:	0f 90       	pop	r0
    1a2e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a30:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a34:	0f b6       	in	r0, 0x3f	; 63
    1a36:	f8 94       	cli
    1a38:	0f 92       	push	r0
    1a3a:	f8 01       	movw	r30, r16
    1a3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a40:	09 f4       	brne	.+2      	; 0x1a44 <xQueueSemaphoreTake+0xa4>
    1a42:	15 8e       	std	Z+29, r1	; 0x1d
    1a44:	d8 01       	movw	r26, r16
    1a46:	5e 96       	adiw	r26, 0x1e	; 30
    1a48:	8c 91       	ld	r24, X
    1a4a:	5e 97       	sbiw	r26, 0x1e	; 30
    1a4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a4e:	11 f4       	brne	.+4      	; 0x1a54 <xQueueSemaphoreTake+0xb4>
    1a50:	5e 96       	adiw	r26, 0x1e	; 30
    1a52:	1c 92       	st	X, r1
    1a54:	0f 90       	pop	r0
    1a56:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a58:	be 01       	movw	r22, r28
    1a5a:	6c 5f       	subi	r22, 0xFC	; 252
    1a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5e:	ce 01       	movw	r24, r28
    1a60:	01 96       	adiw	r24, 0x01	; 1
    1a62:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskCheckForTimeOut>
    1a66:	81 11       	cpse	r24, r1
    1a68:	2b c0       	rjmp	.+86     	; 0x1ac0 <xQueueSemaphoreTake+0x120>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a6a:	c8 01       	movw	r24, r16
    1a6c:	0e 94 1f 0a 	call	0x143e	; 0x143e <prvIsQueueEmpty>
    1a70:	88 23       	and	r24, r24
    1a72:	01 f1       	breq	.+64     	; 0x1ab4 <xQueueSemaphoreTake+0x114>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a74:	f8 01       	movw	r30, r16
    1a76:	80 81       	ld	r24, Z
    1a78:	91 81       	ldd	r25, Z+1	; 0x01
    1a7a:	89 2b       	or	r24, r25
    1a7c:	51 f4       	brne	.+20     	; 0x1a92 <xQueueSemaphoreTake+0xf2>
					{
						taskENTER_CRITICAL();
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    1a84:	84 81       	ldd	r24, Z+4	; 0x04
    1a86:	95 81       	ldd	r25, Z+5	; 0x05
    1a88:	0e 94 f0 06 	call	0xde0	; 0xde0 <xTaskPriorityInherit>
    1a8c:	f8 2e       	mov	r15, r24
						}
						taskEXIT_CRITICAL();
    1a8e:	0f 90       	pop	r0
    1a90:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a92:	6c 81       	ldd	r22, Y+4	; 0x04
    1a94:	7d 81       	ldd	r23, Y+5	; 0x05
    1a96:	c6 01       	movw	r24, r12
    1a98:	0e 94 fe 05 	call	0xbfc	; 0xbfc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1a9c:	c8 01       	movw	r24, r16
    1a9e:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1aa2:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1aa6:	88 23       	and	r24, r24
    1aa8:	11 f0       	breq	.+4      	; 0x1aae <xQueueSemaphoreTake+0x10e>
    1aaa:	91 e0       	ldi	r25, 0x01	; 1
    1aac:	8e cf       	rjmp	.-228    	; 0x19ca <xQueueSemaphoreTake+0x2a>
				{
					portYIELD_WITHIN_API();
    1aae:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    1ab2:	fb cf       	rjmp	.-10     	; 0x1aaa <xQueueSemaphoreTake+0x10a>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1ab4:	c8 01       	movw	r24, r16
    1ab6:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1aba:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1abe:	f5 cf       	rjmp	.-22     	; 0x1aaa <xQueueSemaphoreTake+0x10a>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ac6:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1aca:	c8 01       	movw	r24, r16
    1acc:	0e 94 1f 0a 	call	0x143e	; 0x143e <prvIsQueueEmpty>
    1ad0:	88 23       	and	r24, r24
    1ad2:	59 f3       	breq	.-42     	; 0x1aaa <xQueueSemaphoreTake+0x10a>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    1ad4:	ff 20       	and	r15, r15
    1ad6:	c1 f0       	breq	.+48     	; 0x1b08 <xQueueSemaphoreTake+0x168>
					{
						taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    1ade:	f8 01       	movw	r30, r16
    1ae0:	81 89       	ldd	r24, Z+17	; 0x11
    1ae2:	88 23       	and	r24, r24
    1ae4:	39 f0       	breq	.+14     	; 0x1af4 <xQueueSemaphoreTake+0x154>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    1ae6:	06 88       	ldd	r0, Z+22	; 0x16
    1ae8:	f7 89       	ldd	r31, Z+23	; 0x17
    1aea:	e0 2d       	mov	r30, r0
    1aec:	80 81       	ld	r24, Z
    1aee:	64 e0       	ldi	r22, 0x04	; 4
    1af0:	68 1b       	sub	r22, r24
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <xQueueSemaphoreTake+0x156>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1af4:	60 e0       	ldi	r22, 0x00	; 0
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    1af6:	d8 01       	movw	r26, r16
    1af8:	14 96       	adiw	r26, 0x04	; 4
    1afa:	8d 91       	ld	r24, X+
    1afc:	9c 91       	ld	r25, X
    1afe:	15 97       	sbiw	r26, 0x05	; 5
    1b00:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    1b04:	0f 90       	pop	r0
    1b06:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1b08:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1b0a:	0f 90       	pop	r0
    1b0c:	0f 90       	pop	r0
    1b0e:	0f 90       	pop	r0
    1b10:	0f 90       	pop	r0
    1b12:	0f 90       	pop	r0
    1b14:	df 91       	pop	r29
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	ff 90       	pop	r15
    1b1e:	df 90       	pop	r13
    1b20:	cf 90       	pop	r12
    1b22:	08 95       	ret

00001b24 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1b24:	cf 92       	push	r12
    1b26:	df 92       	push	r13
    1b28:	ef 92       	push	r14
    1b2a:	ff 92       	push	r15
    1b2c:	0f 93       	push	r16
    1b2e:	1f 93       	push	r17
    1b30:	cf 93       	push	r28
    1b32:	df 93       	push	r29
    1b34:	00 d0       	rcall	.+0      	; 0x1b36 <xQueuePeek+0x12>
    1b36:	00 d0       	rcall	.+0      	; 0x1b38 <xQueuePeek+0x14>
    1b38:	1f 92       	push	r1
    1b3a:	cd b7       	in	r28, 0x3d	; 61
    1b3c:	de b7       	in	r29, 0x3e	; 62
    1b3e:	8c 01       	movw	r16, r24
    1b40:	7b 01       	movw	r14, r22
    1b42:	5d 83       	std	Y+5, r21	; 0x05
    1b44:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1b46:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b48:	68 01       	movw	r12, r16
    1b4a:	91 e1       	ldi	r25, 0x11	; 17
    1b4c:	c9 0e       	add	r12, r25
    1b4e:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b56:	f8 01       	movw	r30, r16
    1b58:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b5a:	99 23       	and	r25, r25
    1b5c:	b9 f0       	breq	.+46     	; 0x1b8c <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1b5e:	c6 80       	ldd	r12, Z+6	; 0x06
    1b60:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b62:	b7 01       	movw	r22, r14
    1b64:	c8 01       	movw	r24, r16
    1b66:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1b6a:	f8 01       	movw	r30, r16
    1b6c:	d7 82       	std	Z+7, r13	; 0x07
    1b6e:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b70:	81 89       	ldd	r24, Z+17	; 0x11
    1b72:	88 23       	and	r24, r24
    1b74:	39 f0       	breq	.+14     	; 0x1b84 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b76:	c8 01       	movw	r24, r16
    1b78:	41 96       	adiw	r24, 0x11	; 17
    1b7a:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    1b7e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1b80:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1b84:	0f 90       	pop	r0
    1b86:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	50 c0       	rjmp	.+160    	; 0x1c2c <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b8c:	2c 81       	ldd	r18, Y+4	; 0x04
    1b8e:	3d 81       	ldd	r19, Y+5	; 0x05
    1b90:	23 2b       	or	r18, r19
    1b92:	19 f4       	brne	.+6      	; 0x1b9a <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b94:	0f 90       	pop	r0
    1b96:	0f be       	out	0x3f, r0	; 63
    1b98:	48 c0       	rjmp	.+144    	; 0x1c2a <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1b9a:	81 11       	cpse	r24, r1
    1b9c:	04 c0       	rjmp	.+8      	; 0x1ba6 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1b9e:	ce 01       	movw	r24, r28
    1ba0:	01 96       	adiw	r24, 0x01	; 1
    1ba2:	0e 94 a9 06 	call	0xd52	; 0xd52 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1ba6:	0f 90       	pop	r0
    1ba8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1baa:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	0f 92       	push	r0
    1bb4:	f8 01       	movw	r30, r16
    1bb6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1bba:	09 f4       	brne	.+2      	; 0x1bbe <xQueuePeek+0x9a>
    1bbc:	15 8e       	std	Z+29, r1	; 0x1d
    1bbe:	f8 01       	movw	r30, r16
    1bc0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc4:	09 f4       	brne	.+2      	; 0x1bc8 <xQueuePeek+0xa4>
    1bc6:	16 8e       	std	Z+30, r1	; 0x1e
    1bc8:	0f 90       	pop	r0
    1bca:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bcc:	be 01       	movw	r22, r28
    1bce:	6c 5f       	subi	r22, 0xFC	; 252
    1bd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	01 96       	adiw	r24, 0x01	; 1
    1bd6:	0e 94 b4 06 	call	0xd68	; 0xd68 <xTaskCheckForTimeOut>
    1bda:	81 11       	cpse	r24, r1
    1bdc:	1c c0       	rjmp	.+56     	; 0x1c16 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bde:	c8 01       	movw	r24, r16
    1be0:	0e 94 1f 0a 	call	0x143e	; 0x143e <prvIsQueueEmpty>
    1be4:	88 23       	and	r24, r24
    1be6:	89 f0       	breq	.+34     	; 0x1c0a <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1be8:	6c 81       	ldd	r22, Y+4	; 0x04
    1bea:	7d 81       	ldd	r23, Y+5	; 0x05
    1bec:	c6 01       	movw	r24, r12
    1bee:	0e 94 fe 05 	call	0xbfc	; 0xbfc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1bf2:	c8 01       	movw	r24, r16
    1bf4:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1bf8:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1bfc:	88 23       	and	r24, r24
    1bfe:	11 f0       	breq	.+4      	; 0x1c04 <xQueuePeek+0xe0>
    1c00:	81 e0       	ldi	r24, 0x01	; 1
    1c02:	a6 cf       	rjmp	.-180    	; 0x1b50 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1c04:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    1c08:	fb cf       	rjmp	.-10     	; 0x1c00 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1c0a:	c8 01       	movw	r24, r16
    1c0c:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c10:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
    1c14:	f5 cf       	rjmp	.-22     	; 0x1c00 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1c16:	c8 01       	movw	r24, r16
    1c18:	0e 94 97 0a 	call	0x152e	; 0x152e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c1c:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c20:	c8 01       	movw	r24, r16
    1c22:	0e 94 1f 0a 	call	0x143e	; 0x143e <prvIsQueueEmpty>
    1c26:	88 23       	and	r24, r24
    1c28:	59 f3       	breq	.-42     	; 0x1c00 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1c2a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1c2c:	0f 90       	pop	r0
    1c2e:	0f 90       	pop	r0
    1c30:	0f 90       	pop	r0
    1c32:	0f 90       	pop	r0
    1c34:	0f 90       	pop	r0
    1c36:	df 91       	pop	r29
    1c38:	cf 91       	pop	r28
    1c3a:	1f 91       	pop	r17
    1c3c:	0f 91       	pop	r16
    1c3e:	ff 90       	pop	r15
    1c40:	ef 90       	pop	r14
    1c42:	df 90       	pop	r13
    1c44:	cf 90       	pop	r12
    1c46:	08 95       	ret

00001c48 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c48:	ef 92       	push	r14
    1c4a:	ff 92       	push	r15
    1c4c:	0f 93       	push	r16
    1c4e:	1f 93       	push	r17
    1c50:	cf 93       	push	r28
    1c52:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c54:	fc 01       	movw	r30, r24
    1c56:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c58:	00 23       	and	r16, r16
    1c5a:	e9 f0       	breq	.+58     	; 0x1c96 <xQueueReceiveFromISR+0x4e>
    1c5c:	7a 01       	movw	r14, r20
    1c5e:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1c60:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c62:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1c66:	01 50       	subi	r16, 0x01	; 1
    1c68:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1c6a:	1f 3f       	cpi	r17, 0xFF	; 255
    1c6c:	81 f4       	brne	.+32     	; 0x1c8e <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c6e:	88 85       	ldd	r24, Y+8	; 0x08
    1c70:	88 23       	and	r24, r24
    1c72:	79 f0       	breq	.+30     	; 0x1c92 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c74:	ce 01       	movw	r24, r28
    1c76:	08 96       	adiw	r24, 0x08	; 8
    1c78:	0e 94 27 06 	call	0xc4e	; 0xc4e <xTaskRemoveFromEventList>
    1c7c:	88 23       	and	r24, r24
    1c7e:	49 f0       	breq	.+18     	; 0x1c92 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1c80:	e1 14       	cp	r14, r1
    1c82:	f1 04       	cpc	r15, r1
    1c84:	31 f0       	breq	.+12     	; 0x1c92 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1c86:	81 e0       	ldi	r24, 0x01	; 1
    1c88:	f7 01       	movw	r30, r14
    1c8a:	80 83       	st	Z, r24
    1c8c:	05 c0       	rjmp	.+10     	; 0x1c98 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1c8e:	1f 5f       	subi	r17, 0xFF	; 255
    1c90:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	01 c0       	rjmp	.+2      	; 0x1c98 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1c96:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c98:	df 91       	pop	r29
    1c9a:	cf 91       	pop	r28
    1c9c:	1f 91       	pop	r17
    1c9e:	0f 91       	pop	r16
    1ca0:	ff 90       	pop	r15
    1ca2:	ef 90       	pop	r14
    1ca4:	08 95       	ret

00001ca6 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1ca6:	0f 93       	push	r16
    1ca8:	1f 93       	push	r17
    1caa:	cf 93       	push	r28
    1cac:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cae:	fc 01       	movw	r30, r24
    1cb0:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cb2:	22 23       	and	r18, r18
    1cb4:	49 f0       	breq	.+18     	; 0x1cc8 <xQueuePeekFromISR+0x22>
    1cb6:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1cb8:	06 81       	ldd	r16, Z+6	; 0x06
    1cba:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1cbc:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1cc0:	1f 83       	std	Y+7, r17	; 0x07
    1cc2:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	01 c0       	rjmp	.+2      	; 0x1cca <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1cc8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cca:	df 91       	pop	r29
    1ccc:	cf 91       	pop	r28
    1cce:	1f 91       	pop	r17
    1cd0:	0f 91       	pop	r16
    1cd2:	08 95       	ret

00001cd4 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1cda:	fc 01       	movw	r30, r24
    1cdc:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1cde:	0f 90       	pop	r0
    1ce0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ce2:	08 95       	ret

00001ce4 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ce4:	0f b6       	in	r0, 0x3f	; 63
    1ce6:	f8 94       	cli
    1ce8:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1cea:	fc 01       	movw	r30, r24
    1cec:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1cee:	0f 90       	pop	r0
    1cf0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1cf2:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cf4:	82 1b       	sub	r24, r18
    1cf6:	08 95       	ret

00001cf8 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1cf8:	fc 01       	movw	r30, r24
    1cfa:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cfc:	08 95       	ret

00001cfe <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1cfe:	0c 94 f3 11 	jmp	0x23e6	; 0x23e6 <vPortFree>

00001d02 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d02:	fc 01       	movw	r30, r24
    1d04:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	91 11       	cpse	r25, r1
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1d0c:	08 95       	ret

00001d0e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1d0e:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1d10:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	23 8d       	ldd	r18, Z+27	; 0x1b
    1d16:	29 13       	cpse	r18, r25
    1d18:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1d1a:	08 95       	ret

00001d1c <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1d1c:	cf 93       	push	r28
    1d1e:	df 93       	push	r29
    1d20:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1d22:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1d2a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d2c:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d32:	89 13       	cpse	r24, r25
    1d34:	0f c0       	rjmp	.+30     	; 0x1d54 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d36:	41 15       	cp	r20, r1
    1d38:	51 05       	cpc	r21, r1
    1d3a:	49 f0       	breq	.+18     	; 0x1d4e <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1d3c:	be 01       	movw	r22, r28
    1d3e:	68 5f       	subi	r22, 0xF8	; 248
    1d40:	7f 4f       	sbci	r23, 0xFF	; 255
    1d42:	ca 01       	movw	r24, r20
    1d44:	0e 94 6d 10 	call	0x20da	; 0x20da <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1d48:	78 94       	sei
					return errQUEUE_BLOCKED;
    1d4a:	8c ef       	ldi	r24, 0xFC	; 252
    1d4c:	1b c0       	rjmp	.+54     	; 0x1d84 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1d4e:	78 94       	sei
					return errQUEUE_FULL;
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	18 c0       	rjmp	.+48     	; 0x1d84 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1d54:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d56:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d58:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d5a:	89 17       	cp	r24, r25
    1d5c:	88 f4       	brcc	.+34     	; 0x1d80 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1d5e:	40 e0       	ldi	r20, 0x00	; 0
    1d60:	ce 01       	movw	r24, r28
    1d62:	0e 94 2a 0a 	call	0x1454	; 0x1454 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d66:	89 89       	ldd	r24, Y+17	; 0x11
    1d68:	81 11       	cpse	r24, r1
    1d6a:	02 c0       	rjmp	.+4      	; 0x1d70 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1d6c:	81 e0       	ldi	r24, 0x01	; 1
    1d6e:	09 c0       	rjmp	.+18     	; 0x1d82 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d70:	ce 01       	movw	r24, r28
    1d72:	41 96       	adiw	r24, 0x11	; 17
    1d74:	0e 94 9c 11 	call	0x2338	; 0x2338 <xCoRoutineRemoveFromEventList>
    1d78:	88 23       	and	r24, r24
    1d7a:	c1 f3       	breq	.-16     	; 0x1d6c <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1d7c:	8b ef       	ldi	r24, 0xFB	; 251
    1d7e:	01 c0       	rjmp	.+2      	; 0x1d82 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1d80:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1d82:	78 94       	sei

		return xReturn;
	}
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	08 95       	ret

00001d8a <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	ec 01       	movw	r28, r24
    1d90:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1d92:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d94:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d96:	81 11       	cpse	r24, r1
    1d98:	0f c0       	rjmp	.+30     	; 0x1db8 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d9a:	41 15       	cp	r20, r1
    1d9c:	51 05       	cpc	r21, r1
    1d9e:	49 f0       	breq	.+18     	; 0x1db2 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1da0:	be 01       	movw	r22, r28
    1da2:	6f 5e       	subi	r22, 0xEF	; 239
    1da4:	7f 4f       	sbci	r23, 0xFF	; 255
    1da6:	ca 01       	movw	r24, r20
    1da8:	0e 94 6d 10 	call	0x20da	; 0x20da <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1dac:	78 94       	sei
					return errQUEUE_BLOCKED;
    1dae:	8c ef       	ldi	r24, 0xFC	; 252
    1db0:	30 c0       	rjmp	.+96     	; 0x1e12 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1db2:	78 94       	sei
					return errQUEUE_FULL;
    1db4:	80 e0       	ldi	r24, 0x00	; 0
    1db6:	2d c0       	rjmp	.+90     	; 0x1e12 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1db8:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1dba:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1dbc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dbe:	88 23       	and	r24, r24
    1dc0:	31 f1       	breq	.+76     	; 0x1e0e <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1dc2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1dc4:	50 e0       	ldi	r21, 0x00	; 0
    1dc6:	2e 81       	ldd	r18, Y+6	; 0x06
    1dc8:	3f 81       	ldd	r19, Y+7	; 0x07
    1dca:	24 0f       	add	r18, r20
    1dcc:	35 1f       	adc	r19, r21
    1dce:	3f 83       	std	Y+7, r19	; 0x07
    1dd0:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1dd2:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd4:	9d 81       	ldd	r25, Y+5	; 0x05
    1dd6:	28 17       	cp	r18, r24
    1dd8:	39 07       	cpc	r19, r25
    1dda:	20 f0       	brcs	.+8      	; 0x1de4 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1ddc:	88 81       	ld	r24, Y
    1dde:	99 81       	ldd	r25, Y+1	; 0x01
    1de0:	9f 83       	std	Y+7, r25	; 0x07
    1de2:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1de4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1de6:	91 50       	subi	r25, 0x01	; 1
    1de8:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1dea:	6e 81       	ldd	r22, Y+6	; 0x06
    1dec:	7f 81       	ldd	r23, Y+7	; 0x07
    1dee:	cf 01       	movw	r24, r30
    1df0:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1df4:	88 85       	ldd	r24, Y+8	; 0x08
    1df6:	81 11       	cpse	r24, r1
    1df8:	02 c0       	rjmp	.+4      	; 0x1dfe <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	09 c0       	rjmp	.+18     	; 0x1e10 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1dfe:	ce 01       	movw	r24, r28
    1e00:	08 96       	adiw	r24, 0x08	; 8
    1e02:	0e 94 9c 11 	call	0x2338	; 0x2338 <xCoRoutineRemoveFromEventList>
    1e06:	88 23       	and	r24, r24
    1e08:	c1 f3       	breq	.-16     	; 0x1dfa <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1e0a:	8b ef       	ldi	r24, 0xFB	; 251
    1e0c:	01 c0       	rjmp	.+2      	; 0x1e10 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1e0e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1e10:	78 94       	sei

		return xReturn;
	}
    1e12:	df 91       	pop	r29
    1e14:	cf 91       	pop	r28
    1e16:	08 95       	ret

00001e18 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1e18:	0f 93       	push	r16
    1e1a:	1f 93       	push	r17
    1e1c:	cf 93       	push	r28
    1e1e:	8c 01       	movw	r16, r24
    1e20:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e22:	fc 01       	movw	r30, r24
    1e24:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e26:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e28:	98 17       	cp	r25, r24
    1e2a:	10 f0       	brcs	.+4      	; 0x1e30 <xQueueCRSendFromISR+0x18>
    1e2c:	4c 2f       	mov	r20, r28
    1e2e:	12 c0       	rjmp	.+36     	; 0x1e54 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1e30:	40 e0       	ldi	r20, 0x00	; 0
    1e32:	c8 01       	movw	r24, r16
    1e34:	0e 94 2a 0a 	call	0x1454	; 0x1454 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1e38:	c1 11       	cpse	r28, r1
    1e3a:	f8 cf       	rjmp	.-16     	; 0x1e2c <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	81 89       	ldd	r24, Z+17	; 0x11
    1e40:	88 23       	and	r24, r24
    1e42:	39 f0       	breq	.+14     	; 0x1e52 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e44:	c8 01       	movw	r24, r16
    1e46:	41 96       	adiw	r24, 0x11	; 17
    1e48:	0e 94 9c 11 	call	0x2338	; 0x2338 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1e4c:	41 e0       	ldi	r20, 0x01	; 1
    1e4e:	81 11       	cpse	r24, r1
    1e50:	01 c0       	rjmp	.+2      	; 0x1e54 <xQueueCRSendFromISR+0x3c>
    1e52:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1e54:	84 2f       	mov	r24, r20
    1e56:	cf 91       	pop	r28
    1e58:	1f 91       	pop	r17
    1e5a:	0f 91       	pop	r16
    1e5c:	08 95       	ret

00001e5e <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29
    1e66:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e6a:	88 23       	and	r24, r24
    1e6c:	79 f1       	breq	.+94     	; 0x1ecc <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1e6e:	24 8d       	ldd	r18, Z+28	; 0x1c
    1e70:	30 e0       	ldi	r19, 0x00	; 0
    1e72:	a6 81       	ldd	r26, Z+6	; 0x06
    1e74:	b7 81       	ldd	r27, Z+7	; 0x07
    1e76:	a2 0f       	add	r26, r18
    1e78:	b3 1f       	adc	r27, r19
    1e7a:	b7 83       	std	Z+7, r27	; 0x07
    1e7c:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1e7e:	84 81       	ldd	r24, Z+4	; 0x04
    1e80:	95 81       	ldd	r25, Z+5	; 0x05
    1e82:	a8 17       	cp	r26, r24
    1e84:	b9 07       	cpc	r27, r25
    1e86:	20 f0       	brcs	.+8      	; 0x1e90 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1e88:	80 81       	ld	r24, Z
    1e8a:	91 81       	ldd	r25, Z+1	; 0x01
    1e8c:	97 83       	std	Z+7, r25	; 0x07
    1e8e:	86 83       	std	Z+6, r24	; 0x06
    1e90:	8a 01       	movw	r16, r20
    1e92:	cb 01       	movw	r24, r22
    1e94:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1e96:	42 8d       	ldd	r20, Z+26	; 0x1a
    1e98:	41 50       	subi	r20, 0x01	; 1
    1e9a:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1e9c:	66 81       	ldd	r22, Z+6	; 0x06
    1e9e:	77 81       	ldd	r23, Z+7	; 0x07
    1ea0:	a9 01       	movw	r20, r18
    1ea2:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1ea6:	f8 01       	movw	r30, r16
    1ea8:	80 81       	ld	r24, Z
    1eaa:	88 23       	and	r24, r24
    1eac:	11 f0       	breq	.+4      	; 0x1eb2 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	0e c0       	rjmp	.+28     	; 0x1ece <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1eb2:	88 85       	ldd	r24, Y+8	; 0x08
    1eb4:	88 23       	and	r24, r24
    1eb6:	d9 f3       	breq	.-10     	; 0x1eae <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eb8:	ce 01       	movw	r24, r28
    1eba:	08 96       	adiw	r24, 0x08	; 8
    1ebc:	0e 94 9c 11 	call	0x2338	; 0x2338 <xCoRoutineRemoveFromEventList>
    1ec0:	88 23       	and	r24, r24
    1ec2:	a9 f3       	breq	.-22     	; 0x1eae <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	f8 01       	movw	r30, r16
    1ec8:	80 83       	st	Z, r24
    1eca:	01 c0       	rjmp	.+2      	; 0x1ece <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1ecc:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1ece:	df 91       	pop	r29
    1ed0:	cf 91       	pop	r28
    1ed2:	1f 91       	pop	r17
    1ed4:	0f 91       	pop	r16
    1ed6:	08 95       	ret

00001ed8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ed8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eda:	03 96       	adiw	r24, 0x03	; 3
    1edc:	92 83       	std	Z+2, r25	; 0x02
    1ede:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1ee0:	2f ef       	ldi	r18, 0xFF	; 255
    1ee2:	3f ef       	ldi	r19, 0xFF	; 255
    1ee4:	34 83       	std	Z+4, r19	; 0x04
    1ee6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ee8:	96 83       	std	Z+6, r25	; 0x06
    1eea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eec:	90 87       	std	Z+8, r25	; 0x08
    1eee:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ef0:	10 82       	st	Z, r1
    1ef2:	08 95       	ret

00001ef4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1ef4:	fc 01       	movw	r30, r24
    1ef6:	11 86       	std	Z+9, r1	; 0x09
    1ef8:	10 86       	std	Z+8, r1	; 0x08
    1efa:	08 95       	ret

00001efc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1efc:	cf 93       	push	r28
    1efe:	df 93       	push	r29
    1f00:	9c 01       	movw	r18, r24
    1f02:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1f04:	dc 01       	movw	r26, r24
    1f06:	11 96       	adiw	r26, 0x01	; 1
    1f08:	cd 91       	ld	r28, X+
    1f0a:	dc 91       	ld	r29, X
    1f0c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1f0e:	d3 83       	std	Z+3, r29	; 0x03
    1f10:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1f12:	8c 81       	ldd	r24, Y+4	; 0x04
    1f14:	9d 81       	ldd	r25, Y+5	; 0x05
    1f16:	95 83       	std	Z+5, r25	; 0x05
    1f18:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1f1a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f1c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f1e:	dc 01       	movw	r26, r24
    1f20:	13 96       	adiw	r26, 0x03	; 3
    1f22:	7c 93       	st	X, r23
    1f24:	6e 93       	st	-X, r22
    1f26:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1f28:	7d 83       	std	Y+5, r23	; 0x05
    1f2a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1f2c:	31 87       	std	Z+9, r19	; 0x09
    1f2e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1f30:	f9 01       	movw	r30, r18
    1f32:	80 81       	ld	r24, Z
    1f34:	8f 5f       	subi	r24, 0xFF	; 255
    1f36:	80 83       	st	Z, r24
}
    1f38:	df 91       	pop	r29
    1f3a:	cf 91       	pop	r28
    1f3c:	08 95       	ret

00001f3e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	cf 93       	push	r28
    1f44:	df 93       	push	r29
    1f46:	8c 01       	movw	r16, r24
    1f48:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1f4a:	80 81       	ld	r24, Z
    1f4c:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1f4e:	8f 3f       	cpi	r24, 0xFF	; 255
    1f50:	2f ef       	ldi	r18, 0xFF	; 255
    1f52:	92 07       	cpc	r25, r18
    1f54:	21 f4       	brne	.+8      	; 0x1f5e <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f56:	e8 01       	movw	r28, r16
    1f58:	af 81       	ldd	r26, Y+7	; 0x07
    1f5a:	b8 85       	ldd	r27, Y+8	; 0x08
    1f5c:	0e c0       	rjmp	.+28     	; 0x1f7a <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1f5e:	d8 01       	movw	r26, r16
    1f60:	13 96       	adiw	r26, 0x03	; 3
    1f62:	12 96       	adiw	r26, 0x02	; 2
    1f64:	2d 91       	ld	r18, X+
    1f66:	3c 91       	ld	r19, X
    1f68:	13 97       	sbiw	r26, 0x03	; 3
    1f6a:	e9 01       	movw	r28, r18
    1f6c:	48 81       	ld	r20, Y
    1f6e:	59 81       	ldd	r21, Y+1	; 0x01
    1f70:	84 17       	cp	r24, r20
    1f72:	95 07       	cpc	r25, r21
    1f74:	10 f0       	brcs	.+4      	; 0x1f7a <vListInsert+0x3c>
    1f76:	d9 01       	movw	r26, r18
    1f78:	f4 cf       	rjmp	.-24     	; 0x1f62 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1f7a:	12 96       	adiw	r26, 0x02	; 2
    1f7c:	8d 91       	ld	r24, X+
    1f7e:	9c 91       	ld	r25, X
    1f80:	13 97       	sbiw	r26, 0x03	; 3
    1f82:	93 83       	std	Z+3, r25	; 0x03
    1f84:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1f86:	ec 01       	movw	r28, r24
    1f88:	fd 83       	std	Y+5, r31	; 0x05
    1f8a:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1f8c:	b5 83       	std	Z+5, r27	; 0x05
    1f8e:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1f90:	13 96       	adiw	r26, 0x03	; 3
    1f92:	fc 93       	st	X, r31
    1f94:	ee 93       	st	-X, r30
    1f96:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1f98:	11 87       	std	Z+9, r17	; 0x09
    1f9a:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1f9c:	f8 01       	movw	r30, r16
    1f9e:	80 81       	ld	r24, Z
    1fa0:	8f 5f       	subi	r24, 0xFF	; 255
    1fa2:	80 83       	st	Z, r24
}
    1fa4:	df 91       	pop	r29
    1fa6:	cf 91       	pop	r28
    1fa8:	1f 91       	pop	r17
    1faa:	0f 91       	pop	r16
    1fac:	08 95       	ret

00001fae <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1fae:	cf 93       	push	r28
    1fb0:	df 93       	push	r29
    1fb2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1fb4:	a0 85       	ldd	r26, Z+8	; 0x08
    1fb6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1fb8:	82 81       	ldd	r24, Z+2	; 0x02
    1fba:	93 81       	ldd	r25, Z+3	; 0x03
    1fbc:	24 81       	ldd	r18, Z+4	; 0x04
    1fbe:	35 81       	ldd	r19, Z+5	; 0x05
    1fc0:	ec 01       	movw	r28, r24
    1fc2:	3d 83       	std	Y+5, r19	; 0x05
    1fc4:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1fc6:	c4 81       	ldd	r28, Z+4	; 0x04
    1fc8:	d5 81       	ldd	r29, Z+5	; 0x05
    1fca:	9b 83       	std	Y+3, r25	; 0x03
    1fcc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1fce:	11 96       	adiw	r26, 0x01	; 1
    1fd0:	8d 91       	ld	r24, X+
    1fd2:	9c 91       	ld	r25, X
    1fd4:	12 97       	sbiw	r26, 0x02	; 2
    1fd6:	e8 17       	cp	r30, r24
    1fd8:	f9 07       	cpc	r31, r25
    1fda:	21 f4       	brne	.+8      	; 0x1fe4 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1fdc:	12 96       	adiw	r26, 0x02	; 2
    1fde:	dc 93       	st	X, r29
    1fe0:	ce 93       	st	-X, r28
    1fe2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1fe4:	11 86       	std	Z+9, r1	; 0x09
    1fe6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1fe8:	8c 91       	ld	r24, X
    1fea:	81 50       	subi	r24, 0x01	; 1
    1fec:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1fee:	8c 91       	ld	r24, X
}
    1ff0:	df 91       	pop	r29
    1ff2:	cf 91       	pop	r28
    1ff4:	08 95       	ret

00001ff6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1ff6:	cf 92       	push	r12
    1ff8:	df 92       	push	r13
    1ffa:	ef 92       	push	r14
    1ffc:	ff 92       	push	r15
    1ffe:	1f 93       	push	r17
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
    2004:	6c 01       	movw	r12, r24
    2006:	16 2f       	mov	r17, r22
    2008:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    200a:	8a e1       	ldi	r24, 0x1A	; 26
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	0e 94 c1 11 	call	0x2382	; 0x2382 <pvPortMalloc>
    2012:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2014:	89 2b       	or	r24, r25
    2016:	09 f4       	brne	.+2      	; 0x201a <xCoRoutineCreate+0x24>
    2018:	57 c0       	rjmp	.+174    	; 0x20c8 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    201a:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    201e:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    2022:	89 2b       	or	r24, r25
    2024:	21 f5       	brne	.+72     	; 0x206e <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2026:	d0 93 8c 01 	sts	0x018C, r29	; 0x80018c <pxCurrentCoRoutine+0x1>
    202a:	c0 93 8b 01 	sts	0x018B, r28	; 0x80018b <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    202e:	83 eb       	ldi	r24, 0xB3	; 179
    2030:	91 e0       	ldi	r25, 0x01	; 1
    2032:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
    2036:	8c eb       	ldi	r24, 0xBC	; 188
    2038:	91 e0       	ldi	r25, 0x01	; 1
    203a:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    203e:	8a ea       	ldi	r24, 0xAA	; 170
    2040:	91 e0       	ldi	r25, 0x01	; 1
    2042:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2046:	81 ea       	ldi	r24, 0xA1	; 161
    2048:	91 e0       	ldi	r25, 0x01	; 1
    204a:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    204e:	84 e9       	ldi	r24, 0x94	; 148
    2050:	91 e0       	ldi	r25, 0x01	; 1
    2052:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2056:	8a ea       	ldi	r24, 0xAA	; 170
    2058:	91 e0       	ldi	r25, 0x01	; 1
    205a:	90 93 a0 01 	sts	0x01A0, r25	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    205e:	80 93 9f 01 	sts	0x019F, r24	; 0x80019f <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2062:	81 ea       	ldi	r24, 0xA1	; 161
    2064:	91 e0       	ldi	r25, 0x01	; 1
    2066:	90 93 9e 01 	sts	0x019E, r25	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    206a:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <pxOverflowDelayedCoRoutineList>
    206e:	11 11       	cpse	r17, r1
    2070:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2072:	19 8e       	std	Y+25, r1	; 0x19
    2074:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2076:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2078:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    207a:	fe 01       	movw	r30, r28
    207c:	c1 92       	st	Z+, r12
    207e:	d1 92       	st	Z+, r13
    2080:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2082:	cf 01       	movw	r24, r30
    2084:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2088:	ce 01       	movw	r24, r28
    208a:	0c 96       	adiw	r24, 0x0c	; 12
    208c:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2090:	d9 87       	std	Y+9, r29	; 0x09
    2092:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2094:	db 8b       	std	Y+19, r29	; 0x13
    2096:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2098:	82 e0       	ldi	r24, 0x02	; 2
    209a:	90 e0       	ldi	r25, 0x00	; 0
    209c:	81 1b       	sub	r24, r17
    209e:	91 09       	sbc	r25, r1
    20a0:	9d 87       	std	Y+13, r25	; 0x0d
    20a2:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    20a4:	8e 89       	ldd	r24, Y+22	; 0x16
    20a6:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>
    20aa:	98 17       	cp	r25, r24
    20ac:	10 f4       	brcc	.+4      	; 0x20b2 <xCoRoutineCreate+0xbc>
    20ae:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
    20b2:	f9 e0       	ldi	r31, 0x09	; 9
    20b4:	8f 9f       	mul	r24, r31
    20b6:	c0 01       	movw	r24, r0
    20b8:	11 24       	eor	r1, r1
    20ba:	b7 01       	movw	r22, r14
    20bc:	8d 54       	subi	r24, 0x4D	; 77
    20be:	9e 4f       	sbci	r25, 0xFE	; 254
    20c0:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

		xReturn = pdPASS;
    20c4:	81 e0       	ldi	r24, 0x01	; 1
    20c6:	01 c0       	rjmp	.+2      	; 0x20ca <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    20c8:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    20ca:	df 91       	pop	r29
    20cc:	cf 91       	pop	r28
    20ce:	1f 91       	pop	r17
    20d0:	ff 90       	pop	r15
    20d2:	ef 90       	pop	r14
    20d4:	df 90       	pop	r13
    20d6:	cf 90       	pop	r12
    20d8:	08 95       	ret

000020da <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    20da:	0f 93       	push	r16
    20dc:	1f 93       	push	r17
    20de:	cf 93       	push	r28
    20e0:	df 93       	push	r29
    20e2:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    20e4:	c0 91 91 01 	lds	r28, 0x0191	; 0x800191 <xCoRoutineTickCount>
    20e8:	d0 91 92 01 	lds	r29, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    20ec:	c8 0f       	add	r28, r24
    20ee:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20f0:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    20f4:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    20f8:	02 96       	adiw	r24, 0x02	; 2
    20fa:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    20fe:	e0 91 8b 01 	lds	r30, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    2102:	f0 91 8c 01 	lds	r31, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    2106:	d3 83       	std	Z+3, r29	; 0x03
    2108:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    210a:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <xCoRoutineTickCount>
    210e:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    2112:	bf 01       	movw	r22, r30
    2114:	6e 5f       	subi	r22, 0xFE	; 254
    2116:	7f 4f       	sbci	r23, 0xFF	; 255
    2118:	c8 17       	cp	r28, r24
    211a:	d9 07       	cpc	r29, r25
    211c:	28 f4       	brcc	.+10     	; 0x2128 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    211e:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <pxOverflowDelayedCoRoutineList>
    2122:	90 91 9e 01 	lds	r25, 0x019E	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    2126:	04 c0       	rjmp	.+8      	; 0x2130 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2128:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <pxDelayedCoRoutineList>
    212c:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    2130:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vListInsert>
	}

	if( pxEventList )
    2134:	01 15       	cp	r16, r1
    2136:	11 05       	cpc	r17, r1
    2138:	69 f0       	breq	.+26     	; 0x2154 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    213a:	60 91 8b 01 	lds	r22, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    213e:	70 91 8c 01 	lds	r23, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
    2142:	64 5f       	subi	r22, 0xF4	; 244
    2144:	7f 4f       	sbci	r23, 0xFF	; 255
    2146:	c8 01       	movw	r24, r16
	}
}
    2148:	df 91       	pop	r29
    214a:	cf 91       	pop	r28
    214c:	1f 91       	pop	r17
    214e:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2150:	0c 94 9f 0f 	jmp	0x1f3e	; 0x1f3e <vListInsert>
	}
}
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
    215c:	08 95       	ret

0000215e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    215e:	ff 92       	push	r15
    2160:	0f 93       	push	r16
    2162:	1f 93       	push	r17
    2164:	cf 93       	push	r28
    2166:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2168:	99 e0       	ldi	r25, 0x09	; 9
    216a:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    216c:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xPendingReadyCoRoutineList>
    2170:	88 23       	and	r24, r24
    2172:	11 f1       	breq	.+68     	; 0x21b8 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2174:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2176:	e0 91 99 01 	lds	r30, 0x0199	; 0x800199 <xPendingReadyCoRoutineList+0x5>
    217a:	f0 91 9a 01 	lds	r31, 0x019A	; 0x80019a <xPendingReadyCoRoutineList+0x6>
    217e:	c6 81       	ldd	r28, Z+6	; 0x06
    2180:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2182:	ce 01       	movw	r24, r28
    2184:	0c 96       	adiw	r24, 0x0c	; 12
    2186:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    218a:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    218c:	8e 01       	movw	r16, r28
    218e:	0e 5f       	subi	r16, 0xFE	; 254
    2190:	1f 4f       	sbci	r17, 0xFF	; 255
    2192:	c8 01       	movw	r24, r16
    2194:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2198:	8e 89       	ldd	r24, Y+22	; 0x16
    219a:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>
    219e:	98 17       	cp	r25, r24
    21a0:	10 f4       	brcc	.+4      	; 0x21a6 <vCoRoutineSchedule+0x48>
    21a2:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
    21a6:	f8 9e       	mul	r15, r24
    21a8:	c0 01       	movw	r24, r0
    21aa:	11 24       	eor	r1, r1
    21ac:	b8 01       	movw	r22, r16
    21ae:	8d 54       	subi	r24, 0x4D	; 77
    21b0:	9e 4f       	sbci	r25, 0xFE	; 254
    21b2:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
    21b6:	da cf       	rjmp	.-76     	; 0x216c <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    21b8:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <xTaskGetTickCount>
    21bc:	20 91 8f 01 	lds	r18, 0x018F	; 0x80018f <xLastTickCount>
    21c0:	30 91 90 01 	lds	r19, 0x0190	; 0x800190 <xLastTickCount+0x1>
    21c4:	82 1b       	sub	r24, r18
    21c6:	93 0b       	sbc	r25, r19
    21c8:	90 93 8e 01 	sts	0x018E, r25	; 0x80018e <xPassedTicks+0x1>
    21cc:	80 93 8d 01 	sts	0x018D, r24	; 0x80018d <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    21d0:	89 e0       	ldi	r24, 0x09	; 9
    21d2:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    21d4:	20 91 8d 01 	lds	r18, 0x018D	; 0x80018d <xPassedTicks>
    21d8:	30 91 8e 01 	lds	r19, 0x018E	; 0x80018e <xPassedTicks+0x1>
    21dc:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <xCoRoutineTickCount>
    21e0:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    21e4:	21 15       	cp	r18, r1
    21e6:	31 05       	cpc	r19, r1
    21e8:	09 f4       	brne	.+2      	; 0x21ec <vCoRoutineSchedule+0x8e>
    21ea:	54 c0       	rjmp	.+168    	; 0x2294 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    21ec:	01 96       	adiw	r24, 0x01	; 1
    21ee:	90 93 92 01 	sts	0x0192, r25	; 0x800192 <xCoRoutineTickCount+0x1>
    21f2:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <xCoRoutineTickCount>
		xPassedTicks--;
    21f6:	21 50       	subi	r18, 0x01	; 1
    21f8:	31 09       	sbc	r19, r1
    21fa:	30 93 8e 01 	sts	0x018E, r19	; 0x80018e <xPassedTicks+0x1>
    21fe:	20 93 8d 01 	sts	0x018D, r18	; 0x80018d <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2202:	89 2b       	or	r24, r25
    2204:	09 f0       	breq	.+2      	; 0x2208 <vCoRoutineSchedule+0xaa>
    2206:	3e c0       	rjmp	.+124    	; 0x2284 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2208:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <pxDelayedCoRoutineList>
    220c:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2210:	20 91 9d 01 	lds	r18, 0x019D	; 0x80019d <pxOverflowDelayedCoRoutineList>
    2214:	30 91 9e 01 	lds	r19, 0x019E	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    2218:	30 93 a0 01 	sts	0x01A0, r19	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    221c:	20 93 9f 01 	sts	0x019F, r18	; 0x80019f <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    2220:	90 93 9e 01 	sts	0x019E, r25	; 0x80019e <pxOverflowDelayedCoRoutineList+0x1>
    2224:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <pxOverflowDelayedCoRoutineList>
    2228:	2d c0       	rjmp	.+90     	; 0x2284 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    222a:	05 80       	ldd	r0, Z+5	; 0x05
    222c:	f6 81       	ldd	r31, Z+6	; 0x06
    222e:	e0 2d       	mov	r30, r0
    2230:	c6 81       	ldd	r28, Z+6	; 0x06
    2232:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2234:	2a 81       	ldd	r18, Y+2	; 0x02
    2236:	3b 81       	ldd	r19, Y+3	; 0x03
    2238:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <xCoRoutineTickCount>
    223c:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <xCoRoutineTickCount+0x1>
    2240:	82 17       	cp	r24, r18
    2242:	93 07       	cpc	r25, r19
    2244:	38 f2       	brcs	.-114    	; 0x21d4 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2246:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2248:	8e 01       	movw	r16, r28
    224a:	0e 5f       	subi	r16, 0xFE	; 254
    224c:	1f 4f       	sbci	r17, 0xFF	; 255
    224e:	c8 01       	movw	r24, r16
    2250:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    2254:	8c 89       	ldd	r24, Y+20	; 0x14
    2256:	9d 89       	ldd	r25, Y+21	; 0x15
    2258:	89 2b       	or	r24, r25
    225a:	21 f0       	breq	.+8      	; 0x2264 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    225c:	ce 01       	movw	r24, r28
    225e:	0c 96       	adiw	r24, 0x0c	; 12
    2260:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2264:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2266:	8e 89       	ldd	r24, Y+22	; 0x16
    2268:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>
    226c:	98 17       	cp	r25, r24
    226e:	10 f4       	brcc	.+4      	; 0x2274 <vCoRoutineSchedule+0x116>
    2270:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
    2274:	f8 9e       	mul	r15, r24
    2276:	c0 01       	movw	r24, r0
    2278:	11 24       	eor	r1, r1
    227a:	b8 01       	movw	r22, r16
    227c:	8d 54       	subi	r24, 0x4D	; 77
    227e:	9e 4f       	sbci	r25, 0xFE	; 254
    2280:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2284:	e0 91 9f 01 	lds	r30, 0x019F	; 0x80019f <pxDelayedCoRoutineList>
    2288:	f0 91 a0 01 	lds	r31, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList+0x1>
    228c:	80 81       	ld	r24, Z
    228e:	81 11       	cpse	r24, r1
    2290:	cc cf       	rjmp	.-104    	; 0x222a <vCoRoutineSchedule+0xcc>
    2292:	a0 cf       	rjmp	.-192    	; 0x21d4 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2294:	90 93 90 01 	sts	0x0190, r25	; 0x800190 <xLastTickCount+0x1>
    2298:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <xLastTickCount>
    229c:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    22a0:	69 e0       	ldi	r22, 0x09	; 9
    22a2:	48 2f       	mov	r20, r24
    22a4:	50 e0       	ldi	r21, 0x00	; 0
    22a6:	64 9f       	mul	r22, r20
    22a8:	90 01       	movw	r18, r0
    22aa:	65 9f       	mul	r22, r21
    22ac:	30 0d       	add	r19, r0
    22ae:	11 24       	eor	r1, r1
    22b0:	f9 01       	movw	r30, r18
    22b2:	ed 54       	subi	r30, 0x4D	; 77
    22b4:	fe 4f       	sbci	r31, 0xFE	; 254
    22b6:	90 81       	ld	r25, Z
    22b8:	91 11       	cpse	r25, r1
    22ba:	0c c0       	rjmp	.+24     	; 0x22d4 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    22bc:	81 11       	cpse	r24, r1
    22be:	08 c0       	rjmp	.+16     	; 0x22d0 <vCoRoutineSchedule+0x172>
    22c0:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    22c4:	df 91       	pop	r29
    22c6:	cf 91       	pop	r28
    22c8:	1f 91       	pop	r17
    22ca:	0f 91       	pop	r16
    22cc:	ff 90       	pop	r15
    22ce:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    22d0:	81 50       	subi	r24, 0x01	; 1
    22d2:	e7 cf       	rjmp	.-50     	; 0x22a2 <vCoRoutineSchedule+0x144>
    22d4:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    22d8:	a1 81       	ldd	r26, Z+1	; 0x01
    22da:	b2 81       	ldd	r27, Z+2	; 0x02
    22dc:	12 96       	adiw	r26, 0x02	; 2
    22de:	0d 90       	ld	r0, X+
    22e0:	bc 91       	ld	r27, X
    22e2:	a0 2d       	mov	r26, r0
    22e4:	b2 83       	std	Z+2, r27	; 0x02
    22e6:	a1 83       	std	Z+1, r26	; 0x01
    22e8:	2a 54       	subi	r18, 0x4A	; 74
    22ea:	3e 4f       	sbci	r19, 0xFE	; 254
    22ec:	a2 17       	cp	r26, r18
    22ee:	b3 07       	cpc	r27, r19
    22f0:	31 f4       	brne	.+12     	; 0x22fe <vCoRoutineSchedule+0x1a0>
    22f2:	12 96       	adiw	r26, 0x02	; 2
    22f4:	8d 91       	ld	r24, X+
    22f6:	9c 91       	ld	r25, X
    22f8:	13 97       	sbiw	r26, 0x03	; 3
    22fa:	92 83       	std	Z+2, r25	; 0x02
    22fc:	81 83       	std	Z+1, r24	; 0x01
    22fe:	89 e0       	ldi	r24, 0x09	; 9
    2300:	84 9f       	mul	r24, r20
    2302:	f0 01       	movw	r30, r0
    2304:	85 9f       	mul	r24, r21
    2306:	f0 0d       	add	r31, r0
    2308:	11 24       	eor	r1, r1
    230a:	ed 54       	subi	r30, 0x4D	; 77
    230c:	fe 4f       	sbci	r31, 0xFE	; 254
    230e:	01 80       	ldd	r0, Z+1	; 0x01
    2310:	f2 81       	ldd	r31, Z+2	; 0x02
    2312:	e0 2d       	mov	r30, r0
    2314:	86 81       	ldd	r24, Z+6	; 0x06
    2316:	97 81       	ldd	r25, Z+7	; 0x07
    2318:	90 93 8c 01 	sts	0x018C, r25	; 0x80018c <pxCurrentCoRoutine+0x1>
    231c:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2320:	dc 01       	movw	r26, r24
    2322:	ed 91       	ld	r30, X+
    2324:	fc 91       	ld	r31, X
    2326:	11 97       	sbiw	r26, 0x01	; 1
    2328:	57 96       	adiw	r26, 0x17	; 23
    232a:	6c 91       	ld	r22, X

	return;
}
    232c:	df 91       	pop	r29
    232e:	cf 91       	pop	r28
    2330:	1f 91       	pop	r17
    2332:	0f 91       	pop	r16
    2334:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2336:	09 94       	ijmp

00002338 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2338:	0f 93       	push	r16
    233a:	1f 93       	push	r17
    233c:	cf 93       	push	r28
    233e:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2340:	dc 01       	movw	r26, r24
    2342:	15 96       	adiw	r26, 0x05	; 5
    2344:	ed 91       	ld	r30, X+
    2346:	fc 91       	ld	r31, X
    2348:	16 97       	sbiw	r26, 0x06	; 6
    234a:	c6 81       	ldd	r28, Z+6	; 0x06
    234c:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    234e:	8e 01       	movw	r16, r28
    2350:	04 5f       	subi	r16, 0xF4	; 244
    2352:	1f 4f       	sbci	r17, 0xFF	; 255
    2354:	c8 01       	movw	r24, r16
    2356:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    235a:	b8 01       	movw	r22, r16
    235c:	84 e9       	ldi	r24, 0x94	; 148
    235e:	91 e0       	ldi	r25, 0x01	; 1
    2360:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2364:	e0 91 8b 01 	lds	r30, 0x018B	; 0x80018b <pxCurrentCoRoutine>
    2368:	f0 91 8c 01 	lds	r31, 0x018C	; 0x80018c <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	2e 89       	ldd	r18, Y+22	; 0x16
    2370:	96 89       	ldd	r25, Z+22	; 0x16
    2372:	29 17       	cp	r18, r25
    2374:	08 f4       	brcc	.+2      	; 0x2378 <xCoRoutineRemoveFromEventList+0x40>
    2376:	80 e0       	ldi	r24, 0x00	; 0
}
    2378:	df 91       	pop	r29
    237a:	cf 91       	pop	r28
    237c:	1f 91       	pop	r17
    237e:	0f 91       	pop	r16
    2380:	08 95       	ret

00002382 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2382:	cf 93       	push	r28
    2384:	df 93       	push	r29
    2386:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2388:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    238c:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <pucAlignedHeap.2082>
    2390:	90 91 c6 01 	lds	r25, 0x01C6	; 0x8001c6 <pucAlignedHeap.2082+0x1>
    2394:	89 2b       	or	r24, r25
    2396:	31 f4       	brne	.+12     	; 0x23a4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2398:	8a ec       	ldi	r24, 0xCA	; 202
    239a:	91 e0       	ldi	r25, 0x01	; 1
    239c:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <pucAlignedHeap.2082+0x1>
    23a0:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <pucAlignedHeap.2082>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    23a4:	20 91 c7 01 	lds	r18, 0x01C7	; 0x8001c7 <xNextFreeByte>
    23a8:	30 91 c8 01 	lds	r19, 0x01C8	; 0x8001c8 <xNextFreeByte+0x1>
    23ac:	c9 01       	movw	r24, r18
    23ae:	8c 0f       	add	r24, r28
    23b0:	9d 1f       	adc	r25, r29
    23b2:	8b 3d       	cpi	r24, 0xDB	; 219
    23b4:	45 e0       	ldi	r20, 0x05	; 5
    23b6:	94 07       	cpc	r25, r20
    23b8:	70 f4       	brcc	.+28     	; 0x23d6 <pvPortMalloc+0x54>
    23ba:	28 17       	cp	r18, r24
    23bc:	39 07       	cpc	r19, r25
    23be:	58 f4       	brcc	.+22     	; 0x23d6 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    23c0:	c0 91 c5 01 	lds	r28, 0x01C5	; 0x8001c5 <pucAlignedHeap.2082>
    23c4:	d0 91 c6 01 	lds	r29, 0x01C6	; 0x8001c6 <pucAlignedHeap.2082+0x1>
    23c8:	c2 0f       	add	r28, r18
    23ca:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    23cc:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <xNextFreeByte+0x1>
    23d0:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <xNextFreeByte>
    23d4:	02 c0       	rjmp	.+4      	; 0x23da <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    23d6:	c0 e0       	ldi	r28, 0x00	; 0
    23d8:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    23da:	0e 94 a9 04 	call	0x952	; 0x952 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    23de:	ce 01       	movw	r24, r28
    23e0:	df 91       	pop	r29
    23e2:	cf 91       	pop	r28
    23e4:	08 95       	ret

000023e6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    23e6:	08 95       	ret

000023e8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    23e8:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <xNextFreeByte+0x1>
    23ec:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <xNextFreeByte>
    23f0:	08 95       	ret

000023f2 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    23f2:	20 91 c7 01 	lds	r18, 0x01C7	; 0x8001c7 <xNextFreeByte>
    23f6:	30 91 c8 01 	lds	r19, 0x01C8	; 0x8001c8 <xNextFreeByte+0x1>
}
    23fa:	8b ed       	ldi	r24, 0xDB	; 219
    23fc:	95 e0       	ldi	r25, 0x05	; 5
    23fe:	82 1b       	sub	r24, r18
    2400:	93 0b       	sbc	r25, r19
    2402:	08 95       	ret

00002404 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2404:	31 e1       	ldi	r19, 0x11	; 17
    2406:	fc 01       	movw	r30, r24
    2408:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    240a:	31 97       	sbiw	r30, 0x01	; 1
    240c:	22 e2       	ldi	r18, 0x22	; 34
    240e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2410:	31 97       	sbiw	r30, 0x01	; 1
    2412:	a3 e3       	ldi	r26, 0x33	; 51
    2414:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2416:	31 97       	sbiw	r30, 0x01	; 1
    2418:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    241a:	31 97       	sbiw	r30, 0x01	; 1
    241c:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    241e:	31 97       	sbiw	r30, 0x01	; 1
    2420:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2422:	31 97       	sbiw	r30, 0x01	; 1
    2424:	60 e8       	ldi	r22, 0x80	; 128
    2426:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2428:	31 97       	sbiw	r30, 0x01	; 1
    242a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    242c:	31 97       	sbiw	r30, 0x01	; 1
    242e:	62 e0       	ldi	r22, 0x02	; 2
    2430:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2432:	31 97       	sbiw	r30, 0x01	; 1
    2434:	63 e0       	ldi	r22, 0x03	; 3
    2436:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2438:	31 97       	sbiw	r30, 0x01	; 1
    243a:	64 e0       	ldi	r22, 0x04	; 4
    243c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    243e:	31 97       	sbiw	r30, 0x01	; 1
    2440:	65 e0       	ldi	r22, 0x05	; 5
    2442:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2444:	31 97       	sbiw	r30, 0x01	; 1
    2446:	66 e0       	ldi	r22, 0x06	; 6
    2448:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    244a:	31 97       	sbiw	r30, 0x01	; 1
    244c:	67 e0       	ldi	r22, 0x07	; 7
    244e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2450:	31 97       	sbiw	r30, 0x01	; 1
    2452:	68 e0       	ldi	r22, 0x08	; 8
    2454:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2456:	31 97       	sbiw	r30, 0x01	; 1
    2458:	69 e0       	ldi	r22, 0x09	; 9
    245a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    245c:	31 97       	sbiw	r30, 0x01	; 1
    245e:	60 e1       	ldi	r22, 0x10	; 16
    2460:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2462:	31 97       	sbiw	r30, 0x01	; 1
    2464:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2466:	31 97       	sbiw	r30, 0x01	; 1
    2468:	32 e1       	ldi	r19, 0x12	; 18
    246a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    246c:	31 97       	sbiw	r30, 0x01	; 1
    246e:	33 e1       	ldi	r19, 0x13	; 19
    2470:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2472:	31 97       	sbiw	r30, 0x01	; 1
    2474:	34 e1       	ldi	r19, 0x14	; 20
    2476:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2478:	31 97       	sbiw	r30, 0x01	; 1
    247a:	35 e1       	ldi	r19, 0x15	; 21
    247c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    247e:	31 97       	sbiw	r30, 0x01	; 1
    2480:	36 e1       	ldi	r19, 0x16	; 22
    2482:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2484:	31 97       	sbiw	r30, 0x01	; 1
    2486:	37 e1       	ldi	r19, 0x17	; 23
    2488:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    248a:	31 97       	sbiw	r30, 0x01	; 1
    248c:	38 e1       	ldi	r19, 0x18	; 24
    248e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2490:	31 97       	sbiw	r30, 0x01	; 1
    2492:	39 e1       	ldi	r19, 0x19	; 25
    2494:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2496:	31 97       	sbiw	r30, 0x01	; 1
    2498:	30 e2       	ldi	r19, 0x20	; 32
    249a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    249c:	31 97       	sbiw	r30, 0x01	; 1
    249e:	31 e2       	ldi	r19, 0x21	; 33
    24a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    24a2:	31 97       	sbiw	r30, 0x01	; 1
    24a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    24a6:	31 97       	sbiw	r30, 0x01	; 1
    24a8:	23 e2       	ldi	r18, 0x23	; 35
    24aa:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    24ac:	31 97       	sbiw	r30, 0x01	; 1
    24ae:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    24b0:	31 97       	sbiw	r30, 0x01	; 1
    24b2:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    24b4:	31 97       	sbiw	r30, 0x01	; 1
    24b6:	26 e2       	ldi	r18, 0x26	; 38
    24b8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    24ba:	31 97       	sbiw	r30, 0x01	; 1
    24bc:	27 e2       	ldi	r18, 0x27	; 39
    24be:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    24c0:	31 97       	sbiw	r30, 0x01	; 1
    24c2:	28 e2       	ldi	r18, 0x28	; 40
    24c4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    24c6:	31 97       	sbiw	r30, 0x01	; 1
    24c8:	29 e2       	ldi	r18, 0x29	; 41
    24ca:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    24cc:	31 97       	sbiw	r30, 0x01	; 1
    24ce:	20 e3       	ldi	r18, 0x30	; 48
    24d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    24d2:	31 97       	sbiw	r30, 0x01	; 1
    24d4:	21 e3       	ldi	r18, 0x31	; 49
    24d6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    24d8:	86 97       	sbiw	r24, 0x26	; 38
    24da:	08 95       	ret

000024dc <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    24dc:	89 ef       	ldi	r24, 0xF9	; 249
    24de:	90 e0       	ldi	r25, 0x00	; 0
    24e0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    24e4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    24e8:	e0 e8       	ldi	r30, 0x80	; 128
    24ea:	f0 e0       	ldi	r31, 0x00	; 0
    24ec:	80 81       	ld	r24, Z
    24ee:	8c 7f       	andi	r24, 0xFC	; 252
    24f0:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    24f2:	8b e0       	ldi	r24, 0x0B	; 11
    24f4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    24f8:	ef e6       	ldi	r30, 0x6F	; 111
    24fa:	f0 e0       	ldi	r31, 0x00	; 0
    24fc:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    24fe:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2500:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2502:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    2506:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    250a:	cd 91       	ld	r28, X+
    250c:	cd bf       	out	0x3d, r28	; 61
    250e:	dd 91       	ld	r29, X+
    2510:	de bf       	out	0x3e, r29	; 62
    2512:	ff 91       	pop	r31
    2514:	ef 91       	pop	r30
    2516:	df 91       	pop	r29
    2518:	cf 91       	pop	r28
    251a:	bf 91       	pop	r27
    251c:	af 91       	pop	r26
    251e:	9f 91       	pop	r25
    2520:	8f 91       	pop	r24
    2522:	7f 91       	pop	r23
    2524:	6f 91       	pop	r22
    2526:	5f 91       	pop	r21
    2528:	4f 91       	pop	r20
    252a:	3f 91       	pop	r19
    252c:	2f 91       	pop	r18
    252e:	1f 91       	pop	r17
    2530:	0f 91       	pop	r16
    2532:	ff 90       	pop	r15
    2534:	ef 90       	pop	r14
    2536:	df 90       	pop	r13
    2538:	cf 90       	pop	r12
    253a:	bf 90       	pop	r11
    253c:	af 90       	pop	r10
    253e:	9f 90       	pop	r9
    2540:	8f 90       	pop	r8
    2542:	7f 90       	pop	r7
    2544:	6f 90       	pop	r6
    2546:	5f 90       	pop	r5
    2548:	4f 90       	pop	r4
    254a:	3f 90       	pop	r3
    254c:	2f 90       	pop	r2
    254e:	1f 90       	pop	r1
    2550:	0f 90       	pop	r0
    2552:	0f be       	out	0x3f, r0	; 63
    2554:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2556:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	08 95       	ret

0000255c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    255c:	08 95       	ret

0000255e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    255e:	0f 92       	push	r0
    2560:	0f b6       	in	r0, 0x3f	; 63
    2562:	f8 94       	cli
    2564:	0f 92       	push	r0
    2566:	1f 92       	push	r1
    2568:	11 24       	eor	r1, r1
    256a:	2f 92       	push	r2
    256c:	3f 92       	push	r3
    256e:	4f 92       	push	r4
    2570:	5f 92       	push	r5
    2572:	6f 92       	push	r6
    2574:	7f 92       	push	r7
    2576:	8f 92       	push	r8
    2578:	9f 92       	push	r9
    257a:	af 92       	push	r10
    257c:	bf 92       	push	r11
    257e:	cf 92       	push	r12
    2580:	df 92       	push	r13
    2582:	ef 92       	push	r14
    2584:	ff 92       	push	r15
    2586:	0f 93       	push	r16
    2588:	1f 93       	push	r17
    258a:	2f 93       	push	r18
    258c:	3f 93       	push	r19
    258e:	4f 93       	push	r20
    2590:	5f 93       	push	r21
    2592:	6f 93       	push	r22
    2594:	7f 93       	push	r23
    2596:	8f 93       	push	r24
    2598:	9f 93       	push	r25
    259a:	af 93       	push	r26
    259c:	bf 93       	push	r27
    259e:	cf 93       	push	r28
    25a0:	df 93       	push	r29
    25a2:	ef 93       	push	r30
    25a4:	ff 93       	push	r31
    25a6:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    25aa:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    25ae:	0d b6       	in	r0, 0x3d	; 61
    25b0:	0d 92       	st	X+, r0
    25b2:	0e b6       	in	r0, 0x3e	; 62
    25b4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    25b6:	0e 94 65 05 	call	0xaca	; 0xaca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    25ba:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    25be:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    25c2:	cd 91       	ld	r28, X+
    25c4:	cd bf       	out	0x3d, r28	; 61
    25c6:	dd 91       	ld	r29, X+
    25c8:	de bf       	out	0x3e, r29	; 62
    25ca:	ff 91       	pop	r31
    25cc:	ef 91       	pop	r30
    25ce:	df 91       	pop	r29
    25d0:	cf 91       	pop	r28
    25d2:	bf 91       	pop	r27
    25d4:	af 91       	pop	r26
    25d6:	9f 91       	pop	r25
    25d8:	8f 91       	pop	r24
    25da:	7f 91       	pop	r23
    25dc:	6f 91       	pop	r22
    25de:	5f 91       	pop	r21
    25e0:	4f 91       	pop	r20
    25e2:	3f 91       	pop	r19
    25e4:	2f 91       	pop	r18
    25e6:	1f 91       	pop	r17
    25e8:	0f 91       	pop	r16
    25ea:	ff 90       	pop	r15
    25ec:	ef 90       	pop	r14
    25ee:	df 90       	pop	r13
    25f0:	cf 90       	pop	r12
    25f2:	bf 90       	pop	r11
    25f4:	af 90       	pop	r10
    25f6:	9f 90       	pop	r9
    25f8:	8f 90       	pop	r8
    25fa:	7f 90       	pop	r7
    25fc:	6f 90       	pop	r6
    25fe:	5f 90       	pop	r5
    2600:	4f 90       	pop	r4
    2602:	3f 90       	pop	r3
    2604:	2f 90       	pop	r2
    2606:	1f 90       	pop	r1
    2608:	0f 90       	pop	r0
    260a:	0f be       	out	0x3f, r0	; 63
    260c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    260e:	08 95       	ret

00002610 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2610:	0f 92       	push	r0
    2612:	0f b6       	in	r0, 0x3f	; 63
    2614:	f8 94       	cli
    2616:	0f 92       	push	r0
    2618:	1f 92       	push	r1
    261a:	11 24       	eor	r1, r1
    261c:	2f 92       	push	r2
    261e:	3f 92       	push	r3
    2620:	4f 92       	push	r4
    2622:	5f 92       	push	r5
    2624:	6f 92       	push	r6
    2626:	7f 92       	push	r7
    2628:	8f 92       	push	r8
    262a:	9f 92       	push	r9
    262c:	af 92       	push	r10
    262e:	bf 92       	push	r11
    2630:	cf 92       	push	r12
    2632:	df 92       	push	r13
    2634:	ef 92       	push	r14
    2636:	ff 92       	push	r15
    2638:	0f 93       	push	r16
    263a:	1f 93       	push	r17
    263c:	2f 93       	push	r18
    263e:	3f 93       	push	r19
    2640:	4f 93       	push	r20
    2642:	5f 93       	push	r21
    2644:	6f 93       	push	r22
    2646:	7f 93       	push	r23
    2648:	8f 93       	push	r24
    264a:	9f 93       	push	r25
    264c:	af 93       	push	r26
    264e:	bf 93       	push	r27
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	ef 93       	push	r30
    2656:	ff 93       	push	r31
    2658:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    265c:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    2660:	0d b6       	in	r0, 0x3d	; 61
    2662:	0d 92       	st	X+, r0
    2664:	0e b6       	in	r0, 0x3e	; 62
    2666:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2668:	0e 94 fd 03 	call	0x7fa	; 0x7fa <xTaskIncrementTick>
    266c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    266e:	0e 94 65 05 	call	0xaca	; 0xaca <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2672:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <pxCurrentTCB>
    2676:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <pxCurrentTCB+0x1>
    267a:	cd 91       	ld	r28, X+
    267c:	cd bf       	out	0x3d, r28	; 61
    267e:	dd 91       	ld	r29, X+
    2680:	de bf       	out	0x3e, r29	; 62
    2682:	ff 91       	pop	r31
    2684:	ef 91       	pop	r30
    2686:	df 91       	pop	r29
    2688:	cf 91       	pop	r28
    268a:	bf 91       	pop	r27
    268c:	af 91       	pop	r26
    268e:	9f 91       	pop	r25
    2690:	8f 91       	pop	r24
    2692:	7f 91       	pop	r23
    2694:	6f 91       	pop	r22
    2696:	5f 91       	pop	r21
    2698:	4f 91       	pop	r20
    269a:	3f 91       	pop	r19
    269c:	2f 91       	pop	r18
    269e:	1f 91       	pop	r17
    26a0:	0f 91       	pop	r16
    26a2:	ff 90       	pop	r15
    26a4:	ef 90       	pop	r14
    26a6:	df 90       	pop	r13
    26a8:	cf 90       	pop	r12
    26aa:	bf 90       	pop	r11
    26ac:	af 90       	pop	r10
    26ae:	9f 90       	pop	r9
    26b0:	8f 90       	pop	r8
    26b2:	7f 90       	pop	r7
    26b4:	6f 90       	pop	r6
    26b6:	5f 90       	pop	r5
    26b8:	4f 90       	pop	r4
    26ba:	3f 90       	pop	r3
    26bc:	2f 90       	pop	r2
    26be:	1f 90       	pop	r1
    26c0:	0f 90       	pop	r0
    26c2:	0f be       	out	0x3f, r0	; 63
    26c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    26c6:	08 95       	ret

000026c8 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    26c8:	0e 94 08 13 	call	0x2610	; 0x2610 <vPortYieldFromTick>
		asm volatile ( "reti" );
    26cc:	18 95       	reti

000026ce <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
}

int uart_transmit(char c, FILE *stream) {
    26ce:	cf 93       	push	r28
    26d0:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
    26d2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    26d6:	85 fd       	sbrc	r24, 5
    26d8:	03 c0       	rjmp	.+6      	; 0x26e0 <uart_transmit+0x12>
    26da:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    26de:	f9 cf       	rjmp	.-14     	; 0x26d2 <uart_transmit+0x4>
  UDR0 = c;
    26e0:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  return 0;
}
    26e4:	80 e0       	ldi	r24, 0x00	; 0
    26e6:	90 e0       	ldi	r25, 0x00	; 0
    26e8:	cf 91       	pop	r28
    26ea:	08 95       	ret

000026ec <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
    26ec:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    26f0:	87 fd       	sbrc	r24, 7
    26f2:	03 c0       	rjmp	.+6      	; 0x26fa <uart_receive+0xe>
    26f4:	0e 94 af 12 	call	0x255e	; 0x255e <vPortYield>
    26f8:	f9 cf       	rjmp	.-14     	; 0x26ec <uart_receive>
  return UDR0;
    26fa:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	08 95       	ret

00002702 <uart_init>:
    2702:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    2706:	87 e6       	ldi	r24, 0x67	; 103
    2708:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    270c:	e0 ec       	ldi	r30, 0xC0	; 192
    270e:	f0 e0       	ldi	r31, 0x00	; 0
    2710:	80 81       	ld	r24, Z
    2712:	8d 7f       	andi	r24, 0xFD	; 253
    2714:	80 83       	st	Z, r24
    2716:	86 e0       	ldi	r24, 0x06	; 6
    2718:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    271c:	88 e1       	ldi	r24, 0x18	; 24
    271e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    2722:	08 95       	ret

00002724 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    2724:	ef 92       	push	r14
    2726:	ff 92       	push	r15
    2728:	0f 93       	push	r16
    272a:	cf 93       	push	r28
    272c:	df 93       	push	r29
    272e:	00 d0       	rcall	.+0      	; 0x2730 <main+0xc>
    2730:	00 d0       	rcall	.+0      	; 0x2732 <main+0xe>
    2732:	00 d0       	rcall	.+0      	; 0x2734 <main+0x10>
    2734:	cd b7       	in	r28, 0x3d	; 61
    2736:	de b7       	in	r29, 0x3e	; 62
  adc_init();
    2738:	0e 94 53 00 	call	0xa6	; 0xa6 <adc_init>
  sei();
    273c:	78 94       	sei
  // Create task.
  xTaskHandle adc0_handle;
  xTaskHandle adc1_handle;
  xTaskHandle adc2_handle;
  mutex_a = xSemaphoreCreateMutex();
    273e:	81 e0       	ldi	r24, 0x01	; 1
    2740:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <xQueueCreateMutex>
    2744:	90 93 a6 07 	sts	0x07A6, r25	; 0x8007a6 <mutex_a+0x1>
    2748:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <mutex_a>
  mutex_r = xSemaphoreCreateMutex();
    274c:	81 e0       	ldi	r24, 0x01	; 1
    274e:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <xQueueCreateMutex>
    2752:	90 93 a8 07 	sts	0x07A8, r25	; 0x8007a8 <mutex_r+0x1>
    2756:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <mutex_r>
  mutex_z = xSemaphoreCreateMutex();
    275a:	81 e0       	ldi	r24, 0x01	; 1
    275c:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <xQueueCreateMutex>
    2760:	90 93 aa 07 	sts	0x07AA, r25	; 0x8007aa <mutex_z+0x1>
    2764:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <mutex_z>

    xTaskCreate
    2768:	ce 01       	movw	r24, r28
    276a:	05 96       	adiw	r24, 0x05	; 5
    276c:	7c 01       	movw	r14, r24
    276e:	01 e0       	ldi	r16, 0x01	; 1
    2770:	20 e0       	ldi	r18, 0x00	; 0
    2772:	30 e0       	ldi	r19, 0x00	; 0
    2774:	45 e5       	ldi	r20, 0x55	; 85
    2776:	50 e0       	ldi	r21, 0x00	; 0
    2778:	60 e1       	ldi	r22, 0x10	; 16
    277a:	71 e0       	ldi	r23, 0x01	; 1
    277c:	81 e9       	ldi	r24, 0x91	; 145
    277e:	90 e0       	ldi	r25, 0x00	; 0
    2780:	0e 94 c7 01 	call	0x38e	; 0x38e <xTaskCreate>
         0,
         vADC_TASK_PRIORITY,
         &adc0_handle
        );

    xTaskCreate
    2784:	ce 01       	movw	r24, r28
    2786:	03 96       	adiw	r24, 0x03	; 3
    2788:	7c 01       	movw	r14, r24
    278a:	21 e0       	ldi	r18, 0x01	; 1
    278c:	30 e0       	ldi	r19, 0x00	; 0
    278e:	45 e5       	ldi	r20, 0x55	; 85
    2790:	50 e0       	ldi	r21, 0x00	; 0
    2792:	65 e1       	ldi	r22, 0x15	; 21
    2794:	71 e0       	ldi	r23, 0x01	; 1
    2796:	81 e9       	ldi	r24, 0x91	; 145
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	0e 94 c7 01 	call	0x38e	; 0x38e <xTaskCreate>
         1,
         vADC_TASK_PRIORITY,
         &adc1_handle
        );

    xTaskCreate
    279e:	ce 01       	movw	r24, r28
    27a0:	01 96       	adiw	r24, 0x01	; 1
    27a2:	7c 01       	movw	r14, r24
    27a4:	22 e0       	ldi	r18, 0x02	; 2
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	45 e5       	ldi	r20, 0x55	; 85
    27aa:	50 e0       	ldi	r21, 0x00	; 0
    27ac:	6a e1       	ldi	r22, 0x1A	; 26
    27ae:	71 e0       	ldi	r23, 0x01	; 1
    27b0:	81 e9       	ldi	r24, 0x91	; 145
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	0e 94 c7 01 	call	0x38e	; 0x38e <xTaskCreate>
         vADC_TASK_PRIORITY,
         &adc2_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    27b8:	0e 94 ae 03 	call	0x75c	; 0x75c <vTaskStartScheduler>

    return 0;
}
    27bc:	80 e0       	ldi	r24, 0x00	; 0
    27be:	90 e0       	ldi	r25, 0x00	; 0
    27c0:	26 96       	adiw	r28, 0x06	; 6
    27c2:	0f b6       	in	r0, 0x3f	; 63
    27c4:	f8 94       	cli
    27c6:	de bf       	out	0x3e, r29	; 62
    27c8:	0f be       	out	0x3f, r0	; 63
    27ca:	cd bf       	out	0x3d, r28	; 61
    27cc:	df 91       	pop	r29
    27ce:	cf 91       	pop	r28
    27d0:	0f 91       	pop	r16
    27d2:	ff 90       	pop	r15
    27d4:	ef 90       	pop	r14
    27d6:	08 95       	ret

000027d8 <memcpy>:
    27d8:	fb 01       	movw	r30, r22
    27da:	dc 01       	movw	r26, r24
    27dc:	02 c0       	rjmp	.+4      	; 0x27e2 <memcpy+0xa>
    27de:	01 90       	ld	r0, Z+
    27e0:	0d 92       	st	X+, r0
    27e2:	41 50       	subi	r20, 0x01	; 1
    27e4:	50 40       	sbci	r21, 0x00	; 0
    27e6:	d8 f7       	brcc	.-10     	; 0x27de <memcpy+0x6>
    27e8:	08 95       	ret

000027ea <utoa>:
    27ea:	45 32       	cpi	r20, 0x25	; 37
    27ec:	51 05       	cpc	r21, r1
    27ee:	20 f4       	brcc	.+8      	; 0x27f8 <utoa+0xe>
    27f0:	42 30       	cpi	r20, 0x02	; 2
    27f2:	10 f0       	brcs	.+4      	; 0x27f8 <utoa+0xe>
    27f4:	0c 94 00 14 	jmp	0x2800	; 0x2800 <__utoa_ncheck>
    27f8:	fb 01       	movw	r30, r22
    27fa:	10 82       	st	Z, r1
    27fc:	cb 01       	movw	r24, r22
    27fe:	08 95       	ret

00002800 <__utoa_ncheck>:
    2800:	bb 27       	eor	r27, r27

00002802 <__utoa_common>:
    2802:	fb 01       	movw	r30, r22
    2804:	55 27       	eor	r21, r21
    2806:	aa 27       	eor	r26, r26
    2808:	88 0f       	add	r24, r24
    280a:	99 1f       	adc	r25, r25
    280c:	aa 1f       	adc	r26, r26
    280e:	a4 17       	cp	r26, r20
    2810:	10 f0       	brcs	.+4      	; 0x2816 <__utoa_common+0x14>
    2812:	a4 1b       	sub	r26, r20
    2814:	83 95       	inc	r24
    2816:	50 51       	subi	r21, 0x10	; 16
    2818:	b9 f7       	brne	.-18     	; 0x2808 <__utoa_common+0x6>
    281a:	a0 5d       	subi	r26, 0xD0	; 208
    281c:	aa 33       	cpi	r26, 0x3A	; 58
    281e:	08 f0       	brcs	.+2      	; 0x2822 <__utoa_common+0x20>
    2820:	a9 5d       	subi	r26, 0xD9	; 217
    2822:	a1 93       	st	Z+, r26
    2824:	00 97       	sbiw	r24, 0x00	; 0
    2826:	79 f7       	brne	.-34     	; 0x2806 <__utoa_common+0x4>
    2828:	b1 11       	cpse	r27, r1
    282a:	b1 93       	st	Z+, r27
    282c:	11 92       	st	Z+, r1
    282e:	cb 01       	movw	r24, r22
    2830:	0c 94 86 14 	jmp	0x290c	; 0x290c <strrev>

00002834 <fputc>:
    2834:	0f 93       	push	r16
    2836:	1f 93       	push	r17
    2838:	cf 93       	push	r28
    283a:	df 93       	push	r29
    283c:	fb 01       	movw	r30, r22
    283e:	23 81       	ldd	r18, Z+3	; 0x03
    2840:	21 fd       	sbrc	r18, 1
    2842:	03 c0       	rjmp	.+6      	; 0x284a <fputc+0x16>
    2844:	8f ef       	ldi	r24, 0xFF	; 255
    2846:	9f ef       	ldi	r25, 0xFF	; 255
    2848:	2c c0       	rjmp	.+88     	; 0x28a2 <fputc+0x6e>
    284a:	22 ff       	sbrs	r18, 2
    284c:	16 c0       	rjmp	.+44     	; 0x287a <fputc+0x46>
    284e:	46 81       	ldd	r20, Z+6	; 0x06
    2850:	57 81       	ldd	r21, Z+7	; 0x07
    2852:	24 81       	ldd	r18, Z+4	; 0x04
    2854:	35 81       	ldd	r19, Z+5	; 0x05
    2856:	42 17       	cp	r20, r18
    2858:	53 07       	cpc	r21, r19
    285a:	44 f4       	brge	.+16     	; 0x286c <fputc+0x38>
    285c:	a0 81       	ld	r26, Z
    285e:	b1 81       	ldd	r27, Z+1	; 0x01
    2860:	9d 01       	movw	r18, r26
    2862:	2f 5f       	subi	r18, 0xFF	; 255
    2864:	3f 4f       	sbci	r19, 0xFF	; 255
    2866:	31 83       	std	Z+1, r19	; 0x01
    2868:	20 83       	st	Z, r18
    286a:	8c 93       	st	X, r24
    286c:	26 81       	ldd	r18, Z+6	; 0x06
    286e:	37 81       	ldd	r19, Z+7	; 0x07
    2870:	2f 5f       	subi	r18, 0xFF	; 255
    2872:	3f 4f       	sbci	r19, 0xFF	; 255
    2874:	37 83       	std	Z+7, r19	; 0x07
    2876:	26 83       	std	Z+6, r18	; 0x06
    2878:	14 c0       	rjmp	.+40     	; 0x28a2 <fputc+0x6e>
    287a:	8b 01       	movw	r16, r22
    287c:	ec 01       	movw	r28, r24
    287e:	fb 01       	movw	r30, r22
    2880:	00 84       	ldd	r0, Z+8	; 0x08
    2882:	f1 85       	ldd	r31, Z+9	; 0x09
    2884:	e0 2d       	mov	r30, r0
    2886:	09 95       	icall
    2888:	89 2b       	or	r24, r25
    288a:	e1 f6       	brne	.-72     	; 0x2844 <fputc+0x10>
    288c:	d8 01       	movw	r26, r16
    288e:	16 96       	adiw	r26, 0x06	; 6
    2890:	8d 91       	ld	r24, X+
    2892:	9c 91       	ld	r25, X
    2894:	17 97       	sbiw	r26, 0x07	; 7
    2896:	01 96       	adiw	r24, 0x01	; 1
    2898:	17 96       	adiw	r26, 0x07	; 7
    289a:	9c 93       	st	X, r25
    289c:	8e 93       	st	-X, r24
    289e:	16 97       	sbiw	r26, 0x06	; 6
    28a0:	ce 01       	movw	r24, r28
    28a2:	df 91       	pop	r29
    28a4:	cf 91       	pop	r28
    28a6:	1f 91       	pop	r17
    28a8:	0f 91       	pop	r16
    28aa:	08 95       	ret

000028ac <puts>:
    28ac:	0f 93       	push	r16
    28ae:	1f 93       	push	r17
    28b0:	cf 93       	push	r28
    28b2:	df 93       	push	r29
    28b4:	e0 91 ad 07 	lds	r30, 0x07AD	; 0x8007ad <__iob+0x2>
    28b8:	f0 91 ae 07 	lds	r31, 0x07AE	; 0x8007ae <__iob+0x3>
    28bc:	23 81       	ldd	r18, Z+3	; 0x03
    28be:	21 ff       	sbrs	r18, 1
    28c0:	1b c0       	rjmp	.+54     	; 0x28f8 <puts+0x4c>
    28c2:	8c 01       	movw	r16, r24
    28c4:	d0 e0       	ldi	r29, 0x00	; 0
    28c6:	c0 e0       	ldi	r28, 0x00	; 0
    28c8:	f8 01       	movw	r30, r16
    28ca:	81 91       	ld	r24, Z+
    28cc:	8f 01       	movw	r16, r30
    28ce:	60 91 ad 07 	lds	r22, 0x07AD	; 0x8007ad <__iob+0x2>
    28d2:	70 91 ae 07 	lds	r23, 0x07AE	; 0x8007ae <__iob+0x3>
    28d6:	db 01       	movw	r26, r22
    28d8:	18 96       	adiw	r26, 0x08	; 8
    28da:	ed 91       	ld	r30, X+
    28dc:	fc 91       	ld	r31, X
    28de:	19 97       	sbiw	r26, 0x09	; 9
    28e0:	88 23       	and	r24, r24
    28e2:	31 f0       	breq	.+12     	; 0x28f0 <puts+0x44>
    28e4:	09 95       	icall
    28e6:	89 2b       	or	r24, r25
    28e8:	79 f3       	breq	.-34     	; 0x28c8 <puts+0x1c>
    28ea:	df ef       	ldi	r29, 0xFF	; 255
    28ec:	cf ef       	ldi	r28, 0xFF	; 255
    28ee:	ec cf       	rjmp	.-40     	; 0x28c8 <puts+0x1c>
    28f0:	8a e0       	ldi	r24, 0x0A	; 10
    28f2:	09 95       	icall
    28f4:	89 2b       	or	r24, r25
    28f6:	19 f0       	breq	.+6      	; 0x28fe <puts+0x52>
    28f8:	8f ef       	ldi	r24, 0xFF	; 255
    28fa:	9f ef       	ldi	r25, 0xFF	; 255
    28fc:	02 c0       	rjmp	.+4      	; 0x2902 <puts+0x56>
    28fe:	8d 2f       	mov	r24, r29
    2900:	9c 2f       	mov	r25, r28
    2902:	df 91       	pop	r29
    2904:	cf 91       	pop	r28
    2906:	1f 91       	pop	r17
    2908:	0f 91       	pop	r16
    290a:	08 95       	ret

0000290c <strrev>:
    290c:	dc 01       	movw	r26, r24
    290e:	fc 01       	movw	r30, r24
    2910:	67 2f       	mov	r22, r23
    2912:	71 91       	ld	r23, Z+
    2914:	77 23       	and	r23, r23
    2916:	e1 f7       	brne	.-8      	; 0x2910 <strrev+0x4>
    2918:	32 97       	sbiw	r30, 0x02	; 2
    291a:	04 c0       	rjmp	.+8      	; 0x2924 <strrev+0x18>
    291c:	7c 91       	ld	r23, X
    291e:	6d 93       	st	X+, r22
    2920:	70 83       	st	Z, r23
    2922:	62 91       	ld	r22, -Z
    2924:	ae 17       	cp	r26, r30
    2926:	bf 07       	cpc	r27, r31
    2928:	c8 f3       	brcs	.-14     	; 0x291c <strrev+0x10>
    292a:	08 95       	ret

0000292c <_exit>:
    292c:	f8 94       	cli

0000292e <__stop_program>:
    292e:	ff cf       	rjmp	.-2      	; 0x292e <__stop_program>
