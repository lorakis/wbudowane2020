   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 187               	prvResetNextTaskUnblockTime:
 188               		.stabd	46,0,0
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/Source/tasks.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/tasks.c ****  *
   5:FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/tasks.c ****  *
  12:FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/tasks.c ****  *
  15:FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/tasks.c ****  *
  22:FreeRTOS/Source/tasks.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/tasks.c ****  *
  25:FreeRTOS/Source/tasks.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/tasks.c ****  */
  27:FreeRTOS/Source/tasks.c **** 
  28:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  29:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  30:FreeRTOS/Source/tasks.c **** #include <string.h>
  31:FreeRTOS/Source/tasks.c **** 
  32:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  35:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/Source/tasks.c **** 
  37:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  38:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  39:FreeRTOS/Source/tasks.c **** #include "task.h"
  40:FreeRTOS/Source/tasks.c **** #include "timers.h"
  41:FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:FreeRTOS/Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:FreeRTOS/Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:FreeRTOS/Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:FreeRTOS/Source/tasks.c **** 
  49:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  51:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  57:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:FreeRTOS/Source/tasks.c **** #else
  64:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:FreeRTOS/Source/tasks.c **** #endif
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:FreeRTOS/Source/tasks.c **** 
  72:FreeRTOS/Source/tasks.c **** /*
  73:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:FreeRTOS/Source/tasks.c ****  */
  76:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:FreeRTOS/Source/tasks.c **** 
  78:FreeRTOS/Source/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  79:FreeRTOS/Source/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  80:FreeRTOS/Source/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  81:FreeRTOS/Source/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  82:FreeRTOS/Source/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  83:FreeRTOS/Source/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  84:FreeRTOS/Source/tasks.c **** settings allow a task to be created using either statically or dynamically
  85:FreeRTOS/Source/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  86:FreeRTOS/Source/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  87:FreeRTOS/Source/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  88:FreeRTOS/Source/tasks.c **** made to free the RAM that was allocated statically.
  89:FreeRTOS/Source/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
  90:FreeRTOS/Source/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  91:FreeRTOS/Source/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  92:FreeRTOS/Source/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  93:FreeRTOS/Source/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  94:FreeRTOS/Source/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  95:FreeRTOS/Source/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  96:FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  97:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  98:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  99:FreeRTOS/Source/tasks.c **** 
 100:FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 101:FreeRTOS/Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
 102:FreeRTOS/Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 103:FreeRTOS/Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 104:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 105:FreeRTOS/Source/tasks.c **** #else
 106:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 107:FreeRTOS/Source/tasks.c **** #endif
 108:FreeRTOS/Source/tasks.c **** 
 109:FreeRTOS/Source/tasks.c **** /*
 110:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 111:FreeRTOS/Source/tasks.c ****  */
 112:FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
 113:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** /*
 119:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 121:FreeRTOS/Source/tasks.c ****  */
 122:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:FreeRTOS/Source/tasks.c **** 	#define static
 124:FreeRTOS/Source/tasks.c **** #endif
 125:FreeRTOS/Source/tasks.c **** 
 126:FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:FreeRTOS/Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:FreeRTOS/Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:FreeRTOS/Source/tasks.c **** #endif
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 137:FreeRTOS/Source/tasks.c **** 
 138:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:FreeRTOS/Source/tasks.c **** 	state task. */
 140:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:FreeRTOS/Source/tasks.c **** 	{																									\
 142:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:FreeRTOS/Source/tasks.c **** 		{																								\
 144:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:FreeRTOS/Source/tasks.c **** 		}																								\
 146:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:FreeRTOS/Source/tasks.c **** 	{																									\
 152:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:FreeRTOS/Source/tasks.c **** 																										\
 154:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:FreeRTOS/Source/tasks.c **** 		{																								\
 157:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:FreeRTOS/Source/tasks.c **** 			--uxTopPriority;																			\
 159:FreeRTOS/Source/tasks.c **** 		}																								\
 160:FreeRTOS/Source/tasks.c **** 																										\
 161:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Source/tasks.c **** 
 169:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:FreeRTOS/Source/tasks.c **** 	being used. */
 172:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:FreeRTOS/Source/tasks.c **** 
 177:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:FreeRTOS/Source/tasks.c **** 
 184:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 185:FreeRTOS/Source/tasks.c **** 
 186:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:FreeRTOS/Source/tasks.c **** 	{																								\
 188:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:FreeRTOS/Source/tasks.c **** 																									\
 190:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:FreeRTOS/Source/tasks.c **** 
 196:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 197:FreeRTOS/Source/tasks.c **** 
 198:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:FreeRTOS/Source/tasks.c **** 	{																									\
 203:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 204:FreeRTOS/Source/tasks.c **** 		{																								\
 205:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:FreeRTOS/Source/tasks.c **** 		}																								\
 207:FreeRTOS/Source/tasks.c **** 	}
 208:FreeRTOS/Source/tasks.c **** 
 209:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:FreeRTOS/Source/tasks.c **** 
 211:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 212:FreeRTOS/Source/tasks.c **** 
 213:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:FreeRTOS/Source/tasks.c **** count overflows. */
 215:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:FreeRTOS/Source/tasks.c **** {																									\
 217:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 218:FreeRTOS/Source/tasks.c **** 																									\
 219:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:FreeRTOS/Source/tasks.c **** 																									\
 222:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 226:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:FreeRTOS/Source/tasks.c **** }
 228:FreeRTOS/Source/tasks.c **** 
 229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 230:FreeRTOS/Source/tasks.c **** 
 231:FreeRTOS/Source/tasks.c **** /*
 232:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:FreeRTOS/Source/tasks.c ****  */
 235:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:FreeRTOS/Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 241:FreeRTOS/Source/tasks.c **** 
 242:FreeRTOS/Source/tasks.c **** /*
 243:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:FreeRTOS/Source/tasks.c ****  */
 248:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 249:FreeRTOS/Source/tasks.c **** 
 250:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 258:FreeRTOS/Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:FreeRTOS/Source/tasks.c **** #else
 261:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:FreeRTOS/Source/tasks.c **** #endif
 263:FreeRTOS/Source/tasks.c **** 
 264:FreeRTOS/Source/tasks.c **** /*
 265:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 268:FreeRTOS/Source/tasks.c ****  */
 269:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel 
 270:FreeRTOS/Source/tasks.c **** {
 271:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:FreeRTOS/Source/tasks.c **** 
 273:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:FreeRTOS/Source/tasks.c **** 	#endif
 276:FreeRTOS/Source/tasks.c **** 
 277:FreeRTOS/Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:FreeRTOS/Source/tasks.c **** 
 283:FreeRTOS/Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:FreeRTOS/Source/tasks.c **** 	#endif
 286:FreeRTOS/Source/tasks.c **** 
 287:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:FreeRTOS/Source/tasks.c **** 	#endif
 290:FreeRTOS/Source/tasks.c **** 
 291:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:FreeRTOS/Source/tasks.c **** 	#endif
 295:FreeRTOS/Source/tasks.c **** 
 296:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:FreeRTOS/Source/tasks.c **** 	#endif
 300:FreeRTOS/Source/tasks.c **** 
 301:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:FreeRTOS/Source/tasks.c **** 	#endif
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:FreeRTOS/Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:FreeRTOS/Source/tasks.c **** 	#endif
 308:FreeRTOS/Source/tasks.c **** 
 309:FreeRTOS/Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:FreeRTOS/Source/tasks.c **** 	#endif
 312:FreeRTOS/Source/tasks.c **** 
 313:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 318:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:FreeRTOS/Source/tasks.c **** 		struct	_reent xNewLib_reent;
 322:FreeRTOS/Source/tasks.c **** 	#endif
 323:FreeRTOS/Source/tasks.c **** 
 324:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:FreeRTOS/Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:FreeRTOS/Source/tasks.c **** 	#endif
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** 	/* See the comments above the definition of
 330:FreeRTOS/Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:FreeRTOS/Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 332:FreeRTOS/Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:FreeRTOS/Source/tasks.c **** 	#endif
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:FreeRTOS/Source/tasks.c **** 		uint8_t ucDelayAborted;
 337:FreeRTOS/Source/tasks.c **** 	#endif
 338:FreeRTOS/Source/tasks.c **** 
 339:FreeRTOS/Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 340:FreeRTOS/Source/tasks.c **** 		int iTaskErrno;
 341:FreeRTOS/Source/tasks.c **** 	#endif
 342:FreeRTOS/Source/tasks.c **** 
 343:FreeRTOS/Source/tasks.c **** } tskTCB;
 344:FreeRTOS/Source/tasks.c **** 
 345:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 346:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 347:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 348:FreeRTOS/Source/tasks.c **** 
 349:FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 350:FreeRTOS/Source/tasks.c **** which static variables must be declared volatile. */
 351:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 354:FreeRTOS/Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 355:FreeRTOS/Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 356:FreeRTOS/Source/tasks.c **** the static qualifier. */
 357:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 358:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 359:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 360:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 361:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 362:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 363:FreeRTOS/Source/tasks.c **** 
 364:FreeRTOS/Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 367:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 368:FreeRTOS/Source/tasks.c **** 
 369:FreeRTOS/Source/tasks.c **** #endif
 370:FreeRTOS/Source/tasks.c **** 
 371:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 372:FreeRTOS/Source/tasks.c **** 
 373:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** #endif
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 378:FreeRTOS/Source/tasks.c **** the errno of the currently running task. */
 379:FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 380:FreeRTOS/Source/tasks.c **** 	int FreeRTOS_errno = 0;
 381:FreeRTOS/Source/tasks.c **** #endif
 382:FreeRTOS/Source/tasks.c **** 
 383:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 384:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 385:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 386:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 387:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 388:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 389:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 390:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 391:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 392:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 393:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 394:FreeRTOS/Source/tasks.c **** 
 395:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 396:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 397:FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 398:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 399:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 400:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 401:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 402:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 403:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 404:FreeRTOS/Source/tasks.c **** 
 405:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 406:FreeRTOS/Source/tasks.c **** 
 407:FreeRTOS/Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 408:FreeRTOS/Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 409:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 410:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 411:FreeRTOS/Source/tasks.c **** 
 412:FreeRTOS/Source/tasks.c **** #endif
 413:FreeRTOS/Source/tasks.c **** 
 414:FreeRTOS/Source/tasks.c **** /*lint -restore */
 415:FreeRTOS/Source/tasks.c **** 
 416:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 417:FreeRTOS/Source/tasks.c **** 
 418:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 419:FreeRTOS/Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 420:FreeRTOS/Source/tasks.c **** 
 421:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 422:FreeRTOS/Source/tasks.c **** 
 423:FreeRTOS/Source/tasks.c **** #endif
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** #endif
 430:FreeRTOS/Source/tasks.c **** 
 431:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 434:FreeRTOS/Source/tasks.c **** 
 435:FreeRTOS/Source/tasks.c **** #endif
 436:FreeRTOS/Source/tasks.c **** 
 437:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 438:FreeRTOS/Source/tasks.c **** 
 439:FreeRTOS/Source/tasks.c **** /**
 440:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 441:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 442:FreeRTOS/Source/tasks.c ****  * is in any other state.
 443:FreeRTOS/Source/tasks.c ****  */
 444:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 445:FreeRTOS/Source/tasks.c **** 
 446:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 447:FreeRTOS/Source/tasks.c **** 
 448:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 449:FreeRTOS/Source/tasks.c **** 
 450:FreeRTOS/Source/tasks.c **** /*
 451:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 452:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 453:FreeRTOS/Source/tasks.c ****  */
 454:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 455:FreeRTOS/Source/tasks.c **** 
 456:FreeRTOS/Source/tasks.c **** /*
 457:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 458:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 459:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 460:FreeRTOS/Source/tasks.c ****  *
 461:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 462:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 463:FreeRTOS/Source/tasks.c ****  *
 464:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 465:FreeRTOS/Source/tasks.c ****  *
 466:FreeRTOS/Source/tasks.c ****  */
 467:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 468:FreeRTOS/Source/tasks.c **** 
 469:FreeRTOS/Source/tasks.c **** /*
 470:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 471:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 472:FreeRTOS/Source/tasks.c ****  *
 473:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 474:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 475:FreeRTOS/Source/tasks.c ****  */
 476:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 477:FreeRTOS/Source/tasks.c **** 
 478:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 479:FreeRTOS/Source/tasks.c **** 
 480:FreeRTOS/Source/tasks.c **** #endif
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** /*
 483:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 484:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 485:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 486:FreeRTOS/Source/tasks.c ****  */
 487:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** /*
 490:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 491:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 492:FreeRTOS/Source/tasks.c ****  */
 493:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 494:FreeRTOS/Source/tasks.c **** 
 495:FreeRTOS/Source/tasks.c **** /*
 496:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 497:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 498:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 499:FreeRTOS/Source/tasks.c ****  *
 500:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 501:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 502:FreeRTOS/Source/tasks.c ****  */
 503:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 504:FreeRTOS/Source/tasks.c **** 
 505:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 506:FreeRTOS/Source/tasks.c **** 
 507:FreeRTOS/Source/tasks.c **** #endif
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** /*
 510:FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 511:FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 512:FreeRTOS/Source/tasks.c ****  */
 513:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 514:FreeRTOS/Source/tasks.c **** 
 515:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 516:FreeRTOS/Source/tasks.c **** 
 517:FreeRTOS/Source/tasks.c **** #endif
 518:FreeRTOS/Source/tasks.c **** 
 519:FreeRTOS/Source/tasks.c **** /*
 520:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 521:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 522:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 523:FreeRTOS/Source/tasks.c ****  */
 524:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 525:FreeRTOS/Source/tasks.c **** 
 526:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** #endif
 529:FreeRTOS/Source/tasks.c **** 
 530:FreeRTOS/Source/tasks.c **** /*
 531:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 532:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 533:FreeRTOS/Source/tasks.c ****  *
 534:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 535:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 536:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 537:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 538:FreeRTOS/Source/tasks.c ****  */
 539:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 540:FreeRTOS/Source/tasks.c **** 
 541:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 542:FreeRTOS/Source/tasks.c **** 
 543:FreeRTOS/Source/tasks.c **** #endif
 544:FreeRTOS/Source/tasks.c **** 
 545:FreeRTOS/Source/tasks.c **** /*
 546:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 547:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 548:FreeRTOS/Source/tasks.c ****  */
 549:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 550:FreeRTOS/Source/tasks.c **** 
 551:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 552:FreeRTOS/Source/tasks.c **** 
 553:FreeRTOS/Source/tasks.c **** 	/*
 554:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 555:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 556:FreeRTOS/Source/tasks.c **** 	 */
 557:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 558:FreeRTOS/Source/tasks.c **** 
 559:FreeRTOS/Source/tasks.c **** #endif
 560:FreeRTOS/Source/tasks.c **** 
 561:FreeRTOS/Source/tasks.c **** /*
 562:FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 563:FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 564:FreeRTOS/Source/tasks.c ****  */
 565:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 566:FreeRTOS/Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 567:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 568:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 569:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 570:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 571:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 572:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 573:FreeRTOS/Source/tasks.c **** 
 574:FreeRTOS/Source/tasks.c **** /*
 575:FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 576:FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 577:FreeRTOS/Source/tasks.c ****  */
 578:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 579:FreeRTOS/Source/tasks.c **** 
 580:FreeRTOS/Source/tasks.c **** /*
 581:FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 582:FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 583:FreeRTOS/Source/tasks.c ****  * called by the function.
 584:FreeRTOS/Source/tasks.c ****  */
 585:FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 586:FreeRTOS/Source/tasks.c **** 
 587:FreeRTOS/Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 588:FreeRTOS/Source/tasks.c **** 
 589:FreeRTOS/Source/tasks.c **** #endif
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 592:FreeRTOS/Source/tasks.c **** 
 593:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 596:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 597:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 598:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 599:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 600:FreeRTOS/Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 601:FreeRTOS/Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 602:FreeRTOS/Source/tasks.c **** 	{
 603:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 604:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 605:FreeRTOS/Source/tasks.c **** 
 606:FreeRTOS/Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 607:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 608:FreeRTOS/Source/tasks.c **** 
 609:FreeRTOS/Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 610:FreeRTOS/Source/tasks.c **** 		{
 611:FreeRTOS/Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 612:FreeRTOS/Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 613:FreeRTOS/Source/tasks.c **** 			structure. */
 614:FreeRTOS/Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 615:FreeRTOS/Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 616:FreeRTOS/Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 617:FreeRTOS/Source/tasks.c **** 		}
 618:FreeRTOS/Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 619:FreeRTOS/Source/tasks.c **** 
 620:FreeRTOS/Source/tasks.c **** 
 621:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 622:FreeRTOS/Source/tasks.c **** 		{
 623:FreeRTOS/Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 624:FreeRTOS/Source/tasks.c **** 			function - use them. */
 625:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 626:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 627:FreeRTOS/Source/tasks.c **** 
 628:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 629:FreeRTOS/Source/tasks.c **** 			{
 630:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 631:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 632:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 633:FreeRTOS/Source/tasks.c **** 			}
 634:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 637:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 638:FreeRTOS/Source/tasks.c **** 		}
 639:FreeRTOS/Source/tasks.c **** 		else
 640:FreeRTOS/Source/tasks.c **** 		{
 641:FreeRTOS/Source/tasks.c **** 			xReturn = NULL;
 642:FreeRTOS/Source/tasks.c **** 		}
 643:FreeRTOS/Source/tasks.c **** 
 644:FreeRTOS/Source/tasks.c **** 		return xReturn;
 645:FreeRTOS/Source/tasks.c **** 	}
 646:FreeRTOS/Source/tasks.c **** 
 647:FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 648:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 653:FreeRTOS/Source/tasks.c **** 	{
 654:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 655:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 658:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 659:FreeRTOS/Source/tasks.c **** 
 660:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 661:FreeRTOS/Source/tasks.c **** 		{
 662:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 663:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 664:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 665:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 666:FreeRTOS/Source/tasks.c **** 
 667:FreeRTOS/Source/tasks.c **** 			/* Store the stack location in the TCB. */
 668:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 669:FreeRTOS/Source/tasks.c **** 
 670:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 671:FreeRTOS/Source/tasks.c **** 			{
 672:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 673:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 674:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 675:FreeRTOS/Source/tasks.c **** 			}
 676:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 677:FreeRTOS/Source/tasks.c **** 
 678:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 679:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pcName,
 680:FreeRTOS/Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 681:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 682:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 683:FreeRTOS/Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 684:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->xRegions );
 685:FreeRTOS/Source/tasks.c **** 
 686:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 687:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 688:FreeRTOS/Source/tasks.c **** 		}
 689:FreeRTOS/Source/tasks.c **** 
 690:FreeRTOS/Source/tasks.c **** 		return xReturn;
 691:FreeRTOS/Source/tasks.c **** 	}
 692:FreeRTOS/Source/tasks.c **** 
 693:FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 694:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 695:FreeRTOS/Source/tasks.c **** 
 696:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 697:FreeRTOS/Source/tasks.c **** 
 698:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 699:FreeRTOS/Source/tasks.c **** 	{
 700:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 701:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 702:FreeRTOS/Source/tasks.c **** 
 703:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 704:FreeRTOS/Source/tasks.c **** 
 705:FreeRTOS/Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 706:FreeRTOS/Source/tasks.c **** 		{
 707:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 708:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 709:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 710:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 711:FreeRTOS/Source/tasks.c **** 
 712:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 713:FreeRTOS/Source/tasks.c **** 			{
 714:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
 715:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 716:FreeRTOS/Source/tasks.c **** 
 717:FreeRTOS/Source/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 718:FreeRTOS/Source/tasks.c **** 				{
 719:FreeRTOS/Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 720:FreeRTOS/Source/tasks.c **** 					this task had a statically allocated stack in case it is
 721:FreeRTOS/Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 722:FreeRTOS/Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 723:FreeRTOS/Source/tasks.c **** 				}
 724:FreeRTOS/Source/tasks.c **** 				#endif
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 727:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pcName,
 728:FreeRTOS/Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 729:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 730:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 731:FreeRTOS/Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 732:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->xRegions );
 733:FreeRTOS/Source/tasks.c **** 
 734:FreeRTOS/Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 735:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 736:FreeRTOS/Source/tasks.c **** 			}
 737:FreeRTOS/Source/tasks.c **** 		}
 738:FreeRTOS/Source/tasks.c **** 
 739:FreeRTOS/Source/tasks.c **** 		return xReturn;
 740:FreeRTOS/Source/tasks.c **** 	}
 741:FreeRTOS/Source/tasks.c **** 
 742:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 743:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 746:FreeRTOS/Source/tasks.c **** 
 747:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 748:FreeRTOS/Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 749:FreeRTOS/Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 750:FreeRTOS/Source/tasks.c **** 							void * const pvParameters,
 751:FreeRTOS/Source/tasks.c **** 							UBaseType_t uxPriority,
 752:FreeRTOS/Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 753:FreeRTOS/Source/tasks.c **** 	{
 754:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 755:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 756:FreeRTOS/Source/tasks.c **** 
 757:FreeRTOS/Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 758:FreeRTOS/Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 759:FreeRTOS/Source/tasks.c **** 		the TCB then the stack. */
 760:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 761:FreeRTOS/Source/tasks.c **** 		{
 762:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 763:FreeRTOS/Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 764:FreeRTOS/Source/tasks.c **** 			allocation is being used. */
 765:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 766:FreeRTOS/Source/tasks.c **** 
 767:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 768:FreeRTOS/Source/tasks.c **** 			{
 769:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 770:FreeRTOS/Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 771:FreeRTOS/Source/tasks.c **** 				be deleted later if required. */
 772:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 775:FreeRTOS/Source/tasks.c **** 				{
 776:FreeRTOS/Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 777:FreeRTOS/Source/tasks.c **** 					vPortFree( pxNewTCB );
 778:FreeRTOS/Source/tasks.c **** 					pxNewTCB = NULL;
 779:FreeRTOS/Source/tasks.c **** 				}
 780:FreeRTOS/Source/tasks.c **** 			}
 781:FreeRTOS/Source/tasks.c **** 		}
 782:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 783:FreeRTOS/Source/tasks.c **** 		{
 784:FreeRTOS/Source/tasks.c **** 		StackType_t *pxStack;
 785:FreeRTOS/Source/tasks.c **** 
 786:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 787:FreeRTOS/Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 788:FreeRTOS/Source/tasks.c **** 
 789:FreeRTOS/Source/tasks.c **** 			if( pxStack != NULL )
 790:FreeRTOS/Source/tasks.c **** 			{
 791:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the TCB. */
 792:FreeRTOS/Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB != NULL )
 795:FreeRTOS/Source/tasks.c **** 				{
 796:FreeRTOS/Source/tasks.c **** 					/* Store the stack location in the TCB. */
 797:FreeRTOS/Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 798:FreeRTOS/Source/tasks.c **** 				}
 799:FreeRTOS/Source/tasks.c **** 				else
 800:FreeRTOS/Source/tasks.c **** 				{
 801:FreeRTOS/Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 802:FreeRTOS/Source/tasks.c **** 					it again. */
 803:FreeRTOS/Source/tasks.c **** 					vPortFree( pxStack );
 804:FreeRTOS/Source/tasks.c **** 				}
 805:FreeRTOS/Source/tasks.c **** 			}
 806:FreeRTOS/Source/tasks.c **** 			else
 807:FreeRTOS/Source/tasks.c **** 			{
 808:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
 809:FreeRTOS/Source/tasks.c **** 			}
 810:FreeRTOS/Source/tasks.c **** 		}
 811:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 812:FreeRTOS/Source/tasks.c **** 
 813:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
 814:FreeRTOS/Source/tasks.c **** 		{
 815:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 816:FreeRTOS/Source/tasks.c **** 			{
 817:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 818:FreeRTOS/Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 819:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 820:FreeRTOS/Source/tasks.c **** 			}
 821:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 824:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 825:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 826:FreeRTOS/Source/tasks.c **** 		}
 827:FreeRTOS/Source/tasks.c **** 		else
 828:FreeRTOS/Source/tasks.c **** 		{
 829:FreeRTOS/Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 830:FreeRTOS/Source/tasks.c **** 		}
 831:FreeRTOS/Source/tasks.c **** 
 832:FreeRTOS/Source/tasks.c **** 		return xReturn;
 833:FreeRTOS/Source/tasks.c **** 	}
 834:FreeRTOS/Source/tasks.c **** 
 835:FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 836:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 837:FreeRTOS/Source/tasks.c **** 
 838:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 839:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 840:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 841:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 842:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 843:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 844:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 845:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 846:FreeRTOS/Source/tasks.c **** {
 847:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 848:FreeRTOS/Source/tasks.c **** UBaseType_t x;
 849:FreeRTOS/Source/tasks.c **** 
 850:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 851:FreeRTOS/Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 852:FreeRTOS/Source/tasks.c **** 		BaseType_t xRunPrivileged;
 853:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 854:FreeRTOS/Source/tasks.c **** 		{
 855:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 856:FreeRTOS/Source/tasks.c **** 		}
 857:FreeRTOS/Source/tasks.c **** 		else
 858:FreeRTOS/Source/tasks.c **** 		{
 859:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 860:FreeRTOS/Source/tasks.c **** 		}
 861:FreeRTOS/Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 862:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 863:FreeRTOS/Source/tasks.c **** 
 864:FreeRTOS/Source/tasks.c **** 	configASSERT( pcName );
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 867:FreeRTOS/Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 868:FreeRTOS/Source/tasks.c **** 	{
 869:FreeRTOS/Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 870:FreeRTOS/Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 871:FreeRTOS/Source/tasks.c **** 	}
 872:FreeRTOS/Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 873:FreeRTOS/Source/tasks.c **** 
 874:FreeRTOS/Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 875:FreeRTOS/Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 876:FreeRTOS/Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 877:FreeRTOS/Source/tasks.c **** 	by the port. */
 878:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 879:FreeRTOS/Source/tasks.c **** 	{
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 881:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 882:FreeRTOS/Source/tasks.c **** 
 883:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 884:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 885:FreeRTOS/Source/tasks.c **** 
 886:FreeRTOS/Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 887:FreeRTOS/Source/tasks.c **** 		{
 888:FreeRTOS/Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 889:FreeRTOS/Source/tasks.c **** 			debugging. */
 890:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 891:FreeRTOS/Source/tasks.c **** 		}
 892:FreeRTOS/Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 893:FreeRTOS/Source/tasks.c **** 	}
 894:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 895:FreeRTOS/Source/tasks.c **** 	{
 896:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 897:FreeRTOS/Source/tasks.c **** 
 898:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 899:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 900:FreeRTOS/Source/tasks.c **** 
 901:FreeRTOS/Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 902:FreeRTOS/Source/tasks.c **** 		performed. */
 903:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 904:FreeRTOS/Source/tasks.c **** 	}
 905:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 906:FreeRTOS/Source/tasks.c **** 
 907:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
 908:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 909:FreeRTOS/Source/tasks.c **** 	{
 910:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 911:FreeRTOS/Source/tasks.c **** 
 912:FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 913:FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 914:FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 915:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == ( char ) 0x00 )
 916:FreeRTOS/Source/tasks.c **** 		{
 917:FreeRTOS/Source/tasks.c **** 			break;
 918:FreeRTOS/Source/tasks.c **** 		}
 919:FreeRTOS/Source/tasks.c **** 		else
 920:FreeRTOS/Source/tasks.c **** 		{
 921:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 922:FreeRTOS/Source/tasks.c **** 		}
 923:FreeRTOS/Source/tasks.c **** 	}
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 926:FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 927:FreeRTOS/Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 928:FreeRTOS/Source/tasks.c **** 
 929:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 930:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
 931:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 932:FreeRTOS/Source/tasks.c **** 	{
 933:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 934:FreeRTOS/Source/tasks.c **** 	}
 935:FreeRTOS/Source/tasks.c **** 	else
 936:FreeRTOS/Source/tasks.c **** 	{
 937:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 938:FreeRTOS/Source/tasks.c **** 	}
 939:FreeRTOS/Source/tasks.c **** 
 940:FreeRTOS/Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 941:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 942:FreeRTOS/Source/tasks.c **** 	{
 943:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 944:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 945:FreeRTOS/Source/tasks.c **** 	}
 946:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 949:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 950:FreeRTOS/Source/tasks.c **** 
 951:FreeRTOS/Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 952:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 953:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 954:FreeRTOS/Source/tasks.c **** 
 955:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
 956:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 957:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 958:FreeRTOS/Source/tasks.c **** 
 959:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 960:FreeRTOS/Source/tasks.c **** 	{
 961:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 962:FreeRTOS/Source/tasks.c **** 	}
 963:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 964:FreeRTOS/Source/tasks.c **** 
 965:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 966:FreeRTOS/Source/tasks.c **** 	{
 967:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 968:FreeRTOS/Source/tasks.c **** 	}
 969:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 970:FreeRTOS/Source/tasks.c **** 
 971:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 972:FreeRTOS/Source/tasks.c **** 	{
 973:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 974:FreeRTOS/Source/tasks.c **** 	}
 975:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 976:FreeRTOS/Source/tasks.c **** 
 977:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 978:FreeRTOS/Source/tasks.c **** 	{
 979:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 980:FreeRTOS/Source/tasks.c **** 	}
 981:FreeRTOS/Source/tasks.c **** 	#else
 982:FreeRTOS/Source/tasks.c **** 	{
 983:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 984:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
 985:FreeRTOS/Source/tasks.c **** 	}
 986:FreeRTOS/Source/tasks.c **** 	#endif
 987:FreeRTOS/Source/tasks.c **** 
 988:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 989:FreeRTOS/Source/tasks.c **** 	{
 990:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 991:FreeRTOS/Source/tasks.c **** 		{
 992:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 993:FreeRTOS/Source/tasks.c **** 		}
 994:FreeRTOS/Source/tasks.c **** 	}
 995:FreeRTOS/Source/tasks.c **** 	#endif
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 998:FreeRTOS/Source/tasks.c **** 	{
 999:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
1000:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1001:FreeRTOS/Source/tasks.c **** 	}
1002:FreeRTOS/Source/tasks.c **** 	#endif
1003:FreeRTOS/Source/tasks.c **** 
1004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
1005:FreeRTOS/Source/tasks.c **** 	{
1006:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
1007:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1008:FreeRTOS/Source/tasks.c **** 	}
1009:FreeRTOS/Source/tasks.c **** 	#endif
1010:FreeRTOS/Source/tasks.c **** 
1011:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1012:FreeRTOS/Source/tasks.c **** 	{
1013:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1014:FreeRTOS/Source/tasks.c **** 	}
1015:FreeRTOS/Source/tasks.c **** 	#endif
1016:FreeRTOS/Source/tasks.c **** 
1017:FreeRTOS/Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1018:FreeRTOS/Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1019:FreeRTOS/Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1020:FreeRTOS/Source/tasks.c **** 	the top of stack variable is updated. */
1021:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1022:FreeRTOS/Source/tasks.c **** 	{
1023:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1024:FreeRTOS/Source/tasks.c **** 	}
1025:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1026:FreeRTOS/Source/tasks.c **** 	{
1027:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1028:FreeRTOS/Source/tasks.c **** 	}
1029:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1030:FreeRTOS/Source/tasks.c **** 
1031:FreeRTOS/Source/tasks.c **** 	if( pxCreatedTask != NULL )
1032:FreeRTOS/Source/tasks.c **** 	{
1033:FreeRTOS/Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1034:FreeRTOS/Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1035:FreeRTOS/Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1036:FreeRTOS/Source/tasks.c **** 	}
1037:FreeRTOS/Source/tasks.c **** 	else
1038:FreeRTOS/Source/tasks.c **** 	{
1039:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1040:FreeRTOS/Source/tasks.c **** 	}
1041:FreeRTOS/Source/tasks.c **** }
1042:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1043:FreeRTOS/Source/tasks.c **** 
1044:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1045:FreeRTOS/Source/tasks.c **** {
1046:FreeRTOS/Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1047:FreeRTOS/Source/tasks.c **** 	updated. */
1048:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1049:FreeRTOS/Source/tasks.c **** 	{
1050:FreeRTOS/Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1051:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1052:FreeRTOS/Source/tasks.c **** 		{
1053:FreeRTOS/Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1054:FreeRTOS/Source/tasks.c **** 			the suspended state - make this the current task. */
1055:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1056:FreeRTOS/Source/tasks.c **** 
1057:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1058:FreeRTOS/Source/tasks.c **** 			{
1059:FreeRTOS/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1060:FreeRTOS/Source/tasks.c **** 				initialisation required.  We will not recover if this call
1061:FreeRTOS/Source/tasks.c **** 				fails, but we will report the failure. */
1062:FreeRTOS/Source/tasks.c **** 				prvInitialiseTaskLists();
1063:FreeRTOS/Source/tasks.c **** 			}
1064:FreeRTOS/Source/tasks.c **** 			else
1065:FreeRTOS/Source/tasks.c **** 			{
1066:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1067:FreeRTOS/Source/tasks.c **** 			}
1068:FreeRTOS/Source/tasks.c **** 		}
1069:FreeRTOS/Source/tasks.c **** 		else
1070:FreeRTOS/Source/tasks.c **** 		{
1071:FreeRTOS/Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1072:FreeRTOS/Source/tasks.c **** 			current task if it is the highest priority task to be created
1073:FreeRTOS/Source/tasks.c **** 			so far. */
1074:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1075:FreeRTOS/Source/tasks.c **** 			{
1076:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1077:FreeRTOS/Source/tasks.c **** 				{
1078:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1079:FreeRTOS/Source/tasks.c **** 				}
1080:FreeRTOS/Source/tasks.c **** 				else
1081:FreeRTOS/Source/tasks.c **** 				{
1082:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1083:FreeRTOS/Source/tasks.c **** 				}
1084:FreeRTOS/Source/tasks.c **** 			}
1085:FreeRTOS/Source/tasks.c **** 			else
1086:FreeRTOS/Source/tasks.c **** 			{
1087:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1088:FreeRTOS/Source/tasks.c **** 			}
1089:FreeRTOS/Source/tasks.c **** 		}
1090:FreeRTOS/Source/tasks.c **** 
1091:FreeRTOS/Source/tasks.c **** 		uxTaskNumber++;
1092:FreeRTOS/Source/tasks.c **** 
1093:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1094:FreeRTOS/Source/tasks.c **** 		{
1095:FreeRTOS/Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1096:FreeRTOS/Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1097:FreeRTOS/Source/tasks.c **** 		}
1098:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1099:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1100:FreeRTOS/Source/tasks.c **** 
1101:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1102:FreeRTOS/Source/tasks.c **** 
1103:FreeRTOS/Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1104:FreeRTOS/Source/tasks.c **** 	}
1105:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1106:FreeRTOS/Source/tasks.c **** 
1107:FreeRTOS/Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1108:FreeRTOS/Source/tasks.c **** 	{
1109:FreeRTOS/Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1110:FreeRTOS/Source/tasks.c **** 		then it should run now. */
1111:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1112:FreeRTOS/Source/tasks.c **** 		{
1113:FreeRTOS/Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1114:FreeRTOS/Source/tasks.c **** 		}
1115:FreeRTOS/Source/tasks.c **** 		else
1116:FreeRTOS/Source/tasks.c **** 		{
1117:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1118:FreeRTOS/Source/tasks.c **** 		}
1119:FreeRTOS/Source/tasks.c **** 	}
1120:FreeRTOS/Source/tasks.c **** 	else
1121:FreeRTOS/Source/tasks.c **** 	{
1122:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1123:FreeRTOS/Source/tasks.c **** 	}
1124:FreeRTOS/Source/tasks.c **** }
1125:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1128:FreeRTOS/Source/tasks.c **** 
1129:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1130:FreeRTOS/Source/tasks.c **** 	{
1131:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1132:FreeRTOS/Source/tasks.c **** 
1133:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1134:FreeRTOS/Source/tasks.c **** 		{
1135:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1136:FreeRTOS/Source/tasks.c **** 			being deleted. */
1137:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1138:FreeRTOS/Source/tasks.c **** 
1139:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list. */
1140:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1141:FreeRTOS/Source/tasks.c **** 			{
1142:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1143:FreeRTOS/Source/tasks.c **** 			}
1144:FreeRTOS/Source/tasks.c **** 			else
1145:FreeRTOS/Source/tasks.c **** 			{
1146:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1147:FreeRTOS/Source/tasks.c **** 			}
1148:FreeRTOS/Source/tasks.c **** 
1149:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1150:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1151:FreeRTOS/Source/tasks.c **** 			{
1152:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1153:FreeRTOS/Source/tasks.c **** 			}
1154:FreeRTOS/Source/tasks.c **** 			else
1155:FreeRTOS/Source/tasks.c **** 			{
1156:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1157:FreeRTOS/Source/tasks.c **** 			}
1158:FreeRTOS/Source/tasks.c **** 
1159:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1160:FreeRTOS/Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1161:FreeRTOS/Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1162:FreeRTOS/Source/tasks.c **** 			not return. */
1163:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
1164:FreeRTOS/Source/tasks.c **** 
1165:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1166:FreeRTOS/Source/tasks.c **** 			{
1167:FreeRTOS/Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1168:FreeRTOS/Source/tasks.c **** 				task itself, as a context switch to another task is required.
1169:FreeRTOS/Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1170:FreeRTOS/Source/tasks.c **** 				check the termination list and free up any memory allocated by
1171:FreeRTOS/Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1172:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1173:FreeRTOS/Source/tasks.c **** 
1174:FreeRTOS/Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1175:FreeRTOS/Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1176:FreeRTOS/Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1177:FreeRTOS/Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1178:FreeRTOS/Source/tasks.c **** 
1179:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1180:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1181:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
1182:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1183:FreeRTOS/Source/tasks.c **** 				required. */
1184:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1185:FreeRTOS/Source/tasks.c **** 			}
1186:FreeRTOS/Source/tasks.c **** 			else
1187:FreeRTOS/Source/tasks.c **** 			{
1188:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1189:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1190:FreeRTOS/Source/tasks.c **** 
1191:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1192:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
1193:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1194:FreeRTOS/Source/tasks.c **** 			}
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
1197:FreeRTOS/Source/tasks.c **** 		}
1198:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1199:FreeRTOS/Source/tasks.c **** 
1200:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1201:FreeRTOS/Source/tasks.c **** 		been deleted. */
1202:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1203:FreeRTOS/Source/tasks.c **** 		{
1204:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1205:FreeRTOS/Source/tasks.c **** 			{
1206:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1207:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1208:FreeRTOS/Source/tasks.c **** 			}
1209:FreeRTOS/Source/tasks.c **** 			else
1210:FreeRTOS/Source/tasks.c **** 			{
1211:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1212:FreeRTOS/Source/tasks.c **** 			}
1213:FreeRTOS/Source/tasks.c **** 		}
1214:FreeRTOS/Source/tasks.c **** 	}
1215:FreeRTOS/Source/tasks.c **** 
1216:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1217:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1218:FreeRTOS/Source/tasks.c **** 
1219:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1220:FreeRTOS/Source/tasks.c **** 
1221:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1222:FreeRTOS/Source/tasks.c **** 	{
1223:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
1224:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1225:FreeRTOS/Source/tasks.c **** 
1226:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1227:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1228:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1229:FreeRTOS/Source/tasks.c **** 
1230:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1231:FreeRTOS/Source/tasks.c **** 		{
1232:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1233:FreeRTOS/Source/tasks.c **** 			block. */
1234:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1235:FreeRTOS/Source/tasks.c **** 
1236:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1237:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1238:FreeRTOS/Source/tasks.c **** 
1239:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1240:FreeRTOS/Source/tasks.c **** 			{
1241:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
1242:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1243:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1244:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1245:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1246:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1247:FreeRTOS/Source/tasks.c **** 				{
1248:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1249:FreeRTOS/Source/tasks.c **** 				}
1250:FreeRTOS/Source/tasks.c **** 				else
1251:FreeRTOS/Source/tasks.c **** 				{
1252:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1253:FreeRTOS/Source/tasks.c **** 				}
1254:FreeRTOS/Source/tasks.c **** 			}
1255:FreeRTOS/Source/tasks.c **** 			else
1256:FreeRTOS/Source/tasks.c **** 			{
1257:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1258:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1259:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
1260:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1261:FreeRTOS/Source/tasks.c **** 				{
1262:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1263:FreeRTOS/Source/tasks.c **** 				}
1264:FreeRTOS/Source/tasks.c **** 				else
1265:FreeRTOS/Source/tasks.c **** 				{
1266:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1267:FreeRTOS/Source/tasks.c **** 				}
1268:FreeRTOS/Source/tasks.c **** 			}
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1271:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1272:FreeRTOS/Source/tasks.c **** 
1273:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1274:FreeRTOS/Source/tasks.c **** 			{
1275:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1276:FreeRTOS/Source/tasks.c **** 
1277:FreeRTOS/Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1278:FreeRTOS/Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1279:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1280:FreeRTOS/Source/tasks.c **** 			}
1281:FreeRTOS/Source/tasks.c **** 			else
1282:FreeRTOS/Source/tasks.c **** 			{
1283:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1284:FreeRTOS/Source/tasks.c **** 			}
1285:FreeRTOS/Source/tasks.c **** 		}
1286:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1287:FreeRTOS/Source/tasks.c **** 
1288:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1289:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1290:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1291:FreeRTOS/Source/tasks.c **** 		{
1292:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1293:FreeRTOS/Source/tasks.c **** 		}
1294:FreeRTOS/Source/tasks.c **** 		else
1295:FreeRTOS/Source/tasks.c **** 		{
1296:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1297:FreeRTOS/Source/tasks.c **** 		}
1298:FreeRTOS/Source/tasks.c **** 	}
1299:FreeRTOS/Source/tasks.c **** 
1300:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1301:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1302:FreeRTOS/Source/tasks.c **** 
1303:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1304:FreeRTOS/Source/tasks.c **** 
1305:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1306:FreeRTOS/Source/tasks.c **** 	{
1307:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1308:FreeRTOS/Source/tasks.c **** 
1309:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1310:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1311:FreeRTOS/Source/tasks.c **** 		{
1312:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1313:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
1314:FreeRTOS/Source/tasks.c **** 			{
1315:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
1316:FreeRTOS/Source/tasks.c **** 
1317:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
1318:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1319:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1320:FreeRTOS/Source/tasks.c **** 				is resumed.
1321:FreeRTOS/Source/tasks.c **** 
1322:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1323:FreeRTOS/Source/tasks.c **** 				executing task. */
1324:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1325:FreeRTOS/Source/tasks.c **** 			}
1326:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1327:FreeRTOS/Source/tasks.c **** 		}
1328:FreeRTOS/Source/tasks.c **** 		else
1329:FreeRTOS/Source/tasks.c **** 		{
1330:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1331:FreeRTOS/Source/tasks.c **** 		}
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1335:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1336:FreeRTOS/Source/tasks.c **** 		{
1337:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1338:FreeRTOS/Source/tasks.c **** 		}
1339:FreeRTOS/Source/tasks.c **** 		else
1340:FreeRTOS/Source/tasks.c **** 		{
1341:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1342:FreeRTOS/Source/tasks.c **** 		}
1343:FreeRTOS/Source/tasks.c **** 	}
1344:FreeRTOS/Source/tasks.c **** 
1345:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1346:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1347:FreeRTOS/Source/tasks.c **** 
1348:FreeRTOS/Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1349:FreeRTOS/Source/tasks.c **** 
1350:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1351:FreeRTOS/Source/tasks.c **** 	{
1352:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
1353:FreeRTOS/Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1354:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1355:FreeRTOS/Source/tasks.c **** 
1356:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1359:FreeRTOS/Source/tasks.c **** 		{
1360:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1361:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1362:FreeRTOS/Source/tasks.c **** 		}
1363:FreeRTOS/Source/tasks.c **** 		else
1364:FreeRTOS/Source/tasks.c **** 		{
1365:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1366:FreeRTOS/Source/tasks.c **** 			{
1367:FreeRTOS/Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1368:FreeRTOS/Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1369:FreeRTOS/Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1370:FreeRTOS/Source/tasks.c **** 			}
1371:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1374:FreeRTOS/Source/tasks.c **** 			{
1375:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1376:FreeRTOS/Source/tasks.c **** 				lists. */
1377:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1378:FreeRTOS/Source/tasks.c **** 			}
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1381:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1382:FreeRTOS/Source/tasks.c **** 				{
1383:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1384:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1385:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1386:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1387:FreeRTOS/Source/tasks.c **** 					{
1388:FreeRTOS/Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1389:FreeRTOS/Source/tasks.c **** 						{
1390:FreeRTOS/Source/tasks.c **** 							/* The task does not appear on the event list item of
1391:FreeRTOS/Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1392:FreeRTOS/Source/tasks.c **** 							blocked state if it is waiting on its notification
1393:FreeRTOS/Source/tasks.c **** 							rather than waiting on an object. */
1394:FreeRTOS/Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1395:FreeRTOS/Source/tasks.c **** 							{
1396:FreeRTOS/Source/tasks.c **** 								eReturn = eBlocked;
1397:FreeRTOS/Source/tasks.c **** 							}
1398:FreeRTOS/Source/tasks.c **** 							else
1399:FreeRTOS/Source/tasks.c **** 							{
1400:FreeRTOS/Source/tasks.c **** 								eReturn = eSuspended;
1401:FreeRTOS/Source/tasks.c **** 							}
1402:FreeRTOS/Source/tasks.c **** 						}
1403:FreeRTOS/Source/tasks.c **** 						#else
1404:FreeRTOS/Source/tasks.c **** 						{
1405:FreeRTOS/Source/tasks.c **** 							eReturn = eSuspended;
1406:FreeRTOS/Source/tasks.c **** 						}
1407:FreeRTOS/Source/tasks.c **** 						#endif
1408:FreeRTOS/Source/tasks.c **** 					}
1409:FreeRTOS/Source/tasks.c **** 					else
1410:FreeRTOS/Source/tasks.c **** 					{
1411:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1412:FreeRTOS/Source/tasks.c **** 					}
1413:FreeRTOS/Source/tasks.c **** 				}
1414:FreeRTOS/Source/tasks.c **** 			#endif
1415:FreeRTOS/Source/tasks.c **** 
1416:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1417:FreeRTOS/Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1418:FreeRTOS/Source/tasks.c **** 				{
1419:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1420:FreeRTOS/Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1421:FreeRTOS/Source/tasks.c **** 					all. */
1422:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1423:FreeRTOS/Source/tasks.c **** 				}
1424:FreeRTOS/Source/tasks.c **** 			#endif
1425:FreeRTOS/Source/tasks.c **** 
1426:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1427:FreeRTOS/Source/tasks.c **** 			{
1428:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1429:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1430:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1431:FreeRTOS/Source/tasks.c **** 			}
1432:FreeRTOS/Source/tasks.c **** 		}
1433:FreeRTOS/Source/tasks.c **** 
1434:FreeRTOS/Source/tasks.c **** 		return eReturn;
1435:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1436:FreeRTOS/Source/tasks.c **** 
1437:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1438:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1439:FreeRTOS/Source/tasks.c **** 
1440:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1441:FreeRTOS/Source/tasks.c **** 
1442:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1443:FreeRTOS/Source/tasks.c **** 	{
1444:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1445:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1446:FreeRTOS/Source/tasks.c **** 
1447:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1448:FreeRTOS/Source/tasks.c **** 		{
1449:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1450:FreeRTOS/Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1451:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1452:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1453:FreeRTOS/Source/tasks.c **** 		}
1454:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1455:FreeRTOS/Source/tasks.c **** 
1456:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1457:FreeRTOS/Source/tasks.c **** 	}
1458:FreeRTOS/Source/tasks.c **** 
1459:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1460:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1461:FreeRTOS/Source/tasks.c **** 
1462:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1463:FreeRTOS/Source/tasks.c **** 
1464:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1465:FreeRTOS/Source/tasks.c **** 	{
1466:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1467:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1468:FreeRTOS/Source/tasks.c **** 
1469:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1470:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1471:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1472:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1473:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1474:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1475:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1476:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1477:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1478:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1479:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1480:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1481:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1482:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1483:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1484:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1485:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1486:FreeRTOS/Source/tasks.c **** 
1487:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1488:FreeRTOS/Source/tasks.c **** 		{
1489:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1490:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1491:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1492:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1493:FreeRTOS/Source/tasks.c **** 		}
1494:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1495:FreeRTOS/Source/tasks.c **** 
1496:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1497:FreeRTOS/Source/tasks.c **** 	}
1498:FreeRTOS/Source/tasks.c **** 
1499:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1500:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1501:FreeRTOS/Source/tasks.c **** 
1502:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1503:FreeRTOS/Source/tasks.c **** 
1504:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1505:FreeRTOS/Source/tasks.c **** 	{
1506:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1507:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1508:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1509:FreeRTOS/Source/tasks.c **** 
1510:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1511:FreeRTOS/Source/tasks.c **** 
1512:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1513:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1516:FreeRTOS/Source/tasks.c **** 		}
1517:FreeRTOS/Source/tasks.c **** 		else
1518:FreeRTOS/Source/tasks.c **** 		{
1519:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1520:FreeRTOS/Source/tasks.c **** 		}
1521:FreeRTOS/Source/tasks.c **** 
1522:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1523:FreeRTOS/Source/tasks.c **** 		{
1524:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1525:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1526:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1527:FreeRTOS/Source/tasks.c **** 
1528:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1529:FreeRTOS/Source/tasks.c **** 
1530:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1531:FreeRTOS/Source/tasks.c **** 			{
1532:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1533:FreeRTOS/Source/tasks.c **** 			}
1534:FreeRTOS/Source/tasks.c **** 			#else
1535:FreeRTOS/Source/tasks.c **** 			{
1536:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1537:FreeRTOS/Source/tasks.c **** 			}
1538:FreeRTOS/Source/tasks.c **** 			#endif
1539:FreeRTOS/Source/tasks.c **** 
1540:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1541:FreeRTOS/Source/tasks.c **** 			{
1542:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1543:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1544:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1545:FreeRTOS/Source/tasks.c **** 				{
1546:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1547:FreeRTOS/Source/tasks.c **** 					{
1548:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1549:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1550:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1551:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1552:FreeRTOS/Source/tasks.c **** 						{
1553:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1554:FreeRTOS/Source/tasks.c **** 						}
1555:FreeRTOS/Source/tasks.c **** 						else
1556:FreeRTOS/Source/tasks.c **** 						{
1557:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1558:FreeRTOS/Source/tasks.c **** 						}
1559:FreeRTOS/Source/tasks.c **** 					}
1560:FreeRTOS/Source/tasks.c **** 					else
1561:FreeRTOS/Source/tasks.c **** 					{
1562:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1563:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1564:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1565:FreeRTOS/Source/tasks.c **** 					}
1566:FreeRTOS/Source/tasks.c **** 				}
1567:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1568:FreeRTOS/Source/tasks.c **** 				{
1569:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1570:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1571:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1572:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1573:FreeRTOS/Source/tasks.c **** 				}
1574:FreeRTOS/Source/tasks.c **** 				else
1575:FreeRTOS/Source/tasks.c **** 				{
1576:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1577:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1578:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1579:FreeRTOS/Source/tasks.c **** 				}
1580:FreeRTOS/Source/tasks.c **** 
1581:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1582:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1583:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1584:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1585:FreeRTOS/Source/tasks.c **** 
1586:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1587:FreeRTOS/Source/tasks.c **** 				{
1588:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1589:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1590:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1591:FreeRTOS/Source/tasks.c **** 					{
1592:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1593:FreeRTOS/Source/tasks.c **** 					}
1594:FreeRTOS/Source/tasks.c **** 					else
1595:FreeRTOS/Source/tasks.c **** 					{
1596:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1597:FreeRTOS/Source/tasks.c **** 					}
1598:FreeRTOS/Source/tasks.c **** 
1599:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1600:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1601:FreeRTOS/Source/tasks.c **** 				}
1602:FreeRTOS/Source/tasks.c **** 				#else
1603:FreeRTOS/Source/tasks.c **** 				{
1604:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1605:FreeRTOS/Source/tasks.c **** 				}
1606:FreeRTOS/Source/tasks.c **** 				#endif
1607:FreeRTOS/Source/tasks.c **** 
1608:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1609:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1610:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1611:FreeRTOS/Source/tasks.c **** 				{
1612:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1613:FreeRTOS/Source/tasks.c **** 				}
1614:FreeRTOS/Source/tasks.c **** 				else
1615:FreeRTOS/Source/tasks.c **** 				{
1616:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1617:FreeRTOS/Source/tasks.c **** 				}
1618:FreeRTOS/Source/tasks.c **** 
1619:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1620:FreeRTOS/Source/tasks.c **** 				nothing more than change its priority variable. However, if
1621:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1622:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1623:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1624:FreeRTOS/Source/tasks.c **** 				{
1625:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1626:FreeRTOS/Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1627:FreeRTOS/Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1628:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1629:FreeRTOS/Source/tasks.c **** 					{
1630:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1631:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1632:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1633:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1634:FreeRTOS/Source/tasks.c **** 					}
1635:FreeRTOS/Source/tasks.c **** 					else
1636:FreeRTOS/Source/tasks.c **** 					{
1637:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1638:FreeRTOS/Source/tasks.c **** 					}
1639:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1640:FreeRTOS/Source/tasks.c **** 				}
1641:FreeRTOS/Source/tasks.c **** 				else
1642:FreeRTOS/Source/tasks.c **** 				{
1643:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1644:FreeRTOS/Source/tasks.c **** 				}
1645:FreeRTOS/Source/tasks.c **** 
1646:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1647:FreeRTOS/Source/tasks.c **** 				{
1648:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1649:FreeRTOS/Source/tasks.c **** 				}
1650:FreeRTOS/Source/tasks.c **** 				else
1651:FreeRTOS/Source/tasks.c **** 				{
1652:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:FreeRTOS/Source/tasks.c **** 				}
1654:FreeRTOS/Source/tasks.c **** 
1655:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1656:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1657:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1658:FreeRTOS/Source/tasks.c **** 			}
1659:FreeRTOS/Source/tasks.c **** 		}
1660:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1661:FreeRTOS/Source/tasks.c **** 	}
1662:FreeRTOS/Source/tasks.c **** 
1663:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1664:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1665:FreeRTOS/Source/tasks.c **** 
1666:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1667:FreeRTOS/Source/tasks.c **** 
1668:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1669:FreeRTOS/Source/tasks.c **** 	{
1670:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1671:FreeRTOS/Source/tasks.c **** 
1672:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1673:FreeRTOS/Source/tasks.c **** 		{
1674:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1675:FreeRTOS/Source/tasks.c **** 			being suspended. */
1676:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1677:FreeRTOS/Source/tasks.c **** 
1678:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1679:FreeRTOS/Source/tasks.c **** 
1680:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1681:FreeRTOS/Source/tasks.c **** 			suspended list. */
1682:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1683:FreeRTOS/Source/tasks.c **** 			{
1684:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1685:FreeRTOS/Source/tasks.c **** 			}
1686:FreeRTOS/Source/tasks.c **** 			else
1687:FreeRTOS/Source/tasks.c **** 			{
1688:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1689:FreeRTOS/Source/tasks.c **** 			}
1690:FreeRTOS/Source/tasks.c **** 
1691:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1692:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1693:FreeRTOS/Source/tasks.c **** 			{
1694:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1695:FreeRTOS/Source/tasks.c **** 			}
1696:FreeRTOS/Source/tasks.c **** 			else
1697:FreeRTOS/Source/tasks.c **** 			{
1698:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1699:FreeRTOS/Source/tasks.c **** 			}
1700:FreeRTOS/Source/tasks.c **** 
1701:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1702:FreeRTOS/Source/tasks.c **** 
1703:FreeRTOS/Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1704:FreeRTOS/Source/tasks.c **** 			{
1705:FreeRTOS/Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1706:FreeRTOS/Source/tasks.c **** 				{
1707:FreeRTOS/Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1708:FreeRTOS/Source/tasks.c **** 					now suspended, so no notification was received. */
1709:FreeRTOS/Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1710:FreeRTOS/Source/tasks.c **** 				}
1711:FreeRTOS/Source/tasks.c **** 			}
1712:FreeRTOS/Source/tasks.c **** 			#endif
1713:FreeRTOS/Source/tasks.c **** 		}
1714:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1715:FreeRTOS/Source/tasks.c **** 
1716:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1717:FreeRTOS/Source/tasks.c **** 		{
1718:FreeRTOS/Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1719:FreeRTOS/Source/tasks.c **** 			task that is now in the Suspended state. */
1720:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1721:FreeRTOS/Source/tasks.c **** 			{
1722:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1723:FreeRTOS/Source/tasks.c **** 			}
1724:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1725:FreeRTOS/Source/tasks.c **** 		}
1726:FreeRTOS/Source/tasks.c **** 		else
1727:FreeRTOS/Source/tasks.c **** 		{
1728:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1729:FreeRTOS/Source/tasks.c **** 		}
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1732:FreeRTOS/Source/tasks.c **** 		{
1733:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1734:FreeRTOS/Source/tasks.c **** 			{
1735:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1736:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1737:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1738:FreeRTOS/Source/tasks.c **** 			}
1739:FreeRTOS/Source/tasks.c **** 			else
1740:FreeRTOS/Source/tasks.c **** 			{
1741:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1742:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1743:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1744:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1745:FreeRTOS/Source/tasks.c **** 				{
1746:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1747:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1748:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1749:FreeRTOS/Source/tasks.c **** 					is. */
1750:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1751:FreeRTOS/Source/tasks.c **** 				}
1752:FreeRTOS/Source/tasks.c **** 				else
1753:FreeRTOS/Source/tasks.c **** 				{
1754:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1755:FreeRTOS/Source/tasks.c **** 				}
1756:FreeRTOS/Source/tasks.c **** 			}
1757:FreeRTOS/Source/tasks.c **** 		}
1758:FreeRTOS/Source/tasks.c **** 		else
1759:FreeRTOS/Source/tasks.c **** 		{
1760:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1761:FreeRTOS/Source/tasks.c **** 		}
1762:FreeRTOS/Source/tasks.c **** 	}
1763:FreeRTOS/Source/tasks.c **** 
1764:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1765:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1768:FreeRTOS/Source/tasks.c **** 
1769:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1770:FreeRTOS/Source/tasks.c **** 	{
1771:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1772:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1773:FreeRTOS/Source/tasks.c **** 
1774:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1775:FreeRTOS/Source/tasks.c **** 		section. */
1776:FreeRTOS/Source/tasks.c **** 
1777:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1778:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1779:FreeRTOS/Source/tasks.c **** 
1780:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1781:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1782:FreeRTOS/Source/tasks.c **** 		{
1783:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1784:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1785:FreeRTOS/Source/tasks.c **** 			{
1786:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1787:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1788:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1789:FreeRTOS/Source/tasks.c **** 				{
1790:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1791:FreeRTOS/Source/tasks.c **** 				}
1792:FreeRTOS/Source/tasks.c **** 				else
1793:FreeRTOS/Source/tasks.c **** 				{
1794:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1795:FreeRTOS/Source/tasks.c **** 				}
1796:FreeRTOS/Source/tasks.c **** 			}
1797:FreeRTOS/Source/tasks.c **** 			else
1798:FreeRTOS/Source/tasks.c **** 			{
1799:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1800:FreeRTOS/Source/tasks.c **** 			}
1801:FreeRTOS/Source/tasks.c **** 		}
1802:FreeRTOS/Source/tasks.c **** 		else
1803:FreeRTOS/Source/tasks.c **** 		{
1804:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1805:FreeRTOS/Source/tasks.c **** 		}
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 		return xReturn;
1808:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1809:FreeRTOS/Source/tasks.c **** 
1810:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1811:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1812:FreeRTOS/Source/tasks.c **** 
1813:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1814:FreeRTOS/Source/tasks.c **** 
1815:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1816:FreeRTOS/Source/tasks.c **** 	{
1817:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1818:FreeRTOS/Source/tasks.c **** 
1819:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1820:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1821:FreeRTOS/Source/tasks.c **** 
1822:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1823:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1824:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1825:FreeRTOS/Source/tasks.c **** 		{
1826:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1827:FreeRTOS/Source/tasks.c **** 			{
1828:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1829:FreeRTOS/Source/tasks.c **** 				{
1830:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1831:FreeRTOS/Source/tasks.c **** 
1832:FreeRTOS/Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1833:FreeRTOS/Source/tasks.c **** 					suspended because this is inside a critical section. */
1834:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1835:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1836:FreeRTOS/Source/tasks.c **** 
1837:FreeRTOS/Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1838:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1839:FreeRTOS/Source/tasks.c **** 					{
1840:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1841:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1842:FreeRTOS/Source/tasks.c **** 						next yield. */
1843:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1844:FreeRTOS/Source/tasks.c **** 					}
1845:FreeRTOS/Source/tasks.c **** 					else
1846:FreeRTOS/Source/tasks.c **** 					{
1847:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Source/tasks.c **** 					}
1849:FreeRTOS/Source/tasks.c **** 				}
1850:FreeRTOS/Source/tasks.c **** 				else
1851:FreeRTOS/Source/tasks.c **** 				{
1852:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/Source/tasks.c **** 				}
1854:FreeRTOS/Source/tasks.c **** 			}
1855:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1856:FreeRTOS/Source/tasks.c **** 		}
1857:FreeRTOS/Source/tasks.c **** 		else
1858:FreeRTOS/Source/tasks.c **** 		{
1859:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1860:FreeRTOS/Source/tasks.c **** 		}
1861:FreeRTOS/Source/tasks.c **** 	}
1862:FreeRTOS/Source/tasks.c **** 
1863:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1866:FreeRTOS/Source/tasks.c **** 
1867:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1868:FreeRTOS/Source/tasks.c **** 
1869:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1870:FreeRTOS/Source/tasks.c **** 	{
1871:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1872:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1873:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1874:FreeRTOS/Source/tasks.c **** 
1875:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1876:FreeRTOS/Source/tasks.c **** 
1877:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1878:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1879:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1880:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1881:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1882:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1883:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1884:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1885:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1886:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1887:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1888:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1889:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1890:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1891:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1892:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1893:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1894:FreeRTOS/Source/tasks.c **** 
1895:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1896:FreeRTOS/Source/tasks.c **** 		{
1897:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1898:FreeRTOS/Source/tasks.c **** 			{
1899:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1902:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1903:FreeRTOS/Source/tasks.c **** 				{
1904:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1905:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1906:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1907:FreeRTOS/Source/tasks.c **** 					{
1908:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1909:FreeRTOS/Source/tasks.c **** 					}
1910:FreeRTOS/Source/tasks.c **** 					else
1911:FreeRTOS/Source/tasks.c **** 					{
1912:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1913:FreeRTOS/Source/tasks.c **** 					}
1914:FreeRTOS/Source/tasks.c **** 
1915:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1916:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1917:FreeRTOS/Source/tasks.c **** 				}
1918:FreeRTOS/Source/tasks.c **** 				else
1919:FreeRTOS/Source/tasks.c **** 				{
1920:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1921:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1922:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1923:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1924:FreeRTOS/Source/tasks.c **** 				}
1925:FreeRTOS/Source/tasks.c **** 			}
1926:FreeRTOS/Source/tasks.c **** 			else
1927:FreeRTOS/Source/tasks.c **** 			{
1928:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1929:FreeRTOS/Source/tasks.c **** 			}
1930:FreeRTOS/Source/tasks.c **** 		}
1931:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1932:FreeRTOS/Source/tasks.c **** 
1933:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1934:FreeRTOS/Source/tasks.c **** 	}
1935:FreeRTOS/Source/tasks.c **** 
1936:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1937:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1938:FreeRTOS/Source/tasks.c **** 
1939:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1940:FreeRTOS/Source/tasks.c **** {
1941:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1942:FreeRTOS/Source/tasks.c **** 
1943:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1944:FreeRTOS/Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1945:FreeRTOS/Source/tasks.c **** 	{
1946:FreeRTOS/Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1947:FreeRTOS/Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1948:FreeRTOS/Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1949:FreeRTOS/Source/tasks.c **** 
1950:FreeRTOS/Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1951:FreeRTOS/Source/tasks.c **** 		address of the RAM then create the idle task. */
1952:FreeRTOS/Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1953:FreeRTOS/Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1954:FreeRTOS/Source/tasks.c **** 												configIDLE_TASK_NAME,
1955:FreeRTOS/Source/tasks.c **** 												ulIdleTaskStackSize,
1956:FreeRTOS/Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1957:FreeRTOS/Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1958:FreeRTOS/Source/tasks.c **** 												pxIdleTaskStackBuffer,
1959:FreeRTOS/Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1960:FreeRTOS/Source/tasks.c **** 
1961:FreeRTOS/Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1962:FreeRTOS/Source/tasks.c **** 		{
1963:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
1964:FreeRTOS/Source/tasks.c **** 		}
1965:FreeRTOS/Source/tasks.c **** 		else
1966:FreeRTOS/Source/tasks.c **** 		{
1967:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 	}
1970:FreeRTOS/Source/tasks.c **** 	#else
1971:FreeRTOS/Source/tasks.c **** 	{
1972:FreeRTOS/Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1973:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1974:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
1975:FreeRTOS/Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
1976:FreeRTOS/Source/tasks.c **** 								( void * ) NULL,
1977:FreeRTOS/Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
1978:FreeRTOS/Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1979:FreeRTOS/Source/tasks.c **** 	}
1980:FreeRTOS/Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1981:FreeRTOS/Source/tasks.c **** 
1982:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1983:FreeRTOS/Source/tasks.c **** 	{
1984:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1985:FreeRTOS/Source/tasks.c **** 		{
1986:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1987:FreeRTOS/Source/tasks.c **** 		}
1988:FreeRTOS/Source/tasks.c **** 		else
1989:FreeRTOS/Source/tasks.c **** 		{
1990:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1991:FreeRTOS/Source/tasks.c **** 		}
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1994:FreeRTOS/Source/tasks.c **** 
1995:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1996:FreeRTOS/Source/tasks.c **** 	{
1997:FreeRTOS/Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1998:FreeRTOS/Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1999:FreeRTOS/Source/tasks.c **** 		the only macro called by the function. */
2000:FreeRTOS/Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2001:FreeRTOS/Source/tasks.c **** 		{
2002:FreeRTOS/Source/tasks.c **** 			freertos_tasks_c_additions_init();
2003:FreeRTOS/Source/tasks.c **** 		}
2004:FreeRTOS/Source/tasks.c **** 		#endif
2005:FreeRTOS/Source/tasks.c **** 
2006:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2007:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2008:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2009:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2010:FreeRTOS/Source/tasks.c **** 		starts to run. */
2011:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2014:FreeRTOS/Source/tasks.c **** 		{
2015:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2016:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
2017:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2018:FreeRTOS/Source/tasks.c **** 		}
2019:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2022:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
2023:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2024:FreeRTOS/Source/tasks.c **** 
2025:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2026:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2027:FreeRTOS/Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2028:FreeRTOS/Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2029:FreeRTOS/Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2030:FreeRTOS/Source/tasks.c **** 		FreeRTOSConfig.h file. */
2031:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2034:FreeRTOS/Source/tasks.c **** 
2035:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2036:FreeRTOS/Source/tasks.c **** 		portable interface. */
2037:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2038:FreeRTOS/Source/tasks.c **** 		{
2039:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2040:FreeRTOS/Source/tasks.c **** 			function will not return. */
2041:FreeRTOS/Source/tasks.c **** 		}
2042:FreeRTOS/Source/tasks.c **** 		else
2043:FreeRTOS/Source/tasks.c **** 		{
2044:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2045:FreeRTOS/Source/tasks.c **** 		}
2046:FreeRTOS/Source/tasks.c **** 	}
2047:FreeRTOS/Source/tasks.c **** 	else
2048:FreeRTOS/Source/tasks.c **** 	{
2049:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2050:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2051:FreeRTOS/Source/tasks.c **** 		or the timer task. */
2052:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2053:FreeRTOS/Source/tasks.c **** 	}
2054:FreeRTOS/Source/tasks.c **** 
2055:FreeRTOS/Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2056:FreeRTOS/Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2057:FreeRTOS/Source/tasks.c **** 	( void ) xIdleTaskHandle;
2058:FreeRTOS/Source/tasks.c **** }
2059:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2060:FreeRTOS/Source/tasks.c **** 
2061:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2062:FreeRTOS/Source/tasks.c **** {
2063:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2064:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2065:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2066:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2067:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2068:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
2069:FreeRTOS/Source/tasks.c **** }
2070:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2071:FreeRTOS/Source/tasks.c **** 
2072:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2073:FreeRTOS/Source/tasks.c **** {
2074:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2075:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2076:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2077:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
2078:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
2079:FreeRTOS/Source/tasks.c **** }
2080:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2081:FreeRTOS/Source/tasks.c **** 
2082:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
2087:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2088:FreeRTOS/Source/tasks.c **** 
2089:FreeRTOS/Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2090:FreeRTOS/Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2091:FreeRTOS/Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2092:FreeRTOS/Source/tasks.c **** 		running. */
2093:FreeRTOS/Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2094:FreeRTOS/Source/tasks.c **** 		{
2095:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2096:FreeRTOS/Source/tasks.c **** 			{
2097:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2098:FreeRTOS/Source/tasks.c **** 			}
2099:FreeRTOS/Source/tasks.c **** 		}
2100:FreeRTOS/Source/tasks.c **** 		#else
2101:FreeRTOS/Source/tasks.c **** 		{
2102:FreeRTOS/Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2103:FreeRTOS/Source/tasks.c **** 
2104:FreeRTOS/Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2105:FreeRTOS/Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2106:FreeRTOS/Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2107:FreeRTOS/Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2108:FreeRTOS/Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2109:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2110:FreeRTOS/Source/tasks.c **** 			{
2111:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2112:FreeRTOS/Source/tasks.c **** 			}
2113:FreeRTOS/Source/tasks.c **** 		}
2114:FreeRTOS/Source/tasks.c **** 		#endif
2115:FreeRTOS/Source/tasks.c **** 
2116:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2117:FreeRTOS/Source/tasks.c **** 		{
2118:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2119:FreeRTOS/Source/tasks.c **** 		}
2120:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2121:FreeRTOS/Source/tasks.c **** 		{
2122:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2123:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2124:FreeRTOS/Source/tasks.c **** 			processed. */
2125:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2126:FreeRTOS/Source/tasks.c **** 		}
2127:FreeRTOS/Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2128:FreeRTOS/Source/tasks.c **** 		{
2129:FreeRTOS/Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2130:FreeRTOS/Source/tasks.c **** 			idle priority.  This path can only be reached if
2131:FreeRTOS/Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2132:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2133:FreeRTOS/Source/tasks.c **** 		}
2134:FreeRTOS/Source/tasks.c **** 		else
2135:FreeRTOS/Source/tasks.c **** 		{
2136:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2137:FreeRTOS/Source/tasks.c **** 		}
2138:FreeRTOS/Source/tasks.c **** 
2139:FreeRTOS/Source/tasks.c **** 		return xReturn;
2140:FreeRTOS/Source/tasks.c **** 	}
2141:FreeRTOS/Source/tasks.c **** 
2142:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2143:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2144:FreeRTOS/Source/tasks.c **** 
2145:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2146:FreeRTOS/Source/tasks.c **** {
2147:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
2148:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2149:FreeRTOS/Source/tasks.c **** 
2150:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2151:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2152:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2153:FreeRTOS/Source/tasks.c **** 
2154:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2155:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2156:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2157:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2158:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2159:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2160:FreeRTOS/Source/tasks.c **** 	{
2161:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
2162:FreeRTOS/Source/tasks.c **** 
2163:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2164:FreeRTOS/Source/tasks.c **** 		{
2165:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2166:FreeRTOS/Source/tasks.c **** 			{
2167:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2168:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
2169:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2170:FreeRTOS/Source/tasks.c **** 				{
2171:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2172:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2173:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2174:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2175:FreeRTOS/Source/tasks.c **** 
2176:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2177:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
2178:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2179:FreeRTOS/Source/tasks.c **** 					{
2180:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2181:FreeRTOS/Source/tasks.c **** 					}
2182:FreeRTOS/Source/tasks.c **** 					else
2183:FreeRTOS/Source/tasks.c **** 					{
2184:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2185:FreeRTOS/Source/tasks.c **** 					}
2186:FreeRTOS/Source/tasks.c **** 				}
2187:FreeRTOS/Source/tasks.c **** 
2188:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2189:FreeRTOS/Source/tasks.c **** 				{
2190:FreeRTOS/Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2191:FreeRTOS/Source/tasks.c **** 					which may have prevented the next unblock time from being
2192:FreeRTOS/Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2193:FreeRTOS/Source/tasks.c **** 					important for low power tickless implementations, where
2194:FreeRTOS/Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2195:FreeRTOS/Source/tasks.c **** 					state. */
2196:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2197:FreeRTOS/Source/tasks.c **** 				}
2198:FreeRTOS/Source/tasks.c **** 
2199:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2200:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2201:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2202:FreeRTOS/Source/tasks.c **** 				time. */
2203:FreeRTOS/Source/tasks.c **** 				{
2204:FreeRTOS/Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2205:FreeRTOS/Source/tasks.c **** 
2206:FreeRTOS/Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2207:FreeRTOS/Source/tasks.c **** 					{
2208:FreeRTOS/Source/tasks.c **** 						do
2209:FreeRTOS/Source/tasks.c **** 						{
2210:FreeRTOS/Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2211:FreeRTOS/Source/tasks.c **** 							{
2212:FreeRTOS/Source/tasks.c **** 								xYieldPending = pdTRUE;
2213:FreeRTOS/Source/tasks.c **** 							}
2214:FreeRTOS/Source/tasks.c **** 							else
2215:FreeRTOS/Source/tasks.c **** 							{
2216:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2217:FreeRTOS/Source/tasks.c **** 							}
2218:FreeRTOS/Source/tasks.c **** 							--uxPendedCounts;
2219:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 						uxPendedTicks = 0;
2222:FreeRTOS/Source/tasks.c **** 					}
2223:FreeRTOS/Source/tasks.c **** 					else
2224:FreeRTOS/Source/tasks.c **** 					{
2225:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2226:FreeRTOS/Source/tasks.c **** 					}
2227:FreeRTOS/Source/tasks.c **** 				}
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2230:FreeRTOS/Source/tasks.c **** 				{
2231:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2232:FreeRTOS/Source/tasks.c **** 					{
2233:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2234:FreeRTOS/Source/tasks.c **** 					}
2235:FreeRTOS/Source/tasks.c **** 					#endif
2236:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2237:FreeRTOS/Source/tasks.c **** 				}
2238:FreeRTOS/Source/tasks.c **** 				else
2239:FreeRTOS/Source/tasks.c **** 				{
2240:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2241:FreeRTOS/Source/tasks.c **** 				}
2242:FreeRTOS/Source/tasks.c **** 			}
2243:FreeRTOS/Source/tasks.c **** 		}
2244:FreeRTOS/Source/tasks.c **** 		else
2245:FreeRTOS/Source/tasks.c **** 		{
2246:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2247:FreeRTOS/Source/tasks.c **** 		}
2248:FreeRTOS/Source/tasks.c **** 	}
2249:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2250:FreeRTOS/Source/tasks.c **** 
2251:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
2252:FreeRTOS/Source/tasks.c **** }
2253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2254:FreeRTOS/Source/tasks.c **** 
2255:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2256:FreeRTOS/Source/tasks.c **** {
2257:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
2258:FreeRTOS/Source/tasks.c **** 
2259:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2260:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2261:FreeRTOS/Source/tasks.c **** 	{
2262:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
2263:FreeRTOS/Source/tasks.c **** 	}
2264:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2265:FreeRTOS/Source/tasks.c **** 
2266:FreeRTOS/Source/tasks.c **** 	return xTicks;
2267:FreeRTOS/Source/tasks.c **** }
2268:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2269:FreeRTOS/Source/tasks.c **** 
2270:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2271:FreeRTOS/Source/tasks.c **** {
2272:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
2273:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2274:FreeRTOS/Source/tasks.c **** 
2275:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2276:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2277:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2278:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2279:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2280:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2281:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2282:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2283:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2284:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2285:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2286:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2287:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2288:FreeRTOS/Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2289:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2290:FreeRTOS/Source/tasks.c **** 
2291:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2292:FreeRTOS/Source/tasks.c **** 	{
2293:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
2294:FreeRTOS/Source/tasks.c **** 	}
2295:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2296:FreeRTOS/Source/tasks.c **** 
2297:FreeRTOS/Source/tasks.c **** 	return xReturn;
2298:FreeRTOS/Source/tasks.c **** }
2299:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2300:FreeRTOS/Source/tasks.c **** 
2301:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2302:FreeRTOS/Source/tasks.c **** {
2303:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2304:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
2305:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2306:FreeRTOS/Source/tasks.c **** }
2307:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2308:FreeRTOS/Source/tasks.c **** 
2309:FreeRTOS/Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2310:FreeRTOS/Source/tasks.c **** {
2311:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
2312:FreeRTOS/Source/tasks.c **** 
2313:FreeRTOS/Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2314:FreeRTOS/Source/tasks.c **** 	queried. */
2315:FreeRTOS/Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2316:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
2317:FreeRTOS/Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2318:FreeRTOS/Source/tasks.c **** }
2319:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2320:FreeRTOS/Source/tasks.c **** 
2321:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2322:FreeRTOS/Source/tasks.c **** 
2323:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2324:FreeRTOS/Source/tasks.c **** 	{
2325:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2326:FreeRTOS/Source/tasks.c **** 	UBaseType_t x;
2327:FreeRTOS/Source/tasks.c **** 	char cNextChar;
2328:FreeRTOS/Source/tasks.c **** 	BaseType_t xBreakLoop;
2329:FreeRTOS/Source/tasks.c **** 
2330:FreeRTOS/Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2331:FreeRTOS/Source/tasks.c **** 
2332:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2335:FreeRTOS/Source/tasks.c **** 
2336:FreeRTOS/Source/tasks.c **** 			do
2337:FreeRTOS/Source/tasks.c **** 			{
2338:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 				/* Check each character in the name looking for a match or
2341:FreeRTOS/Source/tasks.c **** 				mismatch. */
2342:FreeRTOS/Source/tasks.c **** 				xBreakLoop = pdFALSE;
2343:FreeRTOS/Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2344:FreeRTOS/Source/tasks.c **** 				{
2345:FreeRTOS/Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2346:FreeRTOS/Source/tasks.c **** 
2347:FreeRTOS/Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2348:FreeRTOS/Source/tasks.c **** 					{
2349:FreeRTOS/Source/tasks.c **** 						/* Characters didn't match. */
2350:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2351:FreeRTOS/Source/tasks.c **** 					}
2352:FreeRTOS/Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2353:FreeRTOS/Source/tasks.c **** 					{
2354:FreeRTOS/Source/tasks.c **** 						/* Both strings terminated, a match must have been
2355:FreeRTOS/Source/tasks.c **** 						found. */
2356:FreeRTOS/Source/tasks.c **** 						pxReturn = pxNextTCB;
2357:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2358:FreeRTOS/Source/tasks.c **** 					}
2359:FreeRTOS/Source/tasks.c **** 					else
2360:FreeRTOS/Source/tasks.c **** 					{
2361:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2362:FreeRTOS/Source/tasks.c **** 					}
2363:FreeRTOS/Source/tasks.c **** 
2364:FreeRTOS/Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2365:FreeRTOS/Source/tasks.c **** 					{
2366:FreeRTOS/Source/tasks.c **** 						break;
2367:FreeRTOS/Source/tasks.c **** 					}
2368:FreeRTOS/Source/tasks.c **** 				}
2369:FreeRTOS/Source/tasks.c **** 
2370:FreeRTOS/Source/tasks.c **** 				if( pxReturn != NULL )
2371:FreeRTOS/Source/tasks.c **** 				{
2372:FreeRTOS/Source/tasks.c **** 					/* The handle has been found. */
2373:FreeRTOS/Source/tasks.c **** 					break;
2374:FreeRTOS/Source/tasks.c **** 				}
2375:FreeRTOS/Source/tasks.c **** 
2376:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2377:FreeRTOS/Source/tasks.c **** 		}
2378:FreeRTOS/Source/tasks.c **** 		else
2379:FreeRTOS/Source/tasks.c **** 		{
2380:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2381:FreeRTOS/Source/tasks.c **** 		}
2382:FreeRTOS/Source/tasks.c **** 
2383:FreeRTOS/Source/tasks.c **** 		return pxReturn;
2384:FreeRTOS/Source/tasks.c **** 	}
2385:FreeRTOS/Source/tasks.c **** 
2386:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2387:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2390:FreeRTOS/Source/tasks.c **** 
2391:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2392:FreeRTOS/Source/tasks.c **** 	{
2393:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2394:FreeRTOS/Source/tasks.c **** 	TCB_t* pxTCB;
2395:FreeRTOS/Source/tasks.c **** 
2396:FreeRTOS/Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2397:FreeRTOS/Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2398:FreeRTOS/Source/tasks.c **** 
2399:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2400:FreeRTOS/Source/tasks.c **** 		{
2401:FreeRTOS/Source/tasks.c **** 			/* Search the ready lists. */
2402:FreeRTOS/Source/tasks.c **** 			do
2403:FreeRTOS/Source/tasks.c **** 			{
2404:FreeRTOS/Source/tasks.c **** 				uxQueue--;
2405:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2408:FreeRTOS/Source/tasks.c **** 				{
2409:FreeRTOS/Source/tasks.c **** 					/* Found the handle. */
2410:FreeRTOS/Source/tasks.c **** 					break;
2411:FreeRTOS/Source/tasks.c **** 				}
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 			/* Search the delayed lists. */
2416:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2417:FreeRTOS/Source/tasks.c **** 			{
2418:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2419:FreeRTOS/Source/tasks.c **** 			}
2420:FreeRTOS/Source/tasks.c **** 
2421:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2422:FreeRTOS/Source/tasks.c **** 			{
2423:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2424:FreeRTOS/Source/tasks.c **** 			}
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2427:FreeRTOS/Source/tasks.c **** 			{
2428:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2429:FreeRTOS/Source/tasks.c **** 				{
2430:FreeRTOS/Source/tasks.c **** 					/* Search the suspended list. */
2431:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2432:FreeRTOS/Source/tasks.c **** 				}
2433:FreeRTOS/Source/tasks.c **** 			}
2434:FreeRTOS/Source/tasks.c **** 			#endif
2435:FreeRTOS/Source/tasks.c **** 
2436:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2437:FreeRTOS/Source/tasks.c **** 			{
2438:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2439:FreeRTOS/Source/tasks.c **** 				{
2440:FreeRTOS/Source/tasks.c **** 					/* Search the deleted list. */
2441:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2442:FreeRTOS/Source/tasks.c **** 				}
2443:FreeRTOS/Source/tasks.c **** 			}
2444:FreeRTOS/Source/tasks.c **** 			#endif
2445:FreeRTOS/Source/tasks.c **** 		}
2446:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2447:FreeRTOS/Source/tasks.c **** 
2448:FreeRTOS/Source/tasks.c **** 		return pxTCB;
2449:FreeRTOS/Source/tasks.c **** 	}
2450:FreeRTOS/Source/tasks.c **** 
2451:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2452:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2453:FreeRTOS/Source/tasks.c **** 
2454:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2455:FreeRTOS/Source/tasks.c **** 
2456:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2457:FreeRTOS/Source/tasks.c **** 	{
2458:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2459:FreeRTOS/Source/tasks.c **** 
2460:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2461:FreeRTOS/Source/tasks.c **** 		{
2462:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2463:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2464:FreeRTOS/Source/tasks.c **** 			{
2465:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2466:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
2467:FreeRTOS/Source/tasks.c **** 				do
2468:FreeRTOS/Source/tasks.c **** 				{
2469:FreeRTOS/Source/tasks.c **** 					uxQueue--;
2470:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2471:FreeRTOS/Source/tasks.c **** 
2472:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2473:FreeRTOS/Source/tasks.c **** 
2474:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2475:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
2476:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2477:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2478:FreeRTOS/Source/tasks.c **** 
2479:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2480:FreeRTOS/Source/tasks.c **** 				{
2481:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2482:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2483:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2484:FreeRTOS/Source/tasks.c **** 				}
2485:FreeRTOS/Source/tasks.c **** 				#endif
2486:FreeRTOS/Source/tasks.c **** 
2487:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2488:FreeRTOS/Source/tasks.c **** 				{
2489:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2490:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
2491:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2492:FreeRTOS/Source/tasks.c **** 				}
2493:FreeRTOS/Source/tasks.c **** 				#endif
2494:FreeRTOS/Source/tasks.c **** 
2495:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2496:FreeRTOS/Source/tasks.c **** 				{
2497:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2498:FreeRTOS/Source/tasks.c **** 					{
2499:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2500:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2501:FreeRTOS/Source/tasks.c **** 						#else
2502:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2503:FreeRTOS/Source/tasks.c **** 						#endif
2504:FreeRTOS/Source/tasks.c **** 					}
2505:FreeRTOS/Source/tasks.c **** 				}
2506:FreeRTOS/Source/tasks.c **** 				#else
2507:FreeRTOS/Source/tasks.c **** 				{
2508:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2509:FreeRTOS/Source/tasks.c **** 					{
2510:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
2511:FreeRTOS/Source/tasks.c **** 					}
2512:FreeRTOS/Source/tasks.c **** 				}
2513:FreeRTOS/Source/tasks.c **** 				#endif
2514:FreeRTOS/Source/tasks.c **** 			}
2515:FreeRTOS/Source/tasks.c **** 			else
2516:FreeRTOS/Source/tasks.c **** 			{
2517:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2518:FreeRTOS/Source/tasks.c **** 			}
2519:FreeRTOS/Source/tasks.c **** 		}
2520:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2521:FreeRTOS/Source/tasks.c **** 
2522:FreeRTOS/Source/tasks.c **** 		return uxTask;
2523:FreeRTOS/Source/tasks.c **** 	}
2524:FreeRTOS/Source/tasks.c **** 
2525:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2527:FreeRTOS/Source/tasks.c **** 
2528:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2529:FreeRTOS/Source/tasks.c **** 
2530:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2531:FreeRTOS/Source/tasks.c **** 	{
2532:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2533:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2534:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2535:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
2536:FreeRTOS/Source/tasks.c **** 	}
2537:FreeRTOS/Source/tasks.c **** 
2538:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2539:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2540:FreeRTOS/Source/tasks.c **** 
2541:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2542:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2543:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2544:FreeRTOS/Source/tasks.c **** 1. */
2545:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2546:FreeRTOS/Source/tasks.c **** 
2547:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2548:FreeRTOS/Source/tasks.c **** 	{
2549:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2550:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2551:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
2552:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2553:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
2554:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2555:FreeRTOS/Source/tasks.c **** 	}
2556:FreeRTOS/Source/tasks.c **** 
2557:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2558:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2559:FreeRTOS/Source/tasks.c **** 
2560:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2561:FreeRTOS/Source/tasks.c **** 
2562:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2563:FreeRTOS/Source/tasks.c **** 	{
2564:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2565:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2566:FreeRTOS/Source/tasks.c **** 
2567:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
2568:FreeRTOS/Source/tasks.c **** 
2569:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2570:FreeRTOS/Source/tasks.c **** 		{
2571:FreeRTOS/Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2572:FreeRTOS/Source/tasks.c **** 			it is actually in the Blocked state. */
2573:FreeRTOS/Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2574:FreeRTOS/Source/tasks.c **** 			{
2575:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
2576:FreeRTOS/Source/tasks.c **** 
2577:FreeRTOS/Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2578:FreeRTOS/Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2579:FreeRTOS/Source/tasks.c **** 				scheduler is suspended. */
2580:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2581:FreeRTOS/Source/tasks.c **** 
2582:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2583:FreeRTOS/Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2584:FreeRTOS/Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2585:FreeRTOS/Source/tasks.c **** 				is used. */
2586:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2587:FreeRTOS/Source/tasks.c **** 				{
2588:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2589:FreeRTOS/Source/tasks.c **** 					{
2590:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2591:FreeRTOS/Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2592:FreeRTOS/Source/tasks.c **** 					}
2593:FreeRTOS/Source/tasks.c **** 					else
2594:FreeRTOS/Source/tasks.c **** 					{
2595:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2596:FreeRTOS/Source/tasks.c **** 					}
2597:FreeRTOS/Source/tasks.c **** 				}
2598:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2599:FreeRTOS/Source/tasks.c **** 
2600:FreeRTOS/Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2601:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2602:FreeRTOS/Source/tasks.c **** 
2603:FreeRTOS/Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2604:FreeRTOS/Source/tasks.c **** 				switch if preemption is turned off. */
2605:FreeRTOS/Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2606:FreeRTOS/Source/tasks.c **** 				{
2607:FreeRTOS/Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2608:FreeRTOS/Source/tasks.c **** 					performed if the unblocked task has a priority that is
2609:FreeRTOS/Source/tasks.c **** 					equal to or higher than the currently executing task. */
2610:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2611:FreeRTOS/Source/tasks.c **** 					{
2612:FreeRTOS/Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2613:FreeRTOS/Source/tasks.c **** 						is unsuspended. */
2614:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2615:FreeRTOS/Source/tasks.c **** 					}
2616:FreeRTOS/Source/tasks.c **** 					else
2617:FreeRTOS/Source/tasks.c **** 					{
2618:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2619:FreeRTOS/Source/tasks.c **** 					}
2620:FreeRTOS/Source/tasks.c **** 				}
2621:FreeRTOS/Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2622:FreeRTOS/Source/tasks.c **** 			}
2623:FreeRTOS/Source/tasks.c **** 			else
2624:FreeRTOS/Source/tasks.c **** 			{
2625:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
2626:FreeRTOS/Source/tasks.c **** 			}
2627:FreeRTOS/Source/tasks.c **** 		}
2628:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2629:FreeRTOS/Source/tasks.c **** 
2630:FreeRTOS/Source/tasks.c **** 		return xReturn;
2631:FreeRTOS/Source/tasks.c **** 	}
2632:FreeRTOS/Source/tasks.c **** 
2633:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2634:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2635:FreeRTOS/Source/tasks.c **** 
2636:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2637:FreeRTOS/Source/tasks.c **** {
2638:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
2639:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
2640:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2641:FreeRTOS/Source/tasks.c **** 
2642:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2643:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2644:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
2645:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2646:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2647:FreeRTOS/Source/tasks.c **** 	{
2648:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2649:FreeRTOS/Source/tasks.c **** 		block. */
2650:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2651:FreeRTOS/Source/tasks.c **** 
2652:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2653:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
2654:FreeRTOS/Source/tasks.c **** 		xTickCount = xConstTickCount;
2655:FreeRTOS/Source/tasks.c **** 
2656:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2657:FreeRTOS/Source/tasks.c **** 		{
2658:FreeRTOS/Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2659:FreeRTOS/Source/tasks.c **** 		}
2660:FreeRTOS/Source/tasks.c **** 		else
2661:FreeRTOS/Source/tasks.c **** 		{
2662:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2663:FreeRTOS/Source/tasks.c **** 		}
2664:FreeRTOS/Source/tasks.c **** 
2665:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2666:FreeRTOS/Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2667:FreeRTOS/Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2668:FreeRTOS/Source/tasks.c **** 		look any further down the list. */
2669:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2670:FreeRTOS/Source/tasks.c **** 		{
2671:FreeRTOS/Source/tasks.c **** 			for( ;; )
2672:FreeRTOS/Source/tasks.c **** 			{
2673:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2674:FreeRTOS/Source/tasks.c **** 				{
2675:FreeRTOS/Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2676:FreeRTOS/Source/tasks.c **** 					to the maximum possible value so it is extremely
2677:FreeRTOS/Source/tasks.c **** 					unlikely that the
2678:FreeRTOS/Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2679:FreeRTOS/Source/tasks.c **** 					next time through. */
2680:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2681:FreeRTOS/Source/tasks.c **** 					break;
2682:FreeRTOS/Source/tasks.c **** 				}
2683:FreeRTOS/Source/tasks.c **** 				else
2684:FreeRTOS/Source/tasks.c **** 				{
2685:FreeRTOS/Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2686:FreeRTOS/Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2687:FreeRTOS/Source/tasks.c **** 					at which the task at the head of the delayed list must
2688:FreeRTOS/Source/tasks.c **** 					be removed from the Blocked state. */
2689:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2690:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2691:FreeRTOS/Source/tasks.c **** 
2692:FreeRTOS/Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2693:FreeRTOS/Source/tasks.c **** 					{
2694:FreeRTOS/Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2695:FreeRTOS/Source/tasks.c **** 						item value is the time at which the task at the head
2696:FreeRTOS/Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2697:FreeRTOS/Source/tasks.c **** 						state -	so record the item value in
2698:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime. */
2699:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2700:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2701:FreeRTOS/Source/tasks.c **** 					}
2702:FreeRTOS/Source/tasks.c **** 					else
2703:FreeRTOS/Source/tasks.c **** 					{
2704:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2705:FreeRTOS/Source/tasks.c **** 					}
2706:FreeRTOS/Source/tasks.c **** 
2707:FreeRTOS/Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2708:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2709:FreeRTOS/Source/tasks.c **** 
2710:FreeRTOS/Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2711:FreeRTOS/Source/tasks.c **** 					it from the event list. */
2712:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2713:FreeRTOS/Source/tasks.c **** 					{
2714:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2715:FreeRTOS/Source/tasks.c **** 					}
2716:FreeRTOS/Source/tasks.c **** 					else
2717:FreeRTOS/Source/tasks.c **** 					{
2718:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2719:FreeRTOS/Source/tasks.c **** 					}
2720:FreeRTOS/Source/tasks.c **** 
2721:FreeRTOS/Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2722:FreeRTOS/Source/tasks.c **** 					list. */
2723:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2724:FreeRTOS/Source/tasks.c **** 
2725:FreeRTOS/Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2726:FreeRTOS/Source/tasks.c **** 					context switch if preemption is turned off. */
2727:FreeRTOS/Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2728:FreeRTOS/Source/tasks.c **** 					{
2729:FreeRTOS/Source/tasks.c **** 						/* Preemption is on, but a context switch should
2730:FreeRTOS/Source/tasks.c **** 						only be performed if the unblocked task has a
2731:FreeRTOS/Source/tasks.c **** 						priority that is equal to or higher than the
2732:FreeRTOS/Source/tasks.c **** 						currently executing task. */
2733:FreeRTOS/Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2734:FreeRTOS/Source/tasks.c **** 						{
2735:FreeRTOS/Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2736:FreeRTOS/Source/tasks.c **** 						}
2737:FreeRTOS/Source/tasks.c **** 						else
2738:FreeRTOS/Source/tasks.c **** 						{
2739:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2740:FreeRTOS/Source/tasks.c **** 						}
2741:FreeRTOS/Source/tasks.c **** 					}
2742:FreeRTOS/Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2743:FreeRTOS/Source/tasks.c **** 				}
2744:FreeRTOS/Source/tasks.c **** 			}
2745:FreeRTOS/Source/tasks.c **** 		}
2746:FreeRTOS/Source/tasks.c **** 
2747:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2748:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2749:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2750:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2751:FreeRTOS/Source/tasks.c **** 		{
2752:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2753:FreeRTOS/Source/tasks.c **** 			{
2754:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2755:FreeRTOS/Source/tasks.c **** 			}
2756:FreeRTOS/Source/tasks.c **** 			else
2757:FreeRTOS/Source/tasks.c **** 			{
2758:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2759:FreeRTOS/Source/tasks.c **** 			}
2760:FreeRTOS/Source/tasks.c **** 		}
2761:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2762:FreeRTOS/Source/tasks.c **** 
2763:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2764:FreeRTOS/Source/tasks.c **** 		{
2765:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2766:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2767:FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2768:FreeRTOS/Source/tasks.c **** 			{
2769:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2770:FreeRTOS/Source/tasks.c **** 			}
2771:FreeRTOS/Source/tasks.c **** 			else
2772:FreeRTOS/Source/tasks.c **** 			{
2773:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2774:FreeRTOS/Source/tasks.c **** 			}
2775:FreeRTOS/Source/tasks.c **** 		}
2776:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2777:FreeRTOS/Source/tasks.c **** 	}
2778:FreeRTOS/Source/tasks.c **** 	else
2779:FreeRTOS/Source/tasks.c **** 	{
2780:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
2781:FreeRTOS/Source/tasks.c **** 
2782:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2783:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2784:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2785:FreeRTOS/Source/tasks.c **** 		{
2786:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2787:FreeRTOS/Source/tasks.c **** 		}
2788:FreeRTOS/Source/tasks.c **** 		#endif
2789:FreeRTOS/Source/tasks.c **** 	}
2790:FreeRTOS/Source/tasks.c **** 
2791:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2792:FreeRTOS/Source/tasks.c **** 	{
2793:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2794:FreeRTOS/Source/tasks.c **** 		{
2795:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2796:FreeRTOS/Source/tasks.c **** 		}
2797:FreeRTOS/Source/tasks.c **** 		else
2798:FreeRTOS/Source/tasks.c **** 		{
2799:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2800:FreeRTOS/Source/tasks.c **** 		}
2801:FreeRTOS/Source/tasks.c **** 	}
2802:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2803:FreeRTOS/Source/tasks.c **** 
2804:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2805:FreeRTOS/Source/tasks.c **** }
2806:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2807:FreeRTOS/Source/tasks.c **** 
2808:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2809:FreeRTOS/Source/tasks.c **** 
2810:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2811:FreeRTOS/Source/tasks.c **** 	{
2812:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2813:FreeRTOS/Source/tasks.c **** 
2814:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2815:FreeRTOS/Source/tasks.c **** 		getting set. */
2816:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2817:FreeRTOS/Source/tasks.c **** 		{
2818:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2819:FreeRTOS/Source/tasks.c **** 		}
2820:FreeRTOS/Source/tasks.c **** 		else
2821:FreeRTOS/Source/tasks.c **** 		{
2822:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2823:FreeRTOS/Source/tasks.c **** 		}
2824:FreeRTOS/Source/tasks.c **** 
2825:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2826:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2827:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2828:FreeRTOS/Source/tasks.c **** 		{
2829:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2830:FreeRTOS/Source/tasks.c **** 		}
2831:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2832:FreeRTOS/Source/tasks.c **** 	}
2833:FreeRTOS/Source/tasks.c **** 
2834:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2835:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2836:FreeRTOS/Source/tasks.c **** 
2837:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2838:FreeRTOS/Source/tasks.c **** 
2839:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2840:FreeRTOS/Source/tasks.c **** 	{
2841:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2842:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2843:FreeRTOS/Source/tasks.c **** 
2844:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2845:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2846:FreeRTOS/Source/tasks.c **** 		{
2847:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2848:FreeRTOS/Source/tasks.c **** 		}
2849:FreeRTOS/Source/tasks.c **** 		else
2850:FreeRTOS/Source/tasks.c **** 		{
2851:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2852:FreeRTOS/Source/tasks.c **** 		}
2853:FreeRTOS/Source/tasks.c **** 
2854:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2855:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2856:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2857:FreeRTOS/Source/tasks.c **** 		{
2858:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2859:FreeRTOS/Source/tasks.c **** 		}
2860:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2861:FreeRTOS/Source/tasks.c **** 
2862:FreeRTOS/Source/tasks.c **** 		return xReturn;
2863:FreeRTOS/Source/tasks.c **** 	}
2864:FreeRTOS/Source/tasks.c **** 
2865:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2867:FreeRTOS/Source/tasks.c **** 
2868:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2869:FreeRTOS/Source/tasks.c **** 
2870:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2871:FreeRTOS/Source/tasks.c **** 	{
2872:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2873:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2874:FreeRTOS/Source/tasks.c **** 
2875:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2876:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2877:FreeRTOS/Source/tasks.c **** 		{
2878:FreeRTOS/Source/tasks.c **** 			xTCB = pxCurrentTCB;
2879:FreeRTOS/Source/tasks.c **** 		}
2880:FreeRTOS/Source/tasks.c **** 		else
2881:FreeRTOS/Source/tasks.c **** 		{
2882:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2883:FreeRTOS/Source/tasks.c **** 		}
2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2886:FreeRTOS/Source/tasks.c **** 		{
2887:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2888:FreeRTOS/Source/tasks.c **** 		}
2889:FreeRTOS/Source/tasks.c **** 		else
2890:FreeRTOS/Source/tasks.c **** 		{
2891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2892:FreeRTOS/Source/tasks.c **** 		}
2893:FreeRTOS/Source/tasks.c **** 
2894:FreeRTOS/Source/tasks.c **** 		return xReturn;
2895:FreeRTOS/Source/tasks.c **** 	}
2896:FreeRTOS/Source/tasks.c **** 
2897:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2898:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2899:FreeRTOS/Source/tasks.c **** 
2900:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2901:FreeRTOS/Source/tasks.c **** {
2902:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2903:FreeRTOS/Source/tasks.c **** 	{
2904:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2905:FreeRTOS/Source/tasks.c **** 		switch. */
2906:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2907:FreeRTOS/Source/tasks.c **** 	}
2908:FreeRTOS/Source/tasks.c **** 	else
2909:FreeRTOS/Source/tasks.c **** 	{
2910:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2911:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2912:FreeRTOS/Source/tasks.c **** 
2913:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2914:FreeRTOS/Source/tasks.c **** 		{
2915:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2916:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2917:FreeRTOS/Source/tasks.c **** 				#else
2918:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2919:FreeRTOS/Source/tasks.c **** 				#endif
2920:FreeRTOS/Source/tasks.c **** 
2921:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2922:FreeRTOS/Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2923:FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2924:FreeRTOS/Source/tasks.c **** 				protection here so count values are only valid until the timer
2925:FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2926:FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2927:FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2928:FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2929:FreeRTOS/Source/tasks.c **** 				{
2930:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2931:FreeRTOS/Source/tasks.c **** 				}
2932:FreeRTOS/Source/tasks.c **** 				else
2933:FreeRTOS/Source/tasks.c **** 				{
2934:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2935:FreeRTOS/Source/tasks.c **** 				}
2936:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2937:FreeRTOS/Source/tasks.c **** 		}
2938:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2939:FreeRTOS/Source/tasks.c **** 
2940:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2941:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2942:FreeRTOS/Source/tasks.c **** 
2943:FreeRTOS/Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
2944:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2945:FreeRTOS/Source/tasks.c **** 		{
2946:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2947:FreeRTOS/Source/tasks.c **** 		}
2948:FreeRTOS/Source/tasks.c **** 		#endif
2949:FreeRTOS/Source/tasks.c **** 
2950:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2951:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2952:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
2953:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2954:FreeRTOS/Source/tasks.c **** 
2955:FreeRTOS/Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
2956:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2957:FreeRTOS/Source/tasks.c **** 		{
2958:FreeRTOS/Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2959:FreeRTOS/Source/tasks.c **** 		}
2960:FreeRTOS/Source/tasks.c **** 		#endif
2961:FreeRTOS/Source/tasks.c **** 
2962:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2963:FreeRTOS/Source/tasks.c **** 		{
2964:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2965:FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2966:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2967:FreeRTOS/Source/tasks.c **** 		}
2968:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2969:FreeRTOS/Source/tasks.c **** 	}
2970:FreeRTOS/Source/tasks.c **** }
2971:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2972:FreeRTOS/Source/tasks.c **** 
2973:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2974:FreeRTOS/Source/tasks.c **** {
2975:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2976:FreeRTOS/Source/tasks.c **** 
2977:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2978:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2979:FreeRTOS/Source/tasks.c **** 
2980:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2981:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2982:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2983:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2984:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2985:FreeRTOS/Source/tasks.c **** 
2986:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2987:FreeRTOS/Source/tasks.c **** }
2988:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2989:FreeRTOS/Source/tasks.c **** 
2990:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2991:FreeRTOS/Source/tasks.c **** {
2992:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2993:FreeRTOS/Source/tasks.c **** 
2994:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2995:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2996:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2997:FreeRTOS/Source/tasks.c **** 
2998:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2999:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3000:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
3001:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3002:FreeRTOS/Source/tasks.c **** 
3003:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3004:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3005:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3006:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3007:FreeRTOS/Source/tasks.c **** 	the task level). */
3008:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3009:FreeRTOS/Source/tasks.c **** 
3010:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3011:FreeRTOS/Source/tasks.c **** }
3012:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3013:FreeRTOS/Source/tasks.c **** 
3014:FreeRTOS/Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3015:FreeRTOS/Source/tasks.c **** 
3016:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3017:FreeRTOS/Source/tasks.c **** 	{
3018:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
3019:FreeRTOS/Source/tasks.c **** 
3020:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
3021:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3022:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3023:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
3024:FreeRTOS/Source/tasks.c **** 
3025:FreeRTOS/Source/tasks.c **** 
3026:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3027:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3028:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3029:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
3030:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3031:FreeRTOS/Source/tasks.c **** 
3032:FreeRTOS/Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3033:FreeRTOS/Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3034:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3035:FreeRTOS/Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3036:FreeRTOS/Source/tasks.c **** 		{
3037:FreeRTOS/Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3038:FreeRTOS/Source/tasks.c **** 		}
3039:FreeRTOS/Source/tasks.c **** 
3040:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3041:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3042:FreeRTOS/Source/tasks.c **** 	}
3043:FreeRTOS/Source/tasks.c **** 
3044:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3045:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3046:FreeRTOS/Source/tasks.c **** 
3047:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3048:FreeRTOS/Source/tasks.c **** {
3049:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3050:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3051:FreeRTOS/Source/tasks.c **** 
3052:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3053:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
3054:FreeRTOS/Source/tasks.c **** 
3055:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3056:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3057:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
3058:FreeRTOS/Source/tasks.c **** 
3059:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3060:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3061:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3062:FreeRTOS/Source/tasks.c **** 
3063:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3064:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
3065:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3066:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3067:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3068:FreeRTOS/Source/tasks.c **** 
3069:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3070:FreeRTOS/Source/tasks.c **** 	{
3071:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3072:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3073:FreeRTOS/Source/tasks.c **** 	}
3074:FreeRTOS/Source/tasks.c **** 	else
3075:FreeRTOS/Source/tasks.c **** 	{
3076:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3077:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
3078:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3079:FreeRTOS/Source/tasks.c **** 	}
3080:FreeRTOS/Source/tasks.c **** 
3081:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3082:FreeRTOS/Source/tasks.c **** 	{
3083:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3084:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3085:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
3086:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
3087:FreeRTOS/Source/tasks.c **** 
3088:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3089:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3090:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3091:FreeRTOS/Source/tasks.c **** 	}
3092:FreeRTOS/Source/tasks.c **** 	else
3093:FreeRTOS/Source/tasks.c **** 	{
3094:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
3095:FreeRTOS/Source/tasks.c **** 	}
3096:FreeRTOS/Source/tasks.c **** 
3097:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3098:FreeRTOS/Source/tasks.c **** 	{
3099:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3100:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3101:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3102:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3103:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3104:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3105:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3106:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3107:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3108:FreeRTOS/Source/tasks.c **** 	}
3109:FreeRTOS/Source/tasks.c **** 	#endif
3110:FreeRTOS/Source/tasks.c **** 
3111:FreeRTOS/Source/tasks.c **** 	return xReturn;
3112:FreeRTOS/Source/tasks.c **** }
3113:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3114:FreeRTOS/Source/tasks.c **** 
3115:FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3116:FreeRTOS/Source/tasks.c **** {
3117:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3118:FreeRTOS/Source/tasks.c **** 
3119:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3120:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
3121:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3122:FreeRTOS/Source/tasks.c **** 
3123:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
3124:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3125:FreeRTOS/Source/tasks.c **** 
3126:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3127:FreeRTOS/Source/tasks.c **** 	event flags. */
3128:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3129:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3130:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3131:FreeRTOS/Source/tasks.c **** 
3132:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3133:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3134:FreeRTOS/Source/tasks.c **** 	lists. */
3135:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3136:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3137:FreeRTOS/Source/tasks.c **** 
3138:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3139:FreeRTOS/Source/tasks.c **** 	{
3140:FreeRTOS/Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3141:FreeRTOS/Source/tasks.c **** 		a context switch is required.  This function is called with the
3142:FreeRTOS/Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3143:FreeRTOS/Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3144:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3145:FreeRTOS/Source/tasks.c **** 	}
3146:FreeRTOS/Source/tasks.c **** }
3147:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3148:FreeRTOS/Source/tasks.c **** 
3149:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3150:FreeRTOS/Source/tasks.c **** {
3151:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3152:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3153:FreeRTOS/Source/tasks.c **** 	{
3154:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3155:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3156:FreeRTOS/Source/tasks.c **** 	}
3157:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3158:FreeRTOS/Source/tasks.c **** }
3159:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3160:FreeRTOS/Source/tasks.c **** 
3161:FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3162:FreeRTOS/Source/tasks.c **** {
3163:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3164:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3165:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3166:FreeRTOS/Source/tasks.c **** }
3167:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3168:FreeRTOS/Source/tasks.c **** 
3169:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3170:FreeRTOS/Source/tasks.c **** {
3171:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3172:FreeRTOS/Source/tasks.c **** 
3173:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3174:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
3175:FreeRTOS/Source/tasks.c **** 
3176:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3177:FreeRTOS/Source/tasks.c **** 	{
3178:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3179:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3180:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3181:FreeRTOS/Source/tasks.c **** 
3182:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3183:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3184:FreeRTOS/Source/tasks.c **** 			{
3185:FreeRTOS/Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3186:FreeRTOS/Source/tasks.c **** 				but has the same result. */
3187:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3188:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3189:FreeRTOS/Source/tasks.c **** 			}
3190:FreeRTOS/Source/tasks.c **** 			else
3191:FreeRTOS/Source/tasks.c **** 		#endif
3192:FreeRTOS/Source/tasks.c **** 
3193:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3194:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3195:FreeRTOS/Source/tasks.c **** 			{
3196:FreeRTOS/Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3197:FreeRTOS/Source/tasks.c **** 				specified is the maximum block time then the task should block
3198:FreeRTOS/Source/tasks.c **** 				indefinitely, and therefore never time out. */
3199:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
3200:FreeRTOS/Source/tasks.c **** 			}
3201:FreeRTOS/Source/tasks.c **** 			else
3202:FreeRTOS/Source/tasks.c **** 		#endif
3203:FreeRTOS/Source/tasks.c **** 
3204:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3205:FreeRTOS/Source/tasks.c **** 		{
3206:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which
3207:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3208:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3209:FreeRTOS/Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3210:FreeRTOS/Source/tasks.c **** 			was called. */
3211:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3212:FreeRTOS/Source/tasks.c **** 		}
3213:FreeRTOS/Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3214:FreeRTOS/Source/tasks.c **** 		{
3215:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3216:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3217:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3218:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
3219:FreeRTOS/Source/tasks.c **** 		}
3220:FreeRTOS/Source/tasks.c **** 		else
3221:FreeRTOS/Source/tasks.c **** 		{
3222:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait = 0;
3223:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3224:FreeRTOS/Source/tasks.c **** 		}
3225:FreeRTOS/Source/tasks.c **** 	}
3226:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3227:FreeRTOS/Source/tasks.c **** 
3228:FreeRTOS/Source/tasks.c **** 	return xReturn;
3229:FreeRTOS/Source/tasks.c **** }
3230:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3231:FreeRTOS/Source/tasks.c **** 
3232:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3233:FreeRTOS/Source/tasks.c **** {
3234:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
3235:FreeRTOS/Source/tasks.c **** }
3236:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3237:FreeRTOS/Source/tasks.c **** 
3238:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3239:FreeRTOS/Source/tasks.c **** 
3240:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3241:FreeRTOS/Source/tasks.c **** 	{
3242:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3243:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
3244:FreeRTOS/Source/tasks.c **** 
3245:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3246:FreeRTOS/Source/tasks.c **** 		{
3247:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3248:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3249:FreeRTOS/Source/tasks.c **** 		}
3250:FreeRTOS/Source/tasks.c **** 		else
3251:FreeRTOS/Source/tasks.c **** 		{
3252:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
3253:FreeRTOS/Source/tasks.c **** 		}
3254:FreeRTOS/Source/tasks.c **** 
3255:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3256:FreeRTOS/Source/tasks.c **** 	}
3257:FreeRTOS/Source/tasks.c **** 
3258:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3259:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3260:FreeRTOS/Source/tasks.c **** 
3261:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3262:FreeRTOS/Source/tasks.c **** 
3263:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3264:FreeRTOS/Source/tasks.c **** 	{
3265:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
3266:FreeRTOS/Source/tasks.c **** 
3267:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3268:FreeRTOS/Source/tasks.c **** 		{
3269:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3270:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3271:FreeRTOS/Source/tasks.c **** 		}
3272:FreeRTOS/Source/tasks.c **** 	}
3273:FreeRTOS/Source/tasks.c **** 
3274:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3275:FreeRTOS/Source/tasks.c **** 
3276:FreeRTOS/Source/tasks.c **** /*
3277:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3278:FreeRTOS/Source/tasks.c ****  * The Idle task.
3279:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3280:FreeRTOS/Source/tasks.c ****  *
3281:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3282:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3283:FreeRTOS/Source/tasks.c ****  *
3284:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3285:FreeRTOS/Source/tasks.c ****  *
3286:FreeRTOS/Source/tasks.c ****  */
3287:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3288:FreeRTOS/Source/tasks.c **** {
3289:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
3290:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
3291:FreeRTOS/Source/tasks.c **** 
3292:FreeRTOS/Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3293:FreeRTOS/Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3294:FreeRTOS/Source/tasks.c **** 
3295:FreeRTOS/Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3296:FreeRTOS/Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3297:FreeRTOS/Source/tasks.c **** 	any. */
3298:FreeRTOS/Source/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3299:FreeRTOS/Source/tasks.c **** 
3300:FreeRTOS/Source/tasks.c **** 	for( ;; )
3301:FreeRTOS/Source/tasks.c **** 	{
3302:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3303:FreeRTOS/Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3304:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3305:FreeRTOS/Source/tasks.c **** 
3306:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3307:FreeRTOS/Source/tasks.c **** 		{
3308:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3309:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
3310:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3311:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
3312:FreeRTOS/Source/tasks.c **** 			taskYIELD();
3313:FreeRTOS/Source/tasks.c **** 		}
3314:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3315:FreeRTOS/Source/tasks.c **** 
3316:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3317:FreeRTOS/Source/tasks.c **** 		{
3318:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3319:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3320:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
3321:FreeRTOS/Source/tasks.c **** 			timeslice.
3322:FreeRTOS/Source/tasks.c **** 
3323:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
3324:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3325:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3326:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3327:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3328:FreeRTOS/Source/tasks.c **** 			{
3329:FreeRTOS/Source/tasks.c **** 				taskYIELD();
3330:FreeRTOS/Source/tasks.c **** 			}
3331:FreeRTOS/Source/tasks.c **** 			else
3332:FreeRTOS/Source/tasks.c **** 			{
3333:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3334:FreeRTOS/Source/tasks.c **** 			}
3335:FreeRTOS/Source/tasks.c **** 		}
3336:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3337:FreeRTOS/Source/tasks.c **** 
3338:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3339:FreeRTOS/Source/tasks.c **** 		{
3340:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3341:FreeRTOS/Source/tasks.c **** 
3342:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3343:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
3344:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
3345:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3346:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3347:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
3348:FreeRTOS/Source/tasks.c **** 		}
3349:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3350:FreeRTOS/Source/tasks.c **** 
3351:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3352:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3353:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
3354:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3355:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3356:FreeRTOS/Source/tasks.c **** 		{
3357:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3358:FreeRTOS/Source/tasks.c **** 
3359:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3360:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3361:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
3362:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3363:FreeRTOS/Source/tasks.c **** 			valid. */
3364:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3365:FreeRTOS/Source/tasks.c **** 
3366:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3367:FreeRTOS/Source/tasks.c **** 			{
3368:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
3369:FreeRTOS/Source/tasks.c **** 				{
3370:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3371:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
3372:FreeRTOS/Source/tasks.c **** 					be used. */
3373:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3374:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3375:FreeRTOS/Source/tasks.c **** 
3376:FreeRTOS/Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3377:FreeRTOS/Source/tasks.c **** 					if the application does not want
3378:FreeRTOS/Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3379:FreeRTOS/Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3380:FreeRTOS/Source/tasks.c **** 
3381:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3382:FreeRTOS/Source/tasks.c **** 					{
3383:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3384:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3385:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3386:FreeRTOS/Source/tasks.c **** 					}
3387:FreeRTOS/Source/tasks.c **** 					else
3388:FreeRTOS/Source/tasks.c **** 					{
3389:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3390:FreeRTOS/Source/tasks.c **** 					}
3391:FreeRTOS/Source/tasks.c **** 				}
3392:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
3393:FreeRTOS/Source/tasks.c **** 			}
3394:FreeRTOS/Source/tasks.c **** 			else
3395:FreeRTOS/Source/tasks.c **** 			{
3396:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3397:FreeRTOS/Source/tasks.c **** 			}
3398:FreeRTOS/Source/tasks.c **** 		}
3399:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3400:FreeRTOS/Source/tasks.c **** 	}
3401:FreeRTOS/Source/tasks.c **** }
3402:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3403:FreeRTOS/Source/tasks.c **** 
3404:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3405:FreeRTOS/Source/tasks.c **** 
3406:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3407:FreeRTOS/Source/tasks.c **** 	{
3408:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3409:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3410:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3411:FreeRTOS/Source/tasks.c **** 
3412:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3413:FreeRTOS/Source/tasks.c **** 		{
3414:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3415:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3416:FreeRTOS/Source/tasks.c **** 		}
3417:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3418:FreeRTOS/Source/tasks.c **** 		{
3419:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3420:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3421:FreeRTOS/Source/tasks.c **** 		}
3422:FreeRTOS/Source/tasks.c **** 		else
3423:FreeRTOS/Source/tasks.c **** 		{
3424:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3425:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3426:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3427:FreeRTOS/Source/tasks.c **** 			interrupts. */
3428:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3429:FreeRTOS/Source/tasks.c **** 			{
3430:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3431:FreeRTOS/Source/tasks.c **** 			}
3432:FreeRTOS/Source/tasks.c **** 			else
3433:FreeRTOS/Source/tasks.c **** 			{
3434:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3435:FreeRTOS/Source/tasks.c **** 			}
3436:FreeRTOS/Source/tasks.c **** 		}
3437:FreeRTOS/Source/tasks.c **** 
3438:FreeRTOS/Source/tasks.c **** 		return eReturn;
3439:FreeRTOS/Source/tasks.c **** 	}
3440:FreeRTOS/Source/tasks.c **** 
3441:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3442:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3443:FreeRTOS/Source/tasks.c **** 
3444:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3445:FreeRTOS/Source/tasks.c **** 
3446:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3447:FreeRTOS/Source/tasks.c **** 	{
3448:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3449:FreeRTOS/Source/tasks.c **** 
3450:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3451:FreeRTOS/Source/tasks.c **** 		{
3452:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3453:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3454:FreeRTOS/Source/tasks.c **** 		}
3455:FreeRTOS/Source/tasks.c **** 	}
3456:FreeRTOS/Source/tasks.c **** 
3457:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3458:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3459:FreeRTOS/Source/tasks.c **** 
3460:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3461:FreeRTOS/Source/tasks.c **** 
3462:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3463:FreeRTOS/Source/tasks.c **** 	{
3464:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
3465:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3466:FreeRTOS/Source/tasks.c **** 
3467:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3468:FreeRTOS/Source/tasks.c **** 		{
3469:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3470:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3471:FreeRTOS/Source/tasks.c **** 		}
3472:FreeRTOS/Source/tasks.c **** 		else
3473:FreeRTOS/Source/tasks.c **** 		{
3474:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
3475:FreeRTOS/Source/tasks.c **** 		}
3476:FreeRTOS/Source/tasks.c **** 
3477:FreeRTOS/Source/tasks.c **** 		return pvReturn;
3478:FreeRTOS/Source/tasks.c **** 	}
3479:FreeRTOS/Source/tasks.c **** 
3480:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3481:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3482:FreeRTOS/Source/tasks.c **** 
3483:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3484:FreeRTOS/Source/tasks.c **** 
3485:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3486:FreeRTOS/Source/tasks.c **** 	{
3487:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3488:FreeRTOS/Source/tasks.c **** 
3489:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3490:FreeRTOS/Source/tasks.c **** 		the calling task. */
3491:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3492:FreeRTOS/Source/tasks.c **** 
3493:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3494:FreeRTOS/Source/tasks.c **** 	}
3495:FreeRTOS/Source/tasks.c **** 
3496:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3497:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3498:FreeRTOS/Source/tasks.c **** 
3499:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3500:FreeRTOS/Source/tasks.c **** {
3501:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3502:FreeRTOS/Source/tasks.c **** 
3503:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3504:FreeRTOS/Source/tasks.c **** 	{
3505:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3506:FreeRTOS/Source/tasks.c **** 	}
3507:FreeRTOS/Source/tasks.c **** 
3508:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3509:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3510:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3511:FreeRTOS/Source/tasks.c **** 
3512:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3513:FreeRTOS/Source/tasks.c **** 	{
3514:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3515:FreeRTOS/Source/tasks.c **** 	}
3516:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3517:FreeRTOS/Source/tasks.c **** 
3518:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3519:FreeRTOS/Source/tasks.c **** 	{
3520:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3521:FreeRTOS/Source/tasks.c **** 	}
3522:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3523:FreeRTOS/Source/tasks.c **** 
3524:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3525:FreeRTOS/Source/tasks.c **** 	using list2. */
3526:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3527:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3528:FreeRTOS/Source/tasks.c **** }
3529:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3530:FreeRTOS/Source/tasks.c **** 
3531:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3532:FreeRTOS/Source/tasks.c **** {
3533:FreeRTOS/Source/tasks.c **** 
3534:FreeRTOS/Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3535:FreeRTOS/Source/tasks.c **** 
3536:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3537:FreeRTOS/Source/tasks.c **** 	{
3538:FreeRTOS/Source/tasks.c **** 		TCB_t *pxTCB;
3539:FreeRTOS/Source/tasks.c **** 
3540:FreeRTOS/Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3541:FreeRTOS/Source/tasks.c **** 		being called too often in the idle task. */
3542:FreeRTOS/Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3543:FreeRTOS/Source/tasks.c **** 		{
3544:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
3545:FreeRTOS/Source/tasks.c **** 			{
3546:FreeRTOS/Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3547:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3548:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3549:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3550:FreeRTOS/Source/tasks.c **** 			}
3551:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
3552:FreeRTOS/Source/tasks.c **** 
3553:FreeRTOS/Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3554:FreeRTOS/Source/tasks.c **** 		}
3555:FreeRTOS/Source/tasks.c **** 	}
3556:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3557:FreeRTOS/Source/tasks.c **** }
3558:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3559:FreeRTOS/Source/tasks.c **** 
3560:FreeRTOS/Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3561:FreeRTOS/Source/tasks.c **** 
3562:FreeRTOS/Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3563:FreeRTOS/Source/tasks.c **** 	{
3564:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3565:FreeRTOS/Source/tasks.c **** 
3566:FreeRTOS/Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3567:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3568:FreeRTOS/Source/tasks.c **** 
3569:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3570:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3571:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3572:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3573:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3574:FreeRTOS/Source/tasks.c **** 
3575:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3576:FreeRTOS/Source/tasks.c **** 		{
3577:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3578:FreeRTOS/Source/tasks.c **** 		}
3579:FreeRTOS/Source/tasks.c **** 		#else
3580:FreeRTOS/Source/tasks.c **** 		{
3581:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3582:FreeRTOS/Source/tasks.c **** 		}
3583:FreeRTOS/Source/tasks.c **** 		#endif
3584:FreeRTOS/Source/tasks.c **** 
3585:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3586:FreeRTOS/Source/tasks.c **** 		{
3587:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3588:FreeRTOS/Source/tasks.c **** 		}
3589:FreeRTOS/Source/tasks.c **** 		#else
3590:FreeRTOS/Source/tasks.c **** 		{
3591:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3592:FreeRTOS/Source/tasks.c **** 		}
3593:FreeRTOS/Source/tasks.c **** 		#endif
3594:FreeRTOS/Source/tasks.c **** 
3595:FreeRTOS/Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3596:FreeRTOS/Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3597:FreeRTOS/Source/tasks.c **** 		state is just set to whatever is passed in. */
3598:FreeRTOS/Source/tasks.c **** 		if( eState != eInvalid )
3599:FreeRTOS/Source/tasks.c **** 		{
3600:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3601:FreeRTOS/Source/tasks.c **** 			{
3602:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3603:FreeRTOS/Source/tasks.c **** 			}
3604:FreeRTOS/Source/tasks.c **** 			else
3605:FreeRTOS/Source/tasks.c **** 			{
3606:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3607:FreeRTOS/Source/tasks.c **** 
3608:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3609:FreeRTOS/Source/tasks.c **** 				{
3610:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3611:FreeRTOS/Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3612:FreeRTOS/Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3613:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3614:FreeRTOS/Source/tasks.c **** 					{
3615:FreeRTOS/Source/tasks.c **** 						vTaskSuspendAll();
3616:FreeRTOS/Source/tasks.c **** 						{
3617:FreeRTOS/Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3618:FreeRTOS/Source/tasks.c **** 							{
3619:FreeRTOS/Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3620:FreeRTOS/Source/tasks.c **** 							}
3621:FreeRTOS/Source/tasks.c **** 						}
3622:FreeRTOS/Source/tasks.c **** 						( void ) xTaskResumeAll();
3623:FreeRTOS/Source/tasks.c **** 					}
3624:FreeRTOS/Source/tasks.c **** 				}
3625:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3626:FreeRTOS/Source/tasks.c **** 			}
3627:FreeRTOS/Source/tasks.c **** 		}
3628:FreeRTOS/Source/tasks.c **** 		else
3629:FreeRTOS/Source/tasks.c **** 		{
3630:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3631:FreeRTOS/Source/tasks.c **** 		}
3632:FreeRTOS/Source/tasks.c **** 
3633:FreeRTOS/Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3634:FreeRTOS/Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3635:FreeRTOS/Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3636:FreeRTOS/Source/tasks.c **** 		{
3637:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3638:FreeRTOS/Source/tasks.c **** 			{
3639:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3640:FreeRTOS/Source/tasks.c **** 			}
3641:FreeRTOS/Source/tasks.c **** 			#else
3642:FreeRTOS/Source/tasks.c **** 			{
3643:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3644:FreeRTOS/Source/tasks.c **** 			}
3645:FreeRTOS/Source/tasks.c **** 			#endif
3646:FreeRTOS/Source/tasks.c **** 		}
3647:FreeRTOS/Source/tasks.c **** 		else
3648:FreeRTOS/Source/tasks.c **** 		{
3649:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3650:FreeRTOS/Source/tasks.c **** 		}
3651:FreeRTOS/Source/tasks.c **** 	}
3652:FreeRTOS/Source/tasks.c **** 
3653:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3654:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3655:FreeRTOS/Source/tasks.c **** 
3656:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3657:FreeRTOS/Source/tasks.c **** 
3658:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3659:FreeRTOS/Source/tasks.c **** 	{
3660:FreeRTOS/Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3661:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3662:FreeRTOS/Source/tasks.c **** 
3663:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3664:FreeRTOS/Source/tasks.c **** 		{
3665:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3666:FreeRTOS/Source/tasks.c **** 
3667:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3668:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3669:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3670:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3671:FreeRTOS/Source/tasks.c **** 			do
3672:FreeRTOS/Source/tasks.c **** 			{
3673:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3674:FreeRTOS/Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3675:FreeRTOS/Source/tasks.c **** 				uxTask++;
3676:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3677:FreeRTOS/Source/tasks.c **** 		}
3678:FreeRTOS/Source/tasks.c **** 		else
3679:FreeRTOS/Source/tasks.c **** 		{
3680:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3681:FreeRTOS/Source/tasks.c **** 		}
3682:FreeRTOS/Source/tasks.c **** 
3683:FreeRTOS/Source/tasks.c **** 		return uxTask;
3684:FreeRTOS/Source/tasks.c **** 	}
3685:FreeRTOS/Source/tasks.c **** 
3686:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3687:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3688:FreeRTOS/Source/tasks.c **** 
3689:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3690:FreeRTOS/Source/tasks.c **** 
3691:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3692:FreeRTOS/Source/tasks.c **** 	{
3693:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3694:FreeRTOS/Source/tasks.c **** 
3695:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3696:FreeRTOS/Source/tasks.c **** 		{
3697:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3698:FreeRTOS/Source/tasks.c **** 			ulCount++;
3699:FreeRTOS/Source/tasks.c **** 		}
3700:FreeRTOS/Source/tasks.c **** 
3701:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3702:FreeRTOS/Source/tasks.c **** 
3703:FreeRTOS/Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3704:FreeRTOS/Source/tasks.c **** 	}
3705:FreeRTOS/Source/tasks.c **** 
3706:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3707:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3708:FreeRTOS/Source/tasks.c **** 
3709:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3710:FreeRTOS/Source/tasks.c **** 
3711:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3712:FreeRTOS/Source/tasks.c **** 	{
3713:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3714:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3715:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3716:FreeRTOS/Source/tasks.c **** 
3717:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3718:FreeRTOS/Source/tasks.c **** 
3719:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3720:FreeRTOS/Source/tasks.c **** 		{
3721:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3722:FreeRTOS/Source/tasks.c **** 		}
3723:FreeRTOS/Source/tasks.c **** 		#else
3724:FreeRTOS/Source/tasks.c **** 		{
3725:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3726:FreeRTOS/Source/tasks.c **** 		}
3727:FreeRTOS/Source/tasks.c **** 		#endif
3728:FreeRTOS/Source/tasks.c **** 
3729:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3730:FreeRTOS/Source/tasks.c **** 
3731:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3732:FreeRTOS/Source/tasks.c **** 	}
3733:FreeRTOS/Source/tasks.c **** 
3734:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3735:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3736:FreeRTOS/Source/tasks.c **** 
3737:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3738:FreeRTOS/Source/tasks.c **** 
3739:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3740:FreeRTOS/Source/tasks.c **** 	{
3741:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3742:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3743:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3744:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3745:FreeRTOS/Source/tasks.c **** 
3746:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3747:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3748:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3749:FreeRTOS/Source/tasks.c **** 		{
3750:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3751:FreeRTOS/Source/tasks.c **** 		}
3752:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3753:FreeRTOS/Source/tasks.c **** 
3754:FreeRTOS/Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3755:FreeRTOS/Source/tasks.c **** 		{
3756:FreeRTOS/Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3757:FreeRTOS/Source/tasks.c **** 			the stack and TCB. */
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3759:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
3760:FreeRTOS/Source/tasks.c **** 		}
3761:FreeRTOS/Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3762:FreeRTOS/Source/tasks.c **** 		{
3763:FreeRTOS/Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3764:FreeRTOS/Source/tasks.c **** 			check what was statically allocated before trying to free the
3765:FreeRTOS/Source/tasks.c **** 			memory. */
3766:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3767:FreeRTOS/Source/tasks.c **** 			{
3768:FreeRTOS/Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3769:FreeRTOS/Source/tasks.c **** 				must be freed. */
3770:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3771:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3772:FreeRTOS/Source/tasks.c **** 			}
3773:FreeRTOS/Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3774:FreeRTOS/Source/tasks.c **** 			{
3775:FreeRTOS/Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3776:FreeRTOS/Source/tasks.c **** 				only memory that must be freed. */
3777:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3778:FreeRTOS/Source/tasks.c **** 			}
3779:FreeRTOS/Source/tasks.c **** 			else
3780:FreeRTOS/Source/tasks.c **** 			{
3781:FreeRTOS/Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3782:FreeRTOS/Source/tasks.c **** 				nothing needs to be freed. */
3783:FreeRTOS/Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3784:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3785:FreeRTOS/Source/tasks.c **** 			}
3786:FreeRTOS/Source/tasks.c **** 		}
3787:FreeRTOS/Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3788:FreeRTOS/Source/tasks.c **** 	}
3789:FreeRTOS/Source/tasks.c **** 
3790:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3791:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3792:FreeRTOS/Source/tasks.c **** 
3793:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3794:FreeRTOS/Source/tasks.c **** {
 190               	.LM0:
 191               	.LFBB1:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
3795:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3796:FreeRTOS/Source/tasks.c **** 
3797:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 197               	.LM1:
 198 0000 E091 0000 		lds r30,pxDelayedTaskList
 199 0004 F091 0000 		lds r31,pxDelayedTaskList+1
 200 0008 8081      		ld r24,Z
 201 000a 8111      		cpse r24,__zero_reg__
 202 000c 00C0      		rjmp .L2
3798:FreeRTOS/Source/tasks.c **** 	{
3799:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3800:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3801:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3802:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3803:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 204               	.LM2:
 205 000e 8FEF      		ldi r24,lo8(-1)
 206 0010 9FEF      		ldi r25,lo8(-1)
 207 0012 00C0      		rjmp .L4
 208               	.L2:
 209               	.LBB6:
 210               	.LBB7:
3804:FreeRTOS/Source/tasks.c **** 	}
3805:FreeRTOS/Source/tasks.c **** 	else
3806:FreeRTOS/Source/tasks.c **** 	{
3807:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3808:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3809:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3810:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3811:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
 212               	.LM3:
 213 0014 E091 0000 		lds r30,pxDelayedTaskList
 214 0018 F091 0000 		lds r31,pxDelayedTaskList+1
 215 001c 0580      		ldd __tmp_reg__,Z+5
 216 001e F681      		ldd r31,Z+6
 217 0020 E02D      		mov r30,__tmp_reg__
3812:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 219               	.LM4:
 220 0022 0680      		ldd __tmp_reg__,Z+6
 221 0024 F781      		ldd r31,Z+7
 222 0026 E02D      		mov r30,__tmp_reg__
 223 0028 8281      		ldd r24,Z+2
 224 002a 9381      		ldd r25,Z+3
 225               	.L4:
 226 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 227 0030 8093 0000 		sts xNextTaskUnblockTime,r24
 228 0034 0895      		ret
 229               	.LBE7:
 230               	.LBE6:
 232               	.Lscope1:
 234               		.stabd	78,0,0
 239               	prvAddCurrentTaskToDelayedList:
 240               		.stabd	46,0,0
3813:FreeRTOS/Source/tasks.c **** 	}
3814:FreeRTOS/Source/tasks.c **** }
3815:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3816:FreeRTOS/Source/tasks.c **** 
3817:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3818:FreeRTOS/Source/tasks.c **** 
3819:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3820:FreeRTOS/Source/tasks.c **** 	{
3821:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3822:FreeRTOS/Source/tasks.c **** 
3823:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3824:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3825:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3826:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3827:FreeRTOS/Source/tasks.c **** 
3828:FreeRTOS/Source/tasks.c **** 		return xReturn;
3829:FreeRTOS/Source/tasks.c **** 	}
3830:FreeRTOS/Source/tasks.c **** 
3831:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3832:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3833:FreeRTOS/Source/tasks.c **** 
3834:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3835:FreeRTOS/Source/tasks.c **** 
3836:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3837:FreeRTOS/Source/tasks.c **** 	{
3838:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3839:FreeRTOS/Source/tasks.c **** 
3840:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3841:FreeRTOS/Source/tasks.c **** 		{
3842:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3843:FreeRTOS/Source/tasks.c **** 		}
3844:FreeRTOS/Source/tasks.c **** 		else
3845:FreeRTOS/Source/tasks.c **** 		{
3846:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3847:FreeRTOS/Source/tasks.c **** 			{
3848:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3849:FreeRTOS/Source/tasks.c **** 			}
3850:FreeRTOS/Source/tasks.c **** 			else
3851:FreeRTOS/Source/tasks.c **** 			{
3852:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3853:FreeRTOS/Source/tasks.c **** 			}
3854:FreeRTOS/Source/tasks.c **** 		}
3855:FreeRTOS/Source/tasks.c **** 
3856:FreeRTOS/Source/tasks.c **** 		return xReturn;
3857:FreeRTOS/Source/tasks.c **** 	}
3858:FreeRTOS/Source/tasks.c **** 
3859:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3860:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3861:FreeRTOS/Source/tasks.c **** 
3862:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3863:FreeRTOS/Source/tasks.c **** 
3864:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3865:FreeRTOS/Source/tasks.c **** 	{
3866:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
3867:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3868:FreeRTOS/Source/tasks.c **** 
3869:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3870:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3871:FreeRTOS/Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3872:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3873:FreeRTOS/Source/tasks.c **** 		{
3874:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3875:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3876:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3877:FreeRTOS/Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3878:FreeRTOS/Source/tasks.c **** 			{
3879:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3880:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3881:FreeRTOS/Source/tasks.c **** 				not being used for anything else. */
3882:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3883:FreeRTOS/Source/tasks.c **** 				{
3884:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3885:FreeRTOS/Source/tasks.c **** 				}
3886:FreeRTOS/Source/tasks.c **** 				else
3887:FreeRTOS/Source/tasks.c **** 				{
3888:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3889:FreeRTOS/Source/tasks.c **** 				}
3890:FreeRTOS/Source/tasks.c **** 
3891:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3892:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
3893:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3894:FreeRTOS/Source/tasks.c **** 				{
3895:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3896:FreeRTOS/Source/tasks.c **** 					{
3897:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3898:FreeRTOS/Source/tasks.c **** 					}
3899:FreeRTOS/Source/tasks.c **** 					else
3900:FreeRTOS/Source/tasks.c **** 					{
3901:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3902:FreeRTOS/Source/tasks.c **** 					}
3903:FreeRTOS/Source/tasks.c **** 
3904:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3905:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3906:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3907:FreeRTOS/Source/tasks.c **** 				}
3908:FreeRTOS/Source/tasks.c **** 				else
3909:FreeRTOS/Source/tasks.c **** 				{
3910:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3911:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3912:FreeRTOS/Source/tasks.c **** 				}
3913:FreeRTOS/Source/tasks.c **** 
3914:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3915:FreeRTOS/Source/tasks.c **** 
3916:FreeRTOS/Source/tasks.c **** 				/* Inheritance occurred. */
3917:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3918:FreeRTOS/Source/tasks.c **** 			}
3919:FreeRTOS/Source/tasks.c **** 			else
3920:FreeRTOS/Source/tasks.c **** 			{
3921:FreeRTOS/Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3922:FreeRTOS/Source/tasks.c **** 				{
3923:FreeRTOS/Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3924:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
3925:FreeRTOS/Source/tasks.c **** 					current priority of the mutex holder is not lower than the
3926:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex.
3927:FreeRTOS/Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
3928:FreeRTOS/Source/tasks.c **** 					priority, but inheritance would have occurred if that had
3929:FreeRTOS/Source/tasks.c **** 					not been the case. */
3930:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
3931:FreeRTOS/Source/tasks.c **** 				}
3932:FreeRTOS/Source/tasks.c **** 				else
3933:FreeRTOS/Source/tasks.c **** 				{
3934:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3935:FreeRTOS/Source/tasks.c **** 				}
3936:FreeRTOS/Source/tasks.c **** 			}
3937:FreeRTOS/Source/tasks.c **** 		}
3938:FreeRTOS/Source/tasks.c **** 		else
3939:FreeRTOS/Source/tasks.c **** 		{
3940:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3941:FreeRTOS/Source/tasks.c **** 		}
3942:FreeRTOS/Source/tasks.c **** 
3943:FreeRTOS/Source/tasks.c **** 		return xReturn;
3944:FreeRTOS/Source/tasks.c **** 	}
3945:FreeRTOS/Source/tasks.c **** 
3946:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3947:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3948:FreeRTOS/Source/tasks.c **** 
3949:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3950:FreeRTOS/Source/tasks.c **** 
3951:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3952:FreeRTOS/Source/tasks.c **** 	{
3953:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
3954:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3955:FreeRTOS/Source/tasks.c **** 
3956:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3957:FreeRTOS/Source/tasks.c **** 		{
3958:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3959:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3960:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3961:FreeRTOS/Source/tasks.c **** 			be the running state task. */
3962:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3963:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3964:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3965:FreeRTOS/Source/tasks.c **** 
3966:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3967:FreeRTOS/Source/tasks.c **** 			task? */
3968:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3969:FreeRTOS/Source/tasks.c **** 			{
3970:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3971:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3972:FreeRTOS/Source/tasks.c **** 				{
3973:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3974:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3975:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3976:FreeRTOS/Source/tasks.c **** 					holding task then it must be the running state task.  Remove
3977:FreeRTOS/Source/tasks.c **** 					the holding task from the ready list. */
3978:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3979:FreeRTOS/Source/tasks.c **** 					{
3980:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3981:FreeRTOS/Source/tasks.c **** 					}
3982:FreeRTOS/Source/tasks.c **** 					else
3983:FreeRTOS/Source/tasks.c **** 					{
3984:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3985:FreeRTOS/Source/tasks.c **** 					}
3986:FreeRTOS/Source/tasks.c **** 
3987:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3988:FreeRTOS/Source/tasks.c **** 					new	ready list. */
3989:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3990:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3991:FreeRTOS/Source/tasks.c **** 
3992:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3993:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3994:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3995:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3996:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3997:FreeRTOS/Source/tasks.c **** 
3998:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3999:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
4000:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4001:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
4002:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4003:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4004:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4005:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
4006:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4007:FreeRTOS/Source/tasks.c **** 				}
4008:FreeRTOS/Source/tasks.c **** 				else
4009:FreeRTOS/Source/tasks.c **** 				{
4010:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4011:FreeRTOS/Source/tasks.c **** 				}
4012:FreeRTOS/Source/tasks.c **** 			}
4013:FreeRTOS/Source/tasks.c **** 			else
4014:FreeRTOS/Source/tasks.c **** 			{
4015:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4016:FreeRTOS/Source/tasks.c **** 			}
4017:FreeRTOS/Source/tasks.c **** 		}
4018:FreeRTOS/Source/tasks.c **** 		else
4019:FreeRTOS/Source/tasks.c **** 		{
4020:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4021:FreeRTOS/Source/tasks.c **** 		}
4022:FreeRTOS/Source/tasks.c **** 
4023:FreeRTOS/Source/tasks.c **** 		return xReturn;
4024:FreeRTOS/Source/tasks.c **** 	}
4025:FreeRTOS/Source/tasks.c **** 
4026:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4027:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4028:FreeRTOS/Source/tasks.c **** 
4029:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4030:FreeRTOS/Source/tasks.c **** 
4031:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4032:FreeRTOS/Source/tasks.c **** 	{
4033:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4034:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4035:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4036:FreeRTOS/Source/tasks.c **** 
4037:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4038:FreeRTOS/Source/tasks.c **** 		{
4039:FreeRTOS/Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4040:FreeRTOS/Source/tasks.c **** 			one mutex. */
4041:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4042:FreeRTOS/Source/tasks.c **** 
4043:FreeRTOS/Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4044:FreeRTOS/Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4045:FreeRTOS/Source/tasks.c **** 			holding task's base priority and the priority of the highest
4046:FreeRTOS/Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4047:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4048:FreeRTOS/Source/tasks.c **** 			{
4049:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4050:FreeRTOS/Source/tasks.c **** 			}
4051:FreeRTOS/Source/tasks.c **** 			else
4052:FreeRTOS/Source/tasks.c **** 			{
4053:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4054:FreeRTOS/Source/tasks.c **** 			}
4055:FreeRTOS/Source/tasks.c **** 
4056:FreeRTOS/Source/tasks.c **** 			/* Does the priority need to change? */
4057:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4058:FreeRTOS/Source/tasks.c **** 			{
4059:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4060:FreeRTOS/Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4061:FreeRTOS/Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4062:FreeRTOS/Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4063:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4064:FreeRTOS/Source/tasks.c **** 				{
4065:FreeRTOS/Source/tasks.c **** 					/* If a task has timed out because it already holds the
4066:FreeRTOS/Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4067:FreeRTOS/Source/tasks.c **** 					its own priority. */
4068:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4069:FreeRTOS/Source/tasks.c **** 
4070:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4071:FreeRTOS/Source/tasks.c **** 					priority to facilitate determining the subject task's
4072:FreeRTOS/Source/tasks.c **** 					state. */
4073:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4074:FreeRTOS/Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4075:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4076:FreeRTOS/Source/tasks.c **** 
4077:FreeRTOS/Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4078:FreeRTOS/Source/tasks.c **** 					being used for anything else. */
4079:FreeRTOS/Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4080:FreeRTOS/Source/tasks.c **** 					{
4081:FreeRTOS/Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4082:FreeRTOS/Source/tasks.c **** 					}
4083:FreeRTOS/Source/tasks.c **** 					else
4084:FreeRTOS/Source/tasks.c **** 					{
4085:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4086:FreeRTOS/Source/tasks.c **** 					}
4087:FreeRTOS/Source/tasks.c **** 
4088:FreeRTOS/Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4089:FreeRTOS/Source/tasks.c **** 					then the task that holds the mutex could be in either the
4090:FreeRTOS/Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4091:FreeRTOS/Source/tasks.c **** 					from its current state list if it is in the Ready state as
4092:FreeRTOS/Source/tasks.c **** 					the task's priority is going to change and there is one
4093:FreeRTOS/Source/tasks.c **** 					Ready list per priority. */
4094:FreeRTOS/Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4095:FreeRTOS/Source/tasks.c **** 					{
4096:FreeRTOS/Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4097:FreeRTOS/Source/tasks.c **** 						{
4098:FreeRTOS/Source/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4099:FreeRTOS/Source/tasks.c **** 						}
4100:FreeRTOS/Source/tasks.c **** 						else
4101:FreeRTOS/Source/tasks.c **** 						{
4102:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4103:FreeRTOS/Source/tasks.c **** 						}
4104:FreeRTOS/Source/tasks.c **** 
4105:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4106:FreeRTOS/Source/tasks.c **** 					}
4107:FreeRTOS/Source/tasks.c **** 					else
4108:FreeRTOS/Source/tasks.c **** 					{
4109:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4110:FreeRTOS/Source/tasks.c **** 					}
4111:FreeRTOS/Source/tasks.c **** 				}
4112:FreeRTOS/Source/tasks.c **** 				else
4113:FreeRTOS/Source/tasks.c **** 				{
4114:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4115:FreeRTOS/Source/tasks.c **** 				}
4116:FreeRTOS/Source/tasks.c **** 			}
4117:FreeRTOS/Source/tasks.c **** 			else
4118:FreeRTOS/Source/tasks.c **** 			{
4119:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4120:FreeRTOS/Source/tasks.c **** 			}
4121:FreeRTOS/Source/tasks.c **** 		}
4122:FreeRTOS/Source/tasks.c **** 		else
4123:FreeRTOS/Source/tasks.c **** 		{
4124:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4125:FreeRTOS/Source/tasks.c **** 		}
4126:FreeRTOS/Source/tasks.c **** 	}
4127:FreeRTOS/Source/tasks.c **** 
4128:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4129:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4130:FreeRTOS/Source/tasks.c **** 
4131:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4132:FreeRTOS/Source/tasks.c **** 
4133:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
4134:FreeRTOS/Source/tasks.c **** 	{
4135:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4136:FreeRTOS/Source/tasks.c **** 
4137:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4138:FreeRTOS/Source/tasks.c **** 		{
4139:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4140:FreeRTOS/Source/tasks.c **** 
4141:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4142:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4143:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4144:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4145:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4146:FreeRTOS/Source/tasks.c **** 			critical section. */
4147:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4148:FreeRTOS/Source/tasks.c **** 			{
4149:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4150:FreeRTOS/Source/tasks.c **** 			}
4151:FreeRTOS/Source/tasks.c **** 		}
4152:FreeRTOS/Source/tasks.c **** 		else
4153:FreeRTOS/Source/tasks.c **** 		{
4154:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4155:FreeRTOS/Source/tasks.c **** 		}
4156:FreeRTOS/Source/tasks.c **** 	}
4157:FreeRTOS/Source/tasks.c **** 
4158:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4159:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4160:FreeRTOS/Source/tasks.c **** 
4161:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4162:FreeRTOS/Source/tasks.c **** 
4163:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
4164:FreeRTOS/Source/tasks.c **** 	{
4165:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4166:FreeRTOS/Source/tasks.c **** 		{
4167:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4168:FreeRTOS/Source/tasks.c **** 			{
4169:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4170:FreeRTOS/Source/tasks.c **** 
4171:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4172:FreeRTOS/Source/tasks.c **** 				{
4173:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
4174:FreeRTOS/Source/tasks.c **** 				}
4175:FreeRTOS/Source/tasks.c **** 				else
4176:FreeRTOS/Source/tasks.c **** 				{
4177:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4178:FreeRTOS/Source/tasks.c **** 				}
4179:FreeRTOS/Source/tasks.c **** 			}
4180:FreeRTOS/Source/tasks.c **** 			else
4181:FreeRTOS/Source/tasks.c **** 			{
4182:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4183:FreeRTOS/Source/tasks.c **** 			}
4184:FreeRTOS/Source/tasks.c **** 		}
4185:FreeRTOS/Source/tasks.c **** 		else
4186:FreeRTOS/Source/tasks.c **** 		{
4187:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4188:FreeRTOS/Source/tasks.c **** 		}
4189:FreeRTOS/Source/tasks.c **** 	}
4190:FreeRTOS/Source/tasks.c **** 
4191:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4192:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4193:FreeRTOS/Source/tasks.c **** 
4194:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4195:FreeRTOS/Source/tasks.c **** 
4196:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4197:FreeRTOS/Source/tasks.c **** 	{
4198:FreeRTOS/Source/tasks.c **** 	size_t x;
4199:FreeRTOS/Source/tasks.c **** 
4200:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
4201:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4202:FreeRTOS/Source/tasks.c **** 
4203:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4204:FreeRTOS/Source/tasks.c **** 		printed out. */
4205:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4206:FreeRTOS/Source/tasks.c **** 		{
4207:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4208:FreeRTOS/Source/tasks.c **** 		}
4209:FreeRTOS/Source/tasks.c **** 
4210:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
4211:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4212:FreeRTOS/Source/tasks.c **** 
4213:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
4214:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
4215:FreeRTOS/Source/tasks.c **** 	}
4216:FreeRTOS/Source/tasks.c **** 
4217:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4218:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4219:FreeRTOS/Source/tasks.c **** 
4220:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4221:FreeRTOS/Source/tasks.c **** 
4222:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4223:FreeRTOS/Source/tasks.c **** 	{
4224:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4225:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4226:FreeRTOS/Source/tasks.c **** 	char cStatus;
4227:FreeRTOS/Source/tasks.c **** 
4228:FreeRTOS/Source/tasks.c **** 		/*
4229:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4230:FreeRTOS/Source/tasks.c **** 		 *
4231:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4232:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4233:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4234:FreeRTOS/Source/tasks.c **** 		 *
4235:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4236:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4237:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
4238:FreeRTOS/Source/tasks.c **** 		 *
4239:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4240:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4241:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4242:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4243:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4244:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4245:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
4246:FreeRTOS/Source/tasks.c **** 		 *
4247:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4248:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4249:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
4250:FreeRTOS/Source/tasks.c **** 		 */
4251:FreeRTOS/Source/tasks.c **** 
4252:FreeRTOS/Source/tasks.c **** 
4253:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4254:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4255:FreeRTOS/Source/tasks.c **** 
4256:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4257:FreeRTOS/Source/tasks.c **** 		function is executing. */
4258:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4259:FreeRTOS/Source/tasks.c **** 
4260:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4261:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4262:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4263:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4264:FreeRTOS/Source/tasks.c **** 
4265:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4266:FreeRTOS/Source/tasks.c **** 		{
4267:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4268:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4269:FreeRTOS/Source/tasks.c **** 
4270:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4271:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4272:FreeRTOS/Source/tasks.c **** 			{
4273:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4274:FreeRTOS/Source/tasks.c **** 				{
4275:FreeRTOS/Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4276:FreeRTOS/Source/tasks.c **** 										break;
4277:FreeRTOS/Source/tasks.c **** 
4278:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4279:FreeRTOS/Source/tasks.c **** 										break;
4280:FreeRTOS/Source/tasks.c **** 
4281:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4282:FreeRTOS/Source/tasks.c **** 										break;
4283:FreeRTOS/Source/tasks.c **** 
4284:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4285:FreeRTOS/Source/tasks.c **** 										break;
4286:FreeRTOS/Source/tasks.c **** 
4287:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4288:FreeRTOS/Source/tasks.c **** 										break;
4289:FreeRTOS/Source/tasks.c **** 
4290:FreeRTOS/Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4291:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
4292:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
4293:FreeRTOS/Source/tasks.c **** 										cStatus = ( char ) 0x00;
4294:FreeRTOS/Source/tasks.c **** 										break;
4295:FreeRTOS/Source/tasks.c **** 				}
4296:FreeRTOS/Source/tasks.c **** 
4297:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4298:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
4299:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4300:FreeRTOS/Source/tasks.c **** 
4301:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
4302:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4303:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4304:FreeRTOS/Source/tasks.c **** 			}
4305:FreeRTOS/Source/tasks.c **** 
4306:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4307:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4308:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4309:FreeRTOS/Source/tasks.c **** 		}
4310:FreeRTOS/Source/tasks.c **** 		else
4311:FreeRTOS/Source/tasks.c **** 		{
4312:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4313:FreeRTOS/Source/tasks.c **** 		}
4314:FreeRTOS/Source/tasks.c **** 	}
4315:FreeRTOS/Source/tasks.c **** 
4316:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4317:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4318:FreeRTOS/Source/tasks.c **** 
4319:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4320:FreeRTOS/Source/tasks.c **** 
4321:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4322:FreeRTOS/Source/tasks.c **** 	{
4323:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4324:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4325:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4326:FreeRTOS/Source/tasks.c **** 
4327:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4328:FreeRTOS/Source/tasks.c **** 		{
4329:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4330:FreeRTOS/Source/tasks.c **** 		}
4331:FreeRTOS/Source/tasks.c **** 		#endif
4332:FreeRTOS/Source/tasks.c **** 
4333:FreeRTOS/Source/tasks.c **** 		/*
4334:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4335:FreeRTOS/Source/tasks.c **** 		 *
4336:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4337:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4338:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4339:FreeRTOS/Source/tasks.c **** 		 *
4340:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4341:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4342:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4343:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
4344:FreeRTOS/Source/tasks.c **** 		 *
4345:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4346:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4347:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4348:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4349:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4350:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4351:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
4352:FreeRTOS/Source/tasks.c **** 		 *
4353:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4354:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4355:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4356:FreeRTOS/Source/tasks.c **** 		 */
4357:FreeRTOS/Source/tasks.c **** 
4358:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4359:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4360:FreeRTOS/Source/tasks.c **** 
4361:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4362:FreeRTOS/Source/tasks.c **** 		function is executing. */
4363:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4364:FreeRTOS/Source/tasks.c **** 
4365:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4366:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4367:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4368:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4369:FreeRTOS/Source/tasks.c **** 
4370:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4371:FreeRTOS/Source/tasks.c **** 		{
4372:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4373:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4374:FreeRTOS/Source/tasks.c **** 
4375:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
4376:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
4377:FreeRTOS/Source/tasks.c **** 
4378:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
4379:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0UL )
4380:FreeRTOS/Source/tasks.c **** 			{
4381:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4382:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4383:FreeRTOS/Source/tasks.c **** 				{
4384:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4385:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4386:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4387:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4388:FreeRTOS/Source/tasks.c **** 
4389:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
4390:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
4391:FreeRTOS/Source/tasks.c **** 					easily. */
4392:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4393:FreeRTOS/Source/tasks.c **** 
4394:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4395:FreeRTOS/Source/tasks.c **** 					{
4396:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4397:FreeRTOS/Source/tasks.c **** 						{
4398:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4399:FreeRTOS/Source/tasks.c **** 						}
4400:FreeRTOS/Source/tasks.c **** 						#else
4401:FreeRTOS/Source/tasks.c **** 						{
4402:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4403:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4404:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4405:FreeRTOS/Source/tasks.c **** 						}
4406:FreeRTOS/Source/tasks.c **** 						#endif
4407:FreeRTOS/Source/tasks.c **** 					}
4408:FreeRTOS/Source/tasks.c **** 					else
4409:FreeRTOS/Source/tasks.c **** 					{
4410:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
4411:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
4412:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4413:FreeRTOS/Source/tasks.c **** 						{
4414:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4415:FreeRTOS/Source/tasks.c **** 						}
4416:FreeRTOS/Source/tasks.c **** 						#else
4417:FreeRTOS/Source/tasks.c **** 						{
4418:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4419:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4420:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4421:FreeRTOS/Source/tasks.c **** 						}
4422:FreeRTOS/Source/tasks.c **** 						#endif
4423:FreeRTOS/Source/tasks.c **** 					}
4424:FreeRTOS/Source/tasks.c **** 
4425:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4426:FreeRTOS/Source/tasks.c **** 				}
4427:FreeRTOS/Source/tasks.c **** 			}
4428:FreeRTOS/Source/tasks.c **** 			else
4429:FreeRTOS/Source/tasks.c **** 			{
4430:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4431:FreeRTOS/Source/tasks.c **** 			}
4432:FreeRTOS/Source/tasks.c **** 
4433:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4434:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4435:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4436:FreeRTOS/Source/tasks.c **** 		}
4437:FreeRTOS/Source/tasks.c **** 		else
4438:FreeRTOS/Source/tasks.c **** 		{
4439:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4440:FreeRTOS/Source/tasks.c **** 		}
4441:FreeRTOS/Source/tasks.c **** 	}
4442:FreeRTOS/Source/tasks.c **** 
4443:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4444:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4445:FreeRTOS/Source/tasks.c **** 
4446:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4447:FreeRTOS/Source/tasks.c **** {
4448:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
4449:FreeRTOS/Source/tasks.c **** 
4450:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4451:FreeRTOS/Source/tasks.c **** 
4452:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4453:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
4454:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4455:FreeRTOS/Source/tasks.c **** 
4456:FreeRTOS/Source/tasks.c **** 	return uxReturn;
4457:FreeRTOS/Source/tasks.c **** }
4458:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4459:FreeRTOS/Source/tasks.c **** 
4460:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4461:FreeRTOS/Source/tasks.c **** 
4462:FreeRTOS/Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4463:FreeRTOS/Source/tasks.c **** 	{
4464:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4465:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4466:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4467:FreeRTOS/Source/tasks.c **** 		{
4468:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4469:FreeRTOS/Source/tasks.c **** 		}
4470:FreeRTOS/Source/tasks.c **** 
4471:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
4472:FreeRTOS/Source/tasks.c **** 	}
4473:FreeRTOS/Source/tasks.c **** 
4474:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4475:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4476:FreeRTOS/Source/tasks.c **** 
4477:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4478:FreeRTOS/Source/tasks.c **** 
4479:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4480:FreeRTOS/Source/tasks.c **** 	{
4481:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
4482:FreeRTOS/Source/tasks.c **** 
4483:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4484:FreeRTOS/Source/tasks.c **** 		{
4485:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4486:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4487:FreeRTOS/Source/tasks.c **** 			{
4488:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4489:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4490:FreeRTOS/Source/tasks.c **** 
4491:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4492:FreeRTOS/Source/tasks.c **** 				{
4493:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4494:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4495:FreeRTOS/Source/tasks.c **** 
4496:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4497:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4498:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4499:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4500:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4501:FreeRTOS/Source/tasks.c **** 				}
4502:FreeRTOS/Source/tasks.c **** 				else
4503:FreeRTOS/Source/tasks.c **** 				{
4504:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4505:FreeRTOS/Source/tasks.c **** 				}
4506:FreeRTOS/Source/tasks.c **** 			}
4507:FreeRTOS/Source/tasks.c **** 			else
4508:FreeRTOS/Source/tasks.c **** 			{
4509:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4510:FreeRTOS/Source/tasks.c **** 			}
4511:FreeRTOS/Source/tasks.c **** 		}
4512:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4513:FreeRTOS/Source/tasks.c **** 
4514:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4515:FreeRTOS/Source/tasks.c **** 		{
4516:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4517:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4518:FreeRTOS/Source/tasks.c **** 
4519:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
4520:FreeRTOS/Source/tasks.c **** 			{
4521:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4522:FreeRTOS/Source/tasks.c **** 				{
4523:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4524:FreeRTOS/Source/tasks.c **** 				}
4525:FreeRTOS/Source/tasks.c **** 				else
4526:FreeRTOS/Source/tasks.c **** 				{
4527:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4528:FreeRTOS/Source/tasks.c **** 				}
4529:FreeRTOS/Source/tasks.c **** 			}
4530:FreeRTOS/Source/tasks.c **** 			else
4531:FreeRTOS/Source/tasks.c **** 			{
4532:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4533:FreeRTOS/Source/tasks.c **** 			}
4534:FreeRTOS/Source/tasks.c **** 
4535:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4536:FreeRTOS/Source/tasks.c **** 		}
4537:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4538:FreeRTOS/Source/tasks.c **** 
4539:FreeRTOS/Source/tasks.c **** 		return ulReturn;
4540:FreeRTOS/Source/tasks.c **** 	}
4541:FreeRTOS/Source/tasks.c **** 
4542:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4543:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4544:FreeRTOS/Source/tasks.c **** 
4545:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4546:FreeRTOS/Source/tasks.c **** 
4547:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4548:FreeRTOS/Source/tasks.c **** 	{
4549:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4550:FreeRTOS/Source/tasks.c **** 
4551:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4552:FreeRTOS/Source/tasks.c **** 		{
4553:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4554:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4555:FreeRTOS/Source/tasks.c **** 			{
4556:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4557:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4558:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4559:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4560:FreeRTOS/Source/tasks.c **** 
4561:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4562:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4563:FreeRTOS/Source/tasks.c **** 
4564:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4565:FreeRTOS/Source/tasks.c **** 				{
4566:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4567:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4568:FreeRTOS/Source/tasks.c **** 
4569:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4570:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4571:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4572:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4573:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4574:FreeRTOS/Source/tasks.c **** 				}
4575:FreeRTOS/Source/tasks.c **** 				else
4576:FreeRTOS/Source/tasks.c **** 				{
4577:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4578:FreeRTOS/Source/tasks.c **** 				}
4579:FreeRTOS/Source/tasks.c **** 			}
4580:FreeRTOS/Source/tasks.c **** 			else
4581:FreeRTOS/Source/tasks.c **** 			{
4582:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4583:FreeRTOS/Source/tasks.c **** 			}
4584:FreeRTOS/Source/tasks.c **** 		}
4585:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4586:FreeRTOS/Source/tasks.c **** 
4587:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4588:FreeRTOS/Source/tasks.c **** 		{
4589:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4590:FreeRTOS/Source/tasks.c **** 
4591:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
4592:FreeRTOS/Source/tasks.c **** 			{
4593:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4594:FreeRTOS/Source/tasks.c **** 				have changed. */
4595:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4596:FreeRTOS/Source/tasks.c **** 			}
4597:FreeRTOS/Source/tasks.c **** 
4598:FreeRTOS/Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4599:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4600:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4601:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4602:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4603:FreeRTOS/Source/tasks.c **** 			{
4604:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4605:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4606:FreeRTOS/Source/tasks.c **** 			}
4607:FreeRTOS/Source/tasks.c **** 			else
4608:FreeRTOS/Source/tasks.c **** 			{
4609:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4610:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4611:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4612:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4613:FreeRTOS/Source/tasks.c **** 			}
4614:FreeRTOS/Source/tasks.c **** 
4615:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4616:FreeRTOS/Source/tasks.c **** 		}
4617:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4618:FreeRTOS/Source/tasks.c **** 
4619:FreeRTOS/Source/tasks.c **** 		return xReturn;
4620:FreeRTOS/Source/tasks.c **** 	}
4621:FreeRTOS/Source/tasks.c **** 
4622:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4623:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4624:FreeRTOS/Source/tasks.c **** 
4625:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4626:FreeRTOS/Source/tasks.c **** 
4627:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4628:FreeRTOS/Source/tasks.c **** 	{
4629:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4630:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4631:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4632:FreeRTOS/Source/tasks.c **** 
4633:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4634:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4635:FreeRTOS/Source/tasks.c **** 
4636:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4637:FreeRTOS/Source/tasks.c **** 		{
4638:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4639:FreeRTOS/Source/tasks.c **** 			{
4640:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4641:FreeRTOS/Source/tasks.c **** 			}
4642:FreeRTOS/Source/tasks.c **** 
4643:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4644:FreeRTOS/Source/tasks.c **** 
4645:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4646:FreeRTOS/Source/tasks.c **** 
4647:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4648:FreeRTOS/Source/tasks.c **** 			{
4649:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4650:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4651:FreeRTOS/Source/tasks.c **** 					break;
4652:FreeRTOS/Source/tasks.c **** 
4653:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4654:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4655:FreeRTOS/Source/tasks.c **** 					break;
4656:FreeRTOS/Source/tasks.c **** 
4657:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4658:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4659:FreeRTOS/Source/tasks.c **** 					break;
4660:FreeRTOS/Source/tasks.c **** 
4661:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4662:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4663:FreeRTOS/Source/tasks.c **** 					{
4664:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4665:FreeRTOS/Source/tasks.c **** 					}
4666:FreeRTOS/Source/tasks.c **** 					else
4667:FreeRTOS/Source/tasks.c **** 					{
4668:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4669:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4670:FreeRTOS/Source/tasks.c **** 					}
4671:FreeRTOS/Source/tasks.c **** 					break;
4672:FreeRTOS/Source/tasks.c **** 
4673:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4674:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4675:FreeRTOS/Source/tasks.c **** 					updated. */
4676:FreeRTOS/Source/tasks.c **** 					break;
4677:FreeRTOS/Source/tasks.c **** 
4678:FreeRTOS/Source/tasks.c **** 				default:
4679:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4680:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4681:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4682:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4683:FreeRTOS/Source/tasks.c **** 
4684:FreeRTOS/Source/tasks.c **** 					break;
4685:FreeRTOS/Source/tasks.c **** 			}
4686:FreeRTOS/Source/tasks.c **** 
4687:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4688:FreeRTOS/Source/tasks.c **** 
4689:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4690:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4691:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4692:FreeRTOS/Source/tasks.c **** 			{
4693:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4694:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4695:FreeRTOS/Source/tasks.c **** 
4696:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4697:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4698:FreeRTOS/Source/tasks.c **** 
4699:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4700:FreeRTOS/Source/tasks.c **** 				{
4701:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4702:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4703:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4704:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4705:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4706:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4707:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4708:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4709:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4710:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4711:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4712:FreeRTOS/Source/tasks.c **** 				}
4713:FreeRTOS/Source/tasks.c **** 				#endif
4714:FreeRTOS/Source/tasks.c **** 
4715:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4716:FreeRTOS/Source/tasks.c **** 				{
4717:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4718:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4719:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4720:FreeRTOS/Source/tasks.c **** 				}
4721:FreeRTOS/Source/tasks.c **** 				else
4722:FreeRTOS/Source/tasks.c **** 				{
4723:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4724:FreeRTOS/Source/tasks.c **** 				}
4725:FreeRTOS/Source/tasks.c **** 			}
4726:FreeRTOS/Source/tasks.c **** 			else
4727:FreeRTOS/Source/tasks.c **** 			{
4728:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4729:FreeRTOS/Source/tasks.c **** 			}
4730:FreeRTOS/Source/tasks.c **** 		}
4731:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4732:FreeRTOS/Source/tasks.c **** 
4733:FreeRTOS/Source/tasks.c **** 		return xReturn;
4734:FreeRTOS/Source/tasks.c **** 	}
4735:FreeRTOS/Source/tasks.c **** 
4736:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4737:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4738:FreeRTOS/Source/tasks.c **** 
4739:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4740:FreeRTOS/Source/tasks.c **** 
4741:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4742:FreeRTOS/Source/tasks.c **** 	{
4743:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4744:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4745:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4746:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4747:FreeRTOS/Source/tasks.c **** 
4748:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4749:FreeRTOS/Source/tasks.c **** 
4750:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4751:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4752:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4753:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4754:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4755:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4756:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4757:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4758:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4759:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4760:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4761:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4762:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4763:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4764:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4765:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4766:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4767:FreeRTOS/Source/tasks.c **** 
4768:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4769:FreeRTOS/Source/tasks.c **** 
4770:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4771:FreeRTOS/Source/tasks.c **** 		{
4772:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4773:FreeRTOS/Source/tasks.c **** 			{
4774:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4775:FreeRTOS/Source/tasks.c **** 			}
4776:FreeRTOS/Source/tasks.c **** 
4777:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4778:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4779:FreeRTOS/Source/tasks.c **** 
4780:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4781:FreeRTOS/Source/tasks.c **** 			{
4782:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4783:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4784:FreeRTOS/Source/tasks.c **** 					break;
4785:FreeRTOS/Source/tasks.c **** 
4786:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4787:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4788:FreeRTOS/Source/tasks.c **** 					break;
4789:FreeRTOS/Source/tasks.c **** 
4790:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4791:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4792:FreeRTOS/Source/tasks.c **** 					break;
4793:FreeRTOS/Source/tasks.c **** 
4794:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4795:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4796:FreeRTOS/Source/tasks.c **** 					{
4797:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4798:FreeRTOS/Source/tasks.c **** 					}
4799:FreeRTOS/Source/tasks.c **** 					else
4800:FreeRTOS/Source/tasks.c **** 					{
4801:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4802:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4803:FreeRTOS/Source/tasks.c **** 					}
4804:FreeRTOS/Source/tasks.c **** 					break;
4805:FreeRTOS/Source/tasks.c **** 
4806:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4807:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4808:FreeRTOS/Source/tasks.c **** 					updated. */
4809:FreeRTOS/Source/tasks.c **** 					break;
4810:FreeRTOS/Source/tasks.c **** 
4811:FreeRTOS/Source/tasks.c **** 				default:
4812:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4813:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4814:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4815:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4816:FreeRTOS/Source/tasks.c **** 					break;
4817:FreeRTOS/Source/tasks.c **** 			}
4818:FreeRTOS/Source/tasks.c **** 
4819:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4820:FreeRTOS/Source/tasks.c **** 
4821:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4822:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4823:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4824:FreeRTOS/Source/tasks.c **** 			{
4825:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4826:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4827:FreeRTOS/Source/tasks.c **** 
4828:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4829:FreeRTOS/Source/tasks.c **** 				{
4830:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4831:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4832:FreeRTOS/Source/tasks.c **** 				}
4833:FreeRTOS/Source/tasks.c **** 				else
4834:FreeRTOS/Source/tasks.c **** 				{
4835:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4836:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4837:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4838:FreeRTOS/Source/tasks.c **** 				}
4839:FreeRTOS/Source/tasks.c **** 
4840:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4841:FreeRTOS/Source/tasks.c **** 				{
4842:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4843:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4844:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4845:FreeRTOS/Source/tasks.c **** 					{
4846:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4847:FreeRTOS/Source/tasks.c **** 					}
4848:FreeRTOS/Source/tasks.c **** 
4849:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4850:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
4851:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
4852:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
4853:FreeRTOS/Source/tasks.c **** 				}
4854:FreeRTOS/Source/tasks.c **** 				else
4855:FreeRTOS/Source/tasks.c **** 				{
4856:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4857:FreeRTOS/Source/tasks.c **** 				}
4858:FreeRTOS/Source/tasks.c **** 			}
4859:FreeRTOS/Source/tasks.c **** 		}
4860:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4861:FreeRTOS/Source/tasks.c **** 
4862:FreeRTOS/Source/tasks.c **** 		return xReturn;
4863:FreeRTOS/Source/tasks.c **** 	}
4864:FreeRTOS/Source/tasks.c **** 
4865:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4867:FreeRTOS/Source/tasks.c **** 
4868:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4869:FreeRTOS/Source/tasks.c **** 
4870:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4871:FreeRTOS/Source/tasks.c **** 	{
4872:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4873:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4874:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4875:FreeRTOS/Source/tasks.c **** 
4876:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4877:FreeRTOS/Source/tasks.c **** 
4878:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4879:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4880:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4881:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4882:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4883:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4884:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4885:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4886:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4887:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4888:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4889:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4890:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4891:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4892:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4893:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4894:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4895:FreeRTOS/Source/tasks.c **** 
4896:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4897:FreeRTOS/Source/tasks.c **** 
4898:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4899:FreeRTOS/Source/tasks.c **** 		{
4900:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4901:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4902:FreeRTOS/Source/tasks.c **** 
4903:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4904:FreeRTOS/Source/tasks.c **** 			semaphore. */
4905:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4906:FreeRTOS/Source/tasks.c **** 
4907:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4908:FreeRTOS/Source/tasks.c **** 
4909:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4910:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4911:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4912:FreeRTOS/Source/tasks.c **** 			{
4913:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4914:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4915:FreeRTOS/Source/tasks.c **** 
4916:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4917:FreeRTOS/Source/tasks.c **** 				{
4918:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4919:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4920:FreeRTOS/Source/tasks.c **** 				}
4921:FreeRTOS/Source/tasks.c **** 				else
4922:FreeRTOS/Source/tasks.c **** 				{
4923:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4924:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4925:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4926:FreeRTOS/Source/tasks.c **** 				}
4927:FreeRTOS/Source/tasks.c **** 
4928:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4929:FreeRTOS/Source/tasks.c **** 				{
4930:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4931:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4932:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4933:FreeRTOS/Source/tasks.c **** 					{
4934:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4935:FreeRTOS/Source/tasks.c **** 					}
4936:FreeRTOS/Source/tasks.c **** 
4937:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4938:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
4939:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
4940:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
4941:FreeRTOS/Source/tasks.c **** 				}
4942:FreeRTOS/Source/tasks.c **** 				else
4943:FreeRTOS/Source/tasks.c **** 				{
4944:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4945:FreeRTOS/Source/tasks.c **** 				}
4946:FreeRTOS/Source/tasks.c **** 			}
4947:FreeRTOS/Source/tasks.c **** 		}
4948:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4949:FreeRTOS/Source/tasks.c **** 	}
4950:FreeRTOS/Source/tasks.c **** 
4951:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4952:FreeRTOS/Source/tasks.c **** 
4953:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4954:FreeRTOS/Source/tasks.c **** 
4955:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4956:FreeRTOS/Source/tasks.c **** 
4957:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4958:FreeRTOS/Source/tasks.c **** 	{
4959:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
4960:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4961:FreeRTOS/Source/tasks.c **** 
4962:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4963:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
4964:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4965:FreeRTOS/Source/tasks.c **** 
4966:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4967:FreeRTOS/Source/tasks.c **** 		{
4968:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4969:FreeRTOS/Source/tasks.c **** 			{
4970:FreeRTOS/Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4971:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
4972:FreeRTOS/Source/tasks.c **** 			}
4973:FreeRTOS/Source/tasks.c **** 			else
4974:FreeRTOS/Source/tasks.c **** 			{
4975:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
4976:FreeRTOS/Source/tasks.c **** 			}
4977:FreeRTOS/Source/tasks.c **** 		}
4978:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4979:FreeRTOS/Source/tasks.c **** 
4980:FreeRTOS/Source/tasks.c **** 		return xReturn;
4981:FreeRTOS/Source/tasks.c **** 	}
4982:FreeRTOS/Source/tasks.c **** 
4983:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4984:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4985:FreeRTOS/Source/tasks.c **** 
4986:FreeRTOS/Source/tasks.c **** 
4987:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4988:FreeRTOS/Source/tasks.c **** {
 242               	.LM5:
 243               	.LFBB2:
 244 0036 FF92      		push r15
 245 0038 0F93      		push r16
 246 003a 1F93      		push r17
 247 003c CF93      		push r28
 248 003e DF93      		push r29
 249               	/* prologue: function */
 250               	/* frame size = 0 */
 251               	/* stack size = 5 */
 252               	.L__stack_usage = 5
 253 0040 EC01      		movw r28,r24
 254 0042 F62E      		mov r15,r22
4989:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
4990:FreeRTOS/Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 256               	.LM6:
 257 0044 0091 0000 		lds r16,xTickCount
 258 0048 1091 0000 		lds r17,xTickCount+1
4991:FreeRTOS/Source/tasks.c **** 
4992:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4993:FreeRTOS/Source/tasks.c **** 	{
4994:FreeRTOS/Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4995:FreeRTOS/Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4996:FreeRTOS/Source/tasks.c **** 		when the task leaves the Blocked state. */
4997:FreeRTOS/Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4998:FreeRTOS/Source/tasks.c **** 	}
4999:FreeRTOS/Source/tasks.c **** 	#endif
5000:FreeRTOS/Source/tasks.c **** 
5001:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5002:FreeRTOS/Source/tasks.c **** 	as the same list item is used for both lists. */
5003:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 260               	.LM7:
 261 004c 8091 0000 		lds r24,pxCurrentTCB
 262 0050 9091 0000 		lds r25,pxCurrentTCB+1
 263 0054 0296      		adiw r24,2
 264 0056 0E94 0000 		call uxListRemove
5004:FreeRTOS/Source/tasks.c **** 	{
5005:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5006:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5007:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
5008:FreeRTOS/Source/tasks.c **** 	}
5009:FreeRTOS/Source/tasks.c **** 	else
5010:FreeRTOS/Source/tasks.c **** 	{
5011:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5012:FreeRTOS/Source/tasks.c **** 	}
5013:FreeRTOS/Source/tasks.c **** 
5014:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5015:FreeRTOS/Source/tasks.c **** 	{
5016:FreeRTOS/Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 266               	.LM8:
 267 005a CF3F      		cpi r28,-1
 268 005c 8FEF      		ldi r24,-1
 269 005e D807      		cpc r29,r24
 270 0060 01F4      		brne .L7
 272               	.LM9:
 273 0062 FF20      		tst r15
 274 0064 01F0      		breq .L7
 275               	.LBB10:
 276               	.LBB11:
5017:FreeRTOS/Source/tasks.c **** 		{
5018:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5019:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5020:FreeRTOS/Source/tasks.c **** 			indefinitely. */
5021:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 278               	.LM10:
 279 0066 6091 0000 		lds r22,pxCurrentTCB
 280 006a 7091 0000 		lds r23,pxCurrentTCB+1
 281 006e 6E5F      		subi r22,-2
 282 0070 7F4F      		sbci r23,-1
 283 0072 80E0      		ldi r24,lo8(xSuspendedTaskList)
 284 0074 90E0      		ldi r25,hi8(xSuspendedTaskList)
 285               	/* epilogue start */
 286               	.LBE11:
 287               	.LBE10:
5022:FreeRTOS/Source/tasks.c **** 		}
5023:FreeRTOS/Source/tasks.c **** 		else
5024:FreeRTOS/Source/tasks.c **** 		{
5025:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5026:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5027:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
5028:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5029:FreeRTOS/Source/tasks.c **** 
5030:FreeRTOS/Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5031:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5032:FreeRTOS/Source/tasks.c **** 
5033:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5034:FreeRTOS/Source/tasks.c **** 			{
5035:FreeRTOS/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5036:FreeRTOS/Source/tasks.c **** 				list. */
5037:FreeRTOS/Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5038:FreeRTOS/Source/tasks.c **** 			}
5039:FreeRTOS/Source/tasks.c **** 			else
5040:FreeRTOS/Source/tasks.c **** 			{
5041:FreeRTOS/Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5042:FreeRTOS/Source/tasks.c **** 				is used. */
5043:FreeRTOS/Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5044:FreeRTOS/Source/tasks.c **** 
5045:FreeRTOS/Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5046:FreeRTOS/Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5047:FreeRTOS/Source/tasks.c **** 				needs to be updated too. */
5048:FreeRTOS/Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5049:FreeRTOS/Source/tasks.c **** 				{
5050:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5051:FreeRTOS/Source/tasks.c **** 				}
5052:FreeRTOS/Source/tasks.c **** 				else
5053:FreeRTOS/Source/tasks.c **** 				{
5054:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5055:FreeRTOS/Source/tasks.c **** 				}
5056:FreeRTOS/Source/tasks.c **** 			}
5057:FreeRTOS/Source/tasks.c **** 		}
5058:FreeRTOS/Source/tasks.c **** 	}
5059:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5060:FreeRTOS/Source/tasks.c **** 	{
5061:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5062:FreeRTOS/Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5063:FreeRTOS/Source/tasks.c **** 		will manage it correctly. */
5064:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
5065:FreeRTOS/Source/tasks.c **** 
5066:FreeRTOS/Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5067:FreeRTOS/Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5068:FreeRTOS/Source/tasks.c **** 
5069:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5070:FreeRTOS/Source/tasks.c **** 		{
5071:FreeRTOS/Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5072:FreeRTOS/Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5073:FreeRTOS/Source/tasks.c **** 		}
5074:FreeRTOS/Source/tasks.c **** 		else
5075:FreeRTOS/Source/tasks.c **** 		{
5076:FreeRTOS/Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5077:FreeRTOS/Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5078:FreeRTOS/Source/tasks.c **** 
5079:FreeRTOS/Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5080:FreeRTOS/Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5081:FreeRTOS/Source/tasks.c **** 			too. */
5082:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5083:FreeRTOS/Source/tasks.c **** 			{
5084:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5085:FreeRTOS/Source/tasks.c **** 			}
5086:FreeRTOS/Source/tasks.c **** 			else
5087:FreeRTOS/Source/tasks.c **** 			{
5088:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5089:FreeRTOS/Source/tasks.c **** 			}
5090:FreeRTOS/Source/tasks.c **** 		}
5091:FreeRTOS/Source/tasks.c **** 
5092:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5093:FreeRTOS/Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5094:FreeRTOS/Source/tasks.c **** 	}
5095:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5096:FreeRTOS/Source/tasks.c **** }
 289               	.LM11:
 290 0076 DF91      		pop r29
 291 0078 CF91      		pop r28
 292 007a 1F91      		pop r17
 293 007c 0F91      		pop r16
 294 007e FF90      		pop r15
 295               	.LBB13:
 296               	.LBB12:
5021:FreeRTOS/Source/tasks.c **** 		}
 298               	.LM12:
 299 0080 0C94 0000 		jmp vListInsertEnd
 300               	.L7:
 301               	.LBE12:
 302               	.LBE13:
5028:FreeRTOS/Source/tasks.c **** 
 304               	.LM13:
 305 0084 C00F      		add r28,r16
 306 0086 D11F      		adc r29,r17
5031:FreeRTOS/Source/tasks.c **** 
 308               	.LM14:
 309 0088 E091 0000 		lds r30,pxCurrentTCB
 310 008c F091 0000 		lds r31,pxCurrentTCB+1
 311 0090 D383      		std Z+3,r29
 312 0092 C283      		std Z+2,r28
5037:FreeRTOS/Source/tasks.c **** 			}
 314               	.LM15:
 315 0094 6091 0000 		lds r22,pxCurrentTCB
 316 0098 7091 0000 		lds r23,pxCurrentTCB+1
5033:FreeRTOS/Source/tasks.c **** 			{
 318               	.LM16:
 319 009c C017      		cp r28,r16
 320 009e D107      		cpc r29,r17
 321 00a0 00F4      		brsh .L8
5037:FreeRTOS/Source/tasks.c **** 			}
 323               	.LM17:
 324 00a2 8091 0000 		lds r24,pxOverflowDelayedTaskList
 325 00a6 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 326 00aa 6E5F      		subi r22,-2
 327 00ac 7F4F      		sbci r23,-1
 328               	/* epilogue start */
 330               	.LM18:
 331 00ae DF91      		pop r29
 332 00b0 CF91      		pop r28
 333 00b2 1F91      		pop r17
 334 00b4 0F91      		pop r16
 335 00b6 FF90      		pop r15
5037:FreeRTOS/Source/tasks.c **** 			}
 337               	.LM19:
 338 00b8 0C94 0000 		jmp vListInsert
 339               	.L8:
5043:FreeRTOS/Source/tasks.c **** 
 341               	.LM20:
 342 00bc 8091 0000 		lds r24,pxDelayedTaskList
 343 00c0 9091 0000 		lds r25,pxDelayedTaskList+1
 344 00c4 6E5F      		subi r22,-2
 345 00c6 7F4F      		sbci r23,-1
 346 00c8 0E94 0000 		call vListInsert
5048:FreeRTOS/Source/tasks.c **** 				{
 348               	.LM21:
 349 00cc 8091 0000 		lds r24,xNextTaskUnblockTime
 350 00d0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 351 00d4 C817      		cp r28,r24
 352 00d6 D907      		cpc r29,r25
 353 00d8 00F4      		brsh .L6
5050:FreeRTOS/Source/tasks.c **** 				}
 355               	.LM22:
 356 00da D093 0000 		sts xNextTaskUnblockTime+1,r29
 357 00de C093 0000 		sts xNextTaskUnblockTime,r28
 358               	.L6:
 359               	/* epilogue start */
 361               	.LM23:
 362 00e2 DF91      		pop r29
 363 00e4 CF91      		pop r28
 364 00e6 1F91      		pop r17
 365 00e8 0F91      		pop r16
 366 00ea FF90      		pop r15
 367 00ec 0895      		ret
 373               	.Lscope2:
 375               		.stabd	78,0,0
 379               	prvIdleTask:
 380               		.stabd	46,0,0
3288:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 382               	.LM24:
 383               	.LFBB3:
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 0 */
 387               	.L__stack_usage = 0
 388               	.L14:
 389               	.LBB20:
 390               	.LBB21:
3542:FreeRTOS/Source/tasks.c **** 		{
 392               	.LM25:
 393 00ee 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 394 00f2 8823      		tst r24
 395 00f4 01F0      		breq .L18
3544:FreeRTOS/Source/tasks.c **** 			{
 397               	.LM26:
 398               	/* #APP */
 399               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 400 00f6 0FB6      		in		__tmp_reg__, __SREG__
 401               	 ;  0 "" 2
 402               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 403 00f8 F894      		cli
 404               	 ;  0 "" 2
 405               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 406 00fa 0F92      		push	__tmp_reg__
 407               	 ;  0 "" 2
3546:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 409               	.LM27:
 410               	/* #NOAPP */
 411 00fc E091 0000 		lds r30,xTasksWaitingTermination+5
 412 0100 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 413 0104 C681      		ldd r28,Z+6
 414 0106 D781      		ldd r29,Z+7
3547:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 416               	.LM28:
 417 0108 CE01      		movw r24,r28
 418 010a 0296      		adiw r24,2
 419 010c 0E94 0000 		call uxListRemove
3548:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 421               	.LM29:
 422 0110 8091 0000 		lds r24,uxCurrentNumberOfTasks
 423 0114 8150      		subi r24,lo8(-(-1))
 424 0116 8093 0000 		sts uxCurrentNumberOfTasks,r24
3549:FreeRTOS/Source/tasks.c **** 			}
 426               	.LM30:
 427 011a 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 428 011e 8150      		subi r24,lo8(-(-1))
 429 0120 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3551:FreeRTOS/Source/tasks.c **** 
 431               	.LM31:
 432               	/* #APP */
 433               	 ;  3551 "FreeRTOS/Source/tasks.c" 1
 434 0124 0F90      		pop		__tmp_reg__
 435               	 ;  0 "" 2
 436               	 ;  3551 "FreeRTOS/Source/tasks.c" 1
 437 0126 0FBE      		out		__SREG__, __tmp_reg__
 438               	 ;  0 "" 2
 439               	/* #NOAPP */
 440               	.LBB22:
 441               	.LBB23:
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 443               	.LM32:
 444 0128 8F89      		ldd r24,Y+23
 445 012a 988D      		ldd r25,Y+24
 446 012c 0E94 0000 		call vPortFree
3759:FreeRTOS/Source/tasks.c **** 		}
 448               	.LM33:
 449 0130 CE01      		movw r24,r28
 450 0132 0E94 0000 		call vPortFree
 451 0136 00C0      		rjmp .L14
 452               	.L18:
 453               	.LBE23:
 454               	.LBE22:
 455               	.LBE21:
 456               	.LBE20:
3327:FreeRTOS/Source/tasks.c **** 			{
 458               	.LM34:
 459 0138 8091 0000 		lds r24,pxReadyTasksLists
 460 013c 8230      		cpi r24,lo8(2)
 461 013e 00F0      		brlo .L16
3329:FreeRTOS/Source/tasks.c **** 			}
 463               	.LM35:
 464 0140 0E94 0000 		call vPortYield
 465               	.L16:
 466               	.LBB24:
3347:FreeRTOS/Source/tasks.c **** 		}
 468               	.LM36:
 469 0144 0E94 0000 		call vApplicationIdleHook
 470               	.LBE24:
3400:FreeRTOS/Source/tasks.c **** }
 472               	.LM37:
 473 0148 00C0      		rjmp .L14
 478               	.Lscope3:
 480               		.stabd	78,0,0
 487               	.global	xTaskCreate
 489               	xTaskCreate:
 490               		.stabd	46,0,0
 753:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 492               	.LM38:
 493               	.LFBB4:
 494 014a 3F92      		push r3
 495 014c 4F92      		push r4
 496 014e 5F92      		push r5
 497 0150 6F92      		push r6
 498 0152 7F92      		push r7
 499 0154 8F92      		push r8
 500 0156 9F92      		push r9
 501 0158 AF92      		push r10
 502 015a BF92      		push r11
 503 015c CF92      		push r12
 504 015e DF92      		push r13
 505 0160 EF92      		push r14
 506 0162 FF92      		push r15
 507 0164 0F93      		push r16
 508 0166 1F93      		push r17
 509 0168 CF93      		push r28
 510 016a DF93      		push r29
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 17 */
 514               	.L__stack_usage = 17
 515 016c 4C01      		movw r8,r24
 516 016e 162F      		mov r17,r22
 517 0170 372E      		mov r3,r23
 518 0172 6A01      		movw r12,r20
 519 0174 5901      		movw r10,r18
 520               	.LBB32:
 787:FreeRTOS/Source/tasks.c **** 
 522               	.LM39:
 523 0176 CA01      		movw r24,r20
 524 0178 0E94 0000 		call pvPortMalloc
 525 017c 2C01      		movw r4,r24
 789:FreeRTOS/Source/tasks.c **** 			{
 527               	.LM40:
 528 017e 892B      		or r24,r25
 529 0180 01F4      		brne .+2
 530 0182 00C0      		rjmp .L20
 792:FreeRTOS/Source/tasks.c **** 
 532               	.LM41:
 533 0184 88E2      		ldi r24,lo8(40)
 534 0186 90E0      		ldi r25,0
 535 0188 0E94 0000 		call pvPortMalloc
 536 018c EC01      		movw r28,r24
 794:FreeRTOS/Source/tasks.c **** 				{
 538               	.LM42:
 539 018e 892B      		or r24,r25
 540 0190 01F0      		breq .L21
 797:FreeRTOS/Source/tasks.c **** 				}
 542               	.LM43:
 543 0192 588E      		std Y+24,r5
 544 0194 4F8A      		std Y+23,r4
 545               	.LBE32:
 546               	.LBB33:
 547               	.LBB34:
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 549               	.LM44:
 550 0196 C601      		movw r24,r12
 551 0198 0197      		sbiw r24,1
 552 019a 3201      		movw r6,r4
 553 019c 680E      		add r6,r24
 554 019e 791E      		adc r7,r25
 555 01a0 BE01      		movw r22,r28
 556 01a2 675E      		subi r22,-25
 557 01a4 7F4F      		sbci r23,-1
 558 01a6 E12F      		mov r30,r17
 559 01a8 F32D      		mov r31,r3
 560 01aa CF01      		movw r24,r30
 561 01ac 0896      		adiw r24,8
 562 01ae 00C0      		rjmp .L22
 563               	.L21:
 564               	.LBE34:
 565               	.LBE33:
 566               	.LBB36:
 803:FreeRTOS/Source/tasks.c **** 				}
 568               	.LM45:
 569 01b0 C201      		movw r24,r4
 570 01b2 0E94 0000 		call vPortFree
 571 01b6 00C0      		rjmp .L20
 572               	.L45:
 573               	.LBE36:
 574               	.LBB37:
 575               	.LBB35:
 908:FreeRTOS/Source/tasks.c **** 	{
 577               	.LM46:
 578 01b8 E817      		cp r30,r24
 579 01ba F907      		cpc r31,r25
 580 01bc 01F0      		breq .L23
 581               	.L22:
 582 01be 9F01      		movw r18,r30
 910:FreeRTOS/Source/tasks.c **** 
 584               	.LM47:
 585 01c0 4191      		ld r20,Z+
 586 01c2 DB01      		movw r26,r22
 587 01c4 4D93      		st X+,r20
 588 01c6 BD01      		movw r22,r26
 915:FreeRTOS/Source/tasks.c **** 		{
 590               	.LM48:
 591 01c8 D901      		movw r26,r18
 592 01ca 2C91      		ld r18,X
 593 01cc 2111      		cpse r18,__zero_reg__
 594 01ce 00C0      		rjmp .L45
 595               	.L23:
 927:FreeRTOS/Source/tasks.c **** 
 597               	.LM49:
 598 01d0 18A2      		std Y+32,__zero_reg__
 599 01d2 0430      		cpi r16,lo8(4)
 600 01d4 00F0      		brlo .L24
 601 01d6 03E0      		ldi r16,lo8(3)
 602               	.L24:
 940:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 604               	.LM50:
 605 01d8 0E8B      		std Y+22,r16
 943:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 607               	.LM51:
 608 01da 09A3      		std Y+33,r16
 944:FreeRTOS/Source/tasks.c **** 	}
 610               	.LM52:
 611 01dc 1AA2      		std Y+34,__zero_reg__
 948:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 613               	.LM53:
 614 01de 6E01      		movw r12,r28
 615 01e0 B2E0      		ldi r27,2
 616 01e2 CB0E      		add r12,r27
 617 01e4 D11C      		adc r13,__zero_reg__
 618 01e6 C601      		movw r24,r12
 619 01e8 0E94 0000 		call vListInitialiseItem
 949:FreeRTOS/Source/tasks.c **** 
 621               	.LM54:
 622 01ec CE01      		movw r24,r28
 623 01ee 0C96      		adiw r24,12
 624 01f0 0E94 0000 		call vListInitialiseItem
 953:FreeRTOS/Source/tasks.c **** 
 626               	.LM55:
 627 01f4 D987      		std Y+9,r29
 628 01f6 C887      		std Y+8,r28
 956:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 630               	.LM56:
 631 01f8 84E0      		ldi r24,lo8(4)
 632 01fa 90E0      		ldi r25,0
 633 01fc 801B      		sub r24,r16
 634 01fe 9109      		sbc r25,__zero_reg__
 635 0200 9D87      		std Y+13,r25
 636 0202 8C87      		std Y+12,r24
 957:FreeRTOS/Source/tasks.c **** 
 638               	.LM57:
 639 0204 DB8B      		std Y+19,r29
 640 0206 CA8B      		std Y+18,r28
 999:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 642               	.LM58:
 643 0208 1BA2      		std Y+35,__zero_reg__
 644 020a 1CA2      		std Y+36,__zero_reg__
 645 020c 1DA2      		std Y+37,__zero_reg__
 646 020e 1EA2      		std Y+38,__zero_reg__
1000:FreeRTOS/Source/tasks.c **** 	}
 648               	.LM59:
 649 0210 1FA2      		std Y+39,__zero_reg__
1027:FreeRTOS/Source/tasks.c **** 	}
 651               	.LM60:
 652 0212 A501      		movw r20,r10
 653 0214 B401      		movw r22,r8
 654 0216 C301      		movw r24,r6
 655 0218 0E94 0000 		call pxPortInitialiseStack
 656 021c 9983      		std Y+1,r25
 657 021e 8883      		st Y,r24
1031:FreeRTOS/Source/tasks.c **** 	{
 659               	.LM61:
 660 0220 E114      		cp r14,__zero_reg__
 661 0222 F104      		cpc r15,__zero_reg__
 662 0224 01F0      		breq .L25
1035:FreeRTOS/Source/tasks.c **** 	}
 664               	.LM62:
 665 0226 F701      		movw r30,r14
 666 0228 D183      		std Z+1,r29
 667 022a C083      		st Z,r28
 668               	.L25:
 669               	.LBE35:
 670               	.LBE37:
 671               	.LBB38:
 672               	.LBB39:
1048:FreeRTOS/Source/tasks.c **** 	{
 674               	.LM63:
 675               	/* #APP */
 676               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 677 022c 0FB6      		in		__tmp_reg__, __SREG__
 678               	 ;  0 "" 2
 679               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 680 022e F894      		cli
 681               	 ;  0 "" 2
 682               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 683 0230 0F92      		push	__tmp_reg__
 684               	 ;  0 "" 2
1050:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 686               	.LM64:
 687               	/* #NOAPP */
 688 0232 8091 0000 		lds r24,uxCurrentNumberOfTasks
 689 0236 8F5F      		subi r24,lo8(-(1))
 690 0238 8093 0000 		sts uxCurrentNumberOfTasks,r24
1051:FreeRTOS/Source/tasks.c **** 		{
 692               	.LM65:
 693 023c 8091 0000 		lds r24,pxCurrentTCB
 694 0240 9091 0000 		lds r25,pxCurrentTCB+1
 695 0244 892B      		or r24,r25
 696 0246 01F4      		brne .L26
1055:FreeRTOS/Source/tasks.c **** 
 698               	.LM66:
 699 0248 D093 0000 		sts pxCurrentTCB+1,r29
 700 024c C093 0000 		sts pxCurrentTCB,r28
1057:FreeRTOS/Source/tasks.c **** 			{
 702               	.LM67:
 703 0250 8091 0000 		lds r24,uxCurrentNumberOfTasks
 704 0254 8130      		cpi r24,lo8(1)
 705 0256 01F0      		breq .+2
 706 0258 00C0      		rjmp .L28
 707               	.LBB40:
 708               	.LBB41:
3505:FreeRTOS/Source/tasks.c **** 	}
 710               	.LM68:
 711 025a 80E0      		ldi r24,lo8(pxReadyTasksLists)
 712 025c 90E0      		ldi r25,hi8(pxReadyTasksLists)
 713 025e 0E94 0000 		call vListInitialise
 714 0262 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 715 0264 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 716 0266 0E94 0000 		call vListInitialise
 717 026a 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 718 026c 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 719 026e 0E94 0000 		call vListInitialise
 720 0272 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 721 0274 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 722 0276 0E94 0000 		call vListInitialise
3508:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 724               	.LM69:
 725 027a 80E0      		ldi r24,lo8(xDelayedTaskList1)
 726 027c 90E0      		ldi r25,hi8(xDelayedTaskList1)
 727 027e 0E94 0000 		call vListInitialise
3509:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 729               	.LM70:
 730 0282 80E0      		ldi r24,lo8(xDelayedTaskList2)
 731 0284 90E0      		ldi r25,hi8(xDelayedTaskList2)
 732 0286 0E94 0000 		call vListInitialise
3510:FreeRTOS/Source/tasks.c **** 
 734               	.LM71:
 735 028a 80E0      		ldi r24,lo8(xPendingReadyList)
 736 028c 90E0      		ldi r25,hi8(xPendingReadyList)
 737 028e 0E94 0000 		call vListInitialise
3514:FreeRTOS/Source/tasks.c **** 	}
 739               	.LM72:
 740 0292 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 741 0294 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 742 0296 0E94 0000 		call vListInitialise
3520:FreeRTOS/Source/tasks.c **** 	}
 744               	.LM73:
 745 029a 80E0      		ldi r24,lo8(xSuspendedTaskList)
 746 029c 90E0      		ldi r25,hi8(xSuspendedTaskList)
 747 029e 0E94 0000 		call vListInitialise
3526:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 749               	.LM74:
 750 02a2 80E0      		ldi r24,lo8(xDelayedTaskList1)
 751 02a4 90E0      		ldi r25,hi8(xDelayedTaskList1)
 752 02a6 9093 0000 		sts pxDelayedTaskList+1,r25
 753 02aa 8093 0000 		sts pxDelayedTaskList,r24
3527:FreeRTOS/Source/tasks.c **** }
 755               	.LM75:
 756 02ae 80E0      		ldi r24,lo8(xDelayedTaskList2)
 757 02b0 90E0      		ldi r25,hi8(xDelayedTaskList2)
 758 02b2 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 759 02b6 8093 0000 		sts pxOverflowDelayedTaskList,r24
 760 02ba 00C0      		rjmp .L28
 761               	.L26:
 762               	.LBE41:
 763               	.LBE40:
1074:FreeRTOS/Source/tasks.c **** 			{
 765               	.LM76:
 766 02bc 8091 0000 		lds r24,xSchedulerRunning
 767 02c0 8111      		cpse r24,__zero_reg__
 768 02c2 00C0      		rjmp .L28
1076:FreeRTOS/Source/tasks.c **** 				{
 770               	.LM77:
 771 02c4 E091 0000 		lds r30,pxCurrentTCB
 772 02c8 F091 0000 		lds r31,pxCurrentTCB+1
 773 02cc 9689      		ldd r25,Z+22
 774 02ce 8E89      		ldd r24,Y+22
 775 02d0 8917      		cp r24,r25
 776 02d2 00F0      		brlo .L28
1078:FreeRTOS/Source/tasks.c **** 				}
 778               	.LM78:
 779 02d4 D093 0000 		sts pxCurrentTCB+1,r29
 780 02d8 C093 0000 		sts pxCurrentTCB,r28
 781               	.L28:
1091:FreeRTOS/Source/tasks.c **** 
 783               	.LM79:
 784 02dc 8091 0000 		lds r24,uxTaskNumber
 785 02e0 8F5F      		subi r24,lo8(-(1))
 786 02e2 8093 0000 		sts uxTaskNumber,r24
1101:FreeRTOS/Source/tasks.c **** 
 788               	.LM80:
 789 02e6 8E89      		ldd r24,Y+22
 790 02e8 9091 0000 		lds r25,uxTopReadyPriority
 791 02ec 9817      		cp r25,r24
 792 02ee 00F4      		brsh .L30
 793 02f0 8093 0000 		sts uxTopReadyPriority,r24
 794               	.L30:
 795 02f4 F9E0      		ldi r31,lo8(9)
 796 02f6 8F9F      		mul r24,r31
 797 02f8 C001      		movw r24,r0
 798 02fa 1124      		clr __zero_reg__
 799 02fc B601      		movw r22,r12
 800 02fe 8050      		subi r24,lo8(-(pxReadyTasksLists))
 801 0300 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 802 0302 0E94 0000 		call vListInsertEnd
1105:FreeRTOS/Source/tasks.c **** 
 804               	.LM81:
 805               	/* #APP */
 806               	 ;  1105 "FreeRTOS/Source/tasks.c" 1
 807 0306 0F90      		pop		__tmp_reg__
 808               	 ;  0 "" 2
 809               	 ;  1105 "FreeRTOS/Source/tasks.c" 1
 810 0308 0FBE      		out		__SREG__, __tmp_reg__
 811               	 ;  0 "" 2
1107:FreeRTOS/Source/tasks.c **** 	{
 813               	.LM82:
 814               	/* #NOAPP */
 815 030a 8091 0000 		lds r24,xSchedulerRunning
 816 030e 8823      		tst r24
 817 0310 01F0      		breq .L33
1111:FreeRTOS/Source/tasks.c **** 		{
 819               	.LM83:
 820 0312 E091 0000 		lds r30,pxCurrentTCB
 821 0316 F091 0000 		lds r31,pxCurrentTCB+1
 822 031a 9689      		ldd r25,Z+22
 823 031c 8E89      		ldd r24,Y+22
 824 031e 9817      		cp r25,r24
 825 0320 00F4      		brsh .L33
1113:FreeRTOS/Source/tasks.c **** 		}
 827               	.LM84:
 828 0322 0E94 0000 		call vPortYield
 829               	.L33:
 830               	.LBE39:
 831               	.LBE38:
 825:FreeRTOS/Source/tasks.c **** 		}
 833               	.LM85:
 834 0326 81E0      		ldi r24,lo8(1)
 835 0328 00C0      		rjmp .L44
 836               	.L20:
 829:FreeRTOS/Source/tasks.c **** 		}
 838               	.LM86:
 839 032a 8FEF      		ldi r24,lo8(-1)
 840               	.L44:
 841               	/* epilogue start */
 833:FreeRTOS/Source/tasks.c **** 
 843               	.LM87:
 844 032c DF91      		pop r29
 845 032e CF91      		pop r28
 846 0330 1F91      		pop r17
 847 0332 0F91      		pop r16
 848 0334 FF90      		pop r15
 849 0336 EF90      		pop r14
 850 0338 DF90      		pop r13
 851 033a CF90      		pop r12
 852 033c BF90      		pop r11
 853 033e AF90      		pop r10
 854 0340 9F90      		pop r9
 855 0342 8F90      		pop r8
 856 0344 7F90      		pop r7
 857 0346 6F90      		pop r6
 858 0348 5F90      		pop r5
 859 034a 4F90      		pop r4
 860 034c 3F90      		pop r3
 861 034e 0895      		ret
 879               	.Lscope4:
 881               		.stabd	78,0,0
 884               	.global	vTaskDelete
 886               	vTaskDelete:
 887               		.stabd	46,0,0
1130:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 889               	.LM88:
 890               	.LFBB5:
 891 0350 0F93      		push r16
 892 0352 1F93      		push r17
 893 0354 CF93      		push r28
 894 0356 DF93      		push r29
 895               	/* prologue: function */
 896               	/* frame size = 0 */
 897               	/* stack size = 4 */
 898               	.L__stack_usage = 4
 899 0358 EC01      		movw r28,r24
1133:FreeRTOS/Source/tasks.c **** 		{
 901               	.LM89:
 902               	/* #APP */
 903               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 904 035a 0FB6      		in		__tmp_reg__, __SREG__
 905               	 ;  0 "" 2
 906               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 907 035c F894      		cli
 908               	 ;  0 "" 2
 909               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 910 035e 0F92      		push	__tmp_reg__
 911               	 ;  0 "" 2
1137:FreeRTOS/Source/tasks.c **** 
 913               	.LM90:
 914               	/* #NOAPP */
 915 0360 892B      		or r24,r25
 916 0362 01F4      		brne .L47
1137:FreeRTOS/Source/tasks.c **** 
 918               	.LM91:
 919 0364 C091 0000 		lds r28,pxCurrentTCB
 920 0368 D091 0000 		lds r29,pxCurrentTCB+1
 921               	.L47:
1140:FreeRTOS/Source/tasks.c **** 			{
 923               	.LM92:
 924 036c 8E01      		movw r16,r28
 925 036e 0E5F      		subi r16,-2
 926 0370 1F4F      		sbci r17,-1
 927 0372 C801      		movw r24,r16
 928 0374 0E94 0000 		call uxListRemove
1150:FreeRTOS/Source/tasks.c **** 			{
 930               	.LM93:
 931 0378 8C89      		ldd r24,Y+20
 932 037a 9D89      		ldd r25,Y+21
 933 037c 892B      		or r24,r25
 934 037e 01F0      		breq .L48
1152:FreeRTOS/Source/tasks.c **** 			}
 936               	.LM94:
 937 0380 CE01      		movw r24,r28
 938 0382 0C96      		adiw r24,12
 939 0384 0E94 0000 		call uxListRemove
 940               	.L48:
1163:FreeRTOS/Source/tasks.c **** 
 942               	.LM95:
 943 0388 8091 0000 		lds r24,uxTaskNumber
 944 038c 8F5F      		subi r24,lo8(-(1))
 945 038e 8093 0000 		sts uxTaskNumber,r24
1165:FreeRTOS/Source/tasks.c **** 			{
 947               	.LM96:
 948 0392 8091 0000 		lds r24,pxCurrentTCB
 949 0396 9091 0000 		lds r25,pxCurrentTCB+1
 950 039a C817      		cp r28,r24
 951 039c D907      		cpc r29,r25
 952 039e 01F4      		brne .L49
1172:FreeRTOS/Source/tasks.c **** 
 954               	.LM97:
 955 03a0 B801      		movw r22,r16
 956 03a2 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 957 03a4 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 958 03a6 0E94 0000 		call vListInsertEnd
1177:FreeRTOS/Source/tasks.c **** 
 960               	.LM98:
 961 03aa 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 962 03ae 8F5F      		subi r24,lo8(-(1))
 963 03b0 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 964 03b4 00C0      		rjmp .L50
 965               	.L49:
1188:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 967               	.LM99:
 968 03b6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 969 03ba 8150      		subi r24,lo8(-(-1))
 970 03bc 8093 0000 		sts uxCurrentNumberOfTasks,r24
 971               	.LBB44:
 972               	.LBB45:
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 974               	.LM100:
 975 03c0 8F89      		ldd r24,Y+23
 976 03c2 988D      		ldd r25,Y+24
 977 03c4 0E94 0000 		call vPortFree
3759:FreeRTOS/Source/tasks.c **** 		}
 979               	.LM101:
 980 03c8 CE01      		movw r24,r28
 981 03ca 0E94 0000 		call vPortFree
 982               	.LBE45:
 983               	.LBE44:
1193:FreeRTOS/Source/tasks.c **** 			}
 985               	.LM102:
 986 03ce 0E94 0000 		call prvResetNextTaskUnblockTime
 987               	.L50:
1198:FreeRTOS/Source/tasks.c **** 
 989               	.LM103:
 990               	/* #APP */
 991               	 ;  1198 "FreeRTOS/Source/tasks.c" 1
 992 03d2 0F90      		pop		__tmp_reg__
 993               	 ;  0 "" 2
 994               	 ;  1198 "FreeRTOS/Source/tasks.c" 1
 995 03d4 0FBE      		out		__SREG__, __tmp_reg__
 996               	 ;  0 "" 2
1202:FreeRTOS/Source/tasks.c **** 		{
 998               	.LM104:
 999               	/* #NOAPP */
 1000 03d6 8091 0000 		lds r24,xSchedulerRunning
 1001 03da 8823      		tst r24
 1002 03dc 01F0      		breq .L46
1204:FreeRTOS/Source/tasks.c **** 			{
 1004               	.LM105:
 1005 03de 8091 0000 		lds r24,pxCurrentTCB
 1006 03e2 9091 0000 		lds r25,pxCurrentTCB+1
 1007 03e6 C817      		cp r28,r24
 1008 03e8 D907      		cpc r29,r25
 1009 03ea 01F4      		brne .L46
1207:FreeRTOS/Source/tasks.c **** 			}
 1011               	.LM106:
 1012 03ec 0E94 0000 		call vPortYield
 1013               	.L46:
 1014               	/* epilogue start */
1214:FreeRTOS/Source/tasks.c **** 
 1016               	.LM107:
 1017 03f0 DF91      		pop r29
 1018 03f2 CF91      		pop r28
 1019 03f4 1F91      		pop r17
 1020 03f6 0F91      		pop r16
 1021 03f8 0895      		ret
 1023               	.Lscope5:
 1025               		.stabd	78,0,0
 1028               	.global	vTaskResume
 1030               	vTaskResume:
 1031               		.stabd	46,0,0
1816:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1033               	.LM108:
 1034               	.LFBB6:
 1035 03fa 0F93      		push r16
 1036 03fc 1F93      		push r17
 1037 03fe CF93      		push r28
 1038 0400 DF93      		push r29
 1039               	/* prologue: function */
 1040               	/* frame size = 0 */
 1041               	/* stack size = 4 */
 1042               	.L__stack_usage = 4
1824:FreeRTOS/Source/tasks.c **** 		{
 1044               	.LM109:
 1045 0402 2091 0000 		lds r18,pxCurrentTCB
 1046 0406 3091 0000 		lds r19,pxCurrentTCB+1
 1047 040a 8217      		cp r24,r18
 1048 040c 9307      		cpc r25,r19
 1049 040e 01F0      		breq .L58
1824:FreeRTOS/Source/tasks.c **** 		{
 1051               	.LM110:
 1052 0410 0097      		sbiw r24,0
 1053 0412 01F0      		breq .L58
1826:FreeRTOS/Source/tasks.c **** 			{
 1055               	.LM111:
 1056               	/* #APP */
 1057               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1058 0414 0FB6      		in		__tmp_reg__, __SREG__
 1059               	 ;  0 "" 2
 1060               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1061 0416 F894      		cli
 1062               	 ;  0 "" 2
 1063               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1064 0418 0F92      		push	__tmp_reg__
 1065               	 ;  0 "" 2
 1066               	/* #NOAPP */
 1067               	.LBB50:
 1068               	.LBB51:
1781:FreeRTOS/Source/tasks.c **** 		{
 1070               	.LM112:
 1071 041a FC01      		movw r30,r24
 1072 041c 2285      		ldd r18,Z+10
 1073 041e 3385      		ldd r19,Z+11
 1074 0420 2050      		subi r18,lo8(xSuspendedTaskList)
 1075 0422 3040      		sbci r19,hi8(xSuspendedTaskList)
 1076 0424 01F4      		brne .L61
 1077               	.LBB52:
 1078               	.LBB53:
1784:FreeRTOS/Source/tasks.c **** 			{
 1080               	.LM113:
 1081 0426 FC01      		movw r30,r24
 1082 0428 2489      		ldd r18,Z+20
 1083 042a 3589      		ldd r19,Z+21
 1084 042c F0E0      		ldi r31,hi8(xPendingReadyList)
 1085 042e 2030      		cpi r18,lo8(xPendingReadyList)
 1086 0430 3F07      		cpc r19,r31
 1087 0432 01F0      		breq .L61
1788:FreeRTOS/Source/tasks.c **** 				{
 1089               	.LM114:
 1090 0434 232B      		or r18,r19
 1091 0436 01F4      		brne .L61
 1092 0438 EC01      		movw r28,r24
 1093               	.LBE53:
 1094               	.LBE52:
 1095               	.LBE51:
 1096               	.LBE50:
1834:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1098               	.LM115:
 1099 043a 8C01      		movw r16,r24
 1100 043c 0E5F      		subi r16,-2
 1101 043e 1F4F      		sbci r17,-1
 1102 0440 C801      		movw r24,r16
 1103 0442 0E94 0000 		call uxListRemove
1835:FreeRTOS/Source/tasks.c **** 
 1105               	.LM116:
 1106 0446 8E89      		ldd r24,Y+22
 1107 0448 9091 0000 		lds r25,uxTopReadyPriority
 1108 044c 9817      		cp r25,r24
 1109 044e 00F4      		brsh .L65
1835:FreeRTOS/Source/tasks.c **** 
 1111               	.LM117:
 1112 0450 8093 0000 		sts uxTopReadyPriority,r24
 1113               	.L65:
1835:FreeRTOS/Source/tasks.c **** 
 1115               	.LM118:
 1116 0454 29E0      		ldi r18,lo8(9)
 1117 0456 829F      		mul r24,r18
 1118 0458 C001      		movw r24,r0
 1119 045a 1124      		clr __zero_reg__
 1120 045c B801      		movw r22,r16
 1121 045e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1122 0460 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1123 0462 0E94 0000 		call vListInsertEnd
1838:FreeRTOS/Source/tasks.c **** 					{
 1125               	.LM119:
 1126 0466 E091 0000 		lds r30,pxCurrentTCB
 1127 046a F091 0000 		lds r31,pxCurrentTCB+1
 1128 046e 9E89      		ldd r25,Y+22
 1129 0470 8689      		ldd r24,Z+22
 1130 0472 9817      		cp r25,r24
 1131 0474 00F0      		brlo .L61
1843:FreeRTOS/Source/tasks.c **** 					}
 1133               	.LM120:
 1134 0476 0E94 0000 		call vPortYield
 1135               	.L61:
1855:FreeRTOS/Source/tasks.c **** 		}
 1137               	.LM121:
 1138               	/* #APP */
 1139               	 ;  1855 "FreeRTOS/Source/tasks.c" 1
 1140 047a 0F90      		pop		__tmp_reg__
 1141               	 ;  0 "" 2
 1142               	 ;  1855 "FreeRTOS/Source/tasks.c" 1
 1143 047c 0FBE      		out		__SREG__, __tmp_reg__
 1144               	 ;  0 "" 2
 1145               	/* #NOAPP */
 1146               	.L58:
 1147               	/* epilogue start */
1861:FreeRTOS/Source/tasks.c **** 
 1149               	.LM122:
 1150 047e DF91      		pop r29
 1151 0480 CF91      		pop r28
 1152 0482 1F91      		pop r17
 1153 0484 0F91      		pop r16
 1154 0486 0895      		ret
 1156               	.Lscope6:
 1158               		.stabd	78,0,0
 1161               	.global	xTaskResumeFromISR
 1163               	xTaskResumeFromISR:
 1164               		.stabd	46,0,0
1870:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1166               	.LM123:
 1167               	.LFBB7:
 1168 0488 EF92      		push r14
 1169 048a FF92      		push r15
 1170 048c 1F93      		push r17
 1171 048e CF93      		push r28
 1172 0490 DF93      		push r29
 1173               	/* prologue: function */
 1174               	/* frame size = 0 */
 1175               	/* stack size = 5 */
 1176               	.L__stack_usage = 5
 1177 0492 EC01      		movw r28,r24
 1178               	.LBB58:
 1179               	.LBB59:
1781:FreeRTOS/Source/tasks.c **** 		{
 1181               	.LM124:
 1182 0494 8A85      		ldd r24,Y+10
 1183 0496 9B85      		ldd r25,Y+11
 1184 0498 8050      		subi r24,lo8(xSuspendedTaskList)
 1185 049a 9040      		sbci r25,hi8(xSuspendedTaskList)
 1186 049c 01F4      		brne .L80
 1187               	.LBB60:
 1188               	.LBB61:
1784:FreeRTOS/Source/tasks.c **** 			{
 1190               	.LM125:
 1191 049e 8C89      		ldd r24,Y+20
 1192 04a0 9D89      		ldd r25,Y+21
 1193 04a2 20E0      		ldi r18,hi8(xPendingReadyList)
 1194 04a4 8030      		cpi r24,lo8(xPendingReadyList)
 1195 04a6 9207      		cpc r25,r18
 1196 04a8 01F0      		breq .L80
1788:FreeRTOS/Source/tasks.c **** 				{
 1198               	.LM126:
 1199 04aa 892B      		or r24,r25
 1200 04ac 01F4      		brne .L80
 1201               	.LBE61:
 1202               	.LBE60:
 1203               	.LBE59:
 1204               	.LBE58:
1902:FreeRTOS/Source/tasks.c **** 				{
 1206               	.LM127:
 1207 04ae 8091 0000 		lds r24,uxSchedulerSuspended
 1208 04b2 8823      		tst r24
 1209 04b4 01F0      		breq .L77
1923:FreeRTOS/Source/tasks.c **** 				}
 1211               	.LM128:
 1212 04b6 BE01      		movw r22,r28
 1213 04b8 645F      		subi r22,-12
 1214 04ba 7F4F      		sbci r23,-1
 1215 04bc 80E0      		ldi r24,lo8(xPendingReadyList)
 1216 04be 90E0      		ldi r25,hi8(xPendingReadyList)
 1217 04c0 0E94 0000 		call vListInsertEnd
 1218               	.L80:
1871:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1220               	.LM129:
 1221 04c4 10E0      		ldi r17,0
1933:FreeRTOS/Source/tasks.c **** 	}
 1223               	.LM130:
 1224 04c6 00C0      		rjmp .L81
 1225               	.L77:
1906:FreeRTOS/Source/tasks.c **** 					{
 1227               	.LM131:
 1228 04c8 E091 0000 		lds r30,pxCurrentTCB
 1229 04cc F091 0000 		lds r31,pxCurrentTCB+1
1871:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1231               	.LM132:
 1232 04d0 11E0      		ldi r17,lo8(1)
 1233 04d2 9E89      		ldd r25,Y+22
 1234 04d4 8689      		ldd r24,Z+22
 1235 04d6 9817      		cp r25,r24
 1236 04d8 00F4      		brsh .L75
 1237 04da 10E0      		ldi r17,0
 1238               	.L75:
1915:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1240               	.LM133:
 1241 04dc 7E01      		movw r14,r28
 1242 04de 82E0      		ldi r24,2
 1243 04e0 E80E      		add r14,r24
 1244 04e2 F11C      		adc r15,__zero_reg__
 1245 04e4 C701      		movw r24,r14
 1246 04e6 0E94 0000 		call uxListRemove
1916:FreeRTOS/Source/tasks.c **** 				}
 1248               	.LM134:
 1249 04ea 8E89      		ldd r24,Y+22
 1250 04ec 9091 0000 		lds r25,uxTopReadyPriority
 1251 04f0 9817      		cp r25,r24
 1252 04f2 00F4      		brsh .L76
1916:FreeRTOS/Source/tasks.c **** 				}
 1254               	.LM135:
 1255 04f4 8093 0000 		sts uxTopReadyPriority,r24
 1256               	.L76:
1916:FreeRTOS/Source/tasks.c **** 				}
 1258               	.LM136:
 1259 04f8 29E0      		ldi r18,lo8(9)
 1260 04fa 829F      		mul r24,r18
 1261 04fc C001      		movw r24,r0
 1262 04fe 1124      		clr __zero_reg__
 1263 0500 B701      		movw r22,r14
 1264 0502 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1265 0504 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1266 0506 0E94 0000 		call vListInsertEnd
 1267               	.L81:
1934:FreeRTOS/Source/tasks.c **** 
 1269               	.LM137:
 1270 050a 812F      		mov r24,r17
 1271               	/* epilogue start */
 1272 050c DF91      		pop r29
 1273 050e CF91      		pop r28
 1274 0510 1F91      		pop r17
 1275 0512 FF90      		pop r15
 1276 0514 EF90      		pop r14
 1277 0516 0895      		ret
 1282               	.Lscope7:
 1284               		.stabd	78,0,0
 1285               		.section	.rodata.str1.1,"aMS",@progbits,1
 1286               	.LC0:
 1287 0000 4944 4C45 		.string	"IDLE"
 1287      00
 1288               		.text
 1290               	.global	vTaskStartScheduler
 1292               	vTaskStartScheduler:
 1293               		.stabd	46,0,0
1940:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 1295               	.LM138:
 1296               	.LFBB8:
 1297 0518 EF92      		push r14
 1298 051a FF92      		push r15
 1299 051c 0F93      		push r16
 1300               	/* prologue: function */
 1301               	/* frame size = 0 */
 1302               	/* stack size = 3 */
 1303               	.L__stack_usage = 3
1973:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
 1305               	.LM139:
 1306 051e 80E0      		ldi r24,lo8(xIdleTaskHandle)
 1307 0520 E82E      		mov r14,r24
 1308 0522 80E0      		ldi r24,hi8(xIdleTaskHandle)
 1309 0524 F82E      		mov r15,r24
 1310 0526 00E0      		ldi r16,0
 1311 0528 20E0      		ldi r18,0
 1312 052a 30E0      		ldi r19,0
 1313 052c 45E5      		ldi r20,lo8(85)
 1314 052e 50E0      		ldi r21,0
 1315 0530 60E0      		ldi r22,lo8(.LC0)
 1316 0532 70E0      		ldi r23,hi8(.LC0)
 1317 0534 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1318 0536 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1319 0538 0E94 0000 		call xTaskCreate
1995:FreeRTOS/Source/tasks.c **** 	{
 1321               	.LM140:
 1322 053c 8130      		cpi r24,lo8(1)
 1323 053e 01F4      		brne .L83
2011:FreeRTOS/Source/tasks.c **** 
 1325               	.LM141:
 1326               	/* #APP */
 1327               	 ;  2011 "FreeRTOS/Source/tasks.c" 1
 1328 0540 F894      		cli
 1329               	 ;  0 "" 2
2021:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1331               	.LM142:
 1332               	/* #NOAPP */
 1333 0542 2FEF      		ldi r18,lo8(-1)
 1334 0544 3FEF      		ldi r19,lo8(-1)
 1335 0546 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1336 054a 2093 0000 		sts xNextTaskUnblockTime,r18
2022:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1338               	.LM143:
 1339 054e 8093 0000 		sts xSchedulerRunning,r24
2023:FreeRTOS/Source/tasks.c **** 
 1341               	.LM144:
 1342 0552 1092 0000 		sts xTickCount+1,__zero_reg__
 1343 0556 1092 0000 		sts xTickCount,__zero_reg__
 1344               	/* epilogue start */
2058:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1346               	.LM145:
 1347 055a 0F91      		pop r16
 1348 055c FF90      		pop r15
 1349 055e EF90      		pop r14
2037:FreeRTOS/Source/tasks.c **** 		{
 1351               	.LM146:
 1352 0560 0C94 0000 		jmp xPortStartScheduler
 1353               	.L83:
 1354               	/* epilogue start */
2058:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1356               	.LM147:
 1357 0564 0F91      		pop r16
 1358 0566 FF90      		pop r15
 1359 0568 EF90      		pop r14
 1360 056a 0895      		ret
 1365               	.Lscope8:
 1367               		.stabd	78,0,0
 1369               	.global	vTaskEndScheduler
 1371               	vTaskEndScheduler:
 1372               		.stabd	46,0,0
2062:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1374               	.LM148:
 1375               	.LFBB9:
 1376               	/* prologue: function */
 1377               	/* frame size = 0 */
 1378               	/* stack size = 0 */
 1379               	.L__stack_usage = 0
2066:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1381               	.LM149:
 1382               	/* #APP */
 1383               	 ;  2066 "FreeRTOS/Source/tasks.c" 1
 1384 056c F894      		cli
 1385               	 ;  0 "" 2
2067:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1387               	.LM150:
 1388               	/* #NOAPP */
 1389 056e 1092 0000 		sts xSchedulerRunning,__zero_reg__
2068:FreeRTOS/Source/tasks.c **** }
 1391               	.LM151:
 1392 0572 0C94 0000 		jmp vPortEndScheduler
 1394               	.Lscope9:
 1396               		.stabd	78,0,0
 1398               	.global	vTaskSuspendAll
 1400               	vTaskSuspendAll:
 1401               		.stabd	46,0,0
2073:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1403               	.LM152:
 1404               	.LFBB10:
 1405               	/* prologue: function */
 1406               	/* frame size = 0 */
 1407               	/* stack size = 0 */
 1408               	.L__stack_usage = 0
2078:FreeRTOS/Source/tasks.c **** }
 1410               	.LM153:
 1411 0576 8091 0000 		lds r24,uxSchedulerSuspended
 1412 057a 8F5F      		subi r24,lo8(-(1))
 1413 057c 8093 0000 		sts uxSchedulerSuspended,r24
 1414 0580 0895      		ret
 1416               	.Lscope10:
 1418               		.stabd	78,0,0
 1420               	.global	xTaskGetTickCount
 1422               	xTaskGetTickCount:
 1423               		.stabd	46,0,0
2256:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1425               	.LM154:
 1426               	.LFBB11:
 1427               	/* prologue: function */
 1428               	/* frame size = 0 */
 1429               	/* stack size = 0 */
 1430               	.L__stack_usage = 0
2260:FreeRTOS/Source/tasks.c **** 	{
 1432               	.LM155:
 1433               	/* #APP */
 1434               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1435 0582 0FB6      		in		__tmp_reg__, __SREG__
 1436               	 ;  0 "" 2
 1437               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1438 0584 F894      		cli
 1439               	 ;  0 "" 2
 1440               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1441 0586 0F92      		push	__tmp_reg__
 1442               	 ;  0 "" 2
2262:FreeRTOS/Source/tasks.c **** 	}
 1444               	.LM156:
 1445               	/* #NOAPP */
 1446 0588 8091 0000 		lds r24,xTickCount
 1447 058c 9091 0000 		lds r25,xTickCount+1
2264:FreeRTOS/Source/tasks.c **** 
 1449               	.LM157:
 1450               	/* #APP */
 1451               	 ;  2264 "FreeRTOS/Source/tasks.c" 1
 1452 0590 0F90      		pop		__tmp_reg__
 1453               	 ;  0 "" 2
 1454               	 ;  2264 "FreeRTOS/Source/tasks.c" 1
 1455 0592 0FBE      		out		__SREG__, __tmp_reg__
 1456               	 ;  0 "" 2
2267:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1458               	.LM158:
 1459               	/* #NOAPP */
 1460 0594 0895      		ret
 1465               	.Lscope11:
 1467               		.stabd	78,0,0
 1469               	.global	xTaskGetTickCountFromISR
 1471               	xTaskGetTickCountFromISR:
 1472               		.stabd	46,0,0
2271:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1474               	.LM159:
 1475               	.LFBB12:
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 0 */
 1479               	.L__stack_usage = 0
2293:FreeRTOS/Source/tasks.c **** 	}
 1481               	.LM160:
 1482 0596 8091 0000 		lds r24,xTickCount
 1483 059a 9091 0000 		lds r25,xTickCount+1
2298:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1485               	.LM161:
 1486 059e 0895      		ret
 1491               	.Lscope12:
 1493               		.stabd	78,0,0
 1495               	.global	uxTaskGetNumberOfTasks
 1497               	uxTaskGetNumberOfTasks:
 1498               		.stabd	46,0,0
2302:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1500               	.LM162:
 1501               	.LFBB13:
 1502               	/* prologue: function */
 1503               	/* frame size = 0 */
 1504               	/* stack size = 0 */
 1505               	.L__stack_usage = 0
2305:FreeRTOS/Source/tasks.c **** }
 1507               	.LM163:
 1508 05a0 8091 0000 		lds r24,uxCurrentNumberOfTasks
2306:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1510               	.LM164:
 1511 05a4 0895      		ret
 1513               	.Lscope13:
 1515               		.stabd	78,0,0
 1518               	.global	pcTaskGetName
 1520               	pcTaskGetName:
 1521               		.stabd	46,0,0
2310:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 1523               	.LM165:
 1524               	.LFBB14:
 1525               	/* prologue: function */
 1526               	/* frame size = 0 */
 1527               	/* stack size = 0 */
 1528               	.L__stack_usage = 0
2315:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1530               	.LM166:
 1531 05a6 0097      		sbiw r24,0
 1532 05a8 01F4      		brne .L91
2315:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1534               	.LM167:
 1535 05aa 8091 0000 		lds r24,pxCurrentTCB
 1536 05ae 9091 0000 		lds r25,pxCurrentTCB+1
 1537               	.L91:
2318:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1539               	.LM168:
 1540 05b2 4996      		adiw r24,25
 1541 05b4 0895      		ret
 1543               	.Lscope14:
 1545               		.stabd	78,0,0
 1547               	.global	xTaskIncrementTick
 1549               	xTaskIncrementTick:
 1550               		.stabd	46,0,0
2637:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1552               	.LM169:
 1553               	.LFBB15:
 1554 05b6 CF92      		push r12
 1555 05b8 DF92      		push r13
 1556 05ba EF92      		push r14
 1557 05bc FF92      		push r15
 1558 05be 0F93      		push r16
 1559 05c0 1F93      		push r17
 1560 05c2 CF93      		push r28
 1561 05c4 DF93      		push r29
 1562               	/* prologue: function */
 1563               	/* frame size = 0 */
 1564               	/* stack size = 8 */
 1565               	.L__stack_usage = 8
2646:FreeRTOS/Source/tasks.c **** 	{
 1567               	.LM170:
 1568 05c6 8091 0000 		lds r24,uxSchedulerSuspended
 1569 05ca 8111      		cpse r24,__zero_reg__
 1570 05cc 00C0      		rjmp .L93
 1571               	.LBB62:
2650:FreeRTOS/Source/tasks.c **** 
 1573               	.LM171:
 1574 05ce 0091 0000 		lds r16,xTickCount
 1575 05d2 1091 0000 		lds r17,xTickCount+1
 1576 05d6 0F5F      		subi r16,-1
 1577 05d8 1F4F      		sbci r17,-1
2654:FreeRTOS/Source/tasks.c **** 
 1579               	.LM172:
 1580 05da 1093 0000 		sts xTickCount+1,r17
 1581 05de 0093 0000 		sts xTickCount,r16
2656:FreeRTOS/Source/tasks.c **** 		{
 1583               	.LM173:
 1584 05e2 0115      		cp r16,__zero_reg__
 1585 05e4 1105      		cpc r17,__zero_reg__
 1586 05e6 01F4      		brne .L94
 1587               	.LBB63:
2658:FreeRTOS/Source/tasks.c **** 		}
 1589               	.LM174:
 1590 05e8 8091 0000 		lds r24,pxDelayedTaskList
 1591 05ec 9091 0000 		lds r25,pxDelayedTaskList+1
 1592 05f0 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1593 05f4 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1594 05f8 3093 0000 		sts pxDelayedTaskList+1,r19
 1595 05fc 2093 0000 		sts pxDelayedTaskList,r18
 1596 0600 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1597 0604 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1598 0608 8091 0000 		lds r24,xNumOfOverflows
 1599 060c 8F5F      		subi r24,lo8(-(1))
 1600 060e 8093 0000 		sts xNumOfOverflows,r24
 1601 0612 0E94 0000 		call prvResetNextTaskUnblockTime
 1602               	.L94:
 1603               	.LBE63:
2669:FreeRTOS/Source/tasks.c **** 		{
 1605               	.LM175:
 1606 0616 8091 0000 		lds r24,xNextTaskUnblockTime
 1607 061a 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1608 061e C0E0      		ldi r28,0
 1609 0620 0817      		cp r16,r24
 1610 0622 1907      		cpc r17,r25
 1611 0624 00F4      		brsh .+2
 1612 0626 00C0      		rjmp .L95
2723:FreeRTOS/Source/tasks.c **** 
 1614               	.LM176:
 1615 0628 D9E0      		ldi r29,lo8(9)
 1616               	.L96:
2673:FreeRTOS/Source/tasks.c **** 				{
 1618               	.LM177:
 1619 062a E091 0000 		lds r30,pxDelayedTaskList
 1620 062e F091 0000 		lds r31,pxDelayedTaskList+1
 1621 0632 8081      		ld r24,Z
 1622 0634 8111      		cpse r24,__zero_reg__
 1623 0636 00C0      		rjmp .L97
2680:FreeRTOS/Source/tasks.c **** 					break;
 1625               	.LM178:
 1626 0638 8FEF      		ldi r24,lo8(-1)
 1627 063a 9FEF      		ldi r25,lo8(-1)
 1628 063c 00C0      		rjmp .L111
 1629               	.L97:
2689:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1631               	.LM179:
 1632 063e E091 0000 		lds r30,pxDelayedTaskList
 1633 0642 F091 0000 		lds r31,pxDelayedTaskList+1
 1634 0646 0580      		ldd __tmp_reg__,Z+5
 1635 0648 F681      		ldd r31,Z+6
 1636 064a E02D      		mov r30,__tmp_reg__
 1637 064c E680      		ldd r14,Z+6
 1638 064e F780      		ldd r15,Z+7
2690:FreeRTOS/Source/tasks.c **** 
 1640               	.LM180:
 1641 0650 D701      		movw r26,r14
 1642 0652 1296      		adiw r26,2
 1643 0654 8D91      		ld r24,X+
 1644 0656 9C91      		ld r25,X
 1645 0658 1397      		sbiw r26,2+1
2692:FreeRTOS/Source/tasks.c **** 					{
 1647               	.LM181:
 1648 065a 0817      		cp r16,r24
 1649 065c 1907      		cpc r17,r25
 1650 065e 00F4      		brsh .L98
 1651               	.L111:
2699:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1653               	.LM182:
 1654 0660 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1655 0664 8093 0000 		sts xNextTaskUnblockTime,r24
2700:FreeRTOS/Source/tasks.c **** 					}
 1657               	.LM183:
 1658 0668 00C0      		rjmp .L95
 1659               	.L98:
2708:FreeRTOS/Source/tasks.c **** 
 1661               	.LM184:
 1662 066a 6701      		movw r12,r14
 1663 066c B2E0      		ldi r27,2
 1664 066e CB0E      		add r12,r27
 1665 0670 D11C      		adc r13,__zero_reg__
 1666 0672 C601      		movw r24,r12
 1667 0674 0E94 0000 		call uxListRemove
2712:FreeRTOS/Source/tasks.c **** 					{
 1669               	.LM185:
 1670 0678 F701      		movw r30,r14
 1671 067a 8489      		ldd r24,Z+20
 1672 067c 9589      		ldd r25,Z+21
 1673 067e 892B      		or r24,r25
 1674 0680 01F0      		breq .L99
2714:FreeRTOS/Source/tasks.c **** 					}
 1676               	.LM186:
 1677 0682 C701      		movw r24,r14
 1678 0684 0C96      		adiw r24,12
 1679 0686 0E94 0000 		call uxListRemove
 1680               	.L99:
2723:FreeRTOS/Source/tasks.c **** 
 1682               	.LM187:
 1683 068a D701      		movw r26,r14
 1684 068c 5696      		adiw r26,22
 1685 068e 8C91      		ld r24,X
 1686 0690 9091 0000 		lds r25,uxTopReadyPriority
 1687 0694 9817      		cp r25,r24
 1688 0696 00F4      		brsh .L100
2723:FreeRTOS/Source/tasks.c **** 
 1690               	.LM188:
 1691 0698 8093 0000 		sts uxTopReadyPriority,r24
 1692               	.L100:
2723:FreeRTOS/Source/tasks.c **** 
 1694               	.LM189:
 1695 069c D89F      		mul r29,r24
 1696 069e C001      		movw r24,r0
 1697 06a0 1124      		clr __zero_reg__
 1698 06a2 B601      		movw r22,r12
 1699 06a4 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1700 06a6 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1701 06a8 0E94 0000 		call vListInsertEnd
2733:FreeRTOS/Source/tasks.c **** 						{
 1703               	.LM190:
 1704 06ac E091 0000 		lds r30,pxCurrentTCB
 1705 06b0 F091 0000 		lds r31,pxCurrentTCB+1
 1706 06b4 D701      		movw r26,r14
 1707 06b6 5696      		adiw r26,22
 1708 06b8 9C91      		ld r25,X
 1709 06ba 8689      		ldd r24,Z+22
 1710 06bc 9817      		cp r25,r24
 1711 06be 00F4      		brsh .+2
 1712 06c0 00C0      		rjmp .L96
2735:FreeRTOS/Source/tasks.c **** 						}
 1714               	.LM191:
 1715 06c2 C1E0      		ldi r28,lo8(1)
 1716 06c4 00C0      		rjmp .L96
 1717               	.L95:
2752:FreeRTOS/Source/tasks.c **** 			{
 1719               	.LM192:
 1720 06c6 E091 0000 		lds r30,pxCurrentTCB
 1721 06ca F091 0000 		lds r31,pxCurrentTCB+1
 1722 06ce E689      		ldd r30,Z+22
 1723 06d0 B9E0      		ldi r27,lo8(9)
 1724 06d2 EB9F      		mul r30,r27
 1725 06d4 F001      		movw r30,r0
 1726 06d6 1124      		clr __zero_reg__
 1727 06d8 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1728 06da F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1729 06dc 8081      		ld r24,Z
 1730 06de 8230      		cpi r24,lo8(2)
 1731 06e0 00F0      		brlo .L102
2754:FreeRTOS/Source/tasks.c **** 			}
 1733               	.LM193:
 1734 06e2 C1E0      		ldi r28,lo8(1)
 1735 06e4 00C0      		rjmp .L102
 1736               	.L93:
 1737               	.LBE62:
2780:FreeRTOS/Source/tasks.c **** 
 1739               	.LM194:
 1740 06e6 8091 0000 		lds r24,uxPendedTicks
 1741 06ea 8F5F      		subi r24,lo8(-(1))
 1742 06ec 8093 0000 		sts uxPendedTicks,r24
2640:FreeRTOS/Source/tasks.c **** 
 1744               	.LM195:
 1745 06f0 C0E0      		ldi r28,0
 1746               	.L102:
2793:FreeRTOS/Source/tasks.c **** 		{
 1748               	.LM196:
 1749 06f2 8091 0000 		lds r24,xYieldPending
 1750 06f6 8111      		cpse r24,__zero_reg__
2795:FreeRTOS/Source/tasks.c **** 		}
 1752               	.LM197:
 1753 06f8 C1E0      		ldi r28,lo8(1)
 1754               	.L103:
2805:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1756               	.LM198:
 1757 06fa 8C2F      		mov r24,r28
 1758               	/* epilogue start */
 1759 06fc DF91      		pop r29
 1760 06fe CF91      		pop r28
 1761 0700 1F91      		pop r17
 1762 0702 0F91      		pop r16
 1763 0704 FF90      		pop r15
 1764 0706 EF90      		pop r14
 1765 0708 DF90      		pop r13
 1766 070a CF90      		pop r12
 1767 070c 0895      		ret
 1780               	.Lscope15:
 1782               		.stabd	78,0,0
 1784               	.global	xTaskResumeAll
 1786               	xTaskResumeAll:
 1787               		.stabd	46,0,0
2146:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
 1789               	.LM199:
 1790               	.LFBB16:
 1791 070e EF92      		push r14
 1792 0710 FF92      		push r15
 1793 0712 0F93      		push r16
 1794 0714 1F93      		push r17
 1795 0716 CF93      		push r28
 1796 0718 DF93      		push r29
 1797               	/* prologue: function */
 1798               	/* frame size = 0 */
 1799               	/* stack size = 6 */
 1800               	.L__stack_usage = 6
2159:FreeRTOS/Source/tasks.c **** 	{
 1802               	.LM200:
 1803               	/* #APP */
 1804               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1805 071a 0FB6      		in		__tmp_reg__, __SREG__
 1806               	 ;  0 "" 2
 1807               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1808 071c F894      		cli
 1809               	 ;  0 "" 2
 1810               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1811 071e 0F92      		push	__tmp_reg__
 1812               	 ;  0 "" 2
2161:FreeRTOS/Source/tasks.c **** 
 1814               	.LM201:
 1815               	/* #NOAPP */
 1816 0720 8091 0000 		lds r24,uxSchedulerSuspended
 1817 0724 8150      		subi r24,lo8(-(-1))
 1818 0726 8093 0000 		sts uxSchedulerSuspended,r24
2163:FreeRTOS/Source/tasks.c **** 		{
 1820               	.LM202:
 1821 072a 8091 0000 		lds r24,uxSchedulerSuspended
 1822 072e 8823      		tst r24
 1823 0730 01F0      		breq .L113
 1824               	.L115:
2148:FreeRTOS/Source/tasks.c **** 
 1826               	.LM203:
 1827 0732 80E0      		ldi r24,0
 1828 0734 00C0      		rjmp .L114
 1829               	.L113:
2165:FreeRTOS/Source/tasks.c **** 			{
 1831               	.LM204:
 1832 0736 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1833 073a 8823      		tst r24
 1834 073c 01F0      		breq .L115
 1835 073e C0E0      		ldi r28,0
 1836 0740 D0E0      		ldi r29,0
2174:FreeRTOS/Source/tasks.c **** 
 1838               	.LM205:
 1839 0742 89E0      		ldi r24,lo8(9)
 1840 0744 F82E      		mov r15,r24
2180:FreeRTOS/Source/tasks.c **** 					}
 1842               	.LM206:
 1843 0746 EE24      		clr r14
 1844 0748 E394      		inc r14
 1845               	.L116:
2169:FreeRTOS/Source/tasks.c **** 				{
 1847               	.LM207:
 1848 074a 8091 0000 		lds r24,xPendingReadyList
 1849 074e 8823      		tst r24
 1850 0750 01F0      		breq .L140
2171:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1852               	.LM208:
 1853 0752 E091 0000 		lds r30,xPendingReadyList+5
 1854 0756 F091 0000 		lds r31,xPendingReadyList+5+1
 1855 075a C681      		ldd r28,Z+6
 1856 075c D781      		ldd r29,Z+7
2172:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1858               	.LM209:
 1859 075e CE01      		movw r24,r28
 1860 0760 0C96      		adiw r24,12
 1861 0762 0E94 0000 		call uxListRemove
2173:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1863               	.LM210:
 1864 0766 8E01      		movw r16,r28
 1865 0768 0E5F      		subi r16,-2
 1866 076a 1F4F      		sbci r17,-1
 1867 076c C801      		movw r24,r16
 1868 076e 0E94 0000 		call uxListRemove
2174:FreeRTOS/Source/tasks.c **** 
 1870               	.LM211:
 1871 0772 8E89      		ldd r24,Y+22
 1872 0774 9091 0000 		lds r25,uxTopReadyPriority
 1873 0778 9817      		cp r25,r24
 1874 077a 00F4      		brsh .L117
2174:FreeRTOS/Source/tasks.c **** 
 1876               	.LM212:
 1877 077c 8093 0000 		sts uxTopReadyPriority,r24
 1878               	.L117:
2174:FreeRTOS/Source/tasks.c **** 
 1880               	.LM213:
 1881 0780 F89E      		mul r15,r24
 1882 0782 C001      		movw r24,r0
 1883 0784 1124      		clr __zero_reg__
 1884 0786 B801      		movw r22,r16
 1885 0788 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1886 078a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1887 078c 0E94 0000 		call vListInsertEnd
2178:FreeRTOS/Source/tasks.c **** 					{
 1889               	.LM214:
 1890 0790 E091 0000 		lds r30,pxCurrentTCB
 1891 0794 F091 0000 		lds r31,pxCurrentTCB+1
 1892 0798 9E89      		ldd r25,Y+22
 1893 079a 8689      		ldd r24,Z+22
 1894 079c 9817      		cp r25,r24
 1895 079e 00F0      		brlo .L116
2180:FreeRTOS/Source/tasks.c **** 					}
 1897               	.LM215:
 1898 07a0 E092 0000 		sts xYieldPending,r14
 1899 07a4 00C0      		rjmp .L116
 1900               	.L140:
2188:FreeRTOS/Source/tasks.c **** 				{
 1902               	.LM216:
 1903 07a6 CD2B      		or r28,r29
 1904 07a8 01F0      		breq .L120
2196:FreeRTOS/Source/tasks.c **** 				}
 1906               	.LM217:
 1907 07aa 0E94 0000 		call prvResetNextTaskUnblockTime
 1908               	.L120:
 1909               	.LBB64:
2204:FreeRTOS/Source/tasks.c **** 
 1911               	.LM218:
 1912 07ae C091 0000 		lds r28,uxPendedTicks
2206:FreeRTOS/Source/tasks.c **** 					{
 1914               	.LM219:
 1915 07b2 CC23      		tst r28
 1916 07b4 01F0      		breq .L121
2212:FreeRTOS/Source/tasks.c **** 							}
 1918               	.LM220:
 1919 07b6 D1E0      		ldi r29,lo8(1)
 1920               	.L123:
2210:FreeRTOS/Source/tasks.c **** 							{
 1922               	.LM221:
 1923 07b8 0E94 0000 		call xTaskIncrementTick
 1924 07bc 8111      		cpse r24,__zero_reg__
2212:FreeRTOS/Source/tasks.c **** 							}
 1926               	.LM222:
 1927 07be D093 0000 		sts xYieldPending,r29
 1928               	.L122:
2218:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 1930               	.LM223:
 1931 07c2 C150      		subi r28,lo8(-(-1))
2219:FreeRTOS/Source/tasks.c **** 
 1933               	.LM224:
 1934 07c4 01F4      		brne .L123
2221:FreeRTOS/Source/tasks.c **** 					}
 1936               	.LM225:
 1937 07c6 1092 0000 		sts uxPendedTicks,__zero_reg__
 1938               	.L121:
 1939               	.LBE64:
2229:FreeRTOS/Source/tasks.c **** 				{
 1941               	.LM226:
 1942 07ca 8091 0000 		lds r24,xYieldPending
 1943 07ce 8823      		tst r24
 1944 07d0 01F4      		brne .+2
 1945 07d2 00C0      		rjmp .L115
2236:FreeRTOS/Source/tasks.c **** 				}
 1947               	.LM227:
 1948 07d4 0E94 0000 		call vPortYield
2233:FreeRTOS/Source/tasks.c **** 					}
 1950               	.LM228:
 1951 07d8 81E0      		ldi r24,lo8(1)
 1952               	.L114:
2249:FreeRTOS/Source/tasks.c **** 
 1954               	.LM229:
 1955               	/* #APP */
 1956               	 ;  2249 "FreeRTOS/Source/tasks.c" 1
 1957 07da 0F90      		pop		__tmp_reg__
 1958               	 ;  0 "" 2
 1959               	 ;  2249 "FreeRTOS/Source/tasks.c" 1
 1960 07dc 0FBE      		out		__SREG__, __tmp_reg__
 1961               	 ;  0 "" 2
 1962               	/* epilogue start */
2252:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1964               	.LM230:
 1965               	/* #NOAPP */
 1966 07de DF91      		pop r29
 1967 07e0 CF91      		pop r28
 1968 07e2 1F91      		pop r17
 1969 07e4 0F91      		pop r16
 1970 07e6 FF90      		pop r15
 1971 07e8 EF90      		pop r14
 1972 07ea 0895      		ret
 1981               	.Lscope16:
 1983               		.stabd	78,0,0
 1987               	.global	vTaskDelayUntil
 1989               	vTaskDelayUntil:
 1990               		.stabd	46,0,0
1222:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 1992               	.LM231:
 1993               	.LFBB17:
 1994 07ec 0F93      		push r16
 1995 07ee 1F93      		push r17
 1996 07f0 CF93      		push r28
 1997 07f2 DF93      		push r29
 1998               	/* prologue: function */
 1999               	/* frame size = 0 */
 2000               	/* stack size = 4 */
 2001               	.L__stack_usage = 4
 2002 07f4 8C01      		movw r16,r24
 2003 07f6 EB01      		movw r28,r22
1230:FreeRTOS/Source/tasks.c **** 		{
 2005               	.LM232:
 2006 07f8 0E94 0000 		call vTaskSuspendAll
 2007               	.LBB65:
1234:FreeRTOS/Source/tasks.c **** 
 2009               	.LM233:
 2010 07fc 4091 0000 		lds r20,xTickCount
 2011 0800 5091 0000 		lds r21,xTickCount+1
1237:FreeRTOS/Source/tasks.c **** 
 2013               	.LM234:
 2014 0804 F801      		movw r30,r16
 2015 0806 2081      		ld r18,Z
 2016 0808 3181      		ldd r19,Z+1
 2017 080a C901      		movw r24,r18
 2018 080c 8C0F      		add r24,r28
 2019 080e 9D1F      		adc r25,r29
1239:FreeRTOS/Source/tasks.c **** 			{
 2021               	.LM235:
 2022 0810 4217      		cp r20,r18
 2023 0812 5307      		cpc r21,r19
 2024 0814 00F4      		brsh .L142
1246:FreeRTOS/Source/tasks.c **** 				{
 2026               	.LM236:
 2027 0816 8217      		cp r24,r18
 2028 0818 9307      		cpc r25,r19
 2029 081a 00F4      		brsh .L148
 2030 081c 00C0      		rjmp .L155
 2031               	.L142:
1260:FreeRTOS/Source/tasks.c **** 				{
 2033               	.LM237:
 2034 081e 8217      		cp r24,r18
 2035 0820 9307      		cpc r25,r19
 2036 0822 00F0      		brlo .L149
 2037               	.L155:
 2038               	.LBE65:
1224:FreeRTOS/Source/tasks.c **** 
 2040               	.LM238:
 2041 0824 21E0      		ldi r18,lo8(1)
 2042 0826 4817      		cp r20,r24
 2043 0828 5907      		cpc r21,r25
 2044 082a 00F0      		brlo .L143
 2045               	.L148:
1224:FreeRTOS/Source/tasks.c **** 
 2047               	.LM239:
 2048 082c 20E0      		ldi r18,0
 2049 082e 00C0      		rjmp .L143
 2050               	.L149:
 2051               	.LBB66:
1262:FreeRTOS/Source/tasks.c **** 				}
 2053               	.LM240:
 2054 0830 21E0      		ldi r18,lo8(1)
 2055               	.L143:
1271:FreeRTOS/Source/tasks.c **** 
 2057               	.LM241:
 2058 0832 F801      		movw r30,r16
 2059 0834 9183      		std Z+1,r25
 2060 0836 8083      		st Z,r24
1273:FreeRTOS/Source/tasks.c **** 			{
 2062               	.LM242:
 2063 0838 2223      		tst r18
 2064 083a 01F0      		breq .L146
1279:FreeRTOS/Source/tasks.c **** 			}
 2066               	.LM243:
 2067 083c 60E0      		ldi r22,0
 2068 083e 841B      		sub r24,r20
 2069 0840 950B      		sbc r25,r21
 2070 0842 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2071               	.L146:
 2072               	.LBE66:
1286:FreeRTOS/Source/tasks.c **** 
 2074               	.LM244:
 2075 0846 0E94 0000 		call xTaskResumeAll
1290:FreeRTOS/Source/tasks.c **** 		{
 2077               	.LM245:
 2078 084a 8111      		cpse r24,__zero_reg__
 2079 084c 00C0      		rjmp .L141
1292:FreeRTOS/Source/tasks.c **** 		}
 2081               	.LM246:
 2082 084e 0E94 0000 		call vPortYield
 2083               	.L141:
 2084               	/* epilogue start */
1298:FreeRTOS/Source/tasks.c **** 
 2086               	.LM247:
 2087 0852 DF91      		pop r29
 2088 0854 CF91      		pop r28
 2089 0856 1F91      		pop r17
 2090 0858 0F91      		pop r16
 2091 085a 0895      		ret
 2103               	.Lscope17:
 2105               		.stabd	78,0,0
 2108               	.global	vTaskDelay
 2110               	vTaskDelay:
 2111               		.stabd	46,0,0
1306:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 2113               	.LM248:
 2114               	.LFBB18:
 2115 085c CF93      		push r28
 2116 085e DF93      		push r29
 2117               	/* prologue: function */
 2118               	/* frame size = 0 */
 2119               	/* stack size = 2 */
 2120               	.L__stack_usage = 2
 2121 0860 EC01      		movw r28,r24
1310:FreeRTOS/Source/tasks.c **** 		{
 2123               	.LM249:
 2124 0862 892B      		or r24,r25
 2125 0864 01F4      		brne .L157
 2126               	.L159:
1337:FreeRTOS/Source/tasks.c **** 		}
 2128               	.LM250:
 2129 0866 0E94 0000 		call vPortYield
 2130 086a 00C0      		rjmp .L156
 2131               	.L157:
1313:FreeRTOS/Source/tasks.c **** 			{
 2133               	.LM251:
 2134 086c 0E94 0000 		call vTaskSuspendAll
1324:FreeRTOS/Source/tasks.c **** 			}
 2136               	.LM252:
 2137 0870 60E0      		ldi r22,0
 2138 0872 CE01      		movw r24,r28
 2139 0874 0E94 0000 		call prvAddCurrentTaskToDelayedList
1326:FreeRTOS/Source/tasks.c **** 		}
 2141               	.LM253:
 2142 0878 0E94 0000 		call xTaskResumeAll
1335:FreeRTOS/Source/tasks.c **** 		{
 2144               	.LM254:
 2145 087c 8823      		tst r24
 2146 087e 01F0      		breq .L159
 2147               	.L156:
 2148               	/* epilogue start */
1343:FreeRTOS/Source/tasks.c **** 
 2150               	.LM255:
 2151 0880 DF91      		pop r29
 2152 0882 CF91      		pop r28
 2153 0884 0895      		ret
 2155               	.Lscope18:
 2157               		.stabd	78,0,0
 2159               	.global	vTaskSwitchContext
 2161               	vTaskSwitchContext:
 2162               		.stabd	46,0,0
2901:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2164               	.LM256:
 2165               	.LFBB19:
 2166               	/* prologue: function */
 2167               	/* frame size = 0 */
 2168               	/* stack size = 0 */
 2169               	.L__stack_usage = 0
2902:FreeRTOS/Source/tasks.c **** 	{
 2171               	.LM257:
 2172 0886 8091 0000 		lds r24,uxSchedulerSuspended
 2173 088a 8823      		tst r24
 2174 088c 01F0      		breq .L164
2906:FreeRTOS/Source/tasks.c **** 	}
 2176               	.LM258:
 2177 088e 81E0      		ldi r24,lo8(1)
 2178 0890 8093 0000 		sts xYieldPending,r24
 2179 0894 0895      		ret
 2180               	.L164:
 2181               	.LBB71:
 2182               	.LBB72:
2910:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2184               	.LM259:
 2185 0896 1092 0000 		sts xYieldPending,__zero_reg__
 2186               	.LBB73:
2952:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2188               	.LM260:
 2189 089a 8091 0000 		lds r24,uxTopReadyPriority
 2190 089e 69E0      		ldi r22,lo8(9)
 2191               	.L166:
 2192 08a0 482F      		mov r20,r24
 2193 08a2 50E0      		ldi r21,0
 2194 08a4 649F      		mul r22,r20
 2195 08a6 9001      		movw r18,r0
 2196 08a8 659F      		mul r22,r21
 2197 08aa 300D      		add r19,r0
 2198 08ac 1124      		clr __zero_reg__
 2199 08ae F901      		movw r30,r18
 2200 08b0 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2201 08b2 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2202 08b4 9081      		ld r25,Z
 2203 08b6 9111      		cpse r25,__zero_reg__
 2204 08b8 00C0      		rjmp .L169
 2205 08ba 8150      		subi r24,lo8(-(-1))
 2206 08bc 00C0      		rjmp .L166
 2207               	.L169:
 2208               	.LBB74:
 2209 08be A181      		ldd r26,Z+1
 2210 08c0 B281      		ldd r27,Z+2
 2211 08c2 1296      		adiw r26,2
 2212 08c4 0D90      		ld __tmp_reg__,X+
 2213 08c6 BC91      		ld r27,X
 2214 08c8 A02D      		mov r26,__tmp_reg__
 2215 08ca B283      		std Z+2,r27
 2216 08cc A183      		std Z+1,r26
 2217 08ce 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 2218 08d0 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 2219 08d2 A217      		cp r26,r18
 2220 08d4 B307      		cpc r27,r19
 2221 08d6 01F4      		brne .L168
 2222 08d8 1296      		adiw r26,2
 2223 08da 2D91      		ld r18,X+
 2224 08dc 3C91      		ld r19,X
 2225 08de 1397      		sbiw r26,2+1
 2226 08e0 3283      		std Z+2,r19
 2227 08e2 2183      		std Z+1,r18
 2228               	.L168:
 2229 08e4 99E0      		ldi r25,lo8(9)
 2230 08e6 949F      		mul r25,r20
 2231 08e8 F001      		movw r30,r0
 2232 08ea 959F      		mul r25,r21
 2233 08ec F00D      		add r31,r0
 2234 08ee 1124      		clr __zero_reg__
 2235 08f0 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2236 08f2 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2237 08f4 0180      		ldd __tmp_reg__,Z+1
 2238 08f6 F281      		ldd r31,Z+2
 2239 08f8 E02D      		mov r30,__tmp_reg__
 2240 08fa 2681      		ldd r18,Z+6
 2241 08fc 3781      		ldd r19,Z+7
 2242 08fe 3093 0000 		sts pxCurrentTCB+1,r19
 2243 0902 2093 0000 		sts pxCurrentTCB,r18
 2244               	.LBE74:
 2245 0906 8093 0000 		sts uxTopReadyPriority,r24
 2246 090a 0895      		ret
 2247               	.LBE73:
 2248               	.LBE72:
 2249               	.LBE71:
 2254               	.Lscope19:
 2256               		.stabd	78,0,0
 2259               	.global	vTaskSuspend
 2261               	vTaskSuspend:
 2262               		.stabd	46,0,0
1669:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 2264               	.LM261:
 2265               	.LFBB20:
 2266 090c 0F93      		push r16
 2267 090e 1F93      		push r17
 2268 0910 CF93      		push r28
 2269 0912 DF93      		push r29
 2270               	/* prologue: function */
 2271               	/* frame size = 0 */
 2272               	/* stack size = 4 */
 2273               	.L__stack_usage = 4
 2274 0914 EC01      		movw r28,r24
1672:FreeRTOS/Source/tasks.c **** 		{
 2276               	.LM262:
 2277               	/* #APP */
 2278               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2279 0916 0FB6      		in		__tmp_reg__, __SREG__
 2280               	 ;  0 "" 2
 2281               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2282 0918 F894      		cli
 2283               	 ;  0 "" 2
 2284               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2285 091a 0F92      		push	__tmp_reg__
 2286               	 ;  0 "" 2
1676:FreeRTOS/Source/tasks.c **** 
 2288               	.LM263:
 2289               	/* #NOAPP */
 2290 091c 892B      		or r24,r25
 2291 091e 01F4      		brne .L171
1676:FreeRTOS/Source/tasks.c **** 
 2293               	.LM264:
 2294 0920 C091 0000 		lds r28,pxCurrentTCB
 2295 0924 D091 0000 		lds r29,pxCurrentTCB+1
 2296               	.L171:
1682:FreeRTOS/Source/tasks.c **** 			{
 2298               	.LM265:
 2299 0928 8E01      		movw r16,r28
 2300 092a 0E5F      		subi r16,-2
 2301 092c 1F4F      		sbci r17,-1
 2302 092e C801      		movw r24,r16
 2303 0930 0E94 0000 		call uxListRemove
1692:FreeRTOS/Source/tasks.c **** 			{
 2305               	.LM266:
 2306 0934 8C89      		ldd r24,Y+20
 2307 0936 9D89      		ldd r25,Y+21
 2308 0938 892B      		or r24,r25
 2309 093a 01F0      		breq .L172
1694:FreeRTOS/Source/tasks.c **** 			}
 2311               	.LM267:
 2312 093c CE01      		movw r24,r28
 2313 093e 0C96      		adiw r24,12
 2314 0940 0E94 0000 		call uxListRemove
 2315               	.L172:
1701:FreeRTOS/Source/tasks.c **** 
 2317               	.LM268:
 2318 0944 B801      		movw r22,r16
 2319 0946 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2320 0948 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2321 094a 0E94 0000 		call vListInsertEnd
1705:FreeRTOS/Source/tasks.c **** 				{
 2323               	.LM269:
 2324 094e 8FA1      		ldd r24,Y+39
 2325 0950 8130      		cpi r24,lo8(1)
 2326 0952 01F4      		brne .L173
1709:FreeRTOS/Source/tasks.c **** 				}
 2328               	.LM270:
 2329 0954 1FA2      		std Y+39,__zero_reg__
 2330               	.L173:
1714:FreeRTOS/Source/tasks.c **** 
 2332               	.LM271:
 2333               	/* #APP */
 2334               	 ;  1714 "FreeRTOS/Source/tasks.c" 1
 2335 0956 0F90      		pop		__tmp_reg__
 2336               	 ;  0 "" 2
 2337               	 ;  1714 "FreeRTOS/Source/tasks.c" 1
 2338 0958 0FBE      		out		__SREG__, __tmp_reg__
 2339               	 ;  0 "" 2
1716:FreeRTOS/Source/tasks.c **** 		{
 2341               	.LM272:
 2342               	/* #NOAPP */
 2343 095a 8091 0000 		lds r24,xSchedulerRunning
 2344 095e 8823      		tst r24
 2345 0960 01F0      		breq .L174
1720:FreeRTOS/Source/tasks.c **** 			{
 2347               	.LM273:
 2348               	/* #APP */
 2349               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2350 0962 0FB6      		in		__tmp_reg__, __SREG__
 2351               	 ;  0 "" 2
 2352               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2353 0964 F894      		cli
 2354               	 ;  0 "" 2
 2355               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2356 0966 0F92      		push	__tmp_reg__
 2357               	 ;  0 "" 2
1722:FreeRTOS/Source/tasks.c **** 			}
 2359               	.LM274:
 2360               	/* #NOAPP */
 2361 0968 0E94 0000 		call prvResetNextTaskUnblockTime
1724:FreeRTOS/Source/tasks.c **** 		}
 2363               	.LM275:
 2364               	/* #APP */
 2365               	 ;  1724 "FreeRTOS/Source/tasks.c" 1
 2366 096c 0F90      		pop		__tmp_reg__
 2367               	 ;  0 "" 2
 2368               	 ;  1724 "FreeRTOS/Source/tasks.c" 1
 2369 096e 0FBE      		out		__SREG__, __tmp_reg__
 2370               	 ;  0 "" 2
 2371               	/* #NOAPP */
 2372               	.L174:
1731:FreeRTOS/Source/tasks.c **** 		{
 2374               	.LM276:
 2375 0970 8091 0000 		lds r24,pxCurrentTCB
 2376 0974 9091 0000 		lds r25,pxCurrentTCB+1
 2377 0978 C817      		cp r28,r24
 2378 097a D907      		cpc r29,r25
 2379 097c 01F4      		brne .L170
1733:FreeRTOS/Source/tasks.c **** 			{
 2381               	.LM277:
 2382 097e 8091 0000 		lds r24,xSchedulerRunning
 2383 0982 8823      		tst r24
 2384 0984 01F0      		breq .L176
1737:FreeRTOS/Source/tasks.c **** 			}
 2386               	.LM278:
 2387 0986 0E94 0000 		call vPortYield
 2388 098a 00C0      		rjmp .L170
 2389               	.L176:
1744:FreeRTOS/Source/tasks.c **** 				{
 2391               	.LM279:
 2392 098c 9091 0000 		lds r25,xSuspendedTaskList
 2393 0990 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2394 0994 9813      		cpse r25,r24
 2395 0996 00C0      		rjmp .L177
1750:FreeRTOS/Source/tasks.c **** 				}
 2397               	.LM280:
 2398 0998 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 2399 099c 1092 0000 		sts pxCurrentTCB,__zero_reg__
 2400 09a0 00C0      		rjmp .L170
 2401               	.L177:
 2402               	/* epilogue start */
1762:FreeRTOS/Source/tasks.c **** 
 2404               	.LM281:
 2405 09a2 DF91      		pop r29
 2406 09a4 CF91      		pop r28
 2407 09a6 1F91      		pop r17
 2408 09a8 0F91      		pop r16
1754:FreeRTOS/Source/tasks.c **** 				}
 2410               	.LM282:
 2411 09aa 0C94 0000 		jmp vTaskSwitchContext
 2412               	.L170:
 2413               	/* epilogue start */
1762:FreeRTOS/Source/tasks.c **** 
 2415               	.LM283:
 2416 09ae DF91      		pop r29
 2417 09b0 CF91      		pop r28
 2418 09b2 1F91      		pop r17
 2419 09b4 0F91      		pop r16
 2420 09b6 0895      		ret
 2422               	.Lscope20:
 2424               		.stabd	78,0,0
 2428               	.global	vTaskPlaceOnEventList
 2430               	vTaskPlaceOnEventList:
 2431               		.stabd	46,0,0
2974:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2433               	.LM284:
 2434               	.LFBB21:
 2435 09b8 CF93      		push r28
 2436 09ba DF93      		push r29
 2437               	/* prologue: function */
 2438               	/* frame size = 0 */
 2439               	/* stack size = 2 */
 2440               	.L__stack_usage = 2
 2441 09bc EB01      		movw r28,r22
2984:FreeRTOS/Source/tasks.c **** 
 2443               	.LM285:
 2444 09be 6091 0000 		lds r22,pxCurrentTCB
 2445 09c2 7091 0000 		lds r23,pxCurrentTCB+1
 2446 09c6 645F      		subi r22,-12
 2447 09c8 7F4F      		sbci r23,-1
 2448 09ca 0E94 0000 		call vListInsert
2986:FreeRTOS/Source/tasks.c **** }
 2450               	.LM286:
 2451 09ce 61E0      		ldi r22,lo8(1)
 2452 09d0 CE01      		movw r24,r28
 2453               	/* epilogue start */
2987:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2455               	.LM287:
 2456 09d2 DF91      		pop r29
 2457 09d4 CF91      		pop r28
2986:FreeRTOS/Source/tasks.c **** }
 2459               	.LM288:
 2460 09d6 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2462               	.Lscope21:
 2464               		.stabd	78,0,0
 2469               	.global	vTaskPlaceOnUnorderedEventList
 2471               	vTaskPlaceOnUnorderedEventList:
 2472               		.stabd	46,0,0
2991:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2474               	.LM289:
 2475               	.LFBB22:
 2476 09da CF93      		push r28
 2477 09dc DF93      		push r29
 2478               	/* prologue: function */
 2479               	/* frame size = 0 */
 2480               	/* stack size = 2 */
 2481               	.L__stack_usage = 2
 2482 09de EA01      		movw r28,r20
3001:FreeRTOS/Source/tasks.c **** 
 2484               	.LM290:
 2485 09e0 E091 0000 		lds r30,pxCurrentTCB
 2486 09e4 F091 0000 		lds r31,pxCurrentTCB+1
 2487 09e8 7068      		ori r23,128
 2488 09ea 7587      		std Z+13,r23
 2489 09ec 6487      		std Z+12,r22
3008:FreeRTOS/Source/tasks.c **** 
 2491               	.LM291:
 2492 09ee 6091 0000 		lds r22,pxCurrentTCB
 2493 09f2 7091 0000 		lds r23,pxCurrentTCB+1
 2494 09f6 645F      		subi r22,-12
 2495 09f8 7F4F      		sbci r23,-1
 2496 09fa 0E94 0000 		call vListInsertEnd
3010:FreeRTOS/Source/tasks.c **** }
 2498               	.LM292:
 2499 09fe 61E0      		ldi r22,lo8(1)
 2500 0a00 CE01      		movw r24,r28
 2501               	/* epilogue start */
3011:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2503               	.LM293:
 2504 0a02 DF91      		pop r29
 2505 0a04 CF91      		pop r28
3010:FreeRTOS/Source/tasks.c **** }
 2507               	.LM294:
 2508 0a06 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2510               	.Lscope22:
 2512               		.stabd	78,0,0
 2515               	.global	xTaskRemoveFromEventList
 2517               	xTaskRemoveFromEventList:
 2518               		.stabd	46,0,0
3048:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2520               	.LM295:
 2521               	.LFBB23:
 2522 0a0a 0F93      		push r16
 2523 0a0c 1F93      		push r17
 2524 0a0e CF93      		push r28
 2525 0a10 DF93      		push r29
 2526               	/* prologue: function */
 2527               	/* frame size = 0 */
 2528               	/* stack size = 4 */
 2529               	.L__stack_usage = 4
3065:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2531               	.LM296:
 2532 0a12 DC01      		movw r26,r24
 2533 0a14 1596      		adiw r26,5
 2534 0a16 ED91      		ld r30,X+
 2535 0a18 FC91      		ld r31,X
 2536 0a1a 1697      		sbiw r26,5+1
 2537 0a1c C681      		ldd r28,Z+6
 2538 0a1e D781      		ldd r29,Z+7
3067:FreeRTOS/Source/tasks.c **** 
 2540               	.LM297:
 2541 0a20 8E01      		movw r16,r28
 2542 0a22 045F      		subi r16,-12
 2543 0a24 1F4F      		sbci r17,-1
 2544 0a26 C801      		movw r24,r16
 2545 0a28 0E94 0000 		call uxListRemove
3069:FreeRTOS/Source/tasks.c **** 	{
 2547               	.LM298:
 2548 0a2c 8091 0000 		lds r24,uxSchedulerSuspended
 2549 0a30 8111      		cpse r24,__zero_reg__
 2550 0a32 00C0      		rjmp .L187
3071:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2552               	.LM299:
 2553 0a34 0A50      		subi r16,10
 2554 0a36 1109      		sbc r17,__zero_reg__
 2555 0a38 C801      		movw r24,r16
 2556 0a3a 0E94 0000 		call uxListRemove
3072:FreeRTOS/Source/tasks.c **** 	}
 2558               	.LM300:
 2559 0a3e 8E89      		ldd r24,Y+22
 2560 0a40 9091 0000 		lds r25,uxTopReadyPriority
 2561 0a44 9817      		cp r25,r24
 2562 0a46 00F4      		brsh .L188
3072:FreeRTOS/Source/tasks.c **** 	}
 2564               	.LM301:
 2565 0a48 8093 0000 		sts uxTopReadyPriority,r24
 2566               	.L188:
3072:FreeRTOS/Source/tasks.c **** 	}
 2568               	.LM302:
 2569 0a4c B9E0      		ldi r27,lo8(9)
 2570 0a4e 8B9F      		mul r24,r27
 2571 0a50 C001      		movw r24,r0
 2572 0a52 1124      		clr __zero_reg__
 2573 0a54 B801      		movw r22,r16
 2574 0a56 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2575 0a58 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2576 0a5a 00C0      		rjmp .L192
 2577               	.L187:
3078:FreeRTOS/Source/tasks.c **** 	}
 2579               	.LM303:
 2580 0a5c B801      		movw r22,r16
 2581 0a5e 80E0      		ldi r24,lo8(xPendingReadyList)
 2582 0a60 90E0      		ldi r25,hi8(xPendingReadyList)
 2583               	.L192:
 2584 0a62 0E94 0000 		call vListInsertEnd
3081:FreeRTOS/Source/tasks.c **** 	{
 2586               	.LM304:
 2587 0a66 E091 0000 		lds r30,pxCurrentTCB
 2588 0a6a F091 0000 		lds r31,pxCurrentTCB+1
 2589 0a6e 9E89      		ldd r25,Y+22
 2590 0a70 8689      		ldd r24,Z+22
 2591 0a72 8917      		cp r24,r25
 2592 0a74 00F4      		brsh .L191
3090:FreeRTOS/Source/tasks.c **** 	}
 2594               	.LM305:
 2595 0a76 81E0      		ldi r24,lo8(1)
 2596 0a78 8093 0000 		sts xYieldPending,r24
 2597 0a7c 00C0      		rjmp .L190
 2598               	.L191:
3094:FreeRTOS/Source/tasks.c **** 	}
 2600               	.LM306:
 2601 0a7e 80E0      		ldi r24,0
 2602               	.L190:
 2603               	/* epilogue start */
3112:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2605               	.LM307:
 2606 0a80 DF91      		pop r29
 2607 0a82 CF91      		pop r28
 2608 0a84 1F91      		pop r17
 2609 0a86 0F91      		pop r16
 2610 0a88 0895      		ret
 2616               	.Lscope23:
 2618               		.stabd	78,0,0
 2622               	.global	vTaskRemoveFromUnorderedEventList
 2624               	vTaskRemoveFromUnorderedEventList:
 2625               		.stabd	46,0,0
3116:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2627               	.LM308:
 2628               	.LFBB24:
 2629 0a8a 0F93      		push r16
 2630 0a8c 1F93      		push r17
 2631 0a8e CF93      		push r28
 2632 0a90 DF93      		push r29
 2633               	/* prologue: function */
 2634               	/* frame size = 0 */
 2635               	/* stack size = 4 */
 2636               	.L__stack_usage = 4
3124:FreeRTOS/Source/tasks.c **** 
 2638               	.LM309:
 2639 0a92 7068      		ori r23,128
 2640 0a94 FC01      		movw r30,r24
 2641 0a96 7183      		std Z+1,r23
 2642 0a98 6083      		st Z,r22
3128:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2644               	.LM310:
 2645 0a9a C681      		ldd r28,Z+6
 2646 0a9c D781      		ldd r29,Z+7
3130:FreeRTOS/Source/tasks.c **** 
 2648               	.LM311:
 2649 0a9e 0E94 0000 		call uxListRemove
3135:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2651               	.LM312:
 2652 0aa2 8E01      		movw r16,r28
 2653 0aa4 0E5F      		subi r16,-2
 2654 0aa6 1F4F      		sbci r17,-1
 2655 0aa8 C801      		movw r24,r16
 2656 0aaa 0E94 0000 		call uxListRemove
3136:FreeRTOS/Source/tasks.c **** 
 2658               	.LM313:
 2659 0aae 8E89      		ldd r24,Y+22
 2660 0ab0 9091 0000 		lds r25,uxTopReadyPriority
 2661 0ab4 9817      		cp r25,r24
 2662 0ab6 00F4      		brsh .L194
3136:FreeRTOS/Source/tasks.c **** 
 2664               	.LM314:
 2665 0ab8 8093 0000 		sts uxTopReadyPriority,r24
 2666               	.L194:
3136:FreeRTOS/Source/tasks.c **** 
 2668               	.LM315:
 2669 0abc F9E0      		ldi r31,lo8(9)
 2670 0abe 8F9F      		mul r24,r31
 2671 0ac0 C001      		movw r24,r0
 2672 0ac2 1124      		clr __zero_reg__
 2673 0ac4 B801      		movw r22,r16
 2674 0ac6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2675 0ac8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2676 0aca 0E94 0000 		call vListInsertEnd
3138:FreeRTOS/Source/tasks.c **** 	{
 2678               	.LM316:
 2679 0ace E091 0000 		lds r30,pxCurrentTCB
 2680 0ad2 F091 0000 		lds r31,pxCurrentTCB+1
 2681 0ad6 9E89      		ldd r25,Y+22
 2682 0ad8 8689      		ldd r24,Z+22
 2683 0ada 8917      		cp r24,r25
 2684 0adc 00F4      		brsh .L193
3144:FreeRTOS/Source/tasks.c **** 	}
 2686               	.LM317:
 2687 0ade 81E0      		ldi r24,lo8(1)
 2688 0ae0 8093 0000 		sts xYieldPending,r24
 2689               	.L193:
 2690               	/* epilogue start */
3146:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2692               	.LM318:
 2693 0ae4 DF91      		pop r29
 2694 0ae6 CF91      		pop r28
 2695 0ae8 1F91      		pop r17
 2696 0aea 0F91      		pop r16
 2697 0aec 0895      		ret
 2702               	.Lscope24:
 2704               		.stabd	78,0,0
 2707               	.global	vTaskSetTimeOutState
 2709               	vTaskSetTimeOutState:
 2710               		.stabd	46,0,0
3150:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2712               	.LM319:
 2713               	.LFBB25:
 2714               	/* prologue: function */
 2715               	/* frame size = 0 */
 2716               	/* stack size = 0 */
 2717               	.L__stack_usage = 0
3152:FreeRTOS/Source/tasks.c **** 	{
 2719               	.LM320:
 2720               	/* #APP */
 2721               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2722 0aee 0FB6      		in		__tmp_reg__, __SREG__
 2723               	 ;  0 "" 2
 2724               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2725 0af0 F894      		cli
 2726               	 ;  0 "" 2
 2727               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2728 0af2 0F92      		push	__tmp_reg__
 2729               	 ;  0 "" 2
3154:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2731               	.LM321:
 2732               	/* #NOAPP */
 2733 0af4 2091 0000 		lds r18,xNumOfOverflows
 2734 0af8 FC01      		movw r30,r24
 2735 0afa 2083      		st Z,r18
3155:FreeRTOS/Source/tasks.c **** 	}
 2737               	.LM322:
 2738 0afc 2091 0000 		lds r18,xTickCount
 2739 0b00 3091 0000 		lds r19,xTickCount+1
 2740 0b04 3283      		std Z+2,r19
 2741 0b06 2183      		std Z+1,r18
3157:FreeRTOS/Source/tasks.c **** }
 2743               	.LM323:
 2744               	/* #APP */
 2745               	 ;  3157 "FreeRTOS/Source/tasks.c" 1
 2746 0b08 0F90      		pop		__tmp_reg__
 2747               	 ;  0 "" 2
 2748               	 ;  3157 "FreeRTOS/Source/tasks.c" 1
 2749 0b0a 0FBE      		out		__SREG__, __tmp_reg__
 2750               	 ;  0 "" 2
 2751               	/* #NOAPP */
 2752 0b0c 0895      		ret
 2754               	.Lscope25:
 2756               		.stabd	78,0,0
 2759               	.global	vTaskInternalSetTimeOutState
 2761               	vTaskInternalSetTimeOutState:
 2762               		.stabd	46,0,0
3162:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2764               	.LM324:
 2765               	.LFBB26:
 2766               	/* prologue: function */
 2767               	/* frame size = 0 */
 2768               	/* stack size = 0 */
 2769               	.L__stack_usage = 0
3164:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2771               	.LM325:
 2772 0b0e 2091 0000 		lds r18,xNumOfOverflows
 2773 0b12 FC01      		movw r30,r24
 2774 0b14 2083      		st Z,r18
3165:FreeRTOS/Source/tasks.c **** }
 2776               	.LM326:
 2777 0b16 2091 0000 		lds r18,xTickCount
 2778 0b1a 3091 0000 		lds r19,xTickCount+1
 2779 0b1e 3283      		std Z+2,r19
 2780 0b20 2183      		std Z+1,r18
 2781 0b22 0895      		ret
 2783               	.Lscope26:
 2785               		.stabd	78,0,0
 2789               	.global	xTaskCheckForTimeOut
 2791               	xTaskCheckForTimeOut:
 2792               		.stabd	46,0,0
3170:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 2794               	.LM327:
 2795               	.LFBB27:
 2796 0b24 CF93      		push r28
 2797 0b26 DF93      		push r29
 2798               	/* prologue: function */
 2799               	/* frame size = 0 */
 2800               	/* stack size = 2 */
 2801               	.L__stack_usage = 2
3176:FreeRTOS/Source/tasks.c **** 	{
 2803               	.LM328:
 2804               	/* #APP */
 2805               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2806 0b28 0FB6      		in		__tmp_reg__, __SREG__
 2807               	 ;  0 "" 2
 2808               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2809 0b2a F894      		cli
 2810               	 ;  0 "" 2
 2811               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2812 0b2c 0F92      		push	__tmp_reg__
 2813               	 ;  0 "" 2
 2814               	/* #NOAPP */
 2815               	.LBB75:
3179:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2817               	.LM329:
 2818 0b2e 4091 0000 		lds r20,xTickCount
 2819 0b32 5091 0000 		lds r21,xTickCount+1
3194:FreeRTOS/Source/tasks.c **** 			{
 2821               	.LM330:
 2822 0b36 DB01      		movw r26,r22
 2823 0b38 2D91      		ld r18,X+
 2824 0b3a 3C91      		ld r19,X
 2825 0b3c 2F3F      		cpi r18,-1
 2826 0b3e BFEF      		ldi r27,-1
 2827 0b40 3B07      		cpc r19,r27
 2828 0b42 01F0      		breq .L202
3180:FreeRTOS/Source/tasks.c **** 
 2830               	.LM331:
 2831 0b44 EC01      		movw r28,r24
 2832 0b46 E981      		ldd r30,Y+1
 2833 0b48 FA81      		ldd r31,Y+2
3204:FreeRTOS/Source/tasks.c **** 		{
 2835               	.LM332:
 2836 0b4a A091 0000 		lds r26,xNumOfOverflows
 2837 0b4e B881      		ld r27,Y
 2838 0b50 BA17      		cp r27,r26
 2839 0b52 01F0      		breq .L200
3204:FreeRTOS/Source/tasks.c **** 		{
 2841               	.LM333:
 2842 0b54 4E17      		cp r20,r30
 2843 0b56 5F07      		cpc r21,r31
 2844 0b58 00F4      		brsh .L203
 2845               	.L200:
3180:FreeRTOS/Source/tasks.c **** 
 2847               	.LM334:
 2848 0b5a 4E1B      		sub r20,r30
 2849 0b5c 5F0B      		sbc r21,r31
 2850 0b5e FB01      		movw r30,r22
3213:FreeRTOS/Source/tasks.c **** 		{
 2852               	.LM335:
 2853 0b60 4217      		cp r20,r18
 2854 0b62 5307      		cpc r21,r19
 2855 0b64 00F4      		brsh .L201
3216:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2857               	.LM336:
 2858 0b66 241B      		sub r18,r20
 2859 0b68 350B      		sbc r19,r21
 2860 0b6a 3183      		std Z+1,r19
 2861 0b6c 2083      		st Z,r18
3217:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2863               	.LM337:
 2864 0b6e 0E94 0000 		call vTaskInternalSetTimeOutState
 2865 0b72 00C0      		rjmp .L202
 2866               	.L201:
3222:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2868               	.LM338:
 2869 0b74 1182      		std Z+1,__zero_reg__
 2870 0b76 1082      		st Z,__zero_reg__
 2871 0b78 00C0      		rjmp .L203
 2872               	.L202:
3199:FreeRTOS/Source/tasks.c **** 			}
 2874               	.LM339:
 2875 0b7a 80E0      		ldi r24,0
 2876 0b7c 00C0      		rjmp .L199
 2877               	.L203:
3211:FreeRTOS/Source/tasks.c **** 		}
 2879               	.LM340:
 2880 0b7e 81E0      		ldi r24,lo8(1)
 2881               	.L199:
 2882               	.LBE75:
3226:FreeRTOS/Source/tasks.c **** 
 2884               	.LM341:
 2885               	/* #APP */
 2886               	 ;  3226 "FreeRTOS/Source/tasks.c" 1
 2887 0b80 0F90      		pop		__tmp_reg__
 2888               	 ;  0 "" 2
 2889               	 ;  3226 "FreeRTOS/Source/tasks.c" 1
 2890 0b82 0FBE      		out		__SREG__, __tmp_reg__
 2891               	 ;  0 "" 2
 2892               	/* epilogue start */
3229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2894               	.LM342:
 2895               	/* #NOAPP */
 2896 0b84 DF91      		pop r29
 2897 0b86 CF91      		pop r28
 2898 0b88 0895      		ret
 2907               	.Lscope27:
 2909               		.stabd	78,0,0
 2911               	.global	vTaskMissedYield
 2913               	vTaskMissedYield:
 2914               		.stabd	46,0,0
3233:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 2916               	.LM343:
 2917               	.LFBB28:
 2918               	/* prologue: function */
 2919               	/* frame size = 0 */
 2920               	/* stack size = 0 */
 2921               	.L__stack_usage = 0
3234:FreeRTOS/Source/tasks.c **** }
 2923               	.LM344:
 2924 0b8a 81E0      		ldi r24,lo8(1)
 2925 0b8c 8093 0000 		sts xYieldPending,r24
 2926 0b90 0895      		ret
 2928               	.Lscope28:
 2930               		.stabd	78,0,0
 2932               	.global	xTaskGetCurrentTaskHandle
 2934               	xTaskGetCurrentTaskHandle:
 2935               		.stabd	46,0,0
3820:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 2937               	.LM345:
 2938               	.LFBB29:
 2939               	/* prologue: function */
 2940               	/* frame size = 0 */
 2941               	/* stack size = 0 */
 2942               	.L__stack_usage = 0
3826:FreeRTOS/Source/tasks.c **** 
 2944               	.LM346:
 2945 0b92 8091 0000 		lds r24,pxCurrentTCB
 2946 0b96 9091 0000 		lds r25,pxCurrentTCB+1
3829:FreeRTOS/Source/tasks.c **** 
 2948               	.LM347:
 2949 0b9a 0895      		ret
 2954               	.Lscope29:
 2956               		.stabd	78,0,0
 2959               	.global	xTaskPriorityInherit
 2961               	xTaskPriorityInherit:
 2962               		.stabd	46,0,0
3865:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 2964               	.LM348:
 2965               	.LFBB30:
 2966 0b9c 0F93      		push r16
 2967 0b9e 1F93      		push r17
 2968 0ba0 CF93      		push r28
 2969 0ba2 DF93      		push r29
 2970               	/* prologue: function */
 2971               	/* frame size = 0 */
 2972               	/* stack size = 4 */
 2973               	.L__stack_usage = 4
 2974 0ba4 FC01      		movw r30,r24
3872:FreeRTOS/Source/tasks.c **** 		{
 2976               	.LM349:
 2977 0ba6 892B      		or r24,r25
 2978 0ba8 01F4      		brne .+2
 2979 0baa 00C0      		rjmp .L213
3877:FreeRTOS/Source/tasks.c **** 			{
 2981               	.LM350:
 2982 0bac 8689      		ldd r24,Z+22
 2983 0bae A091 0000 		lds r26,pxCurrentTCB
 2984 0bb2 B091 0000 		lds r27,pxCurrentTCB+1
 2985 0bb6 5696      		adiw r26,22
 2986 0bb8 9C91      		ld r25,X
 2987 0bba 8917      		cp r24,r25
 2988 0bbc 00F0      		brlo .+2
 2989 0bbe 00C0      		rjmp .L208
3882:FreeRTOS/Source/tasks.c **** 				{
 2991               	.LM351:
 2992 0bc0 2485      		ldd r18,Z+12
 2993 0bc2 3585      		ldd r19,Z+13
 2994 0bc4 37FD      		sbrc r19,7
 2995 0bc6 00C0      		rjmp .L209
3884:FreeRTOS/Source/tasks.c **** 				}
 2997               	.LM352:
 2998 0bc8 A091 0000 		lds r26,pxCurrentTCB
 2999 0bcc B091 0000 		lds r27,pxCurrentTCB+1
 3000 0bd0 5696      		adiw r26,22
 3001 0bd2 9C91      		ld r25,X
 3002 0bd4 24E0      		ldi r18,lo8(4)
 3003 0bd6 30E0      		ldi r19,0
 3004 0bd8 291B      		sub r18,r25
 3005 0bda 3109      		sbc r19,__zero_reg__
 3006 0bdc 3587      		std Z+13,r19
 3007 0bde 2487      		std Z+12,r18
 3008               	.L209:
3893:FreeRTOS/Source/tasks.c **** 				{
 3010               	.LM353:
 3011 0be0 29E0      		ldi r18,lo8(9)
 3012 0be2 829F      		mul r24,r18
 3013 0be4 C001      		movw r24,r0
 3014 0be6 1124      		clr __zero_reg__
 3015 0be8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3016 0bea 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3017 0bec 2285      		ldd r18,Z+10
 3018 0bee 3385      		ldd r19,Z+11
 3019 0bf0 2817      		cp r18,r24
 3020 0bf2 3907      		cpc r19,r25
 3021 0bf4 01F4      		brne .L210
 3022 0bf6 8F01      		movw r16,r30
3895:FreeRTOS/Source/tasks.c **** 					{
 3024               	.LM354:
 3025 0bf8 EF01      		movw r28,r30
 3026 0bfa 2296      		adiw r28,2
 3027 0bfc CE01      		movw r24,r28
 3028 0bfe 0E94 0000 		call uxListRemove
3905:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
 3030               	.LM355:
 3031 0c02 E091 0000 		lds r30,pxCurrentTCB
 3032 0c06 F091 0000 		lds r31,pxCurrentTCB+1
 3033 0c0a 8689      		ldd r24,Z+22
 3034 0c0c F801      		movw r30,r16
 3035 0c0e 868B      		std Z+22,r24
3906:FreeRTOS/Source/tasks.c **** 				}
 3037               	.LM356:
 3038 0c10 9091 0000 		lds r25,uxTopReadyPriority
 3039 0c14 9817      		cp r25,r24
 3040 0c16 00F4      		brsh .L211
3906:FreeRTOS/Source/tasks.c **** 				}
 3042               	.LM357:
 3043 0c18 8093 0000 		sts uxTopReadyPriority,r24
 3044               	.L211:
3906:FreeRTOS/Source/tasks.c **** 				}
 3046               	.LM358:
 3047 0c1c F9E0      		ldi r31,lo8(9)
 3048 0c1e 8F9F      		mul r24,r31
 3049 0c20 C001      		movw r24,r0
 3050 0c22 1124      		clr __zero_reg__
 3051 0c24 BE01      		movw r22,r28
 3052 0c26 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3053 0c28 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3054 0c2a 0E94 0000 		call vListInsertEnd
 3055 0c2e 00C0      		rjmp .L214
 3056               	.L210:
3911:FreeRTOS/Source/tasks.c **** 				}
 3058               	.LM359:
 3059 0c30 A091 0000 		lds r26,pxCurrentTCB
 3060 0c34 B091 0000 		lds r27,pxCurrentTCB+1
 3061 0c38 5696      		adiw r26,22
 3062 0c3a 8C91      		ld r24,X
 3063 0c3c 868B      		std Z+22,r24
 3064               	.L214:
3917:FreeRTOS/Source/tasks.c **** 			}
 3066               	.LM360:
 3067 0c3e 81E0      		ldi r24,lo8(1)
 3068 0c40 00C0      		rjmp .L207
 3069               	.L208:
3921:FreeRTOS/Source/tasks.c **** 				{
 3071               	.LM361:
 3072 0c42 A091 0000 		lds r26,pxCurrentTCB
 3073 0c46 B091 0000 		lds r27,pxCurrentTCB+1
3867:FreeRTOS/Source/tasks.c **** 
 3075               	.LM362:
 3076 0c4a 81E0      		ldi r24,lo8(1)
 3077 0c4c 21A1      		ldd r18,Z+33
 3078 0c4e 5696      		adiw r26,22
 3079 0c50 9C91      		ld r25,X
 3080 0c52 2917      		cp r18,r25
 3081 0c54 00F0      		brlo .L207
 3082               	.L213:
 3083 0c56 80E0      		ldi r24,0
 3084               	.L207:
 3085               	/* epilogue start */
3944:FreeRTOS/Source/tasks.c **** 
 3087               	.LM363:
 3088 0c58 DF91      		pop r29
 3089 0c5a CF91      		pop r28
 3090 0c5c 1F91      		pop r17
 3091 0c5e 0F91      		pop r16
 3092 0c60 0895      		ret
 3097               	.Lscope30:
 3099               		.stabd	78,0,0
 3102               	.global	xTaskPriorityDisinherit
 3104               	xTaskPriorityDisinherit:
 3105               		.stabd	46,0,0
3952:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
 3107               	.LM364:
 3108               	.LFBB31:
 3109 0c62 0F93      		push r16
 3110 0c64 1F93      		push r17
 3111 0c66 CF93      		push r28
 3112 0c68 DF93      		push r29
 3113               	/* prologue: function */
 3114               	/* frame size = 0 */
 3115               	/* stack size = 4 */
 3116               	.L__stack_usage = 4
 3117 0c6a FC01      		movw r30,r24
3956:FreeRTOS/Source/tasks.c **** 		{
 3119               	.LM365:
 3120 0c6c 892B      		or r24,r25
 3121 0c6e 01F4      		brne .L216
 3122               	.L218:
3954:FreeRTOS/Source/tasks.c **** 
 3124               	.LM366:
 3125 0c70 80E0      		ldi r24,0
 3126 0c72 00C0      		rjmp .L217
 3127               	.L216:
3964:FreeRTOS/Source/tasks.c **** 
 3129               	.LM367:
 3130 0c74 82A1      		ldd r24,Z+34
 3131 0c76 8150      		subi r24,lo8(-(-1))
 3132 0c78 82A3      		std Z+34,r24
3968:FreeRTOS/Source/tasks.c **** 			{
 3134               	.LM368:
 3135 0c7a 2689      		ldd r18,Z+22
 3136 0c7c 91A1      		ldd r25,Z+33
 3137 0c7e 2917      		cp r18,r25
 3138 0c80 01F0      		breq .L218
3971:FreeRTOS/Source/tasks.c **** 				{
 3140               	.LM369:
 3141 0c82 8111      		cpse r24,__zero_reg__
 3142 0c84 00C0      		rjmp .L218
 3143 0c86 EF01      		movw r28,r30
3978:FreeRTOS/Source/tasks.c **** 					{
 3145               	.LM370:
 3146 0c88 8F01      		movw r16,r30
 3147 0c8a 0E5F      		subi r16,-2
 3148 0c8c 1F4F      		sbci r17,-1
 3149 0c8e C801      		movw r24,r16
 3150 0c90 0E94 0000 		call uxListRemove
3990:FreeRTOS/Source/tasks.c **** 
 3152               	.LM371:
 3153 0c94 89A1      		ldd r24,Y+33
 3154 0c96 8E8B      		std Y+22,r24
3995:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3156               	.LM372:
 3157 0c98 482F      		mov r20,r24
 3158 0c9a 50E0      		ldi r21,0
 3159 0c9c 24E0      		ldi r18,lo8(4)
 3160 0c9e 30E0      		ldi r19,0
 3161 0ca0 241B      		sub r18,r20
 3162 0ca2 350B      		sbc r19,r21
 3163 0ca4 3D87      		std Y+13,r19
 3164 0ca6 2C87      		std Y+12,r18
3996:FreeRTOS/Source/tasks.c **** 
 3166               	.LM373:
 3167 0ca8 9091 0000 		lds r25,uxTopReadyPriority
 3168 0cac 9817      		cp r25,r24
 3169 0cae 00F4      		brsh .L219
3996:FreeRTOS/Source/tasks.c **** 
 3171               	.LM374:
 3172 0cb0 8093 0000 		sts uxTopReadyPriority,r24
 3173               	.L219:
3996:FreeRTOS/Source/tasks.c **** 
 3175               	.LM375:
 3176 0cb4 29E0      		ldi r18,lo8(9)
 3177 0cb6 249F      		mul r18,r20
 3178 0cb8 C001      		movw r24,r0
 3179 0cba 259F      		mul r18,r21
 3180 0cbc 900D      		add r25,r0
 3181 0cbe 1124      		clr __zero_reg__
 3182 0cc0 B801      		movw r22,r16
 3183 0cc2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3184 0cc4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3185 0cc6 0E94 0000 		call vListInsertEnd
4006:FreeRTOS/Source/tasks.c **** 				}
 3187               	.LM376:
 3188 0cca 81E0      		ldi r24,lo8(1)
 3189               	.L217:
 3190               	/* epilogue start */
4024:FreeRTOS/Source/tasks.c **** 
 3192               	.LM377:
 3193 0ccc DF91      		pop r29
 3194 0cce CF91      		pop r28
 3195 0cd0 1F91      		pop r17
 3196 0cd2 0F91      		pop r16
 3197 0cd4 0895      		ret
 3202               	.Lscope31:
 3204               		.stabd	78,0,0
 3208               	.global	vTaskPriorityDisinheritAfterTimeout
 3210               	vTaskPriorityDisinheritAfterTimeout:
 3211               		.stabd	46,0,0
4032:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
 3213               	.LM378:
 3214               	.LFBB32:
 3215 0cd6 0F93      		push r16
 3216 0cd8 1F93      		push r17
 3217 0cda CF93      		push r28
 3218 0cdc DF93      		push r29
 3219               	/* prologue: function */
 3220               	/* frame size = 0 */
 3221               	/* stack size = 4 */
 3222               	.L__stack_usage = 4
 3223 0cde FC01      		movw r30,r24
4037:FreeRTOS/Source/tasks.c **** 		{
 3225               	.LM379:
 3226 0ce0 892B      		or r24,r25
 3227 0ce2 01F0      		breq .L220
4047:FreeRTOS/Source/tasks.c **** 			{
 3229               	.LM380:
 3230 0ce4 91A1      		ldd r25,Z+33
 3231 0ce6 9617      		cp r25,r22
 3232 0ce8 00F4      		brsh .L223
 3233 0cea 962F      		mov r25,r22
 3234               	.L223:
4057:FreeRTOS/Source/tasks.c **** 			{
 3236               	.LM381:
 3237 0cec 8689      		ldd r24,Z+22
 3238 0cee 8917      		cp r24,r25
 3239 0cf0 01F0      		breq .L220
4063:FreeRTOS/Source/tasks.c **** 				{
 3241               	.LM382:
 3242 0cf2 22A1      		ldd r18,Z+34
 3243 0cf4 2130      		cpi r18,lo8(1)
 3244 0cf6 01F4      		brne .L220
4075:FreeRTOS/Source/tasks.c **** 
 3246               	.LM383:
 3247 0cf8 968B      		std Z+22,r25
4079:FreeRTOS/Source/tasks.c **** 					{
 3249               	.LM384:
 3250 0cfa 2485      		ldd r18,Z+12
 3251 0cfc 3585      		ldd r19,Z+13
 3252 0cfe 37FD      		sbrc r19,7
 3253 0d00 00C0      		rjmp .L225
4081:FreeRTOS/Source/tasks.c **** 					}
 3255               	.LM385:
 3256 0d02 24E0      		ldi r18,lo8(4)
 3257 0d04 30E0      		ldi r19,0
 3258 0d06 291B      		sub r18,r25
 3259 0d08 3109      		sbc r19,__zero_reg__
 3260 0d0a 3587      		std Z+13,r19
 3261 0d0c 2487      		std Z+12,r18
 3262               	.L225:
4094:FreeRTOS/Source/tasks.c **** 					{
 3264               	.LM386:
 3265 0d0e 29E0      		ldi r18,lo8(9)
 3266 0d10 829F      		mul r24,r18
 3267 0d12 C001      		movw r24,r0
 3268 0d14 1124      		clr __zero_reg__
 3269 0d16 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3270 0d18 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3271 0d1a 2285      		ldd r18,Z+10
 3272 0d1c 3385      		ldd r19,Z+11
 3273 0d1e 2817      		cp r18,r24
 3274 0d20 3907      		cpc r19,r25
 3275 0d22 01F4      		brne .L220
 3276 0d24 EF01      		movw r28,r30
4096:FreeRTOS/Source/tasks.c **** 						{
 3278               	.LM387:
 3279 0d26 8F01      		movw r16,r30
 3280 0d28 0E5F      		subi r16,-2
 3281 0d2a 1F4F      		sbci r17,-1
 3282 0d2c C801      		movw r24,r16
 3283 0d2e 0E94 0000 		call uxListRemove
4105:FreeRTOS/Source/tasks.c **** 					}
 3285               	.LM388:
 3286 0d32 8E89      		ldd r24,Y+22
 3287 0d34 9091 0000 		lds r25,uxTopReadyPriority
 3288 0d38 9817      		cp r25,r24
 3289 0d3a 00F4      		brsh .L226
4105:FreeRTOS/Source/tasks.c **** 					}
 3291               	.LM389:
 3292 0d3c 8093 0000 		sts uxTopReadyPriority,r24
 3293               	.L226:
4105:FreeRTOS/Source/tasks.c **** 					}
 3295               	.LM390:
 3296 0d40 29E0      		ldi r18,lo8(9)
 3297 0d42 829F      		mul r24,r18
 3298 0d44 C001      		movw r24,r0
 3299 0d46 1124      		clr __zero_reg__
 3300 0d48 B801      		movw r22,r16
 3301 0d4a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3302 0d4c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3303               	/* epilogue start */
4126:FreeRTOS/Source/tasks.c **** 
 3305               	.LM391:
 3306 0d4e DF91      		pop r29
 3307 0d50 CF91      		pop r28
 3308 0d52 1F91      		pop r17
 3309 0d54 0F91      		pop r16
4105:FreeRTOS/Source/tasks.c **** 					}
 3311               	.LM392:
 3312 0d56 0C94 0000 		jmp vListInsertEnd
 3313               	.L220:
 3314               	/* epilogue start */
4126:FreeRTOS/Source/tasks.c **** 
 3316               	.LM393:
 3317 0d5a DF91      		pop r29
 3318 0d5c CF91      		pop r28
 3319 0d5e 1F91      		pop r17
 3320 0d60 0F91      		pop r16
 3321 0d62 0895      		ret
 3323               	.Lscope32:
 3325               		.stabd	78,0,0
 3327               	.global	uxTaskResetEventItemValue
 3329               	uxTaskResetEventItemValue:
 3330               		.stabd	46,0,0
4447:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
 3332               	.LM394:
 3333               	.LFBB33:
 3334               	/* prologue: function */
 3335               	/* frame size = 0 */
 3336               	/* stack size = 0 */
 3337               	.L__stack_usage = 0
4450:FreeRTOS/Source/tasks.c **** 
 3339               	.LM395:
 3340 0d64 E091 0000 		lds r30,pxCurrentTCB
 3341 0d68 F091 0000 		lds r31,pxCurrentTCB+1
 3342 0d6c 8485      		ldd r24,Z+12
 3343 0d6e 9585      		ldd r25,Z+13
4454:FreeRTOS/Source/tasks.c **** 
 3345               	.LM396:
 3346 0d70 E091 0000 		lds r30,pxCurrentTCB
 3347 0d74 F091 0000 		lds r31,pxCurrentTCB+1
 3348 0d78 A091 0000 		lds r26,pxCurrentTCB
 3349 0d7c B091 0000 		lds r27,pxCurrentTCB+1
 3350 0d80 5696      		adiw r26,22
 3351 0d82 4C91      		ld r20,X
 3352 0d84 24E0      		ldi r18,lo8(4)
 3353 0d86 30E0      		ldi r19,0
 3354 0d88 241B      		sub r18,r20
 3355 0d8a 3109      		sbc r19,__zero_reg__
 3356 0d8c 3587      		std Z+13,r19
 3357 0d8e 2487      		std Z+12,r18
4457:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3359               	.LM397:
 3360 0d90 0895      		ret
 3365               	.Lscope33:
 3367               		.stabd	78,0,0
 3369               	.global	pvTaskIncrementMutexHeldCount
 3371               	pvTaskIncrementMutexHeldCount:
 3372               		.stabd	46,0,0
4463:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
 3374               	.LM398:
 3375               	.LFBB34:
 3376               	/* prologue: function */
 3377               	/* frame size = 0 */
 3378               	/* stack size = 0 */
 3379               	.L__stack_usage = 0
4466:FreeRTOS/Source/tasks.c **** 		{
 3381               	.LM399:
 3382 0d92 8091 0000 		lds r24,pxCurrentTCB
 3383 0d96 9091 0000 		lds r25,pxCurrentTCB+1
 3384 0d9a 892B      		or r24,r25
 3385 0d9c 01F0      		breq .L229
4468:FreeRTOS/Source/tasks.c **** 		}
 3387               	.LM400:
 3388 0d9e E091 0000 		lds r30,pxCurrentTCB
 3389 0da2 F091 0000 		lds r31,pxCurrentTCB+1
 3390 0da6 82A1      		ldd r24,Z+34
 3391 0da8 8F5F      		subi r24,lo8(-(1))
 3392 0daa 82A3      		std Z+34,r24
 3393               	.L229:
4471:FreeRTOS/Source/tasks.c **** 	}
 3395               	.LM401:
 3396 0dac 8091 0000 		lds r24,pxCurrentTCB
 3397 0db0 9091 0000 		lds r25,pxCurrentTCB+1
4472:FreeRTOS/Source/tasks.c **** 
 3399               	.LM402:
 3400 0db4 0895      		ret
 3402               	.Lscope34:
 3404               		.stabd	78,0,0
 3408               	.global	ulTaskNotifyTake
 3410               	ulTaskNotifyTake:
 3411               		.stabd	46,0,0
4480:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
 3413               	.LM403:
 3414               	.LFBB35:
 3415 0db6 0F93      		push r16
 3416 0db8 1F93      		push r17
 3417               	/* prologue: function */
 3418               	/* frame size = 0 */
 3419               	/* stack size = 2 */
 3420               	.L__stack_usage = 2
 3421 0dba 182F      		mov r17,r24
 3422 0dbc CB01      		movw r24,r22
4483:FreeRTOS/Source/tasks.c **** 		{
 3424               	.LM404:
 3425               	/* #APP */
 3426               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 3427 0dbe 0FB6      		in		__tmp_reg__, __SREG__
 3428               	 ;  0 "" 2
 3429               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 3430 0dc0 F894      		cli
 3431               	 ;  0 "" 2
 3432               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 3433 0dc2 0F92      		push	__tmp_reg__
 3434               	 ;  0 "" 2
4486:FreeRTOS/Source/tasks.c **** 			{
 3436               	.LM405:
 3437               	/* #NOAPP */
 3438 0dc4 E091 0000 		lds r30,pxCurrentTCB
 3439 0dc8 F091 0000 		lds r31,pxCurrentTCB+1
 3440 0dcc 43A1      		ldd r20,Z+35
 3441 0dce 54A1      		ldd r21,Z+36
 3442 0dd0 65A1      		ldd r22,Z+37
 3443 0dd2 76A1      		ldd r23,Z+38
 3444 0dd4 452B      		or r20,r21
 3445 0dd6 462B      		or r20,r22
 3446 0dd8 472B      		or r20,r23
 3447 0dda 01F4      		brne .L235
4489:FreeRTOS/Source/tasks.c **** 
 3449               	.LM406:
 3450 0ddc E091 0000 		lds r30,pxCurrentTCB
 3451 0de0 F091 0000 		lds r31,pxCurrentTCB+1
 3452 0de4 21E0      		ldi r18,lo8(1)
 3453 0de6 27A3      		std Z+39,r18
4491:FreeRTOS/Source/tasks.c **** 				{
 3455               	.LM407:
 3456 0de8 0097      		sbiw r24,0
 3457 0dea 01F0      		breq .L235
4493:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 3459               	.LM408:
 3460 0dec 61E0      		ldi r22,lo8(1)
 3461 0dee 0E94 0000 		call prvAddCurrentTaskToDelayedList
4500:FreeRTOS/Source/tasks.c **** 				}
 3463               	.LM409:
 3464 0df2 0E94 0000 		call vPortYield
 3465               	.L235:
4512:FreeRTOS/Source/tasks.c **** 
 3467               	.LM410:
 3468               	/* #APP */
 3469               	 ;  4512 "FreeRTOS/Source/tasks.c" 1
 3470 0df6 0F90      		pop		__tmp_reg__
 3471               	 ;  0 "" 2
 3472               	 ;  4512 "FreeRTOS/Source/tasks.c" 1
 3473 0df8 0FBE      		out		__SREG__, __tmp_reg__
 3474               	 ;  0 "" 2
4514:FreeRTOS/Source/tasks.c **** 		{
 3476               	.LM411:
 3477               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3478 0dfa 0FB6      		in		__tmp_reg__, __SREG__
 3479               	 ;  0 "" 2
 3480               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3481 0dfc F894      		cli
 3482               	 ;  0 "" 2
 3483               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3484 0dfe 0F92      		push	__tmp_reg__
 3485               	 ;  0 "" 2
4517:FreeRTOS/Source/tasks.c **** 
 3487               	.LM412:
 3488               	/* #NOAPP */
 3489 0e00 E091 0000 		lds r30,pxCurrentTCB
 3490 0e04 F091 0000 		lds r31,pxCurrentTCB+1
 3491 0e08 63A1      		ldd r22,Z+35
 3492 0e0a 74A1      		ldd r23,Z+36
 3493 0e0c 85A1      		ldd r24,Z+37
 3494 0e0e 96A1      		ldd r25,Z+38
4519:FreeRTOS/Source/tasks.c **** 			{
 3496               	.LM413:
 3497 0e10 6115      		cp r22,__zero_reg__
 3498 0e12 7105      		cpc r23,__zero_reg__
 3499 0e14 8105      		cpc r24,__zero_reg__
 3500 0e16 9105      		cpc r25,__zero_reg__
 3501 0e18 01F0      		breq .L237
4523:FreeRTOS/Source/tasks.c **** 				}
 3503               	.LM414:
 3504 0e1a E091 0000 		lds r30,pxCurrentTCB
 3505 0e1e F091 0000 		lds r31,pxCurrentTCB+1
4521:FreeRTOS/Source/tasks.c **** 				{
 3507               	.LM415:
 3508 0e22 1123      		tst r17
 3509 0e24 01F0      		breq .L238
4523:FreeRTOS/Source/tasks.c **** 				}
 3511               	.LM416:
 3512 0e26 13A2      		std Z+35,__zero_reg__
 3513 0e28 14A2      		std Z+36,__zero_reg__
 3514 0e2a 15A2      		std Z+37,__zero_reg__
 3515 0e2c 16A2      		std Z+38,__zero_reg__
 3516 0e2e 00C0      		rjmp .L237
 3517               	.L238:
4527:FreeRTOS/Source/tasks.c **** 				}
 3519               	.LM417:
 3520 0e30 8B01      		movw r16,r22
 3521 0e32 9C01      		movw r18,r24
 3522 0e34 0150      		subi r16,1
 3523 0e36 1109      		sbc r17,__zero_reg__
 3524 0e38 2109      		sbc r18,__zero_reg__
 3525 0e3a 3109      		sbc r19,__zero_reg__
 3526 0e3c 03A3      		std Z+35,r16
 3527 0e3e 14A3      		std Z+36,r17
 3528 0e40 25A3      		std Z+37,r18
 3529 0e42 36A3      		std Z+38,r19
 3530               	.L237:
4535:FreeRTOS/Source/tasks.c **** 		}
 3532               	.LM418:
 3533 0e44 E091 0000 		lds r30,pxCurrentTCB
 3534 0e48 F091 0000 		lds r31,pxCurrentTCB+1
 3535 0e4c 17A2      		std Z+39,__zero_reg__
4537:FreeRTOS/Source/tasks.c **** 
 3537               	.LM419:
 3538               	/* #APP */
 3539               	 ;  4537 "FreeRTOS/Source/tasks.c" 1
 3540 0e4e 0F90      		pop		__tmp_reg__
 3541               	 ;  0 "" 2
 3542               	 ;  4537 "FreeRTOS/Source/tasks.c" 1
 3543 0e50 0FBE      		out		__SREG__, __tmp_reg__
 3544               	 ;  0 "" 2
 3545               	/* epilogue start */
4540:FreeRTOS/Source/tasks.c **** 
 3547               	.LM420:
 3548               	/* #NOAPP */
 3549 0e52 1F91      		pop r17
 3550 0e54 0F91      		pop r16
 3551 0e56 0895      		ret
 3556               	.Lscope35:
 3558               		.stabd	78,0,0
 3564               	.global	xTaskNotifyWait
 3566               	xTaskNotifyWait:
 3567               		.stabd	46,0,0
4548:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 3569               	.LM421:
 3570               	.LFBB36:
 3571 0e58 4F92      		push r4
 3572 0e5a 5F92      		push r5
 3573 0e5c 6F92      		push r6
 3574 0e5e 7F92      		push r7
 3575 0e60 8F92      		push r8
 3576 0e62 9F92      		push r9
 3577 0e64 AF92      		push r10
 3578 0e66 BF92      		push r11
 3579 0e68 EF92      		push r14
 3580 0e6a FF92      		push r15
 3581 0e6c 0F93      		push r16
 3582 0e6e 1F93      		push r17
 3583               	/* prologue: function */
 3584               	/* frame size = 0 */
 3585               	/* stack size = 12 */
 3586               	.L__stack_usage = 12
 3587 0e70 4901      		movw r8,r18
 3588 0e72 5A01      		movw r10,r20
4551:FreeRTOS/Source/tasks.c **** 		{
 3590               	.LM422:
 3591               	/* #APP */
 3592               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3593 0e74 0FB6      		in		__tmp_reg__, __SREG__
 3594               	 ;  0 "" 2
 3595               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3596 0e76 F894      		cli
 3597               	 ;  0 "" 2
 3598               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3599 0e78 0F92      		push	__tmp_reg__
 3600               	 ;  0 "" 2
4554:FreeRTOS/Source/tasks.c **** 			{
 3602               	.LM423:
 3603               	/* #NOAPP */
 3604 0e7a E091 0000 		lds r30,pxCurrentTCB
 3605 0e7e F091 0000 		lds r31,pxCurrentTCB+1
 3606 0e82 27A1      		ldd r18,Z+39
 3607 0e84 2230      		cpi r18,lo8(2)
 3608 0e86 01F0      		breq .L247
4559:FreeRTOS/Source/tasks.c **** 
 3610               	.LM424:
 3611 0e88 E091 0000 		lds r30,pxCurrentTCB
 3612 0e8c F091 0000 		lds r31,pxCurrentTCB+1
 3613 0e90 23A1      		ldd r18,Z+35
 3614 0e92 34A1      		ldd r19,Z+36
 3615 0e94 45A1      		ldd r20,Z+37
 3616 0e96 56A1      		ldd r21,Z+38
 3617 0e98 2B01      		movw r4,r22
 3618 0e9a 3C01      		movw r6,r24
 3619 0e9c 4094      		com r4
 3620 0e9e 5094      		com r5
 3621 0ea0 6094      		com r6
 3622 0ea2 7094      		com r7
 3623 0ea4 D301      		movw r26,r6
 3624 0ea6 C201      		movw r24,r4
 3625 0ea8 8223      		and r24,r18
 3626 0eaa 9323      		and r25,r19
 3627 0eac A423      		and r26,r20
 3628 0eae B523      		and r27,r21
 3629 0eb0 83A3      		std Z+35,r24
 3630 0eb2 94A3      		std Z+36,r25
 3631 0eb4 A5A3      		std Z+37,r26
 3632 0eb6 B6A3      		std Z+38,r27
4562:FreeRTOS/Source/tasks.c **** 
 3634               	.LM425:
 3635 0eb8 E091 0000 		lds r30,pxCurrentTCB
 3636 0ebc F091 0000 		lds r31,pxCurrentTCB+1
 3637 0ec0 81E0      		ldi r24,lo8(1)
 3638 0ec2 87A3      		std Z+39,r24
4564:FreeRTOS/Source/tasks.c **** 				{
 3640               	.LM426:
 3641 0ec4 E114      		cp r14,__zero_reg__
 3642 0ec6 F104      		cpc r15,__zero_reg__
 3643 0ec8 01F0      		breq .L247
4566:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 3645               	.LM427:
 3646 0eca 61E0      		ldi r22,lo8(1)
 3647 0ecc C701      		movw r24,r14
 3648 0ece 0E94 0000 		call prvAddCurrentTaskToDelayedList
4573:FreeRTOS/Source/tasks.c **** 				}
 3650               	.LM428:
 3651 0ed2 0E94 0000 		call vPortYield
 3652               	.L247:
4585:FreeRTOS/Source/tasks.c **** 
 3654               	.LM429:
 3655               	/* #APP */
 3656               	 ;  4585 "FreeRTOS/Source/tasks.c" 1
 3657 0ed6 0F90      		pop		__tmp_reg__
 3658               	 ;  0 "" 2
 3659               	 ;  4585 "FreeRTOS/Source/tasks.c" 1
 3660 0ed8 0FBE      		out		__SREG__, __tmp_reg__
 3661               	 ;  0 "" 2
4587:FreeRTOS/Source/tasks.c **** 		{
 3663               	.LM430:
 3664               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3665 0eda 0FB6      		in		__tmp_reg__, __SREG__
 3666               	 ;  0 "" 2
 3667               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3668 0edc F894      		cli
 3669               	 ;  0 "" 2
 3670               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3671 0ede 0F92      		push	__tmp_reg__
 3672               	 ;  0 "" 2
4591:FreeRTOS/Source/tasks.c **** 			{
 3674               	.LM431:
 3675               	/* #NOAPP */
 3676 0ee0 0115      		cp r16,__zero_reg__
 3677 0ee2 1105      		cpc r17,__zero_reg__
 3678 0ee4 01F0      		breq .L249
4595:FreeRTOS/Source/tasks.c **** 			}
 3680               	.LM432:
 3681 0ee6 E091 0000 		lds r30,pxCurrentTCB
 3682 0eea F091 0000 		lds r31,pxCurrentTCB+1
 3683 0eee 83A1      		ldd r24,Z+35
 3684 0ef0 94A1      		ldd r25,Z+36
 3685 0ef2 A5A1      		ldd r26,Z+37
 3686 0ef4 B6A1      		ldd r27,Z+38
 3687 0ef6 F801      		movw r30,r16
 3688 0ef8 8083      		st Z,r24
 3689 0efa 9183      		std Z+1,r25
 3690 0efc A283      		std Z+2,r26
 3691 0efe B383      		std Z+3,r27
 3692               	.L249:
4602:FreeRTOS/Source/tasks.c **** 			{
 3694               	.LM433:
 3695 0f00 E091 0000 		lds r30,pxCurrentTCB
 3696 0f04 F091 0000 		lds r31,pxCurrentTCB+1
 3697 0f08 87A1      		ldd r24,Z+39
 3698 0f0a 8230      		cpi r24,lo8(2)
 3699 0f0c 01F4      		brne .L251
4611:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3701               	.LM434:
 3702 0f0e E091 0000 		lds r30,pxCurrentTCB
 3703 0f12 F091 0000 		lds r31,pxCurrentTCB+1
 3704 0f16 43A1      		ldd r20,Z+35
 3705 0f18 54A1      		ldd r21,Z+36
 3706 0f1a 65A1      		ldd r22,Z+37
 3707 0f1c 76A1      		ldd r23,Z+38
 3708 0f1e D501      		movw r26,r10
 3709 0f20 C401      		movw r24,r8
 3710 0f22 8095      		com r24
 3711 0f24 9095      		com r25
 3712 0f26 A095      		com r26
 3713 0f28 B095      		com r27
 3714 0f2a 8423      		and r24,r20
 3715 0f2c 9523      		and r25,r21
 3716 0f2e A623      		and r26,r22
 3717 0f30 B723      		and r27,r23
 3718 0f32 83A3      		std Z+35,r24
 3719 0f34 94A3      		std Z+36,r25
 3720 0f36 A5A3      		std Z+37,r26
 3721 0f38 B6A3      		std Z+38,r27
4612:FreeRTOS/Source/tasks.c **** 			}
 3723               	.LM435:
 3724 0f3a 81E0      		ldi r24,lo8(1)
 3725 0f3c 00C0      		rjmp .L250
 3726               	.L251:
4605:FreeRTOS/Source/tasks.c **** 			}
 3728               	.LM436:
 3729 0f3e 80E0      		ldi r24,0
 3730               	.L250:
4615:FreeRTOS/Source/tasks.c **** 		}
 3732               	.LM437:
 3733 0f40 E091 0000 		lds r30,pxCurrentTCB
 3734 0f44 F091 0000 		lds r31,pxCurrentTCB+1
 3735 0f48 17A2      		std Z+39,__zero_reg__
4617:FreeRTOS/Source/tasks.c **** 
 3737               	.LM438:
 3738               	/* #APP */
 3739               	 ;  4617 "FreeRTOS/Source/tasks.c" 1
 3740 0f4a 0F90      		pop		__tmp_reg__
 3741               	 ;  0 "" 2
 3742               	 ;  4617 "FreeRTOS/Source/tasks.c" 1
 3743 0f4c 0FBE      		out		__SREG__, __tmp_reg__
 3744               	 ;  0 "" 2
 3745               	/* epilogue start */
4620:FreeRTOS/Source/tasks.c **** 
 3747               	.LM439:
 3748               	/* #NOAPP */
 3749 0f4e 1F91      		pop r17
 3750 0f50 0F91      		pop r16
 3751 0f52 FF90      		pop r15
 3752 0f54 EF90      		pop r14
 3753 0f56 BF90      		pop r11
 3754 0f58 AF90      		pop r10
 3755 0f5a 9F90      		pop r9
 3756 0f5c 8F90      		pop r8
 3757 0f5e 7F90      		pop r7
 3758 0f60 6F90      		pop r6
 3759 0f62 5F90      		pop r5
 3760 0f64 4F90      		pop r4
 3761 0f66 0895      		ret
 3766               	.Lscope36:
 3768               		.stabd	78,0,0
 3774               	.global	xTaskGenericNotify
 3776               	xTaskGenericNotify:
 3777               		.stabd	46,0,0
4628:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3779               	.LM440:
 3780               	.LFBB37:
 3781 0f68 0F93      		push r16
 3782 0f6a 1F93      		push r17
 3783 0f6c CF93      		push r28
 3784 0f6e DF93      		push r29
 3785               	/* prologue: function */
 3786               	/* frame size = 0 */
 3787               	/* stack size = 4 */
 3788               	.L__stack_usage = 4
 3789 0f70 FC01      		movw r30,r24
4636:FreeRTOS/Source/tasks.c **** 		{
 3791               	.LM441:
 3792               	/* #APP */
 3793               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3794 0f72 0FB6      		in		__tmp_reg__, __SREG__
 3795               	 ;  0 "" 2
 3796               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3797 0f74 F894      		cli
 3798               	 ;  0 "" 2
 3799               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3800 0f76 0F92      		push	__tmp_reg__
 3801               	 ;  0 "" 2
4638:FreeRTOS/Source/tasks.c **** 			{
 3803               	.LM442:
 3804               	/* #NOAPP */
 3805 0f78 0115      		cp r16,__zero_reg__
 3806 0f7a 1105      		cpc r17,__zero_reg__
 3807 0f7c 01F0      		breq .L259
4640:FreeRTOS/Source/tasks.c **** 			}
 3809               	.LM443:
 3810 0f7e 83A1      		ldd r24,Z+35
 3811 0f80 94A1      		ldd r25,Z+36
 3812 0f82 A5A1      		ldd r26,Z+37
 3813 0f84 B6A1      		ldd r27,Z+38
 3814 0f86 E801      		movw r28,r16
 3815 0f88 8883      		st Y,r24
 3816 0f8a 9983      		std Y+1,r25
 3817 0f8c AA83      		std Y+2,r26
 3818 0f8e BB83      		std Y+3,r27
 3819               	.L259:
4643:FreeRTOS/Source/tasks.c **** 
 3821               	.LM444:
 3822 0f90 37A1      		ldd r19,Z+39
4645:FreeRTOS/Source/tasks.c **** 
 3824               	.LM445:
 3825 0f92 82E0      		ldi r24,lo8(2)
 3826 0f94 87A3      		std Z+39,r24
4647:FreeRTOS/Source/tasks.c **** 			{
 3828               	.LM446:
 3829 0f96 2230      		cpi r18,lo8(2)
 3830 0f98 01F0      		breq .L261
 3831 0f9a 00F4      		brsh .L262
 3832 0f9c 2130      		cpi r18,lo8(1)
 3833 0f9e 01F4      		brne .L260
4650:FreeRTOS/Source/tasks.c **** 					break;
 3835               	.LM447:
 3836 0fa0 83A1      		ldd r24,Z+35
 3837 0fa2 94A1      		ldd r25,Z+36
 3838 0fa4 A5A1      		ldd r26,Z+37
 3839 0fa6 B6A1      		ldd r27,Z+38
 3840 0fa8 482B      		or r20,r24
 3841 0faa 592B      		or r21,r25
 3842 0fac 6A2B      		or r22,r26
 3843 0fae 7B2B      		or r23,r27
 3844 0fb0 00C0      		rjmp .L274
 3845               	.L262:
4647:FreeRTOS/Source/tasks.c **** 			{
 3847               	.LM448:
 3848 0fb2 2330      		cpi r18,lo8(3)
 3849 0fb4 01F0      		breq .L274
 3850 0fb6 2430      		cpi r18,lo8(4)
 3851 0fb8 01F0      		breq .L265
 3852 0fba 00C0      		rjmp .L260
 3853               	.L261:
4654:FreeRTOS/Source/tasks.c **** 					break;
 3855               	.LM449:
 3856 0fbc 83A1      		ldd r24,Z+35
 3857 0fbe 94A1      		ldd r25,Z+36
 3858 0fc0 A5A1      		ldd r26,Z+37
 3859 0fc2 B6A1      		ldd r27,Z+38
 3860 0fc4 0196      		adiw r24,1
 3861 0fc6 A11D      		adc r26,__zero_reg__
 3862 0fc8 B11D      		adc r27,__zero_reg__
 3863 0fca 83A3      		std Z+35,r24
 3864 0fcc 94A3      		std Z+36,r25
 3865 0fce A5A3      		std Z+37,r26
 3866 0fd0 B6A3      		std Z+38,r27
4655:FreeRTOS/Source/tasks.c **** 
 3868               	.LM450:
 3869 0fd2 00C0      		rjmp .L260
 3870               	.L265:
4662:FreeRTOS/Source/tasks.c **** 					{
 3872               	.LM451:
 3873 0fd4 3230      		cpi r19,lo8(2)
 3874 0fd6 01F0      		breq .L270
 3875               	.L274:
4664:FreeRTOS/Source/tasks.c **** 					}
 3877               	.LM452:
 3878 0fd8 43A3      		std Z+35,r20
 3879 0fda 54A3      		std Z+36,r21
 3880 0fdc 65A3      		std Z+37,r22
 3881 0fde 76A3      		std Z+38,r23
 3882               	.L260:
4691:FreeRTOS/Source/tasks.c **** 			{
 3884               	.LM453:
 3885 0fe0 3130      		cpi r19,lo8(1)
 3886 0fe2 01F4      		brne .L275
 3887 0fe4 EF01      		movw r28,r30
4693:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3889               	.LM454:
 3890 0fe6 8F01      		movw r16,r30
 3891 0fe8 0E5F      		subi r16,-2
 3892 0fea 1F4F      		sbci r17,-1
 3893 0fec C801      		movw r24,r16
 3894 0fee 0E94 0000 		call uxListRemove
4694:FreeRTOS/Source/tasks.c **** 
 3896               	.LM455:
 3897 0ff2 8E89      		ldd r24,Y+22
 3898 0ff4 9091 0000 		lds r25,uxTopReadyPriority
 3899 0ff8 9817      		cp r25,r24
 3900 0ffa 00F4      		brsh .L268
4694:FreeRTOS/Source/tasks.c **** 
 3902               	.LM456:
 3903 0ffc 8093 0000 		sts uxTopReadyPriority,r24
 3904               	.L268:
4694:FreeRTOS/Source/tasks.c **** 
 3906               	.LM457:
 3907 1000 29E0      		ldi r18,lo8(9)
 3908 1002 829F      		mul r24,r18
 3909 1004 C001      		movw r24,r0
 3910 1006 1124      		clr __zero_reg__
 3911 1008 B801      		movw r22,r16
 3912 100a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3913 100c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3914 100e 0E94 0000 		call vListInsertEnd
4715:FreeRTOS/Source/tasks.c **** 				{
 3916               	.LM458:
 3917 1012 E091 0000 		lds r30,pxCurrentTCB
 3918 1016 F091 0000 		lds r31,pxCurrentTCB+1
 3919 101a 9E89      		ldd r25,Y+22
 3920 101c 8689      		ldd r24,Z+22
 3921 101e 8917      		cp r24,r25
 3922 1020 00F4      		brsh .L275
4719:FreeRTOS/Source/tasks.c **** 				}
 3924               	.LM459:
 3925 1022 0E94 0000 		call vPortYield
 3926               	.L275:
 3927 1026 81E0      		ldi r24,lo8(1)
 3928 1028 00C0      		rjmp .L266
 3929               	.L270:
4669:FreeRTOS/Source/tasks.c **** 					}
 3931               	.LM460:
 3932 102a 80E0      		ldi r24,0
 3933               	.L266:
4731:FreeRTOS/Source/tasks.c **** 
 3935               	.LM461:
 3936               	/* #APP */
 3937               	 ;  4731 "FreeRTOS/Source/tasks.c" 1
 3938 102c 0F90      		pop		__tmp_reg__
 3939               	 ;  0 "" 2
 3940               	 ;  4731 "FreeRTOS/Source/tasks.c" 1
 3941 102e 0FBE      		out		__SREG__, __tmp_reg__
 3942               	 ;  0 "" 2
 3943               	/* epilogue start */
4734:FreeRTOS/Source/tasks.c **** 
 3945               	.LM462:
 3946               	/* #NOAPP */
 3947 1030 DF91      		pop r29
 3948 1032 CF91      		pop r28
 3949 1034 1F91      		pop r17
 3950 1036 0F91      		pop r16
 3951 1038 0895      		ret
 3957               	.Lscope37:
 3959               		.stabd	78,0,0
 3966               	.global	xTaskGenericNotifyFromISR
 3968               	xTaskGenericNotifyFromISR:
 3969               		.stabd	46,0,0
4742:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3971               	.LM463:
 3972               	.LFBB38:
 3973 103a EF92      		push r14
 3974 103c FF92      		push r15
 3975 103e 0F93      		push r16
 3976 1040 1F93      		push r17
 3977 1042 CF93      		push r28
 3978 1044 DF93      		push r29
 3979               	/* prologue: function */
 3980               	/* frame size = 0 */
 3981               	/* stack size = 6 */
 3982               	.L__stack_usage = 6
 3983 1046 FC01      		movw r30,r24
4772:FreeRTOS/Source/tasks.c **** 			{
 3985               	.LM464:
 3986 1048 0115      		cp r16,__zero_reg__
 3987 104a 1105      		cpc r17,__zero_reg__
 3988 104c 01F0      		breq .L277
4774:FreeRTOS/Source/tasks.c **** 			}
 3990               	.LM465:
 3991 104e 83A1      		ldd r24,Z+35
 3992 1050 94A1      		ldd r25,Z+36
 3993 1052 A5A1      		ldd r26,Z+37
 3994 1054 B6A1      		ldd r27,Z+38
 3995 1056 E801      		movw r28,r16
 3996 1058 8883      		st Y,r24
 3997 105a 9983      		std Y+1,r25
 3998 105c AA83      		std Y+2,r26
 3999 105e BB83      		std Y+3,r27
 4000               	.L277:
4777:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4002               	.LM466:
 4003 1060 37A1      		ldd r19,Z+39
4778:FreeRTOS/Source/tasks.c **** 
 4005               	.LM467:
 4006 1062 82E0      		ldi r24,lo8(2)
 4007 1064 87A3      		std Z+39,r24
4780:FreeRTOS/Source/tasks.c **** 			{
 4009               	.LM468:
 4010 1066 2230      		cpi r18,lo8(2)
 4011 1068 01F0      		breq .L279
 4012 106a 00F4      		brsh .L280
 4013 106c 2130      		cpi r18,lo8(1)
 4014 106e 01F4      		brne .L278
4783:FreeRTOS/Source/tasks.c **** 					break;
 4016               	.LM469:
 4017 1070 83A1      		ldd r24,Z+35
 4018 1072 94A1      		ldd r25,Z+36
 4019 1074 A5A1      		ldd r26,Z+37
 4020 1076 B6A1      		ldd r27,Z+38
 4021 1078 482B      		or r20,r24
 4022 107a 592B      		or r21,r25
 4023 107c 6A2B      		or r22,r26
 4024 107e 7B2B      		or r23,r27
 4025 1080 00C0      		rjmp .L298
 4026               	.L280:
4780:FreeRTOS/Source/tasks.c **** 			{
 4028               	.LM470:
 4029 1082 2330      		cpi r18,lo8(3)
 4030 1084 01F0      		breq .L298
 4031 1086 2430      		cpi r18,lo8(4)
 4032 1088 01F0      		breq .L283
 4033 108a 00C0      		rjmp .L278
 4034               	.L279:
4787:FreeRTOS/Source/tasks.c **** 					break;
 4036               	.LM471:
 4037 108c 83A1      		ldd r24,Z+35
 4038 108e 94A1      		ldd r25,Z+36
 4039 1090 A5A1      		ldd r26,Z+37
 4040 1092 B6A1      		ldd r27,Z+38
 4041 1094 0196      		adiw r24,1
 4042 1096 A11D      		adc r26,__zero_reg__
 4043 1098 B11D      		adc r27,__zero_reg__
 4044 109a 83A3      		std Z+35,r24
 4045 109c 94A3      		std Z+36,r25
 4046 109e A5A3      		std Z+37,r26
 4047 10a0 B6A3      		std Z+38,r27
4788:FreeRTOS/Source/tasks.c **** 
 4049               	.LM472:
 4050 10a2 00C0      		rjmp .L278
 4051               	.L283:
4795:FreeRTOS/Source/tasks.c **** 					{
 4053               	.LM473:
 4054 10a4 3230      		cpi r19,lo8(2)
 4055 10a6 01F0      		breq .L291
 4056               	.L298:
4797:FreeRTOS/Source/tasks.c **** 					}
 4058               	.LM474:
 4059 10a8 43A3      		std Z+35,r20
 4060 10aa 54A3      		std Z+36,r21
 4061 10ac 65A3      		std Z+37,r22
 4062 10ae 76A3      		std Z+38,r23
 4063               	.L278:
4823:FreeRTOS/Source/tasks.c **** 			{
 4065               	.LM475:
 4066 10b0 3130      		cpi r19,lo8(1)
 4067 10b2 01F0      		breq .L285
 4068               	.L289:
4742:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 4070               	.LM476:
 4071 10b4 81E0      		ldi r24,lo8(1)
 4072 10b6 00C0      		rjmp .L284
 4073               	.L285:
 4074 10b8 EF01      		movw r28,r30
4828:FreeRTOS/Source/tasks.c **** 				{
 4076               	.LM477:
 4077 10ba 8091 0000 		lds r24,uxSchedulerSuspended
 4078 10be 8111      		cpse r24,__zero_reg__
 4079 10c0 00C0      		rjmp .L286
4830:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4081               	.LM478:
 4082 10c2 8F01      		movw r16,r30
 4083 10c4 0E5F      		subi r16,-2
 4084 10c6 1F4F      		sbci r17,-1
 4085 10c8 C801      		movw r24,r16
 4086 10ca 0E94 0000 		call uxListRemove
4831:FreeRTOS/Source/tasks.c **** 				}
 4088               	.LM479:
 4089 10ce 8E89      		ldd r24,Y+22
 4090 10d0 9091 0000 		lds r25,uxTopReadyPriority
 4091 10d4 9817      		cp r25,r24
 4092 10d6 00F4      		brsh .L287
4831:FreeRTOS/Source/tasks.c **** 				}
 4094               	.LM480:
 4095 10d8 8093 0000 		sts uxTopReadyPriority,r24
 4096               	.L287:
4831:FreeRTOS/Source/tasks.c **** 				}
 4098               	.LM481:
 4099 10dc E9E0      		ldi r30,lo8(9)
 4100 10de 8E9F      		mul r24,r30
 4101 10e0 C001      		movw r24,r0
 4102 10e2 1124      		clr __zero_reg__
 4103 10e4 B801      		movw r22,r16
 4104 10e6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 4105 10e8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 4106 10ea 00C0      		rjmp .L299
 4107               	.L286:
4837:FreeRTOS/Source/tasks.c **** 				}
 4109               	.LM482:
 4110 10ec BF01      		movw r22,r30
 4111 10ee 645F      		subi r22,-12
 4112 10f0 7F4F      		sbci r23,-1
 4113 10f2 80E0      		ldi r24,lo8(xPendingReadyList)
 4114 10f4 90E0      		ldi r25,hi8(xPendingReadyList)
 4115               	.L299:
 4116 10f6 0E94 0000 		call vListInsertEnd
4840:FreeRTOS/Source/tasks.c **** 				{
 4118               	.LM483:
 4119 10fa E091 0000 		lds r30,pxCurrentTCB
 4120 10fe F091 0000 		lds r31,pxCurrentTCB+1
 4121 1102 9E89      		ldd r25,Y+22
 4122 1104 8689      		ldd r24,Z+22
 4123 1106 8917      		cp r24,r25
 4124 1108 00F4      		brsh .L289
4844:FreeRTOS/Source/tasks.c **** 					{
 4126               	.LM484:
 4127 110a E114      		cp r14,__zero_reg__
 4128 110c F104      		cpc r15,__zero_reg__
 4129 110e 01F0      		breq .L290
4846:FreeRTOS/Source/tasks.c **** 					}
 4131               	.LM485:
 4132 1110 81E0      		ldi r24,lo8(1)
 4133 1112 E701      		movw r28,r14
 4134 1114 8883      		st Y,r24
 4135               	.L290:
4852:FreeRTOS/Source/tasks.c **** 				}
 4137               	.LM486:
 4138 1116 81E0      		ldi r24,lo8(1)
 4139 1118 8093 0000 		sts xYieldPending,r24
 4140 111c 00C0      		rjmp .L284
 4141               	.L291:
4802:FreeRTOS/Source/tasks.c **** 					}
 4143               	.LM487:
 4144 111e 80E0      		ldi r24,0
 4145               	.L284:
 4146               	/* epilogue start */
4863:FreeRTOS/Source/tasks.c **** 
 4148               	.LM488:
 4149 1120 DF91      		pop r29
 4150 1122 CF91      		pop r28
 4151 1124 1F91      		pop r17
 4152 1126 0F91      		pop r16
 4153 1128 FF90      		pop r15
 4154 112a EF90      		pop r14
 4155 112c 0895      		ret
 4161               	.Lscope38:
 4163               		.stabd	78,0,0
 4167               	.global	vTaskNotifyGiveFromISR
 4169               	vTaskNotifyGiveFromISR:
 4170               		.stabd	46,0,0
4871:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 4172               	.LM489:
 4173               	.LFBB39:
 4174 112e EF92      		push r14
 4175 1130 FF92      		push r15
 4176 1132 0F93      		push r16
 4177 1134 1F93      		push r17
 4178 1136 CF93      		push r28
 4179 1138 DF93      		push r29
 4180               	/* prologue: function */
 4181               	/* frame size = 0 */
 4182               	/* stack size = 6 */
 4183               	.L__stack_usage = 6
 4184 113a FC01      		movw r30,r24
4900:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4186               	.LM490:
 4187 113c 27A1      		ldd r18,Z+39
4901:FreeRTOS/Source/tasks.c **** 
 4189               	.LM491:
 4190 113e 82E0      		ldi r24,lo8(2)
 4191 1140 87A3      		std Z+39,r24
4905:FreeRTOS/Source/tasks.c **** 
 4193               	.LM492:
 4194 1142 83A1      		ldd r24,Z+35
 4195 1144 94A1      		ldd r25,Z+36
 4196 1146 A5A1      		ldd r26,Z+37
 4197 1148 B6A1      		ldd r27,Z+38
 4198 114a 0196      		adiw r24,1
 4199 114c A11D      		adc r26,__zero_reg__
 4200 114e B11D      		adc r27,__zero_reg__
 4201 1150 83A3      		std Z+35,r24
 4202 1152 94A3      		std Z+36,r25
 4203 1154 A5A3      		std Z+37,r26
 4204 1156 B6A3      		std Z+38,r27
4911:FreeRTOS/Source/tasks.c **** 			{
 4206               	.LM493:
 4207 1158 2130      		cpi r18,lo8(1)
 4208 115a 01F4      		brne .L300
 4209 115c 8B01      		movw r16,r22
 4210 115e EF01      		movw r28,r30
4916:FreeRTOS/Source/tasks.c **** 				{
 4212               	.LM494:
 4213 1160 8091 0000 		lds r24,uxSchedulerSuspended
 4214 1164 8111      		cpse r24,__zero_reg__
 4215 1166 00C0      		rjmp .L303
4918:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4217               	.LM495:
 4218 1168 7F01      		movw r14,r30
 4219 116a 22E0      		ldi r18,2
 4220 116c E20E      		add r14,r18
 4221 116e F11C      		adc r15,__zero_reg__
 4222 1170 C701      		movw r24,r14
 4223 1172 0E94 0000 		call uxListRemove
4919:FreeRTOS/Source/tasks.c **** 				}
 4225               	.LM496:
 4226 1176 8E89      		ldd r24,Y+22
 4227 1178 9091 0000 		lds r25,uxTopReadyPriority
 4228 117c 9817      		cp r25,r24
 4229 117e 00F4      		brsh .L304
4919:FreeRTOS/Source/tasks.c **** 				}
 4231               	.LM497:
 4232 1180 8093 0000 		sts uxTopReadyPriority,r24
 4233               	.L304:
4919:FreeRTOS/Source/tasks.c **** 				}
 4235               	.LM498:
 4236 1184 E9E0      		ldi r30,lo8(9)
 4237 1186 8E9F      		mul r24,r30
 4238 1188 C001      		movw r24,r0
 4239 118a 1124      		clr __zero_reg__
 4240 118c B701      		movw r22,r14
 4241 118e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 4242 1190 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 4243 1192 00C0      		rjmp .L311
 4244               	.L303:
4925:FreeRTOS/Source/tasks.c **** 				}
 4246               	.LM499:
 4247 1194 BF01      		movw r22,r30
 4248 1196 645F      		subi r22,-12
 4249 1198 7F4F      		sbci r23,-1
 4250 119a 80E0      		ldi r24,lo8(xPendingReadyList)
 4251 119c 90E0      		ldi r25,hi8(xPendingReadyList)
 4252               	.L311:
 4253 119e 0E94 0000 		call vListInsertEnd
4928:FreeRTOS/Source/tasks.c **** 				{
 4255               	.LM500:
 4256 11a2 E091 0000 		lds r30,pxCurrentTCB
 4257 11a6 F091 0000 		lds r31,pxCurrentTCB+1
 4258 11aa 9E89      		ldd r25,Y+22
 4259 11ac 8689      		ldd r24,Z+22
 4260 11ae 8917      		cp r24,r25
 4261 11b0 00F4      		brsh .L300
4932:FreeRTOS/Source/tasks.c **** 					{
 4263               	.LM501:
 4264 11b2 0115      		cp r16,__zero_reg__
 4265 11b4 1105      		cpc r17,__zero_reg__
 4266 11b6 01F0      		breq .L307
4934:FreeRTOS/Source/tasks.c **** 					}
 4268               	.LM502:
 4269 11b8 81E0      		ldi r24,lo8(1)
 4270 11ba F801      		movw r30,r16
 4271 11bc 8083      		st Z,r24
 4272               	.L307:
4940:FreeRTOS/Source/tasks.c **** 				}
 4274               	.LM503:
 4275 11be 81E0      		ldi r24,lo8(1)
 4276 11c0 8093 0000 		sts xYieldPending,r24
 4277               	.L300:
 4278               	/* epilogue start */
4949:FreeRTOS/Source/tasks.c **** 
 4280               	.LM504:
 4281 11c4 DF91      		pop r29
 4282 11c6 CF91      		pop r28
 4283 11c8 1F91      		pop r17
 4284 11ca 0F91      		pop r16
 4285 11cc FF90      		pop r15
 4286 11ce EF90      		pop r14
 4287 11d0 0895      		ret
 4292               	.Lscope39:
 4294               		.stabd	78,0,0
 4297               	.global	xTaskNotifyStateClear
 4299               	xTaskNotifyStateClear:
 4300               		.stabd	46,0,0
4958:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 4302               	.LM505:
 4303               	.LFBB40:
 4304               	/* prologue: function */
 4305               	/* frame size = 0 */
 4306               	/* stack size = 0 */
 4307               	.L__stack_usage = 0
4964:FreeRTOS/Source/tasks.c **** 
 4309               	.LM506:
 4310 11d2 0097      		sbiw r24,0
 4311 11d4 01F4      		brne .L313
4964:FreeRTOS/Source/tasks.c **** 
 4313               	.LM507:
 4314 11d6 8091 0000 		lds r24,pxCurrentTCB
 4315 11da 9091 0000 		lds r25,pxCurrentTCB+1
 4316               	.L313:
4966:FreeRTOS/Source/tasks.c **** 		{
 4318               	.LM508:
 4319               	/* #APP */
 4320               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 4321 11de 0FB6      		in		__tmp_reg__, __SREG__
 4322               	 ;  0 "" 2
 4323               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 4324 11e0 F894      		cli
 4325               	 ;  0 "" 2
 4326               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 4327 11e2 0F92      		push	__tmp_reg__
 4328               	 ;  0 "" 2
4968:FreeRTOS/Source/tasks.c **** 			{
 4330               	.LM509:
 4331               	/* #NOAPP */
 4332 11e4 FC01      		movw r30,r24
 4333 11e6 27A1      		ldd r18,Z+39
 4334 11e8 2230      		cpi r18,lo8(2)
 4335 11ea 01F4      		brne .L315
4970:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 4337               	.LM510:
 4338 11ec 17A2      		std Z+39,__zero_reg__
4971:FreeRTOS/Source/tasks.c **** 			}
 4340               	.LM511:
 4341 11ee 81E0      		ldi r24,lo8(1)
 4342 11f0 00C0      		rjmp .L314
 4343               	.L315:
4975:FreeRTOS/Source/tasks.c **** 			}
 4345               	.LM512:
 4346 11f2 80E0      		ldi r24,0
 4347               	.L314:
4978:FreeRTOS/Source/tasks.c **** 
 4349               	.LM513:
 4350               	/* #APP */
 4351               	 ;  4978 "FreeRTOS/Source/tasks.c" 1
 4352 11f4 0F90      		pop		__tmp_reg__
 4353               	 ;  0 "" 2
 4354               	 ;  4978 "FreeRTOS/Source/tasks.c" 1
 4355 11f6 0FBE      		out		__SREG__, __tmp_reg__
 4356               	 ;  0 "" 2
4981:FreeRTOS/Source/tasks.c **** 
 4358               	.LM514:
 4359               	/* #NOAPP */
 4360 11f8 0895      		ret
 4365               	.Lscope40:
 4367               		.stabd	78,0,0
 4368               		.local	uxSchedulerSuspended
 4369               		.comm	uxSchedulerSuspended,1,1
 4370               		.local	xIdleTaskHandle
 4371               		.comm	xIdleTaskHandle,2,1
 4372               		.local	xNextTaskUnblockTime
 4373               		.comm	xNextTaskUnblockTime,2,1
 4374               		.local	uxTaskNumber
 4375               		.comm	uxTaskNumber,1,1
 4376               		.local	xNumOfOverflows
 4377               		.comm	xNumOfOverflows,1,1
 4378               		.local	xYieldPending
 4379               		.comm	xYieldPending,1,1
 4380               		.local	uxPendedTicks
 4381               		.comm	uxPendedTicks,1,1
 4382               		.local	xSchedulerRunning
 4383               		.comm	xSchedulerRunning,1,1
 4384               		.local	uxTopReadyPriority
 4385               		.comm	uxTopReadyPriority,1,1
 4386               		.local	xTickCount
 4387               		.comm	xTickCount,2,1
 4388               		.local	uxCurrentNumberOfTasks
 4389               		.comm	uxCurrentNumberOfTasks,1,1
 4390               		.local	xSuspendedTaskList
 4391               		.comm	xSuspendedTaskList,9,1
 4392               		.local	uxDeletedTasksWaitingCleanUp
 4393               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 4394               		.local	xTasksWaitingTermination
 4395               		.comm	xTasksWaitingTermination,9,1
 4396               		.local	xPendingReadyList
 4397               		.comm	xPendingReadyList,9,1
 4398               		.local	pxOverflowDelayedTaskList
 4399               		.comm	pxOverflowDelayedTaskList,2,1
 4400               		.local	pxDelayedTaskList
 4401               		.comm	pxDelayedTaskList,2,1
 4402               		.local	xDelayedTaskList2
 4403               		.comm	xDelayedTaskList2,9,1
 4404               		.local	xDelayedTaskList1
 4405               		.comm	xDelayedTaskList1,9,1
 4406               		.local	pxReadyTasksLists
 4407               		.comm	pxReadyTasksLists,36,1
 4408               	.global	pxCurrentTCB
 4409               		.section .bss
 4412               	pxCurrentTCB:
 4413 0000 0000      		.zero	2
 4435               		.text
 4437               	.Letext0:
 4438               		.ident	"GCC: (GNU) 5.4.0"
 4439               	.global __do_copy_data
 4440               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccdmsBAD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccdmsBAD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccdmsBAD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccdmsBAD.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccdmsBAD.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccdmsBAD.s:187    .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/ccdmsBAD.s:4399   .bss:000000000000002e pxDelayedTaskList
     /tmp/ccdmsBAD.s:4371   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/ccdmsBAD.s:239    .text:0000000000000036 prvAddCurrentTaskToDelayedList
     /tmp/ccdmsBAD.s:4385   .bss:000000000000000d xTickCount
     /tmp/ccdmsBAD.s:4412   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccdmsBAD.s:4389   .bss:0000000000000010 xSuspendedTaskList
     /tmp/ccdmsBAD.s:4397   .bss:000000000000002c pxOverflowDelayedTaskList
     /tmp/ccdmsBAD.s:379    .text:00000000000000ee prvIdleTask
     /tmp/ccdmsBAD.s:4391   .bss:0000000000000019 uxDeletedTasksWaitingCleanUp
     /tmp/ccdmsBAD.s:4393   .bss:000000000000001a xTasksWaitingTermination
     /tmp/ccdmsBAD.s:4387   .bss:000000000000000f uxCurrentNumberOfTasks
     /tmp/ccdmsBAD.s:4405   .bss:0000000000000042 pxReadyTasksLists
     /tmp/ccdmsBAD.s:489    .text:000000000000014a xTaskCreate
     /tmp/ccdmsBAD.s:4403   .bss:0000000000000039 xDelayedTaskList1
     /tmp/ccdmsBAD.s:4401   .bss:0000000000000030 xDelayedTaskList2
     /tmp/ccdmsBAD.s:4395   .bss:0000000000000023 xPendingReadyList
     /tmp/ccdmsBAD.s:4381   .bss:000000000000000b xSchedulerRunning
     /tmp/ccdmsBAD.s:4373   .bss:0000000000000007 uxTaskNumber
     /tmp/ccdmsBAD.s:4383   .bss:000000000000000c uxTopReadyPriority
     /tmp/ccdmsBAD.s:886    .text:0000000000000350 vTaskDelete
     /tmp/ccdmsBAD.s:1030   .text:00000000000003fa vTaskResume
     /tmp/ccdmsBAD.s:1163   .text:0000000000000488 xTaskResumeFromISR
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/ccdmsBAD.s:1292   .text:0000000000000518 vTaskStartScheduler
     /tmp/ccdmsBAD.s:4369   .bss:0000000000000003 xIdleTaskHandle
     /tmp/ccdmsBAD.s:1371   .text:000000000000056c vTaskEndScheduler
     /tmp/ccdmsBAD.s:1400   .text:0000000000000576 vTaskSuspendAll
     /tmp/ccdmsBAD.s:1422   .text:0000000000000582 xTaskGetTickCount
     /tmp/ccdmsBAD.s:1471   .text:0000000000000596 xTaskGetTickCountFromISR
     /tmp/ccdmsBAD.s:1497   .text:00000000000005a0 uxTaskGetNumberOfTasks
     /tmp/ccdmsBAD.s:1520   .text:00000000000005a6 pcTaskGetName
     /tmp/ccdmsBAD.s:1549   .text:00000000000005b6 xTaskIncrementTick
     /tmp/ccdmsBAD.s:4375   .bss:0000000000000008 xNumOfOverflows
     /tmp/ccdmsBAD.s:4379   .bss:000000000000000a uxPendedTicks
     /tmp/ccdmsBAD.s:4377   .bss:0000000000000009 xYieldPending
     /tmp/ccdmsBAD.s:1786   .text:000000000000070e xTaskResumeAll
     /tmp/ccdmsBAD.s:1989   .text:00000000000007ec vTaskDelayUntil
     /tmp/ccdmsBAD.s:2110   .text:000000000000085c vTaskDelay
     /tmp/ccdmsBAD.s:2161   .text:0000000000000886 vTaskSwitchContext
     /tmp/ccdmsBAD.s:2261   .text:000000000000090c vTaskSuspend
     /tmp/ccdmsBAD.s:2430   .text:00000000000009b8 vTaskPlaceOnEventList
     /tmp/ccdmsBAD.s:2471   .text:00000000000009da vTaskPlaceOnUnorderedEventList
     /tmp/ccdmsBAD.s:2517   .text:0000000000000a0a xTaskRemoveFromEventList
     /tmp/ccdmsBAD.s:2624   .text:0000000000000a8a vTaskRemoveFromUnorderedEventList
     /tmp/ccdmsBAD.s:2709   .text:0000000000000aee vTaskSetTimeOutState
     /tmp/ccdmsBAD.s:2761   .text:0000000000000b0e vTaskInternalSetTimeOutState
     /tmp/ccdmsBAD.s:2791   .text:0000000000000b24 xTaskCheckForTimeOut
     /tmp/ccdmsBAD.s:2913   .text:0000000000000b8a vTaskMissedYield
     /tmp/ccdmsBAD.s:2934   .text:0000000000000b92 xTaskGetCurrentTaskHandle
     /tmp/ccdmsBAD.s:2961   .text:0000000000000b9c xTaskPriorityInherit
     /tmp/ccdmsBAD.s:3104   .text:0000000000000c62 xTaskPriorityDisinherit
     /tmp/ccdmsBAD.s:3210   .text:0000000000000cd6 vTaskPriorityDisinheritAfterTimeout
     /tmp/ccdmsBAD.s:3329   .text:0000000000000d64 uxTaskResetEventItemValue
     /tmp/ccdmsBAD.s:3371   .text:0000000000000d92 pvTaskIncrementMutexHeldCount
     /tmp/ccdmsBAD.s:3410   .text:0000000000000db6 ulTaskNotifyTake
     /tmp/ccdmsBAD.s:3566   .text:0000000000000e58 xTaskNotifyWait
     /tmp/ccdmsBAD.s:3776   .text:0000000000000f68 xTaskGenericNotify
     /tmp/ccdmsBAD.s:3968   .text:000000000000103a xTaskGenericNotifyFromISR
     /tmp/ccdmsBAD.s:4169   .text:000000000000112e vTaskNotifyGiveFromISR
     /tmp/ccdmsBAD.s:4299   .text:00000000000011d2 xTaskNotifyStateClear

UNDEFINED SYMBOLS
uxListRemove
vListInsertEnd
vListInsert
vPortFree
vPortYield
vApplicationIdleHook
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss
