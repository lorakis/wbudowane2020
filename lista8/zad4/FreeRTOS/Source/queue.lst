   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 198               	prvIsQueueEmpty:
 199               		.stabd	46,0,0
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/Source/queue.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/queue.c ****  *
   5:FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/queue.c ****  *
  12:FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/queue.c ****  *
  15:FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/queue.c ****  *
  22:FreeRTOS/Source/queue.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/queue.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/queue.c ****  *
  25:FreeRTOS/Source/queue.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/queue.c ****  */
  27:FreeRTOS/Source/queue.c **** 
  28:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  29:FreeRTOS/Source/queue.c **** #include <string.h>
  30:FreeRTOS/Source/queue.c **** 
  31:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  34:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:FreeRTOS/Source/queue.c **** 
  36:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  37:FreeRTOS/Source/queue.c **** #include "task.h"
  38:FreeRTOS/Source/queue.c **** #include "queue.h"
  39:FreeRTOS/Source/queue.c **** 
  40:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  42:FreeRTOS/Source/queue.c **** #endif
  43:FreeRTOS/Source/queue.c **** 
  44:FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:FreeRTOS/Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:FreeRTOS/Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:FreeRTOS/Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:FreeRTOS/Source/queue.c **** 
  50:FreeRTOS/Source/queue.c **** 
  51:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:FreeRTOS/Source/queue.c **** 
  55:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:FreeRTOS/Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:FreeRTOS/Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:FreeRTOS/Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:FreeRTOS/Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:FreeRTOS/Source/queue.c **** being used for. */
  64:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  65:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:FreeRTOS/Source/queue.c **** 
  67:FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  68:FreeRTOS/Source/queue.c **** {
  69:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:FreeRTOS/Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:FreeRTOS/Source/queue.c **** } QueuePointers_t;
  72:FreeRTOS/Source/queue.c **** 
  73:FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  74:FreeRTOS/Source/queue.c **** {
  75:FreeRTOS/Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:FreeRTOS/Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  78:FreeRTOS/Source/queue.c **** 
  79:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:FreeRTOS/Source/queue.c **** zero. */
  81:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:FreeRTOS/Source/queue.c **** 
  84:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:FreeRTOS/Source/queue.c **** #else
  89:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:FreeRTOS/Source/queue.c **** #endif
  91:FreeRTOS/Source/queue.c **** 
  92:FreeRTOS/Source/queue.c **** /*
  93:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:FreeRTOS/Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:FreeRTOS/Source/queue.c ****  */
  97:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
  98:FreeRTOS/Source/queue.c **** {
  99:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:FreeRTOS/Source/queue.c **** 
 102:FreeRTOS/Source/queue.c **** 	union
 103:FreeRTOS/Source/queue.c **** 	{
 104:FreeRTOS/Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:FreeRTOS/Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:FreeRTOS/Source/queue.c **** 	} u;
 107:FreeRTOS/Source/queue.c **** 
 108:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:FreeRTOS/Source/queue.c **** 
 111:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:FreeRTOS/Source/queue.c **** 
 115:FreeRTOS/Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:FreeRTOS/Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:FreeRTOS/Source/queue.c **** 
 118:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:FreeRTOS/Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:FreeRTOS/Source/queue.c **** 	#endif
 121:FreeRTOS/Source/queue.c **** 
 122:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:FreeRTOS/Source/queue.c **** 	#endif
 125:FreeRTOS/Source/queue.c **** 
 126:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 129:FreeRTOS/Source/queue.c **** 	#endif
 130:FreeRTOS/Source/queue.c **** 
 131:FreeRTOS/Source/queue.c **** } xQUEUE;
 132:FreeRTOS/Source/queue.c **** 
 133:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 136:FreeRTOS/Source/queue.c **** 
 137:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 138:FreeRTOS/Source/queue.c **** 
 139:FreeRTOS/Source/queue.c **** /*
 140:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:FreeRTOS/Source/queue.c ****  */
 143:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:FreeRTOS/Source/queue.c **** 
 145:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:FreeRTOS/Source/queue.c **** 	more user friendly. */
 148:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:FreeRTOS/Source/queue.c **** 	{
 150:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 152:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 153:FreeRTOS/Source/queue.c **** 
 154:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:FreeRTOS/Source/queue.c **** 	debuggers. */
 157:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:FreeRTOS/Source/queue.c **** 
 159:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 162:FreeRTOS/Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:FreeRTOS/Source/queue.c **** 
 164:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:FreeRTOS/Source/queue.c **** 
 166:FreeRTOS/Source/queue.c **** /*
 167:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:FreeRTOS/Source/queue.c ****  */
 174:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:FreeRTOS/Source/queue.c **** 
 176:FreeRTOS/Source/queue.c **** /*
 177:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:FreeRTOS/Source/queue.c ****  *
 179:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:FreeRTOS/Source/queue.c ****  */
 181:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** /*
 184:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:FreeRTOS/Source/queue.c ****  *
 186:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:FreeRTOS/Source/queue.c ****  */
 188:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:FreeRTOS/Source/queue.c **** 
 190:FreeRTOS/Source/queue.c **** /*
 191:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:FreeRTOS/Source/queue.c ****  * back of the queue.
 193:FreeRTOS/Source/queue.c ****  */
 194:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:FreeRTOS/Source/queue.c **** 
 196:FreeRTOS/Source/queue.c **** /*
 197:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 198:FreeRTOS/Source/queue.c ****  */
 199:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:FreeRTOS/Source/queue.c **** 
 201:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:FreeRTOS/Source/queue.c **** 	/*
 203:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 205:FreeRTOS/Source/queue.c **** 	 */
 206:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 207:FreeRTOS/Source/queue.c **** #endif
 208:FreeRTOS/Source/queue.c **** 
 209:FreeRTOS/Source/queue.c **** /*
 210:FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 212:FreeRTOS/Source/queue.c ****  */
 213:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:FreeRTOS/Source/queue.c **** 
 215:FreeRTOS/Source/queue.c **** /*
 216:FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:FreeRTOS/Source/queue.c ****  * as a mutex.
 219:FreeRTOS/Source/queue.c ****  */
 220:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:FreeRTOS/Source/queue.c **** #endif
 223:FreeRTOS/Source/queue.c **** 
 224:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:FreeRTOS/Source/queue.c **** 	/*
 226:FreeRTOS/Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:FreeRTOS/Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:FreeRTOS/Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:FreeRTOS/Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:FreeRTOS/Source/queue.c **** 	 * that priority.
 231:FreeRTOS/Source/queue.c **** 	 */
 232:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:FreeRTOS/Source/queue.c **** #endif
 234:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 235:FreeRTOS/Source/queue.c **** 
 236:FreeRTOS/Source/queue.c **** /*
 237:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 239:FreeRTOS/Source/queue.c ****  */
 240:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:FreeRTOS/Source/queue.c **** 	{														\
 243:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:FreeRTOS/Source/queue.c **** 		{													\
 245:FreeRTOS/Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:FreeRTOS/Source/queue.c **** 		}													\
 247:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:FreeRTOS/Source/queue.c **** 		{													\
 249:FreeRTOS/Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:FreeRTOS/Source/queue.c **** 		}													\
 251:FreeRTOS/Source/queue.c **** 	}														\
 252:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 253:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 254:FreeRTOS/Source/queue.c **** 
 255:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:FreeRTOS/Source/queue.c **** {
 257:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 258:FreeRTOS/Source/queue.c **** 
 259:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 260:FreeRTOS/Source/queue.c **** 
 261:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 262:FreeRTOS/Source/queue.c **** 	{
 263:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
 264:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 265:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 266:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 268:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 269:FreeRTOS/Source/queue.c **** 
 270:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 271:FreeRTOS/Source/queue.c **** 		{
 272:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 277:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 278:FreeRTOS/Source/queue.c **** 			{
 279:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 280:FreeRTOS/Source/queue.c **** 				{
 281:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 282:FreeRTOS/Source/queue.c **** 				}
 283:FreeRTOS/Source/queue.c **** 				else
 284:FreeRTOS/Source/queue.c **** 				{
 285:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:FreeRTOS/Source/queue.c **** 				}
 287:FreeRTOS/Source/queue.c **** 			}
 288:FreeRTOS/Source/queue.c **** 			else
 289:FreeRTOS/Source/queue.c **** 			{
 290:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/Source/queue.c **** 			}
 292:FreeRTOS/Source/queue.c **** 		}
 293:FreeRTOS/Source/queue.c **** 		else
 294:FreeRTOS/Source/queue.c **** 		{
 295:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 297:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 298:FreeRTOS/Source/queue.c **** 		}
 299:FreeRTOS/Source/queue.c **** 	}
 300:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 301:FreeRTOS/Source/queue.c **** 
 302:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:FreeRTOS/Source/queue.c **** 	versions. */
 304:FreeRTOS/Source/queue.c **** 	return pdPASS;
 305:FreeRTOS/Source/queue.c **** }
 306:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 307:FreeRTOS/Source/queue.c **** 
 308:FreeRTOS/Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:FreeRTOS/Source/queue.c **** 
 310:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:FreeRTOS/Source/queue.c **** 	{
 312:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 313:FreeRTOS/Source/queue.c **** 
 314:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:FreeRTOS/Source/queue.c **** 
 316:FreeRTOS/Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:FreeRTOS/Source/queue.c **** 		supplied. */
 318:FreeRTOS/Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:FreeRTOS/Source/queue.c **** 
 320:FreeRTOS/Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:FreeRTOS/Source/queue.c **** 		should not be provided if the item size is 0. */
 322:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:FreeRTOS/Source/queue.c **** 
 325:FreeRTOS/Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:FreeRTOS/Source/queue.c **** 		{
 327:FreeRTOS/Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:FreeRTOS/Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:FreeRTOS/Source/queue.c **** 			the real queue and semaphore structures. */
 330:FreeRTOS/Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:FreeRTOS/Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:FreeRTOS/Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:FreeRTOS/Source/queue.c **** 		}
 334:FreeRTOS/Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:FreeRTOS/Source/queue.c **** 
 336:FreeRTOS/Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:FreeRTOS/Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:FreeRTOS/Source/queue.c **** 		but is already set. */
 339:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:FreeRTOS/Source/queue.c **** 
 341:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 342:FreeRTOS/Source/queue.c **** 		{
 343:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:FreeRTOS/Source/queue.c **** 			{
 345:FreeRTOS/Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:FreeRTOS/Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:FreeRTOS/Source/queue.c **** 				later deleted. */
 348:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:FreeRTOS/Source/queue.c **** 			}
 350:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:FreeRTOS/Source/queue.c **** 
 352:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:FreeRTOS/Source/queue.c **** 		}
 354:FreeRTOS/Source/queue.c **** 		else
 355:FreeRTOS/Source/queue.c **** 		{
 356:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:FreeRTOS/Source/queue.c **** 		}
 359:FreeRTOS/Source/queue.c **** 
 360:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 361:FreeRTOS/Source/queue.c **** 	}
 362:FreeRTOS/Source/queue.c **** 
 363:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 365:FreeRTOS/Source/queue.c **** 
 366:FreeRTOS/Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:FreeRTOS/Source/queue.c **** 
 368:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:FreeRTOS/Source/queue.c **** 	{
 370:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 371:FreeRTOS/Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:FreeRTOS/Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:FreeRTOS/Source/queue.c **** 
 374:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:FreeRTOS/Source/queue.c **** 
 376:FreeRTOS/Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 377:FreeRTOS/Source/queue.c **** 		{
 378:FreeRTOS/Source/queue.c **** 			/* There is not going to be a queue storage area. */
 379:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 380:FreeRTOS/Source/queue.c **** 		}
 381:FreeRTOS/Source/queue.c **** 		else
 382:FreeRTOS/Source/queue.c **** 		{
 383:FreeRTOS/Source/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 384:FreeRTOS/Source/queue.c **** 			can be in the queue at any time. */
 385:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 386:FreeRTOS/Source/queue.c **** 		}
 387:FreeRTOS/Source/queue.c **** 
 388:FreeRTOS/Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 389:FreeRTOS/Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 390:FreeRTOS/Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 391:FreeRTOS/Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 392:FreeRTOS/Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 393:FreeRTOS/Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 394:FreeRTOS/Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 395:FreeRTOS/Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 396:FreeRTOS/Source/queue.c **** 		two bytes). */
 397:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 398:FreeRTOS/Source/queue.c **** 
 399:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 400:FreeRTOS/Source/queue.c **** 		{
 401:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 402:FreeRTOS/Source/queue.c **** 			storage area. */
 403:FreeRTOS/Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 404:FreeRTOS/Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 405:FreeRTOS/Source/queue.c **** 
 406:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 407:FreeRTOS/Source/queue.c **** 			{
 408:FreeRTOS/Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 409:FreeRTOS/Source/queue.c **** 				note this task was created dynamically in case it is later
 410:FreeRTOS/Source/queue.c **** 				deleted. */
 411:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 412:FreeRTOS/Source/queue.c **** 			}
 413:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 414:FreeRTOS/Source/queue.c **** 
 415:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 416:FreeRTOS/Source/queue.c **** 		}
 417:FreeRTOS/Source/queue.c **** 		else
 418:FreeRTOS/Source/queue.c **** 		{
 419:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 420:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 421:FreeRTOS/Source/queue.c **** 		}
 422:FreeRTOS/Source/queue.c **** 
 423:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 424:FreeRTOS/Source/queue.c **** 	}
 425:FreeRTOS/Source/queue.c **** 
 426:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 427:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 428:FreeRTOS/Source/queue.c **** 
 429:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 430:FreeRTOS/Source/queue.c **** {
 431:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 432:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 433:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 434:FreeRTOS/Source/queue.c **** 
 435:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 436:FreeRTOS/Source/queue.c **** 	{
 437:FreeRTOS/Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 438:FreeRTOS/Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 439:FreeRTOS/Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 440:FreeRTOS/Source/queue.c **** 		value that is known to be within the memory map. */
 441:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 442:FreeRTOS/Source/queue.c **** 	}
 443:FreeRTOS/Source/queue.c **** 	else
 444:FreeRTOS/Source/queue.c **** 	{
 445:FreeRTOS/Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 446:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 447:FreeRTOS/Source/queue.c **** 	}
 448:FreeRTOS/Source/queue.c **** 
 449:FreeRTOS/Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 450:FreeRTOS/Source/queue.c **** 	defined. */
 451:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 452:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 453:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 454:FreeRTOS/Source/queue.c **** 
 455:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 456:FreeRTOS/Source/queue.c **** 	{
 457:FreeRTOS/Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 458:FreeRTOS/Source/queue.c **** 	}
 459:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 460:FreeRTOS/Source/queue.c **** 
 461:FreeRTOS/Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 462:FreeRTOS/Source/queue.c **** 	{
 463:FreeRTOS/Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 464:FreeRTOS/Source/queue.c **** 	}
 465:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 466:FreeRTOS/Source/queue.c **** 
 467:FreeRTOS/Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 468:FreeRTOS/Source/queue.c **** }
 469:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 470:FreeRTOS/Source/queue.c **** 
 471:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 472:FreeRTOS/Source/queue.c **** 
 473:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 474:FreeRTOS/Source/queue.c **** 	{
 475:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 476:FreeRTOS/Source/queue.c **** 		{
 477:FreeRTOS/Source/queue.c **** 			/* The queue create function will set all the queue structure members
 478:FreeRTOS/Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 479:FreeRTOS/Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 480:FreeRTOS/Source/queue.c **** 			in particular the information required for priority inheritance. */
 481:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 482:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 483:FreeRTOS/Source/queue.c **** 
 484:FreeRTOS/Source/queue.c **** 			/* In case this is a recursive mutex. */
 485:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 486:FreeRTOS/Source/queue.c **** 
 487:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 488:FreeRTOS/Source/queue.c **** 
 489:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 490:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 491:FreeRTOS/Source/queue.c **** 		}
 492:FreeRTOS/Source/queue.c **** 		else
 493:FreeRTOS/Source/queue.c **** 		{
 494:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 495:FreeRTOS/Source/queue.c **** 		}
 496:FreeRTOS/Source/queue.c **** 	}
 497:FreeRTOS/Source/queue.c **** 
 498:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 499:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 500:FreeRTOS/Source/queue.c **** 
 501:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 502:FreeRTOS/Source/queue.c **** 
 503:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 504:FreeRTOS/Source/queue.c **** 	{
 505:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 506:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 507:FreeRTOS/Source/queue.c **** 
 508:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 509:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 510:FreeRTOS/Source/queue.c **** 
 511:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 512:FreeRTOS/Source/queue.c **** 	}
 513:FreeRTOS/Source/queue.c **** 
 514:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 515:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 516:FreeRTOS/Source/queue.c **** 
 517:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 518:FreeRTOS/Source/queue.c **** 
 519:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 520:FreeRTOS/Source/queue.c **** 	{
 521:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 522:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 523:FreeRTOS/Source/queue.c **** 
 524:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 525:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 526:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 527:FreeRTOS/Source/queue.c **** 
 528:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 529:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 530:FreeRTOS/Source/queue.c **** 
 531:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 532:FreeRTOS/Source/queue.c **** 	}
 533:FreeRTOS/Source/queue.c **** 
 534:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 535:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 536:FreeRTOS/Source/queue.c **** 
 537:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 538:FreeRTOS/Source/queue.c **** 
 539:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 540:FreeRTOS/Source/queue.c **** 	{
 541:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 542:FreeRTOS/Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 543:FreeRTOS/Source/queue.c **** 
 544:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 545:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 546:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 547:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 548:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 549:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 550:FreeRTOS/Source/queue.c **** 		{
 551:FreeRTOS/Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 552:FreeRTOS/Source/queue.c **** 			{
 553:FreeRTOS/Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 554:FreeRTOS/Source/queue.c **** 			}
 555:FreeRTOS/Source/queue.c **** 			else
 556:FreeRTOS/Source/queue.c **** 			{
 557:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 558:FreeRTOS/Source/queue.c **** 			}
 559:FreeRTOS/Source/queue.c **** 		}
 560:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 561:FreeRTOS/Source/queue.c **** 
 562:FreeRTOS/Source/queue.c **** 		return pxReturn;
 563:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 564:FreeRTOS/Source/queue.c **** 
 565:FreeRTOS/Source/queue.c **** #endif
 566:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 567:FreeRTOS/Source/queue.c **** 
 568:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 569:FreeRTOS/Source/queue.c **** 
 570:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 571:FreeRTOS/Source/queue.c **** 	{
 572:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 573:FreeRTOS/Source/queue.c **** 
 574:FreeRTOS/Source/queue.c **** 		configASSERT( xSemaphore );
 575:FreeRTOS/Source/queue.c **** 
 576:FreeRTOS/Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 577:FreeRTOS/Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 578:FreeRTOS/Source/queue.c **** 		not required here. */
 579:FreeRTOS/Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 580:FreeRTOS/Source/queue.c **** 		{
 581:FreeRTOS/Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 582:FreeRTOS/Source/queue.c **** 		}
 583:FreeRTOS/Source/queue.c **** 		else
 584:FreeRTOS/Source/queue.c **** 		{
 585:FreeRTOS/Source/queue.c **** 			pxReturn = NULL;
 586:FreeRTOS/Source/queue.c **** 		}
 587:FreeRTOS/Source/queue.c **** 
 588:FreeRTOS/Source/queue.c **** 		return pxReturn;
 589:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 590:FreeRTOS/Source/queue.c **** 
 591:FreeRTOS/Source/queue.c **** #endif
 592:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 593:FreeRTOS/Source/queue.c **** 
 594:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 595:FreeRTOS/Source/queue.c **** 
 596:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 597:FreeRTOS/Source/queue.c **** 	{
 598:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 599:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 600:FreeRTOS/Source/queue.c **** 
 601:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 602:FreeRTOS/Source/queue.c **** 
 603:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 604:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 605:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 606:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 607:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 608:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 609:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 610:FreeRTOS/Source/queue.c **** 		{
 611:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 612:FreeRTOS/Source/queue.c **** 
 613:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 614:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 615:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 616:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 617:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 618:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 619:FreeRTOS/Source/queue.c **** 
 620:FreeRTOS/Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 621:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 622:FreeRTOS/Source/queue.c **** 			{
 623:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 624:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 625:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 626:FreeRTOS/Source/queue.c **** 			}
 627:FreeRTOS/Source/queue.c **** 			else
 628:FreeRTOS/Source/queue.c **** 			{
 629:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 630:FreeRTOS/Source/queue.c **** 			}
 631:FreeRTOS/Source/queue.c **** 
 632:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 633:FreeRTOS/Source/queue.c **** 		}
 634:FreeRTOS/Source/queue.c **** 		else
 635:FreeRTOS/Source/queue.c **** 		{
 636:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 637:FreeRTOS/Source/queue.c **** 			holder. */
 638:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 639:FreeRTOS/Source/queue.c **** 
 640:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 641:FreeRTOS/Source/queue.c **** 		}
 642:FreeRTOS/Source/queue.c **** 
 643:FreeRTOS/Source/queue.c **** 		return xReturn;
 644:FreeRTOS/Source/queue.c **** 	}
 645:FreeRTOS/Source/queue.c **** 
 646:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 647:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 648:FreeRTOS/Source/queue.c **** 
 649:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 650:FreeRTOS/Source/queue.c **** 
 651:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 652:FreeRTOS/Source/queue.c **** 	{
 653:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 654:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 655:FreeRTOS/Source/queue.c **** 
 656:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 657:FreeRTOS/Source/queue.c **** 
 658:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 659:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 660:FreeRTOS/Source/queue.c **** 
 661:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 662:FreeRTOS/Source/queue.c **** 
 663:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 664:FreeRTOS/Source/queue.c **** 		{
 665:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 666:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 667:FreeRTOS/Source/queue.c **** 		}
 668:FreeRTOS/Source/queue.c **** 		else
 669:FreeRTOS/Source/queue.c **** 		{
 670:FreeRTOS/Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 671:FreeRTOS/Source/queue.c **** 
 672:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 673:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 674:FreeRTOS/Source/queue.c **** 			before reaching here. */
 675:FreeRTOS/Source/queue.c **** 			if( xReturn != pdFAIL )
 676:FreeRTOS/Source/queue.c **** 			{
 677:FreeRTOS/Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 678:FreeRTOS/Source/queue.c **** 			}
 679:FreeRTOS/Source/queue.c **** 			else
 680:FreeRTOS/Source/queue.c **** 			{
 681:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 682:FreeRTOS/Source/queue.c **** 			}
 683:FreeRTOS/Source/queue.c **** 		}
 684:FreeRTOS/Source/queue.c **** 
 685:FreeRTOS/Source/queue.c **** 		return xReturn;
 686:FreeRTOS/Source/queue.c **** 	}
 687:FreeRTOS/Source/queue.c **** 
 688:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 689:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 690:FreeRTOS/Source/queue.c **** 
 691:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 692:FreeRTOS/Source/queue.c **** 
 693:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 694:FreeRTOS/Source/queue.c **** 	{
 695:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 696:FreeRTOS/Source/queue.c **** 
 697:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 698:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 699:FreeRTOS/Source/queue.c **** 
 700:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 701:FreeRTOS/Source/queue.c **** 
 702:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 703:FreeRTOS/Source/queue.c **** 		{
 704:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 705:FreeRTOS/Source/queue.c **** 
 706:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 707:FreeRTOS/Source/queue.c **** 		}
 708:FreeRTOS/Source/queue.c **** 		else
 709:FreeRTOS/Source/queue.c **** 		{
 710:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 711:FreeRTOS/Source/queue.c **** 		}
 712:FreeRTOS/Source/queue.c **** 
 713:FreeRTOS/Source/queue.c **** 		return xHandle;
 714:FreeRTOS/Source/queue.c **** 	}
 715:FreeRTOS/Source/queue.c **** 
 716:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 717:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 718:FreeRTOS/Source/queue.c **** 
 719:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 720:FreeRTOS/Source/queue.c **** 
 721:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 722:FreeRTOS/Source/queue.c **** 	{
 723:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 724:FreeRTOS/Source/queue.c **** 
 725:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 726:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 727:FreeRTOS/Source/queue.c **** 
 728:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 729:FreeRTOS/Source/queue.c **** 
 730:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 731:FreeRTOS/Source/queue.c **** 		{
 732:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 733:FreeRTOS/Source/queue.c **** 
 734:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 735:FreeRTOS/Source/queue.c **** 		}
 736:FreeRTOS/Source/queue.c **** 		else
 737:FreeRTOS/Source/queue.c **** 		{
 738:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 739:FreeRTOS/Source/queue.c **** 		}
 740:FreeRTOS/Source/queue.c **** 
 741:FreeRTOS/Source/queue.c **** 		return xHandle;
 742:FreeRTOS/Source/queue.c **** 	}
 743:FreeRTOS/Source/queue.c **** 
 744:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 745:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 746:FreeRTOS/Source/queue.c **** 
 747:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 748:FreeRTOS/Source/queue.c **** {
 749:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 750:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 751:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 752:FreeRTOS/Source/queue.c **** 
 753:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 754:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 755:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 756:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 757:FreeRTOS/Source/queue.c **** 	{
 758:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 759:FreeRTOS/Source/queue.c **** 	}
 760:FreeRTOS/Source/queue.c **** 	#endif
 761:FreeRTOS/Source/queue.c **** 
 762:FreeRTOS/Source/queue.c **** 
 763:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 764:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 765:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
 766:FreeRTOS/Source/queue.c **** 	for( ;; )
 767:FreeRTOS/Source/queue.c **** 	{
 768:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 769:FreeRTOS/Source/queue.c **** 		{
 770:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 771:FreeRTOS/Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 772:FreeRTOS/Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 773:FreeRTOS/Source/queue.c **** 			queue is full. */
 774:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 775:FreeRTOS/Source/queue.c **** 			{
 776:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 777:FreeRTOS/Source/queue.c **** 
 778:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 779:FreeRTOS/Source/queue.c **** 				{
 780:FreeRTOS/Source/queue.c **** 				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 781:FreeRTOS/Source/queue.c **** 
 782:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 783:FreeRTOS/Source/queue.c **** 
 784:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 785:FreeRTOS/Source/queue.c **** 					{
 786:FreeRTOS/Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 787:FreeRTOS/Source/queue.c **** 						{
 788:FreeRTOS/Source/queue.c **** 							/* Do not notify the queue set as an existing item
 789:FreeRTOS/Source/queue.c **** 							was overwritten in the queue so the number of items
 790:FreeRTOS/Source/queue.c **** 							in the queue has not changed. */
 791:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 792:FreeRTOS/Source/queue.c **** 						}
 793:FreeRTOS/Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 794:FreeRTOS/Source/queue.c **** 						{
 795:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 796:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 797:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 798:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 799:FreeRTOS/Source/queue.c **** 						}
 800:FreeRTOS/Source/queue.c **** 						else
 801:FreeRTOS/Source/queue.c **** 						{
 802:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 803:FreeRTOS/Source/queue.c **** 						}
 804:FreeRTOS/Source/queue.c **** 					}
 805:FreeRTOS/Source/queue.c **** 					else
 806:FreeRTOS/Source/queue.c **** 					{
 807:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 808:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 809:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 810:FreeRTOS/Source/queue.c **** 						{
 811:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 812:FreeRTOS/Source/queue.c **** 							{
 813:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 814:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 815:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 816:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 817:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 818:FreeRTOS/Source/queue.c **** 							}
 819:FreeRTOS/Source/queue.c **** 							else
 820:FreeRTOS/Source/queue.c **** 							{
 821:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 822:FreeRTOS/Source/queue.c **** 							}
 823:FreeRTOS/Source/queue.c **** 						}
 824:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 825:FreeRTOS/Source/queue.c **** 						{
 826:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 827:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 828:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 829:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 830:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 831:FreeRTOS/Source/queue.c **** 						}
 832:FreeRTOS/Source/queue.c **** 						else
 833:FreeRTOS/Source/queue.c **** 						{
 834:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 835:FreeRTOS/Source/queue.c **** 						}
 836:FreeRTOS/Source/queue.c **** 					}
 837:FreeRTOS/Source/queue.c **** 				}
 838:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 839:FreeRTOS/Source/queue.c **** 				{
 840:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 841:FreeRTOS/Source/queue.c **** 
 842:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 843:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 844:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 845:FreeRTOS/Source/queue.c **** 					{
 846:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 847:FreeRTOS/Source/queue.c **** 						{
 848:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 849:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 850:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 851:FreeRTOS/Source/queue.c **** 							takes care of that. */
 852:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 853:FreeRTOS/Source/queue.c **** 						}
 854:FreeRTOS/Source/queue.c **** 						else
 855:FreeRTOS/Source/queue.c **** 						{
 856:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 857:FreeRTOS/Source/queue.c **** 						}
 858:FreeRTOS/Source/queue.c **** 					}
 859:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 860:FreeRTOS/Source/queue.c **** 					{
 861:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 862:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 863:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 864:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 865:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 866:FreeRTOS/Source/queue.c **** 					}
 867:FreeRTOS/Source/queue.c **** 					else
 868:FreeRTOS/Source/queue.c **** 					{
 869:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 870:FreeRTOS/Source/queue.c **** 					}
 871:FreeRTOS/Source/queue.c **** 				}
 872:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 873:FreeRTOS/Source/queue.c **** 
 874:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 875:FreeRTOS/Source/queue.c **** 				return pdPASS;
 876:FreeRTOS/Source/queue.c **** 			}
 877:FreeRTOS/Source/queue.c **** 			else
 878:FreeRTOS/Source/queue.c **** 			{
 879:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 880:FreeRTOS/Source/queue.c **** 				{
 881:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 882:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 883:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 884:FreeRTOS/Source/queue.c **** 
 885:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 886:FreeRTOS/Source/queue.c **** 					the function. */
 887:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 888:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 889:FreeRTOS/Source/queue.c **** 				}
 890:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 891:FreeRTOS/Source/queue.c **** 				{
 892:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 893:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 894:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 895:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 896:FreeRTOS/Source/queue.c **** 				}
 897:FreeRTOS/Source/queue.c **** 				else
 898:FreeRTOS/Source/queue.c **** 				{
 899:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 900:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 901:FreeRTOS/Source/queue.c **** 				}
 902:FreeRTOS/Source/queue.c **** 			}
 903:FreeRTOS/Source/queue.c **** 		}
 904:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 905:FreeRTOS/Source/queue.c **** 
 906:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 907:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 908:FreeRTOS/Source/queue.c **** 
 909:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 910:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 911:FreeRTOS/Source/queue.c **** 
 912:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 913:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 914:FreeRTOS/Source/queue.c **** 		{
 915:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 916:FreeRTOS/Source/queue.c **** 			{
 917:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 918:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 919:FreeRTOS/Source/queue.c **** 
 920:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 921:FreeRTOS/Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 922:FreeRTOS/Source/queue.c **** 				remove this task from the event list again - but as the
 923:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 924:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 925:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 926:FreeRTOS/Source/queue.c **** 
 927:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 928:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 929:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 930:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 931:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 932:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 933:FreeRTOS/Source/queue.c **** 				{
 934:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 935:FreeRTOS/Source/queue.c **** 				}
 936:FreeRTOS/Source/queue.c **** 			}
 937:FreeRTOS/Source/queue.c **** 			else
 938:FreeRTOS/Source/queue.c **** 			{
 939:FreeRTOS/Source/queue.c **** 				/* Try again. */
 940:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 941:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 942:FreeRTOS/Source/queue.c **** 			}
 943:FreeRTOS/Source/queue.c **** 		}
 944:FreeRTOS/Source/queue.c **** 		else
 945:FreeRTOS/Source/queue.c **** 		{
 946:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 947:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 948:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 949:FreeRTOS/Source/queue.c **** 
 950:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 951:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 952:FreeRTOS/Source/queue.c **** 		}
 953:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
 954:FreeRTOS/Source/queue.c **** }
 955:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 956:FreeRTOS/Source/queue.c **** 
 957:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 958:FreeRTOS/Source/queue.c **** {
 959:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 960:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 961:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 962:FreeRTOS/Source/queue.c **** 
 963:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 964:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 965:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 966:FreeRTOS/Source/queue.c **** 
 967:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 968:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 969:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 970:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 971:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 972:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 973:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 974:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 975:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 976:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 977:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 978:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 979:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 980:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 981:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 982:FreeRTOS/Source/queue.c **** 
 983:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 984:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 985:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 986:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 987:FreeRTOS/Source/queue.c **** 	post). */
 988:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 989:FreeRTOS/Source/queue.c **** 	{
 990:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 991:FreeRTOS/Source/queue.c **** 		{
 992:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 993:FreeRTOS/Source/queue.c **** 
 994:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 995:FreeRTOS/Source/queue.c **** 
 996:FreeRTOS/Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 997:FreeRTOS/Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 998:FreeRTOS/Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 999:FreeRTOS/Source/queue.c **** 			called here even though the disinherit function does not check if
1000:FreeRTOS/Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
1001:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1002:FreeRTOS/Source/queue.c **** 
1003:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1004:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1005:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1006:FreeRTOS/Source/queue.c **** 			{
1007:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1008:FreeRTOS/Source/queue.c **** 				{
1009:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1010:FreeRTOS/Source/queue.c **** 					{
1011:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
1012:FreeRTOS/Source/queue.c **** 						{
1013:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1014:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1015:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1016:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1017:FreeRTOS/Source/queue.c **** 							{
1018:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1019:FreeRTOS/Source/queue.c **** 							}
1020:FreeRTOS/Source/queue.c **** 							else
1021:FreeRTOS/Source/queue.c **** 							{
1022:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1023:FreeRTOS/Source/queue.c **** 							}
1024:FreeRTOS/Source/queue.c **** 						}
1025:FreeRTOS/Source/queue.c **** 						else
1026:FreeRTOS/Source/queue.c **** 						{
1027:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1028:FreeRTOS/Source/queue.c **** 						}
1029:FreeRTOS/Source/queue.c **** 					}
1030:FreeRTOS/Source/queue.c **** 					else
1031:FreeRTOS/Source/queue.c **** 					{
1032:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1033:FreeRTOS/Source/queue.c **** 						{
1034:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1035:FreeRTOS/Source/queue.c **** 							{
1036:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1037:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1038:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1039:FreeRTOS/Source/queue.c **** 								{
1040:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1041:FreeRTOS/Source/queue.c **** 								}
1042:FreeRTOS/Source/queue.c **** 								else
1043:FreeRTOS/Source/queue.c **** 								{
1044:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1045:FreeRTOS/Source/queue.c **** 								}
1046:FreeRTOS/Source/queue.c **** 							}
1047:FreeRTOS/Source/queue.c **** 							else
1048:FreeRTOS/Source/queue.c **** 							{
1049:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1050:FreeRTOS/Source/queue.c **** 							}
1051:FreeRTOS/Source/queue.c **** 						}
1052:FreeRTOS/Source/queue.c **** 						else
1053:FreeRTOS/Source/queue.c **** 						{
1054:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1055:FreeRTOS/Source/queue.c **** 						}
1056:FreeRTOS/Source/queue.c **** 					}
1057:FreeRTOS/Source/queue.c **** 				}
1058:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1059:FreeRTOS/Source/queue.c **** 				{
1060:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1061:FreeRTOS/Source/queue.c **** 					{
1062:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1063:FreeRTOS/Source/queue.c **** 						{
1064:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1065:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1066:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1067:FreeRTOS/Source/queue.c **** 							{
1068:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1069:FreeRTOS/Source/queue.c **** 							}
1070:FreeRTOS/Source/queue.c **** 							else
1071:FreeRTOS/Source/queue.c **** 							{
1072:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1073:FreeRTOS/Source/queue.c **** 							}
1074:FreeRTOS/Source/queue.c **** 						}
1075:FreeRTOS/Source/queue.c **** 						else
1076:FreeRTOS/Source/queue.c **** 						{
1077:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1078:FreeRTOS/Source/queue.c **** 						}
1079:FreeRTOS/Source/queue.c **** 					}
1080:FreeRTOS/Source/queue.c **** 					else
1081:FreeRTOS/Source/queue.c **** 					{
1082:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1083:FreeRTOS/Source/queue.c **** 					}
1084:FreeRTOS/Source/queue.c **** 				}
1085:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1086:FreeRTOS/Source/queue.c **** 			}
1087:FreeRTOS/Source/queue.c **** 			else
1088:FreeRTOS/Source/queue.c **** 			{
1089:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1090:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1091:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1092:FreeRTOS/Source/queue.c **** 			}
1093:FreeRTOS/Source/queue.c **** 
1094:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1095:FreeRTOS/Source/queue.c **** 		}
1096:FreeRTOS/Source/queue.c **** 		else
1097:FreeRTOS/Source/queue.c **** 		{
1098:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1099:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1100:FreeRTOS/Source/queue.c **** 		}
1101:FreeRTOS/Source/queue.c **** 	}
1102:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1103:FreeRTOS/Source/queue.c **** 
1104:FreeRTOS/Source/queue.c **** 	return xReturn;
1105:FreeRTOS/Source/queue.c **** }
1106:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1107:FreeRTOS/Source/queue.c **** 
1108:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1109:FreeRTOS/Source/queue.c **** {
1110:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1111:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1112:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1113:FreeRTOS/Source/queue.c **** 
1114:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1115:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1116:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1117:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1118:FreeRTOS/Source/queue.c **** 	post). */
1119:FreeRTOS/Source/queue.c **** 
1120:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1121:FreeRTOS/Source/queue.c **** 
1122:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1123:FreeRTOS/Source/queue.c **** 	if the item size is not 0. */
1124:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1125:FreeRTOS/Source/queue.c **** 
1126:FreeRTOS/Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1127:FreeRTOS/Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1128:FreeRTOS/Source/queue.c **** 	interrupts, only tasks. */
1129:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1130:FreeRTOS/Source/queue.c **** 
1131:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1132:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1133:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1134:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1135:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1136:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1137:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1138:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1139:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1140:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1141:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1142:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1143:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1144:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1145:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1146:FreeRTOS/Source/queue.c **** 
1147:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1148:FreeRTOS/Source/queue.c **** 	{
1149:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1150:FreeRTOS/Source/queue.c **** 
1151:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1152:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1153:FreeRTOS/Source/queue.c **** 		space'. */
1154:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
1155:FreeRTOS/Source/queue.c **** 		{
1156:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
1157:FreeRTOS/Source/queue.c **** 
1158:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1159:FreeRTOS/Source/queue.c **** 
1160:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1161:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1162:FreeRTOS/Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1163:FreeRTOS/Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1164:FreeRTOS/Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1165:FreeRTOS/Source/queue.c **** 			messages (semaphores) available. */
1166:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1167:FreeRTOS/Source/queue.c **** 
1168:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1169:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1170:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1171:FreeRTOS/Source/queue.c **** 			{
1172:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1173:FreeRTOS/Source/queue.c **** 				{
1174:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1175:FreeRTOS/Source/queue.c **** 					{
1176:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1177:FreeRTOS/Source/queue.c **** 						{
1178:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1179:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1180:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1181:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1182:FreeRTOS/Source/queue.c **** 							{
1183:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1184:FreeRTOS/Source/queue.c **** 							}
1185:FreeRTOS/Source/queue.c **** 							else
1186:FreeRTOS/Source/queue.c **** 							{
1187:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1188:FreeRTOS/Source/queue.c **** 							}
1189:FreeRTOS/Source/queue.c **** 						}
1190:FreeRTOS/Source/queue.c **** 						else
1191:FreeRTOS/Source/queue.c **** 						{
1192:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1193:FreeRTOS/Source/queue.c **** 						}
1194:FreeRTOS/Source/queue.c **** 					}
1195:FreeRTOS/Source/queue.c **** 					else
1196:FreeRTOS/Source/queue.c **** 					{
1197:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1198:FreeRTOS/Source/queue.c **** 						{
1199:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1200:FreeRTOS/Source/queue.c **** 							{
1201:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1202:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1203:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1204:FreeRTOS/Source/queue.c **** 								{
1205:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1206:FreeRTOS/Source/queue.c **** 								}
1207:FreeRTOS/Source/queue.c **** 								else
1208:FreeRTOS/Source/queue.c **** 								{
1209:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1210:FreeRTOS/Source/queue.c **** 								}
1211:FreeRTOS/Source/queue.c **** 							}
1212:FreeRTOS/Source/queue.c **** 							else
1213:FreeRTOS/Source/queue.c **** 							{
1214:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1215:FreeRTOS/Source/queue.c **** 							}
1216:FreeRTOS/Source/queue.c **** 						}
1217:FreeRTOS/Source/queue.c **** 						else
1218:FreeRTOS/Source/queue.c **** 						{
1219:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1220:FreeRTOS/Source/queue.c **** 						}
1221:FreeRTOS/Source/queue.c **** 					}
1222:FreeRTOS/Source/queue.c **** 				}
1223:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1224:FreeRTOS/Source/queue.c **** 				{
1225:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1226:FreeRTOS/Source/queue.c **** 					{
1227:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1228:FreeRTOS/Source/queue.c **** 						{
1229:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1230:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1231:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1232:FreeRTOS/Source/queue.c **** 							{
1233:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1234:FreeRTOS/Source/queue.c **** 							}
1235:FreeRTOS/Source/queue.c **** 							else
1236:FreeRTOS/Source/queue.c **** 							{
1237:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1238:FreeRTOS/Source/queue.c **** 							}
1239:FreeRTOS/Source/queue.c **** 						}
1240:FreeRTOS/Source/queue.c **** 						else
1241:FreeRTOS/Source/queue.c **** 						{
1242:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1243:FreeRTOS/Source/queue.c **** 						}
1244:FreeRTOS/Source/queue.c **** 					}
1245:FreeRTOS/Source/queue.c **** 					else
1246:FreeRTOS/Source/queue.c **** 					{
1247:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1248:FreeRTOS/Source/queue.c **** 					}
1249:FreeRTOS/Source/queue.c **** 				}
1250:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1251:FreeRTOS/Source/queue.c **** 			}
1252:FreeRTOS/Source/queue.c **** 			else
1253:FreeRTOS/Source/queue.c **** 			{
1254:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1255:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1256:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1257:FreeRTOS/Source/queue.c **** 			}
1258:FreeRTOS/Source/queue.c **** 
1259:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1260:FreeRTOS/Source/queue.c **** 		}
1261:FreeRTOS/Source/queue.c **** 		else
1262:FreeRTOS/Source/queue.c **** 		{
1263:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1264:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1265:FreeRTOS/Source/queue.c **** 		}
1266:FreeRTOS/Source/queue.c **** 	}
1267:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1268:FreeRTOS/Source/queue.c **** 
1269:FreeRTOS/Source/queue.c **** 	return xReturn;
1270:FreeRTOS/Source/queue.c **** }
1271:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1272:FreeRTOS/Source/queue.c **** 
1273:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1274:FreeRTOS/Source/queue.c **** {
1275:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1276:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1277:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1278:FreeRTOS/Source/queue.c **** 
1279:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1280:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1281:FreeRTOS/Source/queue.c **** 
1282:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1283:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1284:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1285:FreeRTOS/Source/queue.c **** 
1286:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1287:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1288:FreeRTOS/Source/queue.c **** 	{
1289:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1290:FreeRTOS/Source/queue.c **** 	}
1291:FreeRTOS/Source/queue.c **** 	#endif
1292:FreeRTOS/Source/queue.c **** 
1293:FreeRTOS/Source/queue.c **** 
1294:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1295:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1296:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1297:FreeRTOS/Source/queue.c **** 	for( ;; )
1298:FreeRTOS/Source/queue.c **** 	{
1299:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1300:FreeRTOS/Source/queue.c **** 		{
1301:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1302:FreeRTOS/Source/queue.c **** 
1303:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1304:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1305:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1306:FreeRTOS/Source/queue.c **** 			{
1307:FreeRTOS/Source/queue.c **** 				/* Data available, remove one item. */
1308:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1309:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1310:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1311:FreeRTOS/Source/queue.c **** 
1312:FreeRTOS/Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1313:FreeRTOS/Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1314:FreeRTOS/Source/queue.c **** 				task. */
1315:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1316:FreeRTOS/Source/queue.c **** 				{
1317:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1318:FreeRTOS/Source/queue.c **** 					{
1319:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1320:FreeRTOS/Source/queue.c **** 					}
1321:FreeRTOS/Source/queue.c **** 					else
1322:FreeRTOS/Source/queue.c **** 					{
1323:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1324:FreeRTOS/Source/queue.c **** 					}
1325:FreeRTOS/Source/queue.c **** 				}
1326:FreeRTOS/Source/queue.c **** 				else
1327:FreeRTOS/Source/queue.c **** 				{
1328:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1329:FreeRTOS/Source/queue.c **** 				}
1330:FreeRTOS/Source/queue.c **** 
1331:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1332:FreeRTOS/Source/queue.c **** 				return pdPASS;
1333:FreeRTOS/Source/queue.c **** 			}
1334:FreeRTOS/Source/queue.c **** 			else
1335:FreeRTOS/Source/queue.c **** 			{
1336:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1337:FreeRTOS/Source/queue.c **** 				{
1338:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1339:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1340:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1341:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1342:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1343:FreeRTOS/Source/queue.c **** 				}
1344:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1345:FreeRTOS/Source/queue.c **** 				{
1346:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1347:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1348:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1349:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1350:FreeRTOS/Source/queue.c **** 				}
1351:FreeRTOS/Source/queue.c **** 				else
1352:FreeRTOS/Source/queue.c **** 				{
1353:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1354:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1355:FreeRTOS/Source/queue.c **** 				}
1356:FreeRTOS/Source/queue.c **** 			}
1357:FreeRTOS/Source/queue.c **** 		}
1358:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1359:FreeRTOS/Source/queue.c **** 
1360:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1361:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1362:FreeRTOS/Source/queue.c **** 
1363:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1364:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1365:FreeRTOS/Source/queue.c **** 
1366:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1367:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1368:FreeRTOS/Source/queue.c **** 		{
1369:FreeRTOS/Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1370:FreeRTOS/Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1371:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1372:FreeRTOS/Source/queue.c **** 			{
1373:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1374:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1375:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1376:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1377:FreeRTOS/Source/queue.c **** 				{
1378:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1379:FreeRTOS/Source/queue.c **** 				}
1380:FreeRTOS/Source/queue.c **** 				else
1381:FreeRTOS/Source/queue.c **** 				{
1382:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1383:FreeRTOS/Source/queue.c **** 				}
1384:FreeRTOS/Source/queue.c **** 			}
1385:FreeRTOS/Source/queue.c **** 			else
1386:FreeRTOS/Source/queue.c **** 			{
1387:FreeRTOS/Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1388:FreeRTOS/Source/queue.c **** 				data. */
1389:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1390:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1391:FreeRTOS/Source/queue.c **** 			}
1392:FreeRTOS/Source/queue.c **** 		}
1393:FreeRTOS/Source/queue.c **** 		else
1394:FreeRTOS/Source/queue.c **** 		{
1395:FreeRTOS/Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1396:FreeRTOS/Source/queue.c **** 			back and attempt to read the data. */
1397:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1398:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1399:FreeRTOS/Source/queue.c **** 
1400:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1401:FreeRTOS/Source/queue.c **** 			{
1402:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1403:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1404:FreeRTOS/Source/queue.c **** 			}
1405:FreeRTOS/Source/queue.c **** 			else
1406:FreeRTOS/Source/queue.c **** 			{
1407:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1408:FreeRTOS/Source/queue.c **** 			}
1409:FreeRTOS/Source/queue.c **** 		}
1410:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1411:FreeRTOS/Source/queue.c **** }
1412:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1413:FreeRTOS/Source/queue.c **** 
1414:FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1415:FreeRTOS/Source/queue.c **** {
1416:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1417:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1418:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1419:FreeRTOS/Source/queue.c **** 
1420:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1421:FreeRTOS/Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1422:FreeRTOS/Source/queue.c **** #endif
1423:FreeRTOS/Source/queue.c **** 
1424:FreeRTOS/Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1425:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1426:FreeRTOS/Source/queue.c **** 
1427:FreeRTOS/Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1428:FreeRTOS/Source/queue.c **** 	0. */
1429:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1430:FreeRTOS/Source/queue.c **** 
1431:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1432:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1433:FreeRTOS/Source/queue.c **** 	{
1434:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1435:FreeRTOS/Source/queue.c **** 	}
1436:FreeRTOS/Source/queue.c **** 	#endif
1437:FreeRTOS/Source/queue.c **** 
1438:FreeRTOS/Source/queue.c **** 
1439:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1440:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1441:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1442:FreeRTOS/Source/queue.c **** 	for( ;; )
1443:FreeRTOS/Source/queue.c **** 	{
1444:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1445:FreeRTOS/Source/queue.c **** 		{
1446:FreeRTOS/Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1447:FreeRTOS/Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1448:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1449:FreeRTOS/Source/queue.c **** 
1450:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1451:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1452:FreeRTOS/Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1453:FreeRTOS/Source/queue.c **** 			{
1454:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1455:FreeRTOS/Source/queue.c **** 
1456:FreeRTOS/Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1457:FreeRTOS/Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1458:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1459:FreeRTOS/Source/queue.c **** 
1460:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1461:FreeRTOS/Source/queue.c **** 				{
1462:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1463:FreeRTOS/Source/queue.c **** 					{
1464:FreeRTOS/Source/queue.c **** 						/* Record the information required to implement
1465:FreeRTOS/Source/queue.c **** 						priority inheritance should it become necessary. */
1466:FreeRTOS/Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1467:FreeRTOS/Source/queue.c **** 					}
1468:FreeRTOS/Source/queue.c **** 					else
1469:FreeRTOS/Source/queue.c **** 					{
1470:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1471:FreeRTOS/Source/queue.c **** 					}
1472:FreeRTOS/Source/queue.c **** 				}
1473:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1474:FreeRTOS/Source/queue.c **** 
1475:FreeRTOS/Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1476:FreeRTOS/Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1477:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1478:FreeRTOS/Source/queue.c **** 				{
1479:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1480:FreeRTOS/Source/queue.c **** 					{
1481:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1482:FreeRTOS/Source/queue.c **** 					}
1483:FreeRTOS/Source/queue.c **** 					else
1484:FreeRTOS/Source/queue.c **** 					{
1485:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1486:FreeRTOS/Source/queue.c **** 					}
1487:FreeRTOS/Source/queue.c **** 				}
1488:FreeRTOS/Source/queue.c **** 				else
1489:FreeRTOS/Source/queue.c **** 				{
1490:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1491:FreeRTOS/Source/queue.c **** 				}
1492:FreeRTOS/Source/queue.c **** 
1493:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1494:FreeRTOS/Source/queue.c **** 				return pdPASS;
1495:FreeRTOS/Source/queue.c **** 			}
1496:FreeRTOS/Source/queue.c **** 			else
1497:FreeRTOS/Source/queue.c **** 			{
1498:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1499:FreeRTOS/Source/queue.c **** 				{
1500:FreeRTOS/Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1501:FreeRTOS/Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1502:FreeRTOS/Source/queue.c **** 					if it were 0 the function would have exited. */
1503:FreeRTOS/Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1504:FreeRTOS/Source/queue.c **** 					{
1505:FreeRTOS/Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1506:FreeRTOS/Source/queue.c **** 					}
1507:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1508:FreeRTOS/Source/queue.c **** 
1509:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1510:FreeRTOS/Source/queue.c **** 					(or the block time has expired) so exit now. */
1511:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1512:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1513:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1514:FreeRTOS/Source/queue.c **** 				}
1515:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1516:FreeRTOS/Source/queue.c **** 				{
1517:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1518:FreeRTOS/Source/queue.c **** 					so configure the timeout structure ready to block. */
1519:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1520:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1521:FreeRTOS/Source/queue.c **** 				}
1522:FreeRTOS/Source/queue.c **** 				else
1523:FreeRTOS/Source/queue.c **** 				{
1524:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1525:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1526:FreeRTOS/Source/queue.c **** 				}
1527:FreeRTOS/Source/queue.c **** 			}
1528:FreeRTOS/Source/queue.c **** 		}
1529:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1530:FreeRTOS/Source/queue.c **** 
1531:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1532:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1533:FreeRTOS/Source/queue.c **** 
1534:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1535:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1536:FreeRTOS/Source/queue.c **** 
1537:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1538:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1539:FreeRTOS/Source/queue.c **** 		{
1540:FreeRTOS/Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1541:FreeRTOS/Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1542:FreeRTOS/Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1543:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1544:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1545:FreeRTOS/Source/queue.c **** 			{
1546:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1547:FreeRTOS/Source/queue.c **** 
1548:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1549:FreeRTOS/Source/queue.c **** 				{
1550:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1551:FreeRTOS/Source/queue.c **** 					{
1552:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1553:FreeRTOS/Source/queue.c **** 						{
1554:FreeRTOS/Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1555:FreeRTOS/Source/queue.c **** 						}
1556:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1557:FreeRTOS/Source/queue.c **** 					}
1558:FreeRTOS/Source/queue.c **** 					else
1559:FreeRTOS/Source/queue.c **** 					{
1560:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1561:FreeRTOS/Source/queue.c **** 					}
1562:FreeRTOS/Source/queue.c **** 				}
1563:FreeRTOS/Source/queue.c **** 				#endif
1564:FreeRTOS/Source/queue.c **** 
1565:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1566:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1567:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1568:FreeRTOS/Source/queue.c **** 				{
1569:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1570:FreeRTOS/Source/queue.c **** 				}
1571:FreeRTOS/Source/queue.c **** 				else
1572:FreeRTOS/Source/queue.c **** 				{
1573:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1574:FreeRTOS/Source/queue.c **** 				}
1575:FreeRTOS/Source/queue.c **** 			}
1576:FreeRTOS/Source/queue.c **** 			else
1577:FreeRTOS/Source/queue.c **** 			{
1578:FreeRTOS/Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1579:FreeRTOS/Source/queue.c **** 				attempt to take the semaphore again. */
1580:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1581:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1582:FreeRTOS/Source/queue.c **** 			}
1583:FreeRTOS/Source/queue.c **** 		}
1584:FreeRTOS/Source/queue.c **** 		else
1585:FreeRTOS/Source/queue.c **** 		{
1586:FreeRTOS/Source/queue.c **** 			/* Timed out. */
1587:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1588:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1589:FreeRTOS/Source/queue.c **** 
1590:FreeRTOS/Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1591:FreeRTOS/Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1592:FreeRTOS/Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1593:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1594:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1595:FreeRTOS/Source/queue.c **** 			{
1596:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1597:FreeRTOS/Source/queue.c **** 				{
1598:FreeRTOS/Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1599:FreeRTOS/Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1600:FreeRTOS/Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1601:FreeRTOS/Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1602:FreeRTOS/Source/queue.c **** 					{
1603:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1604:FreeRTOS/Source/queue.c **** 						{
1605:FreeRTOS/Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1606:FreeRTOS/Source/queue.c **** 
1607:FreeRTOS/Source/queue.c **** 							/* This task blocking on the mutex caused another
1608:FreeRTOS/Source/queue.c **** 							task to inherit this task's priority.  Now this task
1609:FreeRTOS/Source/queue.c **** 							has timed out the priority should be disinherited
1610:FreeRTOS/Source/queue.c **** 							again, but only as low as the next highest priority
1611:FreeRTOS/Source/queue.c **** 							task that is waiting for the same mutex. */
1612:FreeRTOS/Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1613:FreeRTOS/Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
1614:FreeRTOS/Source/queue.c **** 						}
1615:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1616:FreeRTOS/Source/queue.c **** 					}
1617:FreeRTOS/Source/queue.c **** 				}
1618:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1619:FreeRTOS/Source/queue.c **** 
1620:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1621:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1622:FreeRTOS/Source/queue.c **** 			}
1623:FreeRTOS/Source/queue.c **** 			else
1624:FreeRTOS/Source/queue.c **** 			{
1625:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1626:FreeRTOS/Source/queue.c **** 			}
1627:FreeRTOS/Source/queue.c **** 		}
1628:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1629:FreeRTOS/Source/queue.c **** }
1630:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1631:FreeRTOS/Source/queue.c **** 
1632:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1633:FreeRTOS/Source/queue.c **** {
1634:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1635:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1636:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1637:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1638:FreeRTOS/Source/queue.c **** 
1639:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1640:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1641:FreeRTOS/Source/queue.c **** 
1642:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1643:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1644:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1645:FreeRTOS/Source/queue.c **** 
1646:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1647:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1648:FreeRTOS/Source/queue.c **** 	{
1649:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1650:FreeRTOS/Source/queue.c **** 	}
1651:FreeRTOS/Source/queue.c **** 	#endif
1652:FreeRTOS/Source/queue.c **** 
1653:FreeRTOS/Source/queue.c **** 
1654:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1655:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1656:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1657:FreeRTOS/Source/queue.c **** 	for( ;; )
1658:FreeRTOS/Source/queue.c **** 	{
1659:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1660:FreeRTOS/Source/queue.c **** 		{
1661:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1662:FreeRTOS/Source/queue.c **** 
1663:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1664:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1665:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1666:FreeRTOS/Source/queue.c **** 			{
1667:FreeRTOS/Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1668:FreeRTOS/Source/queue.c **** 				is read from the queue as this function is only peeking the
1669:FreeRTOS/Source/queue.c **** 				data, not removing it. */
1670:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1671:FreeRTOS/Source/queue.c **** 
1672:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1673:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1674:FreeRTOS/Source/queue.c **** 
1675:FreeRTOS/Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1676:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1677:FreeRTOS/Source/queue.c **** 
1678:FreeRTOS/Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1679:FreeRTOS/Source/queue.c **** 				any other tasks waiting for the data. */
1680:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1681:FreeRTOS/Source/queue.c **** 				{
1682:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1683:FreeRTOS/Source/queue.c **** 					{
1684:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1685:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1686:FreeRTOS/Source/queue.c **** 					}
1687:FreeRTOS/Source/queue.c **** 					else
1688:FreeRTOS/Source/queue.c **** 					{
1689:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1690:FreeRTOS/Source/queue.c **** 					}
1691:FreeRTOS/Source/queue.c **** 				}
1692:FreeRTOS/Source/queue.c **** 				else
1693:FreeRTOS/Source/queue.c **** 				{
1694:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1695:FreeRTOS/Source/queue.c **** 				}
1696:FreeRTOS/Source/queue.c **** 
1697:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1698:FreeRTOS/Source/queue.c **** 				return pdPASS;
1699:FreeRTOS/Source/queue.c **** 			}
1700:FreeRTOS/Source/queue.c **** 			else
1701:FreeRTOS/Source/queue.c **** 			{
1702:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1703:FreeRTOS/Source/queue.c **** 				{
1704:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1705:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1706:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1707:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1708:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1709:FreeRTOS/Source/queue.c **** 				}
1710:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1711:FreeRTOS/Source/queue.c **** 				{
1712:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1713:FreeRTOS/Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1714:FreeRTOS/Source/queue.c **** 					state. */
1715:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1716:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1717:FreeRTOS/Source/queue.c **** 				}
1718:FreeRTOS/Source/queue.c **** 				else
1719:FreeRTOS/Source/queue.c **** 				{
1720:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1721:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1722:FreeRTOS/Source/queue.c **** 				}
1723:FreeRTOS/Source/queue.c **** 			}
1724:FreeRTOS/Source/queue.c **** 		}
1725:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1726:FreeRTOS/Source/queue.c **** 
1727:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1728:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1729:FreeRTOS/Source/queue.c **** 
1730:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1731:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1732:FreeRTOS/Source/queue.c **** 
1733:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1734:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1735:FreeRTOS/Source/queue.c **** 		{
1736:FreeRTOS/Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1737:FreeRTOS/Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1738:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1739:FreeRTOS/Source/queue.c **** 			{
1740:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1741:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1742:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1743:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1744:FreeRTOS/Source/queue.c **** 				{
1745:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1746:FreeRTOS/Source/queue.c **** 				}
1747:FreeRTOS/Source/queue.c **** 				else
1748:FreeRTOS/Source/queue.c **** 				{
1749:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1750:FreeRTOS/Source/queue.c **** 				}
1751:FreeRTOS/Source/queue.c **** 			}
1752:FreeRTOS/Source/queue.c **** 			else
1753:FreeRTOS/Source/queue.c **** 			{
1754:FreeRTOS/Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1755:FreeRTOS/Source/queue.c **** 				state, instead return to try and obtain the data. */
1756:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1757:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1758:FreeRTOS/Source/queue.c **** 			}
1759:FreeRTOS/Source/queue.c **** 		}
1760:FreeRTOS/Source/queue.c **** 		else
1761:FreeRTOS/Source/queue.c **** 		{
1762:FreeRTOS/Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1763:FreeRTOS/Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1764:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1765:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1766:FreeRTOS/Source/queue.c **** 
1767:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1768:FreeRTOS/Source/queue.c **** 			{
1769:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1770:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1771:FreeRTOS/Source/queue.c **** 			}
1772:FreeRTOS/Source/queue.c **** 			else
1773:FreeRTOS/Source/queue.c **** 			{
1774:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1775:FreeRTOS/Source/queue.c **** 			}
1776:FreeRTOS/Source/queue.c **** 		}
1777:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1778:FreeRTOS/Source/queue.c **** }
1779:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1780:FreeRTOS/Source/queue.c **** 
1781:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1782:FreeRTOS/Source/queue.c **** {
1783:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1784:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1785:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1786:FreeRTOS/Source/queue.c **** 
1787:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1788:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1789:FreeRTOS/Source/queue.c **** 
1790:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1791:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1792:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1793:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1794:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1795:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1796:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1797:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1798:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1799:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1800:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1801:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1802:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1803:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1804:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1805:FreeRTOS/Source/queue.c **** 
1806:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1807:FreeRTOS/Source/queue.c **** 	{
1808:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1809:FreeRTOS/Source/queue.c **** 
1810:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1811:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1812:FreeRTOS/Source/queue.c **** 		{
1813:FreeRTOS/Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
1814:FreeRTOS/Source/queue.c **** 
1815:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1816:FreeRTOS/Source/queue.c **** 
1817:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1818:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1819:FreeRTOS/Source/queue.c **** 
1820:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1821:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1822:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1823:FreeRTOS/Source/queue.c **** 			locked. */
1824:FreeRTOS/Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
1825:FreeRTOS/Source/queue.c **** 			{
1826:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1827:FreeRTOS/Source/queue.c **** 				{
1828:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1829:FreeRTOS/Source/queue.c **** 					{
1830:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1831:FreeRTOS/Source/queue.c **** 						force a context switch. */
1832:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1833:FreeRTOS/Source/queue.c **** 						{
1834:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1835:FreeRTOS/Source/queue.c **** 						}
1836:FreeRTOS/Source/queue.c **** 						else
1837:FreeRTOS/Source/queue.c **** 						{
1838:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1839:FreeRTOS/Source/queue.c **** 						}
1840:FreeRTOS/Source/queue.c **** 					}
1841:FreeRTOS/Source/queue.c **** 					else
1842:FreeRTOS/Source/queue.c **** 					{
1843:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1844:FreeRTOS/Source/queue.c **** 					}
1845:FreeRTOS/Source/queue.c **** 				}
1846:FreeRTOS/Source/queue.c **** 				else
1847:FreeRTOS/Source/queue.c **** 				{
1848:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1849:FreeRTOS/Source/queue.c **** 				}
1850:FreeRTOS/Source/queue.c **** 			}
1851:FreeRTOS/Source/queue.c **** 			else
1852:FreeRTOS/Source/queue.c **** 			{
1853:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1854:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1855:FreeRTOS/Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1856:FreeRTOS/Source/queue.c **** 			}
1857:FreeRTOS/Source/queue.c **** 
1858:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1859:FreeRTOS/Source/queue.c **** 		}
1860:FreeRTOS/Source/queue.c **** 		else
1861:FreeRTOS/Source/queue.c **** 		{
1862:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1863:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1864:FreeRTOS/Source/queue.c **** 		}
1865:FreeRTOS/Source/queue.c **** 	}
1866:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1867:FreeRTOS/Source/queue.c **** 
1868:FreeRTOS/Source/queue.c **** 	return xReturn;
1869:FreeRTOS/Source/queue.c **** }
1870:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1871:FreeRTOS/Source/queue.c **** 
1872:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1873:FreeRTOS/Source/queue.c **** {
1874:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1875:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1876:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1877:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1878:FreeRTOS/Source/queue.c **** 
1879:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1880:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1881:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1882:FreeRTOS/Source/queue.c **** 
1883:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1884:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1885:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1886:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1887:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1888:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1889:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1890:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1891:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1892:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1893:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1894:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1895:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1896:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1897:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1898:FreeRTOS/Source/queue.c **** 
1899:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1900:FreeRTOS/Source/queue.c **** 	{
1901:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1902:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1903:FreeRTOS/Source/queue.c **** 		{
1904:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1905:FreeRTOS/Source/queue.c **** 
1906:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1907:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1908:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1909:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1910:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1911:FreeRTOS/Source/queue.c **** 
1912:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1913:FreeRTOS/Source/queue.c **** 		}
1914:FreeRTOS/Source/queue.c **** 		else
1915:FreeRTOS/Source/queue.c **** 		{
1916:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1917:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1918:FreeRTOS/Source/queue.c **** 		}
1919:FreeRTOS/Source/queue.c **** 	}
1920:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1921:FreeRTOS/Source/queue.c **** 
1922:FreeRTOS/Source/queue.c **** 	return xReturn;
1923:FreeRTOS/Source/queue.c **** }
1924:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1925:FreeRTOS/Source/queue.c **** 
1926:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1927:FreeRTOS/Source/queue.c **** {
1928:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1929:FreeRTOS/Source/queue.c **** 
1930:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1931:FreeRTOS/Source/queue.c **** 
1932:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1933:FreeRTOS/Source/queue.c **** 	{
1934:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1935:FreeRTOS/Source/queue.c **** 	}
1936:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1937:FreeRTOS/Source/queue.c **** 
1938:FreeRTOS/Source/queue.c **** 	return uxReturn;
1939:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1940:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1941:FreeRTOS/Source/queue.c **** 
1942:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1943:FreeRTOS/Source/queue.c **** {
1944:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1945:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1946:FreeRTOS/Source/queue.c **** 
1947:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1948:FreeRTOS/Source/queue.c **** 
1949:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1950:FreeRTOS/Source/queue.c **** 	{
1951:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1952:FreeRTOS/Source/queue.c **** 	}
1953:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1954:FreeRTOS/Source/queue.c **** 
1955:FreeRTOS/Source/queue.c **** 	return uxReturn;
1956:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1957:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1958:FreeRTOS/Source/queue.c **** 
1959:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1960:FreeRTOS/Source/queue.c **** {
1961:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1962:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1963:FreeRTOS/Source/queue.c **** 
1964:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1965:FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1966:FreeRTOS/Source/queue.c **** 
1967:FreeRTOS/Source/queue.c **** 	return uxReturn;
1968:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1969:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1970:FreeRTOS/Source/queue.c **** 
1971:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1972:FreeRTOS/Source/queue.c **** {
1973:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1974:FreeRTOS/Source/queue.c **** 
1975:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1976:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1977:FreeRTOS/Source/queue.c **** 
1978:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1979:FreeRTOS/Source/queue.c **** 	{
1980:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1981:FreeRTOS/Source/queue.c **** 	}
1982:FreeRTOS/Source/queue.c **** 	#endif
1983:FreeRTOS/Source/queue.c **** 
1984:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1985:FreeRTOS/Source/queue.c **** 	{
1986:FreeRTOS/Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1987:FreeRTOS/Source/queue.c **** 		again. */
1988:FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue );
1989:FreeRTOS/Source/queue.c **** 	}
1990:FreeRTOS/Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1991:FreeRTOS/Source/queue.c **** 	{
1992:FreeRTOS/Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1993:FreeRTOS/Source/queue.c **** 		check before attempting to free the memory. */
1994:FreeRTOS/Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1995:FreeRTOS/Source/queue.c **** 		{
1996:FreeRTOS/Source/queue.c **** 			vPortFree( pxQueue );
1997:FreeRTOS/Source/queue.c **** 		}
1998:FreeRTOS/Source/queue.c **** 		else
1999:FreeRTOS/Source/queue.c **** 		{
2000:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2001:FreeRTOS/Source/queue.c **** 		}
2002:FreeRTOS/Source/queue.c **** 	}
2003:FreeRTOS/Source/queue.c **** 	#else
2004:FreeRTOS/Source/queue.c **** 	{
2005:FreeRTOS/Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2006:FreeRTOS/Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2007:FreeRTOS/Source/queue.c **** 		( void ) pxQueue;
2008:FreeRTOS/Source/queue.c **** 	}
2009:FreeRTOS/Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2010:FreeRTOS/Source/queue.c **** }
2011:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2012:FreeRTOS/Source/queue.c **** 
2013:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2014:FreeRTOS/Source/queue.c **** 
2015:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2016:FreeRTOS/Source/queue.c **** 	{
2017:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2018:FreeRTOS/Source/queue.c **** 	}
2019:FreeRTOS/Source/queue.c **** 
2020:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2021:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2022:FreeRTOS/Source/queue.c **** 
2023:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2024:FreeRTOS/Source/queue.c **** 
2025:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2026:FreeRTOS/Source/queue.c **** 	{
2027:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2028:FreeRTOS/Source/queue.c **** 	}
2029:FreeRTOS/Source/queue.c **** 
2030:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2031:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2032:FreeRTOS/Source/queue.c **** 
2033:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2034:FreeRTOS/Source/queue.c **** 
2035:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2036:FreeRTOS/Source/queue.c **** 	{
2037:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2038:FreeRTOS/Source/queue.c **** 	}
2039:FreeRTOS/Source/queue.c **** 
2040:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2041:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2042:FreeRTOS/Source/queue.c **** 
2043:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2044:FreeRTOS/Source/queue.c **** 
2045:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2046:FreeRTOS/Source/queue.c **** 	{
2047:FreeRTOS/Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2048:FreeRTOS/Source/queue.c **** 
2049:FreeRTOS/Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2050:FreeRTOS/Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2051:FreeRTOS/Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2052:FreeRTOS/Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2053:FreeRTOS/Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2054:FreeRTOS/Source/queue.c **** 		mutex. */
2055:FreeRTOS/Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2056:FreeRTOS/Source/queue.c **** 		{
2057:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
2058:FreeRTOS/Source/queue.c **** 		}
2059:FreeRTOS/Source/queue.c **** 		else
2060:FreeRTOS/Source/queue.c **** 		{
2061:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2062:FreeRTOS/Source/queue.c **** 		}
2063:FreeRTOS/Source/queue.c **** 
2064:FreeRTOS/Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2065:FreeRTOS/Source/queue.c **** 	}
2066:FreeRTOS/Source/queue.c **** 
2067:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2068:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2069:FreeRTOS/Source/queue.c **** 
2070:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2071:FreeRTOS/Source/queue.c **** {
2072:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
2073:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
2074:FreeRTOS/Source/queue.c **** 
2075:FreeRTOS/Source/queue.c **** 	/* This function is called from a critical section. */
2076:FreeRTOS/Source/queue.c **** 
2077:FreeRTOS/Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2078:FreeRTOS/Source/queue.c **** 
2079:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2080:FreeRTOS/Source/queue.c **** 	{
2081:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2082:FreeRTOS/Source/queue.c **** 		{
2083:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2084:FreeRTOS/Source/queue.c **** 			{
2085:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
2086:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2087:FreeRTOS/Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2088:FreeRTOS/Source/queue.c **** 			}
2089:FreeRTOS/Source/queue.c **** 			else
2090:FreeRTOS/Source/queue.c **** 			{
2091:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2092:FreeRTOS/Source/queue.c **** 			}
2093:FreeRTOS/Source/queue.c **** 		}
2094:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2095:FreeRTOS/Source/queue.c **** 	}
2096:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
2097:FreeRTOS/Source/queue.c **** 	{
2098:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
2099:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
2100:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
2101:FreeRTOS/Source/queue.c **** 		{
2102:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
2103:FreeRTOS/Source/queue.c **** 		}
2104:FreeRTOS/Source/queue.c **** 		else
2105:FreeRTOS/Source/queue.c **** 		{
2106:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2107:FreeRTOS/Source/queue.c **** 		}
2108:FreeRTOS/Source/queue.c **** 	}
2109:FreeRTOS/Source/queue.c **** 	else
2110:FreeRTOS/Source/queue.c **** 	{
2111:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
2112:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2113:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
2114:FreeRTOS/Source/queue.c **** 		{
2115:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2116:FreeRTOS/Source/queue.c **** 		}
2117:FreeRTOS/Source/queue.c **** 		else
2118:FreeRTOS/Source/queue.c **** 		{
2119:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2120:FreeRTOS/Source/queue.c **** 		}
2121:FreeRTOS/Source/queue.c **** 
2122:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
2123:FreeRTOS/Source/queue.c **** 		{
2124:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2125:FreeRTOS/Source/queue.c **** 			{
2126:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2127:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
2128:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
2129:FreeRTOS/Source/queue.c **** 				correct. */
2130:FreeRTOS/Source/queue.c **** 				--uxMessagesWaiting;
2131:FreeRTOS/Source/queue.c **** 			}
2132:FreeRTOS/Source/queue.c **** 			else
2133:FreeRTOS/Source/queue.c **** 			{
2134:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2135:FreeRTOS/Source/queue.c **** 			}
2136:FreeRTOS/Source/queue.c **** 		}
2137:FreeRTOS/Source/queue.c **** 		else
2138:FreeRTOS/Source/queue.c **** 		{
2139:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2140:FreeRTOS/Source/queue.c **** 		}
2141:FreeRTOS/Source/queue.c **** 	}
2142:FreeRTOS/Source/queue.c **** 
2143:FreeRTOS/Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2144:FreeRTOS/Source/queue.c **** 
2145:FreeRTOS/Source/queue.c **** 	return xReturn;
2146:FreeRTOS/Source/queue.c **** }
2147:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2148:FreeRTOS/Source/queue.c **** 
2149:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2150:FreeRTOS/Source/queue.c **** {
2151:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2152:FreeRTOS/Source/queue.c **** 	{
2153:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
2154:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
2155:FreeRTOS/Source/queue.c **** 		{
2156:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2157:FreeRTOS/Source/queue.c **** 		}
2158:FreeRTOS/Source/queue.c **** 		else
2159:FreeRTOS/Source/queue.c **** 		{
2160:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2161:FreeRTOS/Source/queue.c **** 		}
2162:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
2163:FreeRTOS/Source/queue.c **** 	}
2164:FreeRTOS/Source/queue.c **** }
2165:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2166:FreeRTOS/Source/queue.c **** 
2167:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2168:FreeRTOS/Source/queue.c **** {
2169:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2170:FreeRTOS/Source/queue.c **** 
2171:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2172:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2173:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2174:FreeRTOS/Source/queue.c **** 	updated. */
2175:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2176:FreeRTOS/Source/queue.c **** 	{
2177:FreeRTOS/Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
2178:FreeRTOS/Source/queue.c **** 
2179:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2180:FreeRTOS/Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
2181:FreeRTOS/Source/queue.c **** 		{
2182:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2183:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
2184:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2185:FreeRTOS/Source/queue.c **** 			{
2186:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2187:FreeRTOS/Source/queue.c **** 				{
2188:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
2189:FreeRTOS/Source/queue.c **** 					{
2190:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2191:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2192:FreeRTOS/Source/queue.c **** 						A context switch is required. */
2193:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2194:FreeRTOS/Source/queue.c **** 					}
2195:FreeRTOS/Source/queue.c **** 					else
2196:FreeRTOS/Source/queue.c **** 					{
2197:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2198:FreeRTOS/Source/queue.c **** 					}
2199:FreeRTOS/Source/queue.c **** 				}
2200:FreeRTOS/Source/queue.c **** 				else
2201:FreeRTOS/Source/queue.c **** 				{
2202:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get
2203:FreeRTOS/Source/queue.c **** 					added to the pending ready list as the scheduler is still
2204:FreeRTOS/Source/queue.c **** 					suspended. */
2205:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2206:FreeRTOS/Source/queue.c **** 					{
2207:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2208:FreeRTOS/Source/queue.c **** 						{
2209:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2210:FreeRTOS/Source/queue.c **** 							context	switch is required. */
2211:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
2212:FreeRTOS/Source/queue.c **** 						}
2213:FreeRTOS/Source/queue.c **** 						else
2214:FreeRTOS/Source/queue.c **** 						{
2215:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2216:FreeRTOS/Source/queue.c **** 						}
2217:FreeRTOS/Source/queue.c **** 					}
2218:FreeRTOS/Source/queue.c **** 					else
2219:FreeRTOS/Source/queue.c **** 					{
2220:FreeRTOS/Source/queue.c **** 						break;
2221:FreeRTOS/Source/queue.c **** 					}
2222:FreeRTOS/Source/queue.c **** 				}
2223:FreeRTOS/Source/queue.c **** 			}
2224:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2225:FreeRTOS/Source/queue.c **** 			{
2226:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2227:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2228:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2229:FreeRTOS/Source/queue.c **** 				{
2230:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2231:FreeRTOS/Source/queue.c **** 					{
2232:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that
2233:FreeRTOS/Source/queue.c **** 						a context switch is required. */
2234:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2235:FreeRTOS/Source/queue.c **** 					}
2236:FreeRTOS/Source/queue.c **** 					else
2237:FreeRTOS/Source/queue.c **** 					{
2238:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2239:FreeRTOS/Source/queue.c **** 					}
2240:FreeRTOS/Source/queue.c **** 				}
2241:FreeRTOS/Source/queue.c **** 				else
2242:FreeRTOS/Source/queue.c **** 				{
2243:FreeRTOS/Source/queue.c **** 					break;
2244:FreeRTOS/Source/queue.c **** 				}
2245:FreeRTOS/Source/queue.c **** 			}
2246:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2247:FreeRTOS/Source/queue.c **** 
2248:FreeRTOS/Source/queue.c **** 			--cTxLock;
2249:FreeRTOS/Source/queue.c **** 		}
2250:FreeRTOS/Source/queue.c **** 
2251:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
2252:FreeRTOS/Source/queue.c **** 	}
2253:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2254:FreeRTOS/Source/queue.c **** 
2255:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
2256:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2257:FreeRTOS/Source/queue.c **** 	{
2258:FreeRTOS/Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
2259:FreeRTOS/Source/queue.c **** 
2260:FreeRTOS/Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
2261:FreeRTOS/Source/queue.c **** 		{
2262:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2263:FreeRTOS/Source/queue.c **** 			{
2264:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2265:FreeRTOS/Source/queue.c **** 				{
2266:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
2267:FreeRTOS/Source/queue.c **** 				}
2268:FreeRTOS/Source/queue.c **** 				else
2269:FreeRTOS/Source/queue.c **** 				{
2270:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2271:FreeRTOS/Source/queue.c **** 				}
2272:FreeRTOS/Source/queue.c **** 
2273:FreeRTOS/Source/queue.c **** 				--cRxLock;
2274:FreeRTOS/Source/queue.c **** 			}
2275:FreeRTOS/Source/queue.c **** 			else
2276:FreeRTOS/Source/queue.c **** 			{
2277:FreeRTOS/Source/queue.c **** 				break;
2278:FreeRTOS/Source/queue.c **** 			}
2279:FreeRTOS/Source/queue.c **** 		}
2280:FreeRTOS/Source/queue.c **** 
2281:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
2282:FreeRTOS/Source/queue.c **** 	}
2283:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2284:FreeRTOS/Source/queue.c **** }
2285:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2286:FreeRTOS/Source/queue.c **** 
2287:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2288:FreeRTOS/Source/queue.c **** {
 201               	.LM0:
 202               	.LFBB1:
 203               	/* prologue: function */
 204               	/* frame size = 0 */
 205               	/* stack size = 0 */
 206               	.L__stack_usage = 0
2289:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2290:FreeRTOS/Source/queue.c **** 
2291:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 208               	.LM1:
 209               	/* #APP */
 210               	 ;  2291 "FreeRTOS/Source/queue.c" 1
 211 0000 0FB6      		in		__tmp_reg__, __SREG__
 212               	 ;  0 "" 2
 213               	 ;  2291 "FreeRTOS/Source/queue.c" 1
 214 0002 F894      		cli
 215               	 ;  0 "" 2
 216               	 ;  2291 "FreeRTOS/Source/queue.c" 1
 217 0004 0F92      		push	__tmp_reg__
 218               	 ;  0 "" 2
2292:FreeRTOS/Source/queue.c **** 	{
2293:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 220               	.LM2:
 221               	/* #NOAPP */
 222 0006 FC01      		movw r30,r24
 223 0008 928D      		ldd r25,Z+26
2294:FreeRTOS/Source/queue.c **** 		{
2295:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2296:FreeRTOS/Source/queue.c **** 		}
2297:FreeRTOS/Source/queue.c **** 		else
2298:FreeRTOS/Source/queue.c **** 		{
2299:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2300:FreeRTOS/Source/queue.c **** 		}
2301:FreeRTOS/Source/queue.c **** 	}
2302:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 225               	.LM3:
 226               	/* #APP */
 227               	 ;  2302 "FreeRTOS/Source/queue.c" 1
 228 000a 0F90      		pop		__tmp_reg__
 229               	 ;  0 "" 2
 230               	 ;  2302 "FreeRTOS/Source/queue.c" 1
 231 000c 0FBE      		out		__SREG__, __tmp_reg__
 232               	 ;  0 "" 2
2303:FreeRTOS/Source/queue.c **** 
2304:FreeRTOS/Source/queue.c **** 	return xReturn;
 234               	.LM4:
 235               	/* #NOAPP */
 236 000e 81E0      		ldi r24,lo8(1)
 237 0010 9111      		cpse r25,__zero_reg__
 238 0012 80E0      		ldi r24,0
 239               	.L2:
2305:FreeRTOS/Source/queue.c **** }
 241               	.LM5:
 242 0014 0895      		ret
 244               	.Lscope1:
 246               		.stabd	78,0,0
 252               	prvCopyDataToQueue:
 253               		.stabd	46,0,0
2071:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
 255               	.LM6:
 256               	.LFBB2:
 257 0016 0F93      		push r16
 258 0018 1F93      		push r17
 259 001a CF93      		push r28
 260 001c DF93      		push r29
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 4 */
 264               	.L__stack_usage = 4
 265 001e EC01      		movw r28,r24
 266 0020 042F      		mov r16,r20
2077:FreeRTOS/Source/queue.c **** 
 268               	.LM7:
 269 0022 1A8D      		ldd r17,Y+26
2079:FreeRTOS/Source/queue.c **** 	{
 271               	.LM8:
 272 0024 4C8D      		ldd r20,Y+28
 273 0026 4111      		cpse r20,__zero_reg__
 274 0028 00C0      		rjmp .L8
2083:FreeRTOS/Source/queue.c **** 			{
 276               	.LM9:
 277 002a 8881      		ld r24,Y
 278 002c 9981      		ldd r25,Y+1
 279 002e 892B      		or r24,r25
 280 0030 01F4      		brne .L15
2086:FreeRTOS/Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 282               	.LM10:
 283 0032 8C81      		ldd r24,Y+4
 284 0034 9D81      		ldd r25,Y+5
 285 0036 0E94 0000 		call xTaskPriorityDisinherit
2087:FreeRTOS/Source/queue.c **** 			}
 287               	.LM11:
 288 003a 1D82      		std Y+5,__zero_reg__
 289 003c 1C82      		std Y+4,__zero_reg__
 290 003e 00C0      		rjmp .L9
 291               	.L8:
 292 0040 50E0      		ldi r21,0
2096:FreeRTOS/Source/queue.c **** 	{
 294               	.LM12:
 295 0042 0111      		cpse r16,__zero_reg__
 296 0044 00C0      		rjmp .L10
2098:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 298               	.LM13:
 299 0046 8A81      		ldd r24,Y+2
 300 0048 9B81      		ldd r25,Y+3
 301 004a 0E94 0000 		call memcpy
2099:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 303               	.LM14:
 304 004e 2C8D      		ldd r18,Y+28
 305 0050 8A81      		ldd r24,Y+2
 306 0052 9B81      		ldd r25,Y+3
 307 0054 820F      		add r24,r18
 308 0056 911D      		adc r25,__zero_reg__
 309 0058 9B83      		std Y+3,r25
 310 005a 8A83      		std Y+2,r24
2100:FreeRTOS/Source/queue.c **** 		{
 312               	.LM15:
 313 005c 2C81      		ldd r18,Y+4
 314 005e 3D81      		ldd r19,Y+5
 315 0060 8217      		cp r24,r18
 316 0062 9307      		cpc r25,r19
 317 0064 00F0      		brlo .L15
2102:FreeRTOS/Source/queue.c **** 		}
 319               	.LM16:
 320 0066 8881      		ld r24,Y
 321 0068 9981      		ldd r25,Y+1
 322 006a 9B83      		std Y+3,r25
 323 006c 8A83      		std Y+2,r24
 324 006e 00C0      		rjmp .L15
 325               	.L10:
2111:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 327               	.LM17:
 328 0070 8E81      		ldd r24,Y+6
 329 0072 9F81      		ldd r25,Y+7
 330 0074 0E94 0000 		call memcpy
2112:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 332               	.LM18:
 333 0078 8C8D      		ldd r24,Y+28
 334 007a 90E0      		ldi r25,0
 335 007c 9195      		neg r25
 336 007e 8195      		neg r24
 337 0080 9109      		sbc r25,__zero_reg__
 338 0082 2E81      		ldd r18,Y+6
 339 0084 3F81      		ldd r19,Y+7
 340 0086 280F      		add r18,r24
 341 0088 391F      		adc r19,r25
 342 008a 3F83      		std Y+7,r19
 343 008c 2E83      		std Y+6,r18
2113:FreeRTOS/Source/queue.c **** 		{
 345               	.LM19:
 346 008e 4881      		ld r20,Y
 347 0090 5981      		ldd r21,Y+1
 348 0092 2417      		cp r18,r20
 349 0094 3507      		cpc r19,r21
 350 0096 00F4      		brsh .L11
2115:FreeRTOS/Source/queue.c **** 		}
 352               	.LM20:
 353 0098 2C81      		ldd r18,Y+4
 354 009a 3D81      		ldd r19,Y+5
 355 009c 820F      		add r24,r18
 356 009e 931F      		adc r25,r19
 357 00a0 9F83      		std Y+7,r25
 358 00a2 8E83      		std Y+6,r24
 359               	.L11:
2122:FreeRTOS/Source/queue.c **** 		{
 361               	.LM21:
 362 00a4 0230      		cpi r16,lo8(2)
 363 00a6 01F4      		brne .L15
2124:FreeRTOS/Source/queue.c **** 			{
 365               	.LM22:
 366 00a8 1111      		cpse r17,__zero_reg__
2130:FreeRTOS/Source/queue.c **** 			}
 368               	.LM23:
 369 00aa 1150      		subi r17,lo8(-(-1))
 370               	.L15:
2072:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
 372               	.LM24:
 373 00ac 80E0      		ldi r24,0
 374               	.L9:
2143:FreeRTOS/Source/queue.c **** 
 376               	.LM25:
 377 00ae 1F5F      		subi r17,lo8(-(1))
 378 00b0 1A8F      		std Y+26,r17
 379               	/* epilogue start */
2146:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 381               	.LM26:
 382 00b2 DF91      		pop r29
 383 00b4 CF91      		pop r28
 384 00b6 1F91      		pop r17
 385 00b8 0F91      		pop r16
 386 00ba 0895      		ret
 392               	.Lscope2:
 394               		.stabd	78,0,0
 399               	prvCopyDataFromQueue:
 400               		.stabd	46,0,0
2150:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 402               	.LM27:
 403               	.LFBB3:
 404               	/* prologue: function */
 405               	/* frame size = 0 */
 406               	/* stack size = 0 */
 407               	.L__stack_usage = 0
 408 00bc FC01      		movw r30,r24
 409 00be CB01      		movw r24,r22
2151:FreeRTOS/Source/queue.c **** 	{
 411               	.LM28:
 412 00c0 448D      		ldd r20,Z+28
 413 00c2 4423      		tst r20
 414 00c4 01F0      		breq .L16
2153:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 416               	.LM29:
 417 00c6 50E0      		ldi r21,0
 418 00c8 2681      		ldd r18,Z+6
 419 00ca 3781      		ldd r19,Z+7
 420 00cc 240F      		add r18,r20
 421 00ce 351F      		adc r19,r21
 422 00d0 3783      		std Z+7,r19
 423 00d2 2683      		std Z+6,r18
2154:FreeRTOS/Source/queue.c **** 		{
 425               	.LM30:
 426 00d4 6481      		ldd r22,Z+4
 427 00d6 7581      		ldd r23,Z+5
 428 00d8 2617      		cp r18,r22
 429 00da 3707      		cpc r19,r23
 430 00dc 00F0      		brlo .L18
2156:FreeRTOS/Source/queue.c **** 		}
 432               	.LM31:
 433 00de 2081      		ld r18,Z
 434 00e0 3181      		ldd r19,Z+1
 435 00e2 3783      		std Z+7,r19
 436 00e4 2683      		std Z+6,r18
 437               	.L18:
2162:FreeRTOS/Source/queue.c **** 	}
 439               	.LM32:
 440 00e6 6681      		ldd r22,Z+6
 441 00e8 7781      		ldd r23,Z+7
 442 00ea 0C94 0000 		jmp memcpy
 443               	.L16:
 444 00ee 0895      		ret
 446               	.Lscope3:
 448               		.stabd	78,0,0
 452               	prvUnlockQueue:
 453               		.stabd	46,0,0
2168:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 455               	.LM33:
 456               	.LFBB4:
 457 00f0 EF92      		push r14
 458 00f2 FF92      		push r15
 459 00f4 1F93      		push r17
 460 00f6 CF93      		push r28
 461 00f8 DF93      		push r29
 462               	/* prologue: function */
 463               	/* frame size = 0 */
 464               	/* stack size = 5 */
 465               	.L__stack_usage = 5
 466 00fa EC01      		movw r28,r24
2175:FreeRTOS/Source/queue.c **** 	{
 468               	.LM34:
 469               	/* #APP */
 470               	 ;  2175 "FreeRTOS/Source/queue.c" 1
 471 00fc 0FB6      		in		__tmp_reg__, __SREG__
 472               	 ;  0 "" 2
 473               	 ;  2175 "FreeRTOS/Source/queue.c" 1
 474 00fe F894      		cli
 475               	 ;  0 "" 2
 476               	 ;  2175 "FreeRTOS/Source/queue.c" 1
 477 0100 0F92      		push	__tmp_reg__
 478               	 ;  0 "" 2
 479               	/* #NOAPP */
 480               	.LBB2:
2177:FreeRTOS/Source/queue.c **** 
 482               	.LM35:
 483 0102 1E8D      		ldd r17,Y+30
2230:FreeRTOS/Source/queue.c **** 					{
 485               	.LM36:
 486 0104 7C01      		movw r14,r24
 487 0106 81E1      		ldi r24,17
 488 0108 E80E      		add r14,r24
 489 010a F11C      		adc r15,__zero_reg__
 490               	.L20:
2180:FreeRTOS/Source/queue.c **** 		{
 492               	.LM37:
 493 010c 1116      		cp __zero_reg__,r17
 494 010e 04F4      		brge .L21
2228:FreeRTOS/Source/queue.c **** 				{
 496               	.LM38:
 497 0110 8989      		ldd r24,Y+17
 498 0112 8823      		tst r24
 499 0114 01F0      		breq .L21
2230:FreeRTOS/Source/queue.c **** 					{
 501               	.LM39:
 502 0116 C701      		movw r24,r14
 503 0118 0E94 0000 		call xTaskRemoveFromEventList
 504 011c 8111      		cpse r24,__zero_reg__
2234:FreeRTOS/Source/queue.c **** 					}
 506               	.LM40:
 507 011e 0E94 0000 		call vTaskMissedYield
 508               	.L22:
 509 0122 1150      		subi r17,lo8(-(-1))
 510 0124 00C0      		rjmp .L20
 511               	.L21:
2251:FreeRTOS/Source/queue.c **** 	}
 513               	.LM41:
 514 0126 8FEF      		ldi r24,lo8(-1)
 515 0128 8E8F      		std Y+30,r24
 516               	.LBE2:
2253:FreeRTOS/Source/queue.c **** 
 518               	.LM42:
 519               	/* #APP */
 520               	 ;  2253 "FreeRTOS/Source/queue.c" 1
 521 012a 0F90      		pop		__tmp_reg__
 522               	 ;  0 "" 2
 523               	 ;  2253 "FreeRTOS/Source/queue.c" 1
 524 012c 0FBE      		out		__SREG__, __tmp_reg__
 525               	 ;  0 "" 2
2256:FreeRTOS/Source/queue.c **** 	{
 527               	.LM43:
 528               	 ;  2256 "FreeRTOS/Source/queue.c" 1
 529 012e 0FB6      		in		__tmp_reg__, __SREG__
 530               	 ;  0 "" 2
 531               	 ;  2256 "FreeRTOS/Source/queue.c" 1
 532 0130 F894      		cli
 533               	 ;  0 "" 2
 534               	 ;  2256 "FreeRTOS/Source/queue.c" 1
 535 0132 0F92      		push	__tmp_reg__
 536               	 ;  0 "" 2
 537               	/* #NOAPP */
 538               	.LBB3:
2258:FreeRTOS/Source/queue.c **** 
 540               	.LM44:
 541 0134 1D8D      		ldd r17,Y+29
2264:FreeRTOS/Source/queue.c **** 				{
 543               	.LM45:
 544 0136 7E01      		movw r14,r28
 545 0138 88E0      		ldi r24,8
 546 013a E80E      		add r14,r24
 547 013c F11C      		adc r15,__zero_reg__
 548               	.L24:
2260:FreeRTOS/Source/queue.c **** 		{
 550               	.LM46:
 551 013e 1116      		cp __zero_reg__,r17
 552 0140 04F4      		brge .L25
2262:FreeRTOS/Source/queue.c **** 			{
 554               	.LM47:
 555 0142 8885      		ldd r24,Y+8
 556 0144 8823      		tst r24
 557 0146 01F0      		breq .L25
2264:FreeRTOS/Source/queue.c **** 				{
 559               	.LM48:
 560 0148 C701      		movw r24,r14
 561 014a 0E94 0000 		call xTaskRemoveFromEventList
 562 014e 8111      		cpse r24,__zero_reg__
2266:FreeRTOS/Source/queue.c **** 				}
 564               	.LM49:
 565 0150 0E94 0000 		call vTaskMissedYield
 566               	.L26:
 567 0154 1150      		subi r17,lo8(-(-1))
 568 0156 00C0      		rjmp .L24
 569               	.L25:
2281:FreeRTOS/Source/queue.c **** 	}
 571               	.LM50:
 572 0158 8FEF      		ldi r24,lo8(-1)
 573 015a 8D8F      		std Y+29,r24
 574               	.LBE3:
2283:FreeRTOS/Source/queue.c **** }
 576               	.LM51:
 577               	/* #APP */
 578               	 ;  2283 "FreeRTOS/Source/queue.c" 1
 579 015c 0F90      		pop		__tmp_reg__
 580               	 ;  0 "" 2
 581               	 ;  2283 "FreeRTOS/Source/queue.c" 1
 582 015e 0FBE      		out		__SREG__, __tmp_reg__
 583               	 ;  0 "" 2
 584               	/* epilogue start */
2284:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 586               	.LM52:
 587               	/* #NOAPP */
 588 0160 DF91      		pop r29
 589 0162 CF91      		pop r28
 590 0164 1F91      		pop r17
 591 0166 FF90      		pop r15
 592 0168 EF90      		pop r14
 593 016a 0895      		ret
 601               	.Lscope4:
 603               		.stabd	78,0,0
 607               	.global	xQueueGenericReset
 609               	xQueueGenericReset:
 610               		.stabd	46,0,0
 256:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 612               	.LM53:
 613               	.LFBB5:
 614 016c CF93      		push r28
 615 016e DF93      		push r29
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 2 */
 619               	.L__stack_usage = 2
 620 0170 EC01      		movw r28,r24
 261:FreeRTOS/Source/queue.c **** 	{
 622               	.LM54:
 623               	/* #APP */
 624               	 ;  261 "FreeRTOS/Source/queue.c" 1
 625 0172 0FB6      		in		__tmp_reg__, __SREG__
 626               	 ;  0 "" 2
 627               	 ;  261 "FreeRTOS/Source/queue.c" 1
 628 0174 F894      		cli
 629               	 ;  0 "" 2
 630               	 ;  261 "FreeRTOS/Source/queue.c" 1
 631 0176 0F92      		push	__tmp_reg__
 632               	 ;  0 "" 2
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 634               	.LM55:
 635               	/* #NOAPP */
 636 0178 4881      		ld r20,Y
 637 017a 5981      		ldd r21,Y+1
 638 017c 8B8D      		ldd r24,Y+27
 639 017e 7C8D      		ldd r23,Y+28
 640 0180 9A01      		movw r18,r20
 641 0182 879F      		mul r24,r23
 642 0184 200D      		add r18,r0
 643 0186 311D      		adc r19,r1
 644 0188 1124      		clr __zero_reg__
 645 018a 3D83      		std Y+5,r19
 646 018c 2C83      		std Y+4,r18
 264:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 648               	.LM56:
 649 018e 1A8E      		std Y+26,__zero_reg__
 265:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 651               	.LM57:
 652 0190 5B83      		std Y+3,r21
 653 0192 4A83      		std Y+2,r20
 266:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 655               	.LM58:
 656 0194 90E0      		ldi r25,0
 657 0196 0197      		sbiw r24,1
 658 0198 789F      		mul r23,r24
 659 019a 9001      		movw r18,r0
 660 019c 799F      		mul r23,r25
 661 019e 300D      		add r19,r0
 662 01a0 1124      		clr __zero_reg__
 663 01a2 CA01      		movw r24,r20
 664 01a4 820F      		add r24,r18
 665 01a6 931F      		adc r25,r19
 666 01a8 9F83      		std Y+7,r25
 667 01aa 8E83      		std Y+6,r24
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 669               	.LM59:
 670 01ac 8FEF      		ldi r24,lo8(-1)
 671 01ae 8D8F      		std Y+29,r24
 268:FreeRTOS/Source/queue.c **** 
 673               	.LM60:
 674 01b0 8E8F      		std Y+30,r24
 270:FreeRTOS/Source/queue.c **** 		{
 676               	.LM61:
 677 01b2 6111      		cpse r22,__zero_reg__
 678 01b4 00C0      		rjmp .L41
 277:FreeRTOS/Source/queue.c **** 			{
 680               	.LM62:
 681 01b6 8885      		ldd r24,Y+8
 682 01b8 8823      		tst r24
 683 01ba 01F0      		breq .L43
 279:FreeRTOS/Source/queue.c **** 				{
 685               	.LM63:
 686 01bc CE01      		movw r24,r28
 687 01be 0896      		adiw r24,8
 688 01c0 0E94 0000 		call xTaskRemoveFromEventList
 689 01c4 8823      		tst r24
 690 01c6 01F0      		breq .L43
 281:FreeRTOS/Source/queue.c **** 				}
 692               	.LM64:
 693 01c8 0E94 0000 		call vPortYield
 694 01cc 00C0      		rjmp .L43
 695               	.L41:
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 697               	.LM65:
 698 01ce CE01      		movw r24,r28
 699 01d0 0896      		adiw r24,8
 700 01d2 0E94 0000 		call vListInitialise
 297:FreeRTOS/Source/queue.c **** 		}
 702               	.LM66:
 703 01d6 CE01      		movw r24,r28
 704 01d8 4196      		adiw r24,17
 705 01da 0E94 0000 		call vListInitialise
 706               	.L43:
 300:FreeRTOS/Source/queue.c **** 
 708               	.LM67:
 709               	/* #APP */
 710               	 ;  300 "FreeRTOS/Source/queue.c" 1
 711 01de 0F90      		pop		__tmp_reg__
 712               	 ;  0 "" 2
 713               	 ;  300 "FreeRTOS/Source/queue.c" 1
 714 01e0 0FBE      		out		__SREG__, __tmp_reg__
 715               	 ;  0 "" 2
 305:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 717               	.LM68:
 718               	/* #NOAPP */
 719 01e2 81E0      		ldi r24,lo8(1)
 720               	/* epilogue start */
 721 01e4 DF91      		pop r29
 722 01e6 CF91      		pop r28
 723 01e8 0895      		ret
 725               	.Lscope5:
 727               		.stabd	78,0,0
 732               	.global	xQueueGenericCreate
 734               	xQueueGenericCreate:
 735               		.stabd	46,0,0
 369:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 737               	.LM69:
 738               	.LFBB6:
 739 01ea 0F93      		push r16
 740 01ec 1F93      		push r17
 741 01ee CF93      		push r28
 742 01f0 DF93      		push r29
 743               	/* prologue: function */
 744               	/* frame size = 0 */
 745               	/* stack size = 4 */
 746               	.L__stack_usage = 4
 747 01f2 082F      		mov r16,r24
 748 01f4 162F      		mov r17,r22
 376:FreeRTOS/Source/queue.c **** 		{
 750               	.LM70:
 751 01f6 6623      		tst r22
 752 01f8 01F0      		breq .L53
 385:FreeRTOS/Source/queue.c **** 		}
 754               	.LM71:
 755 01fa 869F      		mul r24,r22
 756 01fc C001      		movw r24,r0
 757 01fe 1124      		clr __zero_reg__
 758 0200 00C0      		rjmp .L49
 759               	.L53:
 379:FreeRTOS/Source/queue.c **** 		}
 761               	.LM72:
 762 0202 80E0      		ldi r24,0
 763 0204 90E0      		ldi r25,0
 764               	.L49:
 397:FreeRTOS/Source/queue.c **** 
 766               	.LM73:
 767 0206 4F96      		adiw r24,31
 768 0208 0E94 0000 		call pvPortMalloc
 769 020c EC01      		movw r28,r24
 399:FreeRTOS/Source/queue.c **** 		{
 771               	.LM74:
 772 020e 0097      		sbiw r24,0
 773 0210 01F0      		breq .L50
 774               	.LBB6:
 775               	.LBB7:
 435:FreeRTOS/Source/queue.c **** 	{
 777               	.LM75:
 778 0212 1111      		cpse r17,__zero_reg__
 779 0214 00C0      		rjmp .L51
 441:FreeRTOS/Source/queue.c **** 	}
 781               	.LM76:
 782 0216 9983      		std Y+1,r25
 783 0218 8883      		st Y,r24
 784 021a 00C0      		rjmp .L52
 785               	.L51:
 446:FreeRTOS/Source/queue.c **** 	}
 787               	.LM77:
 788 021c 4F96      		adiw r24,31
 789 021e 9983      		std Y+1,r25
 790 0220 8883      		st Y,r24
 791               	.L52:
 451:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 793               	.LM78:
 794 0222 0B8F      		std Y+27,r16
 452:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 796               	.LM79:
 797 0224 1C8F      		std Y+28,r17
 453:FreeRTOS/Source/queue.c **** 
 799               	.LM80:
 800 0226 61E0      		ldi r22,lo8(1)
 801 0228 CE01      		movw r24,r28
 802 022a 0E94 0000 		call xQueueGenericReset
 803               	.L50:
 804               	.LBE7:
 805               	.LBE6:
 424:FreeRTOS/Source/queue.c **** 
 807               	.LM81:
 808 022e CE01      		movw r24,r28
 809               	/* epilogue start */
 810 0230 DF91      		pop r29
 811 0232 CF91      		pop r28
 812 0234 1F91      		pop r17
 813 0236 0F91      		pop r16
 814 0238 0895      		ret
 819               	.Lscope6:
 821               		.stabd	78,0,0
 827               	.global	xQueueGenericSend
 829               	xQueueGenericSend:
 830               		.stabd	46,0,0
 748:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 832               	.LM82:
 833               	.LFBB7:
 834 023a AF92      		push r10
 835 023c BF92      		push r11
 836 023e CF92      		push r12
 837 0240 DF92      		push r13
 838 0242 FF92      		push r15
 839 0244 0F93      		push r16
 840 0246 1F93      		push r17
 841 0248 CF93      		push r28
 842 024a DF93      		push r29
 843 024c 00D0      		rcall .
 844 024e 00D0      		rcall .
 845 0250 1F92      		push __zero_reg__
 846 0252 CDB7      		in r28,__SP_L__
 847 0254 DEB7      		in r29,__SP_H__
 848               	/* prologue: function */
 849               	/* frame size = 5 */
 850               	/* stack size = 14 */
 851               	.L__stack_usage = 14
 852 0256 8C01      		movw r16,r24
 853 0258 6B01      		movw r12,r22
 854 025a 5D83      		std Y+5,r21
 855 025c 4C83      		std Y+4,r20
 856 025e F22E      		mov r15,r18
 749:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 858               	.LM83:
 859 0260 80E0      		ldi r24,0
 918:FreeRTOS/Source/queue.c **** 
 861               	.LM84:
 862 0262 5801      		movw r10,r16
 863 0264 98E0      		ldi r25,8
 864 0266 A90E      		add r10,r25
 865 0268 B11C      		adc r11,__zero_reg__
 866               	.L58:
 768:FreeRTOS/Source/queue.c **** 		{
 868               	.LM85:
 869               	/* #APP */
 870               	 ;  768 "FreeRTOS/Source/queue.c" 1
 871 026a 0FB6      		in		__tmp_reg__, __SREG__
 872               	 ;  0 "" 2
 873               	 ;  768 "FreeRTOS/Source/queue.c" 1
 874 026c F894      		cli
 875               	 ;  0 "" 2
 876               	 ;  768 "FreeRTOS/Source/queue.c" 1
 877 026e 0F92      		push	__tmp_reg__
 878               	 ;  0 "" 2
 774:FreeRTOS/Source/queue.c **** 			{
 880               	.LM86:
 881               	/* #NOAPP */
 882 0270 F801      		movw r30,r16
 883 0272 228D      		ldd r18,Z+26
 884 0274 938D      		ldd r25,Z+27
 885 0276 2917      		cp r18,r25
 886 0278 00F0      		brlo .L59
 774:FreeRTOS/Source/queue.c **** 			{
 888               	.LM87:
 889 027a F2E0      		ldi r31,lo8(2)
 890 027c FF12      		cpse r15,r31
 891 027e 00C0      		rjmp .L60
 892               	.L59:
 840:FreeRTOS/Source/queue.c **** 
 894               	.LM88:
 895 0280 4F2D      		mov r20,r15
 896 0282 B601      		movw r22,r12
 897 0284 C801      		movw r24,r16
 898 0286 0E94 0000 		call prvCopyDataToQueue
 844:FreeRTOS/Source/queue.c **** 					{
 900               	.LM89:
 901 028a F801      		movw r30,r16
 902 028c 9189      		ldd r25,Z+17
 903 028e 9923      		tst r25
 904 0290 01F0      		breq .L73
 846:FreeRTOS/Source/queue.c **** 						{
 906               	.LM90:
 907 0292 C801      		movw r24,r16
 908 0294 4196      		adiw r24,17
 909 0296 0E94 0000 		call xTaskRemoveFromEventList
 910               	.L73:
 911 029a 8111      		cpse r24,__zero_reg__
 852:FreeRTOS/Source/queue.c **** 						}
 913               	.LM91:
 914 029c 0E94 0000 		call vPortYield
 915               	.L63:
 874:FreeRTOS/Source/queue.c **** 				return pdPASS;
 917               	.LM92:
 918               	/* #APP */
 919               	 ;  874 "FreeRTOS/Source/queue.c" 1
 920 02a0 0F90      		pop		__tmp_reg__
 921               	 ;  0 "" 2
 922               	 ;  874 "FreeRTOS/Source/queue.c" 1
 923 02a2 0FBE      		out		__SREG__, __tmp_reg__
 924               	 ;  0 "" 2
 875:FreeRTOS/Source/queue.c **** 			}
 926               	.LM93:
 927               	/* #NOAPP */
 928 02a4 81E0      		ldi r24,lo8(1)
 929 02a6 00C0      		rjmp .L65
 930               	.L60:
 879:FreeRTOS/Source/queue.c **** 				{
 932               	.LM94:
 933 02a8 2C81      		ldd r18,Y+4
 934 02aa 3D81      		ldd r19,Y+5
 935 02ac 232B      		or r18,r19
 936 02ae 01F4      		brne .L66
 883:FreeRTOS/Source/queue.c **** 
 938               	.LM95:
 939               	/* #APP */
 940               	 ;  883 "FreeRTOS/Source/queue.c" 1
 941 02b0 0F90      		pop		__tmp_reg__
 942               	 ;  0 "" 2
 943               	 ;  883 "FreeRTOS/Source/queue.c" 1
 944 02b2 0FBE      		out		__SREG__, __tmp_reg__
 945               	 ;  0 "" 2
 946               	/* #NOAPP */
 947 02b4 00C0      		rjmp .L74
 948               	.L66:
 890:FreeRTOS/Source/queue.c **** 				{
 950               	.LM96:
 951 02b6 8111      		cpse r24,__zero_reg__
 952 02b8 00C0      		rjmp .L67
 894:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 954               	.LM97:
 955 02ba CE01      		movw r24,r28
 956 02bc 0196      		adiw r24,1
 957 02be 0E94 0000 		call vTaskInternalSetTimeOutState
 958               	.L67:
 904:FreeRTOS/Source/queue.c **** 
 960               	.LM98:
 961               	/* #APP */
 962               	 ;  904 "FreeRTOS/Source/queue.c" 1
 963 02c2 0F90      		pop		__tmp_reg__
 964               	 ;  0 "" 2
 965               	 ;  904 "FreeRTOS/Source/queue.c" 1
 966 02c4 0FBE      		out		__SREG__, __tmp_reg__
 967               	 ;  0 "" 2
 909:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 969               	.LM99:
 970               	/* #NOAPP */
 971 02c6 0E94 0000 		call vTaskSuspendAll
 910:FreeRTOS/Source/queue.c **** 
 973               	.LM100:
 974               	/* #APP */
 975               	 ;  910 "FreeRTOS/Source/queue.c" 1
 976 02ca 0FB6      		in		__tmp_reg__, __SREG__
 977               	 ;  0 "" 2
 978               	 ;  910 "FreeRTOS/Source/queue.c" 1
 979 02cc F894      		cli
 980               	 ;  0 "" 2
 981               	 ;  910 "FreeRTOS/Source/queue.c" 1
 982 02ce 0F92      		push	__tmp_reg__
 983               	 ;  0 "" 2
 984               	/* #NOAPP */
 985 02d0 F801      		movw r30,r16
 986 02d2 858D      		ldd r24,Z+29
 987 02d4 8F3F      		cpi r24,lo8(-1)
 988 02d6 01F4      		brne .L68
 910:FreeRTOS/Source/queue.c **** 
 990               	.LM101:
 991 02d8 158E      		std Z+29,__zero_reg__
 992               	.L68:
 910:FreeRTOS/Source/queue.c **** 
 994               	.LM102:
 995 02da F801      		movw r30,r16
 996 02dc 868D      		ldd r24,Z+30
 997 02de 8F3F      		cpi r24,lo8(-1)
 998 02e0 01F4      		brne .L69
 910:FreeRTOS/Source/queue.c **** 
 1000               	.LM103:
 1001 02e2 168E      		std Z+30,__zero_reg__
 1002               	.L69:
 910:FreeRTOS/Source/queue.c **** 
 1004               	.LM104:
 1005               	/* #APP */
 1006               	 ;  910 "FreeRTOS/Source/queue.c" 1
 1007 02e4 0F90      		pop		__tmp_reg__
 1008               	 ;  0 "" 2
 1009               	 ;  910 "FreeRTOS/Source/queue.c" 1
 1010 02e6 0FBE      		out		__SREG__, __tmp_reg__
 1011               	 ;  0 "" 2
 913:FreeRTOS/Source/queue.c **** 		{
 1013               	.LM105:
 1014               	/* #NOAPP */
 1015 02e8 BE01      		movw r22,r28
 1016 02ea 6C5F      		subi r22,-4
 1017 02ec 7F4F      		sbci r23,-1
 1018 02ee CE01      		movw r24,r28
 1019 02f0 0196      		adiw r24,1
 1020 02f2 0E94 0000 		call xTaskCheckForTimeOut
 1021 02f6 8111      		cpse r24,__zero_reg__
 1022 02f8 00C0      		rjmp .L70
 1023               	.LBB10:
 1024               	.LBB11:
2306:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2307:FreeRTOS/Source/queue.c **** 
2308:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2309:FreeRTOS/Source/queue.c **** {
2310:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2311:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
2312:FreeRTOS/Source/queue.c **** 
2313:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2314:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2315:FreeRTOS/Source/queue.c **** 	{
2316:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2317:FreeRTOS/Source/queue.c **** 	}
2318:FreeRTOS/Source/queue.c **** 	else
2319:FreeRTOS/Source/queue.c **** 	{
2320:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2321:FreeRTOS/Source/queue.c **** 	}
2322:FreeRTOS/Source/queue.c **** 
2323:FreeRTOS/Source/queue.c **** 	return xReturn;
2324:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2325:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2326:FreeRTOS/Source/queue.c **** 
2327:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2328:FreeRTOS/Source/queue.c **** {
2329:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2330:FreeRTOS/Source/queue.c **** 
2331:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1026               	.LM106:
 1027               	/* #APP */
 1028               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 1029 02fa 0FB6      		in		__tmp_reg__, __SREG__
 1030               	 ;  0 "" 2
 1031               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 1032 02fc F894      		cli
 1033               	 ;  0 "" 2
 1034               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 1035 02fe 0F92      		push	__tmp_reg__
 1036               	 ;  0 "" 2
2332:FreeRTOS/Source/queue.c **** 	{
2333:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1038               	.LM107:
 1039               	/* #NOAPP */
 1040 0300 F801      		movw r30,r16
 1041 0302 928D      		ldd r25,Z+26
2334:FreeRTOS/Source/queue.c **** 		{
2335:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2336:FreeRTOS/Source/queue.c **** 		}
2337:FreeRTOS/Source/queue.c **** 		else
2338:FreeRTOS/Source/queue.c **** 		{
2339:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2340:FreeRTOS/Source/queue.c **** 		}
2341:FreeRTOS/Source/queue.c **** 	}
2342:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1043               	.LM108:
 1044               	/* #APP */
 1045               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 1046 0304 0F90      		pop		__tmp_reg__
 1047               	 ;  0 "" 2
 1048               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 1049 0306 0FBE      		out		__SREG__, __tmp_reg__
 1050               	 ;  0 "" 2
 1051               	/* #NOAPP */
 1052               	.LBE11:
 1053               	.LBE10:
 915:FreeRTOS/Source/queue.c **** 			{
 1055               	.LM109:
 1056 0308 838D      		ldd r24,Z+27
 1057 030a 9813      		cpse r25,r24
 1058 030c 00C0      		rjmp .L71
 918:FreeRTOS/Source/queue.c **** 
 1060               	.LM110:
 1061 030e 6C81      		ldd r22,Y+4
 1062 0310 7D81      		ldd r23,Y+5
 1063 0312 C501      		movw r24,r10
 1064 0314 0E94 0000 		call vTaskPlaceOnEventList
 925:FreeRTOS/Source/queue.c **** 
 1066               	.LM111:
 1067 0318 C801      		movw r24,r16
 1068 031a 0E94 0000 		call prvUnlockQueue
 932:FreeRTOS/Source/queue.c **** 				{
 1070               	.LM112:
 1071 031e 0E94 0000 		call xTaskResumeAll
 1072 0322 8823      		tst r24
 1073 0324 01F0      		breq .L75
 1074               	.L72:
 1075 0326 81E0      		ldi r24,lo8(1)
 1076 0328 00C0      		rjmp .L58
 1077               	.L75:
 934:FreeRTOS/Source/queue.c **** 				}
 1079               	.LM113:
 1080 032a 0E94 0000 		call vPortYield
 1081 032e 00C0      		rjmp .L72
 1082               	.L71:
 940:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1084               	.LM114:
 1085 0330 C801      		movw r24,r16
 1086 0332 0E94 0000 		call prvUnlockQueue
 941:FreeRTOS/Source/queue.c **** 			}
 1088               	.LM115:
 1089 0336 0E94 0000 		call xTaskResumeAll
 1090 033a 00C0      		rjmp .L72
 1091               	.L70:
 947:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1093               	.LM116:
 1094 033c C801      		movw r24,r16
 1095 033e 0E94 0000 		call prvUnlockQueue
 948:FreeRTOS/Source/queue.c **** 
 1097               	.LM117:
 1098 0342 0E94 0000 		call xTaskResumeAll
 1099               	.L74:
 951:FreeRTOS/Source/queue.c **** 		}
 1101               	.LM118:
 1102 0346 80E0      		ldi r24,0
 1103               	.L65:
 1104               	/* epilogue start */
 954:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1106               	.LM119:
 1107 0348 0F90      		pop __tmp_reg__
 1108 034a 0F90      		pop __tmp_reg__
 1109 034c 0F90      		pop __tmp_reg__
 1110 034e 0F90      		pop __tmp_reg__
 1111 0350 0F90      		pop __tmp_reg__
 1112 0352 DF91      		pop r29
 1113 0354 CF91      		pop r28
 1114 0356 1F91      		pop r17
 1115 0358 0F91      		pop r16
 1116 035a FF90      		pop r15
 1117 035c DF90      		pop r13
 1118 035e CF90      		pop r12
 1119 0360 BF90      		pop r11
 1120 0362 AF90      		pop r10
 1121 0364 0895      		ret
 1128               	.Lscope7:
 1130               		.stabd	78,0,0
 1133               	.global	xQueueCreateMutex
 1135               	xQueueCreateMutex:
 1136               		.stabd	46,0,0
 504:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 1138               	.LM120:
 1139               	.LFBB8:
 1140 0366 CF93      		push r28
 1141 0368 DF93      		push r29
 1142               	/* prologue: function */
 1143               	/* frame size = 0 */
 1144               	/* stack size = 2 */
 1145               	.L__stack_usage = 2
 508:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1147               	.LM121:
 1148 036a 482F      		mov r20,r24
 1149 036c 60E0      		ldi r22,0
 1150 036e 81E0      		ldi r24,lo8(1)
 1151 0370 0E94 0000 		call xQueueGenericCreate
 1152 0374 EC01      		movw r28,r24
 1153               	.LBB14:
 1154               	.LBB15:
 475:FreeRTOS/Source/queue.c **** 		{
 1156               	.LM122:
 1157 0376 0097      		sbiw r24,0
 1158 0378 01F0      		breq .L77
 481:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1160               	.LM123:
 1161 037a 1D82      		std Y+5,__zero_reg__
 1162 037c 1C82      		std Y+4,__zero_reg__
 482:FreeRTOS/Source/queue.c **** 
 1164               	.LM124:
 1165 037e 1982      		std Y+1,__zero_reg__
 1166 0380 1882      		st Y,__zero_reg__
 485:FreeRTOS/Source/queue.c **** 
 1168               	.LM125:
 1169 0382 1E82      		std Y+6,__zero_reg__
 490:FreeRTOS/Source/queue.c **** 		}
 1171               	.LM126:
 1172 0384 20E0      		ldi r18,0
 1173 0386 40E0      		ldi r20,0
 1174 0388 50E0      		ldi r21,0
 1175 038a 60E0      		ldi r22,0
 1176 038c 70E0      		ldi r23,0
 1177 038e 0E94 0000 		call xQueueGenericSend
 1178               	.L77:
 1179               	.LBE15:
 1180               	.LBE14:
 512:FreeRTOS/Source/queue.c **** 
 1182               	.LM127:
 1183 0392 CE01      		movw r24,r28
 1184               	/* epilogue start */
 1185 0394 DF91      		pop r29
 1186 0396 CF91      		pop r28
 1187 0398 0895      		ret
 1192               	.Lscope8:
 1194               		.stabd	78,0,0
 1200               	.global	xQueueGenericSendFromISR
 1202               	xQueueGenericSendFromISR:
 1203               		.stabd	46,0,0
 958:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1205               	.LM128:
 1206               	.LFBB9:
 1207 039a EF92      		push r14
 1208 039c FF92      		push r15
 1209 039e 1F93      		push r17
 1210 03a0 CF93      		push r28
 1211 03a2 DF93      		push r29
 1212               	/* prologue: function */
 1213               	/* frame size = 0 */
 1214               	/* stack size = 5 */
 1215               	.L__stack_usage = 5
 1216 03a4 EC01      		movw r28,r24
 990:FreeRTOS/Source/queue.c **** 		{
 1218               	.LM129:
 1219 03a6 9A8D      		ldd r25,Y+26
 1220 03a8 8B8D      		ldd r24,Y+27
 1221 03aa 9817      		cp r25,r24
 1222 03ac 00F0      		brlo .L82
 990:FreeRTOS/Source/queue.c **** 		{
 1224               	.LM130:
 1225 03ae 2230      		cpi r18,lo8(2)
 1226 03b0 01F4      		brne .L87
 1227               	.L82:
 1228 03b2 7A01      		movw r14,r20
 1229               	.LBB16:
 992:FreeRTOS/Source/queue.c **** 
 1231               	.LM131:
 1232 03b4 1E8D      		ldd r17,Y+30
1001:FreeRTOS/Source/queue.c **** 
 1234               	.LM132:
 1235 03b6 422F      		mov r20,r18
 1236 03b8 CE01      		movw r24,r28
 1237 03ba 0E94 0000 		call prvCopyDataToQueue
1005:FreeRTOS/Source/queue.c **** 			{
 1239               	.LM133:
 1240 03be 1F3F      		cpi r17,lo8(-1)
 1241 03c0 01F4      		brne .L84
1060:FreeRTOS/Source/queue.c **** 					{
 1243               	.LM134:
 1244 03c2 8989      		ldd r24,Y+17
 1245 03c4 8823      		tst r24
 1246 03c6 01F0      		breq .L94
1062:FreeRTOS/Source/queue.c **** 						{
 1248               	.LM135:
 1249 03c8 CE01      		movw r24,r28
 1250 03ca 4196      		adiw r24,17
 1251 03cc 0E94 0000 		call xTaskRemoveFromEventList
 1252 03d0 8823      		tst r24
 1253 03d2 01F0      		breq .L94
1066:FreeRTOS/Source/queue.c **** 							{
 1255               	.LM136:
 1256 03d4 E114      		cp r14,__zero_reg__
 1257 03d6 F104      		cpc r15,__zero_reg__
 1258 03d8 01F0      		breq .L94
1068:FreeRTOS/Source/queue.c **** 							}
 1260               	.LM137:
 1261 03da 81E0      		ldi r24,lo8(1)
 1262 03dc F701      		movw r30,r14
 1263 03de 8083      		st Z,r24
 1264 03e0 00C0      		rjmp .L83
 1265               	.L84:
1091:FreeRTOS/Source/queue.c **** 			}
 1267               	.LM138:
 1268 03e2 1F5F      		subi r17,lo8(-(1))
 1269 03e4 1E8F      		std Y+30,r17
 1270               	.L94:
1094:FreeRTOS/Source/queue.c **** 		}
 1272               	.LM139:
 1273 03e6 81E0      		ldi r24,lo8(1)
 1274 03e8 00C0      		rjmp .L83
 1275               	.L87:
 1276               	.LBE16:
1099:FreeRTOS/Source/queue.c **** 		}
 1278               	.LM140:
 1279 03ea 80E0      		ldi r24,0
 1280               	.L83:
 1281               	/* epilogue start */
1105:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1283               	.LM141:
 1284 03ec DF91      		pop r29
 1285 03ee CF91      		pop r28
 1286 03f0 1F91      		pop r17
 1287 03f2 FF90      		pop r15
 1288 03f4 EF90      		pop r14
 1289 03f6 0895      		ret
 1297               	.Lscope9:
 1299               		.stabd	78,0,0
 1303               	.global	xQueueGiveFromISR
 1305               	xQueueGiveFromISR:
 1306               		.stabd	46,0,0
1109:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1308               	.LM142:
 1309               	.LFBB10:
 1310 03f8 CF93      		push r28
 1311 03fa DF93      		push r29
 1312               	/* prologue: function */
 1313               	/* frame size = 0 */
 1314               	/* stack size = 2 */
 1315               	.L__stack_usage = 2
 1316 03fc FC01      		movw r30,r24
 1317               	.LBB17:
1149:FreeRTOS/Source/queue.c **** 
 1319               	.LM143:
 1320 03fe 928D      		ldd r25,Z+26
1154:FreeRTOS/Source/queue.c **** 		{
 1322               	.LM144:
 1323 0400 838D      		ldd r24,Z+27
 1324 0402 9817      		cp r25,r24
 1325 0404 00F4      		brsh .L100
 1326               	.LBB18:
1156:FreeRTOS/Source/queue.c **** 
 1328               	.LM145:
 1329 0406 868D      		ldd r24,Z+30
1166:FreeRTOS/Source/queue.c **** 
 1331               	.LM146:
 1332 0408 9F5F      		subi r25,lo8(-(1))
 1333 040a 928F      		std Z+26,r25
1170:FreeRTOS/Source/queue.c **** 			{
 1335               	.LM147:
 1336 040c 8F3F      		cpi r24,lo8(-1)
 1337 040e 01F4      		brne .L97
1225:FreeRTOS/Source/queue.c **** 					{
 1339               	.LM148:
 1340 0410 8189      		ldd r24,Z+17
 1341 0412 8823      		tst r24
 1342 0414 01F0      		breq .L107
 1343 0416 EB01      		movw r28,r22
 1344 0418 CF01      		movw r24,r30
1227:FreeRTOS/Source/queue.c **** 						{
 1346               	.LM149:
 1347 041a 4196      		adiw r24,17
 1348 041c 0E94 0000 		call xTaskRemoveFromEventList
 1349 0420 8823      		tst r24
 1350 0422 01F0      		breq .L107
1231:FreeRTOS/Source/queue.c **** 							{
 1352               	.LM150:
 1353 0424 2097      		sbiw r28,0
 1354 0426 01F0      		breq .L107
1233:FreeRTOS/Source/queue.c **** 							}
 1356               	.LM151:
 1357 0428 81E0      		ldi r24,lo8(1)
 1358 042a 8883      		st Y,r24
 1359 042c 00C0      		rjmp .L96
 1360               	.L97:
1256:FreeRTOS/Source/queue.c **** 			}
 1362               	.LM152:
 1363 042e 8F5F      		subi r24,lo8(-(1))
 1364 0430 868F      		std Z+30,r24
 1365               	.L107:
1259:FreeRTOS/Source/queue.c **** 		}
 1367               	.LM153:
 1368 0432 81E0      		ldi r24,lo8(1)
 1369 0434 00C0      		rjmp .L96
 1370               	.L100:
 1371               	.LBE18:
1264:FreeRTOS/Source/queue.c **** 		}
 1373               	.LM154:
 1374 0436 80E0      		ldi r24,0
 1375               	.L96:
 1376               	/* epilogue start */
 1377               	.LBE17:
1270:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1379               	.LM155:
 1380 0438 DF91      		pop r29
 1381 043a CF91      		pop r28
 1382 043c 0895      		ret
 1393               	.Lscope10:
 1395               		.stabd	78,0,0
 1400               	.global	xQueueReceive
 1402               	xQueueReceive:
 1403               		.stabd	46,0,0
1274:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1405               	.LM156:
 1406               	.LFBB11:
 1407 043e AF92      		push r10
 1408 0440 BF92      		push r11
 1409 0442 CF92      		push r12
 1410 0444 DF92      		push r13
 1411 0446 FF92      		push r15
 1412 0448 0F93      		push r16
 1413 044a 1F93      		push r17
 1414 044c CF93      		push r28
 1415 044e DF93      		push r29
 1416 0450 00D0      		rcall .
 1417 0452 00D0      		rcall .
 1418 0454 1F92      		push __zero_reg__
 1419 0456 CDB7      		in r28,__SP_L__
 1420 0458 DEB7      		in r29,__SP_H__
 1421               	/* prologue: function */
 1422               	/* frame size = 5 */
 1423               	/* stack size = 14 */
 1424               	.L__stack_usage = 14
 1425 045a 8C01      		movw r16,r24
 1426 045c 6B01      		movw r12,r22
 1427 045e 5D83      		std Y+5,r21
 1428 0460 4C83      		std Y+4,r20
1275:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1430               	.LM157:
 1431 0462 80E0      		ldi r24,0
1374:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1433               	.LM158:
 1434 0464 5801      		movw r10,r16
 1435 0466 91E1      		ldi r25,17
 1436 0468 A90E      		add r10,r25
 1437 046a B11C      		adc r11,__zero_reg__
 1438               	.L109:
1299:FreeRTOS/Source/queue.c **** 		{
 1440               	.LM159:
 1441               	/* #APP */
 1442               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1443 046c 0FB6      		in		__tmp_reg__, __SREG__
 1444               	 ;  0 "" 2
 1445               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1446 046e F894      		cli
 1447               	 ;  0 "" 2
 1448               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1449 0470 0F92      		push	__tmp_reg__
 1450               	 ;  0 "" 2
 1451               	/* #NOAPP */
 1452               	.LBB19:
1301:FreeRTOS/Source/queue.c **** 
 1454               	.LM160:
 1455 0472 F801      		movw r30,r16
 1456 0474 F28C      		ldd r15,Z+26
1305:FreeRTOS/Source/queue.c **** 			{
 1458               	.LM161:
 1459 0476 FF20      		tst r15
 1460 0478 01F0      		breq .L110
1308:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
 1462               	.LM162:
 1463 047a B601      		movw r22,r12
 1464 047c C801      		movw r24,r16
 1465 047e 0E94 0000 		call prvCopyDataFromQueue
1310:FreeRTOS/Source/queue.c **** 
 1467               	.LM163:
 1468 0482 FA94      		dec r15
 1469 0484 F801      		movw r30,r16
 1470 0486 F28E      		std Z+26,r15
1315:FreeRTOS/Source/queue.c **** 				{
 1472               	.LM164:
 1473 0488 8085      		ldd r24,Z+8
 1474 048a 8823      		tst r24
 1475 048c 01F0      		breq .L112
1317:FreeRTOS/Source/queue.c **** 					{
 1477               	.LM165:
 1478 048e C801      		movw r24,r16
 1479 0490 0896      		adiw r24,8
 1480 0492 0E94 0000 		call xTaskRemoveFromEventList
 1481 0496 8111      		cpse r24,__zero_reg__
1319:FreeRTOS/Source/queue.c **** 					}
 1483               	.LM166:
 1484 0498 0E94 0000 		call vPortYield
 1485               	.L112:
1331:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1487               	.LM167:
 1488               	/* #APP */
 1489               	 ;  1331 "FreeRTOS/Source/queue.c" 1
 1490 049c 0F90      		pop		__tmp_reg__
 1491               	 ;  0 "" 2
 1492               	 ;  1331 "FreeRTOS/Source/queue.c" 1
 1493 049e 0FBE      		out		__SREG__, __tmp_reg__
 1494               	 ;  0 "" 2
1332:FreeRTOS/Source/queue.c **** 			}
 1496               	.LM168:
 1497               	/* #NOAPP */
 1498 04a0 81E0      		ldi r24,lo8(1)
 1499 04a2 00C0      		rjmp .L114
 1500               	.L110:
1336:FreeRTOS/Source/queue.c **** 				{
 1502               	.LM169:
 1503 04a4 2C81      		ldd r18,Y+4
 1504 04a6 3D81      		ldd r19,Y+5
 1505 04a8 232B      		or r18,r19
 1506 04aa 01F4      		brne .L115
1340:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1508               	.LM170:
 1509               	/* #APP */
 1510               	 ;  1340 "FreeRTOS/Source/queue.c" 1
 1511 04ac 0F90      		pop		__tmp_reg__
 1512               	 ;  0 "" 2
 1513               	 ;  1340 "FreeRTOS/Source/queue.c" 1
 1514 04ae 0FBE      		out		__SREG__, __tmp_reg__
 1515               	 ;  0 "" 2
 1516               	/* #NOAPP */
 1517 04b0 00C0      		rjmp .L129
 1518               	.L115:
1344:FreeRTOS/Source/queue.c **** 				{
 1520               	.LM171:
 1521 04b2 8111      		cpse r24,__zero_reg__
 1522 04b4 00C0      		rjmp .L116
1348:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1524               	.LM172:
 1525 04b6 CE01      		movw r24,r28
 1526 04b8 0196      		adiw r24,1
 1527 04ba 0E94 0000 		call vTaskInternalSetTimeOutState
 1528               	.L116:
 1529               	.LBE19:
1358:FreeRTOS/Source/queue.c **** 
 1531               	.LM173:
 1532               	/* #APP */
 1533               	 ;  1358 "FreeRTOS/Source/queue.c" 1
 1534 04be 0F90      		pop		__tmp_reg__
 1535               	 ;  0 "" 2
 1536               	 ;  1358 "FreeRTOS/Source/queue.c" 1
 1537 04c0 0FBE      		out		__SREG__, __tmp_reg__
 1538               	 ;  0 "" 2
1363:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1540               	.LM174:
 1541               	/* #NOAPP */
 1542 04c2 0E94 0000 		call vTaskSuspendAll
1364:FreeRTOS/Source/queue.c **** 
 1544               	.LM175:
 1545               	/* #APP */
 1546               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1547 04c6 0FB6      		in		__tmp_reg__, __SREG__
 1548               	 ;  0 "" 2
 1549               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1550 04c8 F894      		cli
 1551               	 ;  0 "" 2
 1552               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1553 04ca 0F92      		push	__tmp_reg__
 1554               	 ;  0 "" 2
 1555               	/* #NOAPP */
 1556 04cc F801      		movw r30,r16
 1557 04ce 858D      		ldd r24,Z+29
 1558 04d0 8F3F      		cpi r24,lo8(-1)
 1559 04d2 01F4      		brne .L117
1364:FreeRTOS/Source/queue.c **** 
 1561               	.LM176:
 1562 04d4 158E      		std Z+29,__zero_reg__
 1563               	.L117:
1364:FreeRTOS/Source/queue.c **** 
 1565               	.LM177:
 1566 04d6 F801      		movw r30,r16
 1567 04d8 868D      		ldd r24,Z+30
 1568 04da 8F3F      		cpi r24,lo8(-1)
 1569 04dc 01F4      		brne .L118
1364:FreeRTOS/Source/queue.c **** 
 1571               	.LM178:
 1572 04de 168E      		std Z+30,__zero_reg__
 1573               	.L118:
1364:FreeRTOS/Source/queue.c **** 
 1575               	.LM179:
 1576               	/* #APP */
 1577               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1578 04e0 0F90      		pop		__tmp_reg__
 1579               	 ;  0 "" 2
 1580               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1581 04e2 0FBE      		out		__SREG__, __tmp_reg__
 1582               	 ;  0 "" 2
1367:FreeRTOS/Source/queue.c **** 		{
 1584               	.LM180:
 1585               	/* #NOAPP */
 1586 04e4 BE01      		movw r22,r28
 1587 04e6 6C5F      		subi r22,-4
 1588 04e8 7F4F      		sbci r23,-1
 1589 04ea CE01      		movw r24,r28
 1590 04ec 0196      		adiw r24,1
 1591 04ee 0E94 0000 		call xTaskCheckForTimeOut
 1592 04f2 8111      		cpse r24,__zero_reg__
 1593 04f4 00C0      		rjmp .L119
1371:FreeRTOS/Source/queue.c **** 			{
 1595               	.LM181:
 1596 04f6 C801      		movw r24,r16
 1597 04f8 0E94 0000 		call prvIsQueueEmpty
 1598 04fc 8823      		tst r24
 1599 04fe 01F0      		breq .L120
1374:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1601               	.LM182:
 1602 0500 6C81      		ldd r22,Y+4
 1603 0502 7D81      		ldd r23,Y+5
 1604 0504 C501      		movw r24,r10
 1605 0506 0E94 0000 		call vTaskPlaceOnEventList
1375:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1607               	.LM183:
 1608 050a C801      		movw r24,r16
 1609 050c 0E94 0000 		call prvUnlockQueue
1376:FreeRTOS/Source/queue.c **** 				{
 1611               	.LM184:
 1612 0510 0E94 0000 		call xTaskResumeAll
 1613 0514 8823      		tst r24
 1614 0516 01F0      		breq .L130
 1615               	.L122:
 1616 0518 81E0      		ldi r24,lo8(1)
 1617 051a 00C0      		rjmp .L109
 1618               	.L130:
1378:FreeRTOS/Source/queue.c **** 				}
 1620               	.LM185:
 1621 051c 0E94 0000 		call vPortYield
 1622 0520 00C0      		rjmp .L122
 1623               	.L120:
1389:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1625               	.LM186:
 1626 0522 C801      		movw r24,r16
 1627 0524 0E94 0000 		call prvUnlockQueue
1390:FreeRTOS/Source/queue.c **** 			}
 1629               	.LM187:
 1630 0528 0E94 0000 		call xTaskResumeAll
 1631 052c 00C0      		rjmp .L122
 1632               	.L119:
1397:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1634               	.LM188:
 1635 052e C801      		movw r24,r16
 1636 0530 0E94 0000 		call prvUnlockQueue
1398:FreeRTOS/Source/queue.c **** 
 1638               	.LM189:
 1639 0534 0E94 0000 		call xTaskResumeAll
1400:FreeRTOS/Source/queue.c **** 			{
 1641               	.LM190:
 1642 0538 C801      		movw r24,r16
 1643 053a 0E94 0000 		call prvIsQueueEmpty
 1644 053e 8823      		tst r24
 1645 0540 01F0      		breq .L122
 1646               	.L129:
1403:FreeRTOS/Source/queue.c **** 			}
 1648               	.LM191:
 1649 0542 80E0      		ldi r24,0
 1650               	.L114:
 1651               	/* epilogue start */
1411:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1653               	.LM192:
 1654 0544 0F90      		pop __tmp_reg__
 1655 0546 0F90      		pop __tmp_reg__
 1656 0548 0F90      		pop __tmp_reg__
 1657 054a 0F90      		pop __tmp_reg__
 1658 054c 0F90      		pop __tmp_reg__
 1659 054e DF91      		pop r29
 1660 0550 CF91      		pop r28
 1661 0552 1F91      		pop r17
 1662 0554 0F91      		pop r16
 1663 0556 FF90      		pop r15
 1664 0558 DF90      		pop r13
 1665 055a CF90      		pop r12
 1666 055c BF90      		pop r11
 1667 055e AF90      		pop r10
 1668 0560 0895      		ret
 1677               	.Lscope11:
 1679               		.stabd	78,0,0
 1683               	.global	xQueueSemaphoreTake
 1685               	xQueueSemaphoreTake:
 1686               		.stabd	46,0,0
1415:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1688               	.LM193:
 1689               	.LFBB12:
 1690 0562 CF92      		push r12
 1691 0564 DF92      		push r13
 1692 0566 FF92      		push r15
 1693 0568 0F93      		push r16
 1694 056a 1F93      		push r17
 1695 056c CF93      		push r28
 1696 056e DF93      		push r29
 1697 0570 00D0      		rcall .
 1698 0572 00D0      		rcall .
 1699 0574 1F92      		push __zero_reg__
 1700 0576 CDB7      		in r28,__SP_L__
 1701 0578 DEB7      		in r29,__SP_H__
 1702               	/* prologue: function */
 1703               	/* frame size = 5 */
 1704               	/* stack size = 12 */
 1705               	.L__stack_usage = 12
 1706 057a 8C01      		movw r16,r24
 1707 057c 7D83      		std Y+5,r23
 1708 057e 6C83      		std Y+4,r22
1421:FreeRTOS/Source/queue.c **** #endif
 1710               	.LM194:
 1711 0580 F12C      		mov r15,__zero_reg__
1416:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1713               	.LM195:
 1714 0582 90E0      		ldi r25,0
1565:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1716               	.LM196:
 1717 0584 6801      		movw r12,r16
 1718 0586 81E1      		ldi r24,17
 1719 0588 C80E      		add r12,r24
 1720 058a D11C      		adc r13,__zero_reg__
 1721               	.L132:
1444:FreeRTOS/Source/queue.c **** 		{
 1723               	.LM197:
 1724               	/* #APP */
 1725               	 ;  1444 "FreeRTOS/Source/queue.c" 1
 1726 058c 0FB6      		in		__tmp_reg__, __SREG__
 1727               	 ;  0 "" 2
 1728               	 ;  1444 "FreeRTOS/Source/queue.c" 1
 1729 058e F894      		cli
 1730               	 ;  0 "" 2
 1731               	 ;  1444 "FreeRTOS/Source/queue.c" 1
 1732 0590 0F92      		push	__tmp_reg__
 1733               	 ;  0 "" 2
 1734               	/* #NOAPP */
 1735               	.LBB24:
1448:FreeRTOS/Source/queue.c **** 
 1737               	.LM198:
 1738 0592 D801      		movw r26,r16
 1739 0594 5A96      		adiw r26,26
 1740 0596 8C91      		ld r24,X
 1741 0598 5A97      		sbiw r26,26
1452:FreeRTOS/Source/queue.c **** 			{
 1743               	.LM199:
 1744 059a 8823      		tst r24
 1745 059c 01F0      		breq .L133
1458:FreeRTOS/Source/queue.c **** 
 1747               	.LM200:
 1748 059e 8150      		subi r24,lo8(-(-1))
 1749 05a0 5A96      		adiw r26,26
 1750 05a2 8C93      		st X,r24
 1751 05a4 5A97      		sbiw r26,26
1462:FreeRTOS/Source/queue.c **** 					{
 1753               	.LM201:
 1754 05a6 8D91      		ld r24,X+
 1755 05a8 9C91      		ld r25,X
 1756 05aa 892B      		or r24,r25
 1757 05ac 01F4      		brne .L134
1466:FreeRTOS/Source/queue.c **** 					}
 1759               	.LM202:
 1760 05ae 0E94 0000 		call pvTaskIncrementMutexHeldCount
 1761 05b2 F801      		movw r30,r16
 1762 05b4 9583      		std Z+5,r25
 1763 05b6 8483      		std Z+4,r24
 1764               	.L134:
1477:FreeRTOS/Source/queue.c **** 				{
 1766               	.LM203:
 1767 05b8 D801      		movw r26,r16
 1768 05ba 1896      		adiw r26,8
 1769 05bc 8C91      		ld r24,X
 1770 05be 8823      		tst r24
 1771 05c0 01F0      		breq .L136
1479:FreeRTOS/Source/queue.c **** 					{
 1773               	.LM204:
 1774 05c2 C801      		movw r24,r16
 1775 05c4 0896      		adiw r24,8
 1776 05c6 0E94 0000 		call xTaskRemoveFromEventList
 1777 05ca 8111      		cpse r24,__zero_reg__
1481:FreeRTOS/Source/queue.c **** 					}
 1779               	.LM205:
 1780 05cc 0E94 0000 		call vPortYield
 1781               	.L136:
1493:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1783               	.LM206:
 1784               	/* #APP */
 1785               	 ;  1493 "FreeRTOS/Source/queue.c" 1
 1786 05d0 0F90      		pop		__tmp_reg__
 1787               	 ;  0 "" 2
 1788               	 ;  1493 "FreeRTOS/Source/queue.c" 1
 1789 05d2 0FBE      		out		__SREG__, __tmp_reg__
 1790               	 ;  0 "" 2
1494:FreeRTOS/Source/queue.c **** 			}
 1792               	.LM207:
 1793               	/* #NOAPP */
 1794 05d4 81E0      		ldi r24,lo8(1)
 1795 05d6 00C0      		rjmp .L138
 1796               	.L133:
1498:FreeRTOS/Source/queue.c **** 				{
 1798               	.LM208:
 1799 05d8 2C81      		ldd r18,Y+4
 1800 05da 3D81      		ldd r19,Y+5
 1801 05dc 232B      		or r18,r19
 1802 05de 01F4      		brne .+2
 1803 05e0 00C0      		rjmp .L156
1515:FreeRTOS/Source/queue.c **** 				{
 1805               	.LM209:
 1806 05e2 9111      		cpse r25,__zero_reg__
 1807 05e4 00C0      		rjmp .L140
1519:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1809               	.LM210:
 1810 05e6 CE01      		movw r24,r28
 1811 05e8 0196      		adiw r24,1
 1812 05ea 0E94 0000 		call vTaskInternalSetTimeOutState
 1813               	.L140:
 1814               	.LBE24:
1529:FreeRTOS/Source/queue.c **** 
 1816               	.LM211:
 1817               	/* #APP */
 1818               	 ;  1529 "FreeRTOS/Source/queue.c" 1
 1819 05ee 0F90      		pop		__tmp_reg__
 1820               	 ;  0 "" 2
 1821               	 ;  1529 "FreeRTOS/Source/queue.c" 1
 1822 05f0 0FBE      		out		__SREG__, __tmp_reg__
 1823               	 ;  0 "" 2
1534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1825               	.LM212:
 1826               	/* #NOAPP */
 1827 05f2 0E94 0000 		call vTaskSuspendAll
1535:FreeRTOS/Source/queue.c **** 
 1829               	.LM213:
 1830               	/* #APP */
 1831               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1832 05f6 0FB6      		in		__tmp_reg__, __SREG__
 1833               	 ;  0 "" 2
 1834               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1835 05f8 F894      		cli
 1836               	 ;  0 "" 2
 1837               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1838 05fa 0F92      		push	__tmp_reg__
 1839               	 ;  0 "" 2
 1840               	/* #NOAPP */
 1841 05fc F801      		movw r30,r16
 1842 05fe 858D      		ldd r24,Z+29
 1843 0600 8F3F      		cpi r24,lo8(-1)
 1844 0602 01F4      		brne .L141
1535:FreeRTOS/Source/queue.c **** 
 1846               	.LM214:
 1847 0604 158E      		std Z+29,__zero_reg__
 1848               	.L141:
1535:FreeRTOS/Source/queue.c **** 
 1850               	.LM215:
 1851 0606 D801      		movw r26,r16
 1852 0608 5E96      		adiw r26,30
 1853 060a 8C91      		ld r24,X
 1854 060c 5E97      		sbiw r26,30
 1855 060e 8F3F      		cpi r24,lo8(-1)
 1856 0610 01F4      		brne .L142
1535:FreeRTOS/Source/queue.c **** 
 1858               	.LM216:
 1859 0612 5E96      		adiw r26,30
 1860 0614 1C92      		st X,__zero_reg__
 1861               	.L142:
1535:FreeRTOS/Source/queue.c **** 
 1863               	.LM217:
 1864               	/* #APP */
 1865               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1866 0616 0F90      		pop		__tmp_reg__
 1867               	 ;  0 "" 2
 1868               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1869 0618 0FBE      		out		__SREG__, __tmp_reg__
 1870               	 ;  0 "" 2
1538:FreeRTOS/Source/queue.c **** 		{
 1872               	.LM218:
 1873               	/* #NOAPP */
 1874 061a BE01      		movw r22,r28
 1875 061c 6C5F      		subi r22,-4
 1876 061e 7F4F      		sbci r23,-1
 1877 0620 CE01      		movw r24,r28
 1878 0622 0196      		adiw r24,1
 1879 0624 0E94 0000 		call xTaskCheckForTimeOut
 1880 0628 8111      		cpse r24,__zero_reg__
 1881 062a 00C0      		rjmp .L143
1544:FreeRTOS/Source/queue.c **** 			{
 1883               	.LM219:
 1884 062c C801      		movw r24,r16
 1885 062e 0E94 0000 		call prvIsQueueEmpty
 1886 0632 8823      		tst r24
 1887 0634 01F0      		breq .L144
1550:FreeRTOS/Source/queue.c **** 					{
 1889               	.LM220:
 1890 0636 F801      		movw r30,r16
 1891 0638 8081      		ld r24,Z
 1892 063a 9181      		ldd r25,Z+1
 1893 063c 892B      		or r24,r25
 1894 063e 01F4      		brne .L145
1552:FreeRTOS/Source/queue.c **** 						{
 1896               	.LM221:
 1897               	/* #APP */
 1898               	 ;  1552 "FreeRTOS/Source/queue.c" 1
 1899 0640 0FB6      		in		__tmp_reg__, __SREG__
 1900               	 ;  0 "" 2
 1901               	 ;  1552 "FreeRTOS/Source/queue.c" 1
 1902 0642 F894      		cli
 1903               	 ;  0 "" 2
 1904               	 ;  1552 "FreeRTOS/Source/queue.c" 1
 1905 0644 0F92      		push	__tmp_reg__
 1906               	 ;  0 "" 2
1554:FreeRTOS/Source/queue.c **** 						}
 1908               	.LM222:
 1909               	/* #NOAPP */
 1910 0646 8481      		ldd r24,Z+4
 1911 0648 9581      		ldd r25,Z+5
 1912 064a 0E94 0000 		call xTaskPriorityInherit
 1913 064e F82E      		mov r15,r24
1556:FreeRTOS/Source/queue.c **** 					}
 1915               	.LM223:
 1916               	/* #APP */
 1917               	 ;  1556 "FreeRTOS/Source/queue.c" 1
 1918 0650 0F90      		pop		__tmp_reg__
 1919               	 ;  0 "" 2
 1920               	 ;  1556 "FreeRTOS/Source/queue.c" 1
 1921 0652 0FBE      		out		__SREG__, __tmp_reg__
 1922               	 ;  0 "" 2
 1923               	/* #NOAPP */
 1924               	.L145:
1565:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1926               	.LM224:
 1927 0654 6C81      		ldd r22,Y+4
 1928 0656 7D81      		ldd r23,Y+5
 1929 0658 C601      		movw r24,r12
 1930 065a 0E94 0000 		call vTaskPlaceOnEventList
1566:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1932               	.LM225:
 1933 065e C801      		movw r24,r16
 1934 0660 0E94 0000 		call prvUnlockQueue
1567:FreeRTOS/Source/queue.c **** 				{
 1936               	.LM226:
 1937 0664 0E94 0000 		call xTaskResumeAll
 1938 0668 8823      		tst r24
 1939 066a 01F0      		breq .L157
 1940               	.L146:
 1941 066c 91E0      		ldi r25,lo8(1)
 1942 066e 00C0      		rjmp .L132
 1943               	.L157:
1569:FreeRTOS/Source/queue.c **** 				}
 1945               	.LM227:
 1946 0670 0E94 0000 		call vPortYield
 1947 0674 00C0      		rjmp .L146
 1948               	.L144:
1580:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1950               	.LM228:
 1951 0676 C801      		movw r24,r16
 1952 0678 0E94 0000 		call prvUnlockQueue
1581:FreeRTOS/Source/queue.c **** 			}
 1954               	.LM229:
 1955 067c 0E94 0000 		call xTaskResumeAll
 1956 0680 00C0      		rjmp .L146
 1957               	.L143:
1587:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1959               	.LM230:
 1960 0682 C801      		movw r24,r16
 1961 0684 0E94 0000 		call prvUnlockQueue
1588:FreeRTOS/Source/queue.c **** 
 1963               	.LM231:
 1964 0688 0E94 0000 		call xTaskResumeAll
1594:FreeRTOS/Source/queue.c **** 			{
 1966               	.LM232:
 1967 068c C801      		movw r24,r16
 1968 068e 0E94 0000 		call prvIsQueueEmpty
 1969 0692 8823      		tst r24
 1970 0694 01F0      		breq .L146
1601:FreeRTOS/Source/queue.c **** 					{
 1972               	.LM233:
 1973 0696 FF20      		tst r15
 1974 0698 01F0      		breq .L148
1603:FreeRTOS/Source/queue.c **** 						{
 1976               	.LM234:
 1977               	/* #APP */
 1978               	 ;  1603 "FreeRTOS/Source/queue.c" 1
 1979 069a 0FB6      		in		__tmp_reg__, __SREG__
 1980               	 ;  0 "" 2
 1981               	 ;  1603 "FreeRTOS/Source/queue.c" 1
 1982 069c F894      		cli
 1983               	 ;  0 "" 2
 1984               	 ;  1603 "FreeRTOS/Source/queue.c" 1
 1985 069e 0F92      		push	__tmp_reg__
 1986               	 ;  0 "" 2
 1987               	/* #NOAPP */
 1988               	.LBB25:
 1989               	.LBB26:
 1990               	.LBB27:
2055:FreeRTOS/Source/queue.c **** 		{
 1992               	.LM235:
 1993 06a0 F801      		movw r30,r16
 1994 06a2 8189      		ldd r24,Z+17
 1995 06a4 8823      		tst r24
 1996 06a6 01F0      		breq .L149
2057:FreeRTOS/Source/queue.c **** 		}
 1998               	.LM236:
 1999 06a8 0688      		ldd __tmp_reg__,Z+22
 2000 06aa F789      		ldd r31,Z+23
 2001 06ac E02D      		mov r30,__tmp_reg__
 2002 06ae 8081      		ld r24,Z
 2003 06b0 64E0      		ldi r22,lo8(4)
 2004 06b2 681B      		sub r22,r24
 2005 06b4 00C0      		rjmp .L147
 2006               	.L149:
2061:FreeRTOS/Source/queue.c **** 		}
 2008               	.LM237:
 2009 06b6 60E0      		ldi r22,0
 2010               	.L147:
 2011               	.LBE27:
 2012               	.LBE26:
1613:FreeRTOS/Source/queue.c **** 						}
 2014               	.LM238:
 2015 06b8 D801      		movw r26,r16
 2016 06ba 1496      		adiw r26,4
 2017 06bc 8D91      		ld r24,X+
 2018 06be 9C91      		ld r25,X
 2019 06c0 1597      		sbiw r26,4+1
 2020 06c2 0E94 0000 		call vTaskPriorityDisinheritAfterTimeout
 2021               	.L156:
 2022               	.LBE25:
1615:FreeRTOS/Source/queue.c **** 					}
 2024               	.LM239:
 2025               	/* #APP */
 2026               	 ;  1615 "FreeRTOS/Source/queue.c" 1
 2027 06c6 0F90      		pop		__tmp_reg__
 2028               	 ;  0 "" 2
 2029               	 ;  1615 "FreeRTOS/Source/queue.c" 1
 2030 06c8 0FBE      		out		__SREG__, __tmp_reg__
 2031               	 ;  0 "" 2
 2032               	/* #NOAPP */
 2033               	.L148:
1621:FreeRTOS/Source/queue.c **** 			}
 2035               	.LM240:
 2036 06ca 80E0      		ldi r24,0
 2037               	.L138:
 2038               	/* epilogue start */
1629:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2040               	.LM241:
 2041 06cc 0F90      		pop __tmp_reg__
 2042 06ce 0F90      		pop __tmp_reg__
 2043 06d0 0F90      		pop __tmp_reg__
 2044 06d2 0F90      		pop __tmp_reg__
 2045 06d4 0F90      		pop __tmp_reg__
 2046 06d6 DF91      		pop r29
 2047 06d8 CF91      		pop r28
 2048 06da 1F91      		pop r17
 2049 06dc 0F91      		pop r16
 2050 06de FF90      		pop r15
 2051 06e0 DF90      		pop r13
 2052 06e2 CF90      		pop r12
 2053 06e4 0895      		ret
 2066               	.Lscope12:
 2068               		.stabd	78,0,0
 2073               	.global	xQueuePeek
 2075               	xQueuePeek:
 2076               		.stabd	46,0,0
1633:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2078               	.LM242:
 2079               	.LFBB13:
 2080 06e6 CF92      		push r12
 2081 06e8 DF92      		push r13
 2082 06ea EF92      		push r14
 2083 06ec FF92      		push r15
 2084 06ee 0F93      		push r16
 2085 06f0 1F93      		push r17
 2086 06f2 CF93      		push r28
 2087 06f4 DF93      		push r29
 2088 06f6 00D0      		rcall .
 2089 06f8 00D0      		rcall .
 2090 06fa 1F92      		push __zero_reg__
 2091 06fc CDB7      		in r28,__SP_L__
 2092 06fe DEB7      		in r29,__SP_H__
 2093               	/* prologue: function */
 2094               	/* frame size = 5 */
 2095               	/* stack size = 13 */
 2096               	.L__stack_usage = 13
 2097 0700 8C01      		movw r16,r24
 2098 0702 7B01      		movw r14,r22
 2099 0704 5D83      		std Y+5,r21
 2100 0706 4C83      		std Y+4,r20
1634:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 2102               	.LM243:
 2103 0708 80E0      		ldi r24,0
1741:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2105               	.LM244:
 2106 070a 6801      		movw r12,r16
 2107 070c 91E1      		ldi r25,17
 2108 070e C90E      		add r12,r25
 2109 0710 D11C      		adc r13,__zero_reg__
 2110               	.L159:
1659:FreeRTOS/Source/queue.c **** 		{
 2112               	.LM245:
 2113               	/* #APP */
 2114               	 ;  1659 "FreeRTOS/Source/queue.c" 1
 2115 0712 0FB6      		in		__tmp_reg__, __SREG__
 2116               	 ;  0 "" 2
 2117               	 ;  1659 "FreeRTOS/Source/queue.c" 1
 2118 0714 F894      		cli
 2119               	 ;  0 "" 2
 2120               	 ;  1659 "FreeRTOS/Source/queue.c" 1
 2121 0716 0F92      		push	__tmp_reg__
 2122               	 ;  0 "" 2
 2123               	/* #NOAPP */
 2124               	.LBB28:
1661:FreeRTOS/Source/queue.c **** 
 2126               	.LM246:
 2127 0718 F801      		movw r30,r16
 2128 071a 928D      		ldd r25,Z+26
1665:FreeRTOS/Source/queue.c **** 			{
 2130               	.LM247:
 2131 071c 9923      		tst r25
 2132 071e 01F0      		breq .L160
1670:FreeRTOS/Source/queue.c **** 
 2134               	.LM248:
 2135 0720 C680      		ldd r12,Z+6
 2136 0722 D780      		ldd r13,Z+7
1672:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
 2138               	.LM249:
 2139 0724 B701      		movw r22,r14
 2140 0726 C801      		movw r24,r16
 2141 0728 0E94 0000 		call prvCopyDataFromQueue
1676:FreeRTOS/Source/queue.c **** 
 2143               	.LM250:
 2144 072c F801      		movw r30,r16
 2145 072e D782      		std Z+7,r13
 2146 0730 C682      		std Z+6,r12
1680:FreeRTOS/Source/queue.c **** 				{
 2148               	.LM251:
 2149 0732 8189      		ldd r24,Z+17
 2150 0734 8823      		tst r24
 2151 0736 01F0      		breq .L162
1682:FreeRTOS/Source/queue.c **** 					{
 2153               	.LM252:
 2154 0738 C801      		movw r24,r16
 2155 073a 4196      		adiw r24,17
 2156 073c 0E94 0000 		call xTaskRemoveFromEventList
 2157 0740 8111      		cpse r24,__zero_reg__
1685:FreeRTOS/Source/queue.c **** 					}
 2159               	.LM253:
 2160 0742 0E94 0000 		call vPortYield
 2161               	.L162:
1697:FreeRTOS/Source/queue.c **** 				return pdPASS;
 2163               	.LM254:
 2164               	/* #APP */
 2165               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 2166 0746 0F90      		pop		__tmp_reg__
 2167               	 ;  0 "" 2
 2168               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 2169 0748 0FBE      		out		__SREG__, __tmp_reg__
 2170               	 ;  0 "" 2
1698:FreeRTOS/Source/queue.c **** 			}
 2172               	.LM255:
 2173               	/* #NOAPP */
 2174 074a 81E0      		ldi r24,lo8(1)
 2175 074c 00C0      		rjmp .L164
 2176               	.L160:
1702:FreeRTOS/Source/queue.c **** 				{
 2178               	.LM256:
 2179 074e 2C81      		ldd r18,Y+4
 2180 0750 3D81      		ldd r19,Y+5
 2181 0752 232B      		or r18,r19
 2182 0754 01F4      		brne .L165
1706:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
 2184               	.LM257:
 2185               	/* #APP */
 2186               	 ;  1706 "FreeRTOS/Source/queue.c" 1
 2187 0756 0F90      		pop		__tmp_reg__
 2188               	 ;  0 "" 2
 2189               	 ;  1706 "FreeRTOS/Source/queue.c" 1
 2190 0758 0FBE      		out		__SREG__, __tmp_reg__
 2191               	 ;  0 "" 2
 2192               	/* #NOAPP */
 2193 075a 00C0      		rjmp .L179
 2194               	.L165:
1710:FreeRTOS/Source/queue.c **** 				{
 2196               	.LM258:
 2197 075c 8111      		cpse r24,__zero_reg__
 2198 075e 00C0      		rjmp .L166
1715:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 2200               	.LM259:
 2201 0760 CE01      		movw r24,r28
 2202 0762 0196      		adiw r24,1
 2203 0764 0E94 0000 		call vTaskInternalSetTimeOutState
 2204               	.L166:
 2205               	.LBE28:
1725:FreeRTOS/Source/queue.c **** 
 2207               	.LM260:
 2208               	/* #APP */
 2209               	 ;  1725 "FreeRTOS/Source/queue.c" 1
 2210 0768 0F90      		pop		__tmp_reg__
 2211               	 ;  0 "" 2
 2212               	 ;  1725 "FreeRTOS/Source/queue.c" 1
 2213 076a 0FBE      		out		__SREG__, __tmp_reg__
 2214               	 ;  0 "" 2
1730:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 2216               	.LM261:
 2217               	/* #NOAPP */
 2218 076c 0E94 0000 		call vTaskSuspendAll
1731:FreeRTOS/Source/queue.c **** 
 2220               	.LM262:
 2221               	/* #APP */
 2222               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2223 0770 0FB6      		in		__tmp_reg__, __SREG__
 2224               	 ;  0 "" 2
 2225               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2226 0772 F894      		cli
 2227               	 ;  0 "" 2
 2228               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2229 0774 0F92      		push	__tmp_reg__
 2230               	 ;  0 "" 2
 2231               	/* #NOAPP */
 2232 0776 F801      		movw r30,r16
 2233 0778 858D      		ldd r24,Z+29
 2234 077a 8F3F      		cpi r24,lo8(-1)
 2235 077c 01F4      		brne .L167
1731:FreeRTOS/Source/queue.c **** 
 2237               	.LM263:
 2238 077e 158E      		std Z+29,__zero_reg__
 2239               	.L167:
1731:FreeRTOS/Source/queue.c **** 
 2241               	.LM264:
 2242 0780 F801      		movw r30,r16
 2243 0782 868D      		ldd r24,Z+30
 2244 0784 8F3F      		cpi r24,lo8(-1)
 2245 0786 01F4      		brne .L168
1731:FreeRTOS/Source/queue.c **** 
 2247               	.LM265:
 2248 0788 168E      		std Z+30,__zero_reg__
 2249               	.L168:
1731:FreeRTOS/Source/queue.c **** 
 2251               	.LM266:
 2252               	/* #APP */
 2253               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2254 078a 0F90      		pop		__tmp_reg__
 2255               	 ;  0 "" 2
 2256               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2257 078c 0FBE      		out		__SREG__, __tmp_reg__
 2258               	 ;  0 "" 2
1734:FreeRTOS/Source/queue.c **** 		{
 2260               	.LM267:
 2261               	/* #NOAPP */
 2262 078e BE01      		movw r22,r28
 2263 0790 6C5F      		subi r22,-4
 2264 0792 7F4F      		sbci r23,-1
 2265 0794 CE01      		movw r24,r28
 2266 0796 0196      		adiw r24,1
 2267 0798 0E94 0000 		call xTaskCheckForTimeOut
 2268 079c 8111      		cpse r24,__zero_reg__
 2269 079e 00C0      		rjmp .L169
1738:FreeRTOS/Source/queue.c **** 			{
 2271               	.LM268:
 2272 07a0 C801      		movw r24,r16
 2273 07a2 0E94 0000 		call prvIsQueueEmpty
 2274 07a6 8823      		tst r24
 2275 07a8 01F0      		breq .L170
1741:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2277               	.LM269:
 2278 07aa 6C81      		ldd r22,Y+4
 2279 07ac 7D81      		ldd r23,Y+5
 2280 07ae C601      		movw r24,r12
 2281 07b0 0E94 0000 		call vTaskPlaceOnEventList
1742:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2283               	.LM270:
 2284 07b4 C801      		movw r24,r16
 2285 07b6 0E94 0000 		call prvUnlockQueue
1743:FreeRTOS/Source/queue.c **** 				{
 2287               	.LM271:
 2288 07ba 0E94 0000 		call xTaskResumeAll
 2289 07be 8823      		tst r24
 2290 07c0 01F0      		breq .L180
 2291               	.L172:
 2292 07c2 81E0      		ldi r24,lo8(1)
 2293 07c4 00C0      		rjmp .L159
 2294               	.L180:
1745:FreeRTOS/Source/queue.c **** 				}
 2296               	.LM272:
 2297 07c6 0E94 0000 		call vPortYield
 2298 07ca 00C0      		rjmp .L172
 2299               	.L170:
1756:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 2301               	.LM273:
 2302 07cc C801      		movw r24,r16
 2303 07ce 0E94 0000 		call prvUnlockQueue
1757:FreeRTOS/Source/queue.c **** 			}
 2305               	.LM274:
 2306 07d2 0E94 0000 		call xTaskResumeAll
 2307 07d6 00C0      		rjmp .L172
 2308               	.L169:
1764:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 2310               	.LM275:
 2311 07d8 C801      		movw r24,r16
 2312 07da 0E94 0000 		call prvUnlockQueue
1765:FreeRTOS/Source/queue.c **** 
 2314               	.LM276:
 2315 07de 0E94 0000 		call xTaskResumeAll
1767:FreeRTOS/Source/queue.c **** 			{
 2317               	.LM277:
 2318 07e2 C801      		movw r24,r16
 2319 07e4 0E94 0000 		call prvIsQueueEmpty
 2320 07e8 8823      		tst r24
 2321 07ea 01F0      		breq .L172
 2322               	.L179:
1770:FreeRTOS/Source/queue.c **** 			}
 2324               	.LM278:
 2325 07ec 80E0      		ldi r24,0
 2326               	.L164:
 2327               	/* epilogue start */
1778:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2329               	.LM279:
 2330 07ee 0F90      		pop __tmp_reg__
 2331 07f0 0F90      		pop __tmp_reg__
 2332 07f2 0F90      		pop __tmp_reg__
 2333 07f4 0F90      		pop __tmp_reg__
 2334 07f6 0F90      		pop __tmp_reg__
 2335 07f8 DF91      		pop r29
 2336 07fa CF91      		pop r28
 2337 07fc 1F91      		pop r17
 2338 07fe 0F91      		pop r16
 2339 0800 FF90      		pop r15
 2340 0802 EF90      		pop r14
 2341 0804 DF90      		pop r13
 2342 0806 CF90      		pop r12
 2343 0808 0895      		ret
 2353               	.Lscope13:
 2355               		.stabd	78,0,0
 2360               	.global	xQueueReceiveFromISR
 2362               	xQueueReceiveFromISR:
 2363               		.stabd	46,0,0
1782:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2365               	.LM280:
 2366               	.LFBB14:
 2367 080a EF92      		push r14
 2368 080c FF92      		push r15
 2369 080e 0F93      		push r16
 2370 0810 1F93      		push r17
 2371 0812 CF93      		push r28
 2372 0814 DF93      		push r29
 2373               	/* prologue: function */
 2374               	/* frame size = 0 */
 2375               	/* stack size = 6 */
 2376               	.L__stack_usage = 6
 2377               	.LBB29:
1808:FreeRTOS/Source/queue.c **** 
 2379               	.LM281:
 2380 0816 FC01      		movw r30,r24
 2381 0818 028D      		ldd r16,Z+26
1811:FreeRTOS/Source/queue.c **** 		{
 2383               	.LM282:
 2384 081a 0023      		tst r16
 2385 081c 01F0      		breq .L186
 2386 081e 7A01      		movw r14,r20
 2387 0820 EC01      		movw r28,r24
 2388               	.LBB30:
1813:FreeRTOS/Source/queue.c **** 
 2390               	.LM283:
 2391 0822 158D      		ldd r17,Z+29
1817:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2393               	.LM284:
 2394 0824 0E94 0000 		call prvCopyDataFromQueue
1818:FreeRTOS/Source/queue.c **** 
 2396               	.LM285:
 2397 0828 0150      		subi r16,lo8(-(-1))
 2398 082a 0A8F      		std Y+26,r16
1824:FreeRTOS/Source/queue.c **** 			{
 2400               	.LM286:
 2401 082c 1F3F      		cpi r17,lo8(-1)
 2402 082e 01F4      		brne .L183
1826:FreeRTOS/Source/queue.c **** 				{
 2404               	.LM287:
 2405 0830 8885      		ldd r24,Y+8
 2406 0832 8823      		tst r24
 2407 0834 01F0      		breq .L193
1828:FreeRTOS/Source/queue.c **** 					{
 2409               	.LM288:
 2410 0836 CE01      		movw r24,r28
 2411 0838 0896      		adiw r24,8
 2412 083a 0E94 0000 		call xTaskRemoveFromEventList
 2413 083e 8823      		tst r24
 2414 0840 01F0      		breq .L193
1832:FreeRTOS/Source/queue.c **** 						{
 2416               	.LM289:
 2417 0842 E114      		cp r14,__zero_reg__
 2418 0844 F104      		cpc r15,__zero_reg__
 2419 0846 01F0      		breq .L193
1834:FreeRTOS/Source/queue.c **** 						}
 2421               	.LM290:
 2422 0848 81E0      		ldi r24,lo8(1)
 2423 084a F701      		movw r30,r14
 2424 084c 8083      		st Z,r24
 2425 084e 00C0      		rjmp .L182
 2426               	.L183:
1855:FreeRTOS/Source/queue.c **** 			}
 2428               	.LM291:
 2429 0850 1F5F      		subi r17,lo8(-(1))
 2430 0852 1D8F      		std Y+29,r17
 2431               	.L193:
1858:FreeRTOS/Source/queue.c **** 		}
 2433               	.LM292:
 2434 0854 81E0      		ldi r24,lo8(1)
 2435 0856 00C0      		rjmp .L182
 2436               	.L186:
 2437               	.LBE30:
1862:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2439               	.LM293:
 2440 0858 80E0      		ldi r24,0
 2441               	.L182:
 2442               	/* epilogue start */
 2443               	.LBE29:
1869:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2445               	.LM294:
 2446 085a DF91      		pop r29
 2447 085c CF91      		pop r28
 2448 085e 1F91      		pop r17
 2449 0860 0F91      		pop r16
 2450 0862 FF90      		pop r15
 2451 0864 EF90      		pop r14
 2452 0866 0895      		ret
 2463               	.Lscope14:
 2465               		.stabd	78,0,0
 2469               	.global	xQueuePeekFromISR
 2471               	xQueuePeekFromISR:
 2472               		.stabd	46,0,0
1873:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2474               	.LM295:
 2475               	.LFBB15:
 2476 0868 0F93      		push r16
 2477 086a 1F93      		push r17
 2478 086c CF93      		push r28
 2479 086e DF93      		push r29
 2480               	/* prologue: function */
 2481               	/* frame size = 0 */
 2482               	/* stack size = 4 */
 2483               	.L__stack_usage = 4
1902:FreeRTOS/Source/queue.c **** 		{
 2485               	.LM296:
 2486 0870 FC01      		movw r30,r24
 2487 0872 228D      		ldd r18,Z+26
 2488 0874 2223      		tst r18
 2489 0876 01F0      		breq .L196
 2490 0878 EC01      		movw r28,r24
1908:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2492               	.LM297:
 2493 087a 0681      		ldd r16,Z+6
 2494 087c 1781      		ldd r17,Z+7
1909:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2496               	.LM298:
 2497 087e 0E94 0000 		call prvCopyDataFromQueue
1910:FreeRTOS/Source/queue.c **** 
 2499               	.LM299:
 2500 0882 1F83      		std Y+7,r17
 2501 0884 0E83      		std Y+6,r16
1912:FreeRTOS/Source/queue.c **** 		}
 2503               	.LM300:
 2504 0886 81E0      		ldi r24,lo8(1)
 2505 0888 00C0      		rjmp .L195
 2506               	.L196:
1916:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2508               	.LM301:
 2509 088a 80E0      		ldi r24,0
 2510               	.L195:
 2511               	/* epilogue start */
1923:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2513               	.LM302:
 2514 088c DF91      		pop r29
 2515 088e CF91      		pop r28
 2516 0890 1F91      		pop r17
 2517 0892 0F91      		pop r16
 2518 0894 0895      		ret
 2524               	.Lscope15:
 2526               		.stabd	78,0,0
 2529               	.global	uxQueueMessagesWaiting
 2531               	uxQueueMessagesWaiting:
 2532               		.stabd	46,0,0
1927:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2534               	.LM303:
 2535               	.LFBB16:
 2536               	/* prologue: function */
 2537               	/* frame size = 0 */
 2538               	/* stack size = 0 */
 2539               	.L__stack_usage = 0
1932:FreeRTOS/Source/queue.c **** 	{
 2541               	.LM304:
 2542               	/* #APP */
 2543               	 ;  1932 "FreeRTOS/Source/queue.c" 1
 2544 0896 0FB6      		in		__tmp_reg__, __SREG__
 2545               	 ;  0 "" 2
 2546               	 ;  1932 "FreeRTOS/Source/queue.c" 1
 2547 0898 F894      		cli
 2548               	 ;  0 "" 2
 2549               	 ;  1932 "FreeRTOS/Source/queue.c" 1
 2550 089a 0F92      		push	__tmp_reg__
 2551               	 ;  0 "" 2
1934:FreeRTOS/Source/queue.c **** 	}
 2553               	.LM305:
 2554               	/* #NOAPP */
 2555 089c FC01      		movw r30,r24
 2556 089e 828D      		ldd r24,Z+26
1936:FreeRTOS/Source/queue.c **** 
 2558               	.LM306:
 2559               	/* #APP */
 2560               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2561 08a0 0F90      		pop		__tmp_reg__
 2562               	 ;  0 "" 2
 2563               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2564 08a2 0FBE      		out		__SREG__, __tmp_reg__
 2565               	 ;  0 "" 2
1939:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2567               	.LM307:
 2568               	/* #NOAPP */
 2569 08a4 0895      		ret
 2574               	.Lscope16:
 2576               		.stabd	78,0,0
 2579               	.global	uxQueueSpacesAvailable
 2581               	uxQueueSpacesAvailable:
 2582               		.stabd	46,0,0
1943:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2584               	.LM308:
 2585               	.LFBB17:
 2586               	/* prologue: function */
 2587               	/* frame size = 0 */
 2588               	/* stack size = 0 */
 2589               	.L__stack_usage = 0
1949:FreeRTOS/Source/queue.c **** 	{
 2591               	.LM309:
 2592               	/* #APP */
 2593               	 ;  1949 "FreeRTOS/Source/queue.c" 1
 2594 08a6 0FB6      		in		__tmp_reg__, __SREG__
 2595               	 ;  0 "" 2
 2596               	 ;  1949 "FreeRTOS/Source/queue.c" 1
 2597 08a8 F894      		cli
 2598               	 ;  0 "" 2
 2599               	 ;  1949 "FreeRTOS/Source/queue.c" 1
 2600 08aa 0F92      		push	__tmp_reg__
 2601               	 ;  0 "" 2
1951:FreeRTOS/Source/queue.c **** 	}
 2603               	.LM310:
 2604               	/* #NOAPP */
 2605 08ac FC01      		movw r30,r24
 2606 08ae 228D      		ldd r18,Z+26
1953:FreeRTOS/Source/queue.c **** 
 2608               	.LM311:
 2609               	/* #APP */
 2610               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2611 08b0 0F90      		pop		__tmp_reg__
 2612               	 ;  0 "" 2
 2613               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2614 08b2 0FBE      		out		__SREG__, __tmp_reg__
 2615               	 ;  0 "" 2
1955:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2617               	.LM312:
 2618               	/* #NOAPP */
 2619 08b4 838D      		ldd r24,Z+27
1956:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2621               	.LM313:
 2622 08b6 821B      		sub r24,r18
 2623 08b8 0895      		ret
 2625               	.Lscope17:
 2627               		.stabd	78,0,0
 2630               	.global	uxQueueMessagesWaitingFromISR
 2632               	uxQueueMessagesWaitingFromISR:
 2633               		.stabd	46,0,0
1960:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2635               	.LM314:
 2636               	.LFBB18:
 2637               	/* prologue: function */
 2638               	/* frame size = 0 */
 2639               	/* stack size = 0 */
 2640               	.L__stack_usage = 0
1965:FreeRTOS/Source/queue.c **** 
 2642               	.LM315:
 2643 08ba FC01      		movw r30,r24
 2644 08bc 828D      		ldd r24,Z+26
1968:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2646               	.LM316:
 2647 08be 0895      		ret
 2652               	.Lscope18:
 2654               		.stabd	78,0,0
 2657               	.global	vQueueDelete
 2659               	vQueueDelete:
 2660               		.stabd	46,0,0
1972:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2662               	.LM317:
 2663               	.LFBB19:
 2664               	/* prologue: function */
 2665               	/* frame size = 0 */
 2666               	/* stack size = 0 */
 2667               	.L__stack_usage = 0
1988:FreeRTOS/Source/queue.c **** 	}
 2669               	.LM318:
 2670 08c0 0C94 0000 		jmp vPortFree
 2672               	.Lscope19:
 2674               		.stabd	78,0,0
 2677               	.global	xQueueIsQueueEmptyFromISR
 2679               	xQueueIsQueueEmptyFromISR:
 2680               		.stabd	46,0,0
2309:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2682               	.LM319:
 2683               	.LFBB20:
 2684               	/* prologue: function */
 2685               	/* frame size = 0 */
 2686               	/* stack size = 0 */
 2687               	.L__stack_usage = 0
2314:FreeRTOS/Source/queue.c **** 	{
 2689               	.LM320:
 2690 08c4 FC01      		movw r30,r24
 2691 08c6 928D      		ldd r25,Z+26
2323:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2693               	.LM321:
 2694 08c8 81E0      		ldi r24,lo8(1)
 2695 08ca 9111      		cpse r25,__zero_reg__
 2696 08cc 80E0      		ldi r24,0
 2697               	.L202:
2324:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2699               	.LM322:
 2700 08ce 0895      		ret
 2702               	.Lscope20:
 2704               		.stabd	78,0,0
 2707               	.global	xQueueIsQueueFullFromISR
 2709               	xQueueIsQueueFullFromISR:
 2710               		.stabd	46,0,0
2343:FreeRTOS/Source/queue.c **** 
2344:FreeRTOS/Source/queue.c **** 	return xReturn;
2345:FreeRTOS/Source/queue.c **** }
2346:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2347:FreeRTOS/Source/queue.c **** 
2348:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2349:FreeRTOS/Source/queue.c **** {
 2712               	.LM323:
 2713               	.LFBB21:
 2714               	/* prologue: function */
 2715               	/* frame size = 0 */
 2716               	/* stack size = 0 */
 2717               	.L__stack_usage = 0
 2718 08d0 FC01      		movw r30,r24
2350:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2351:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
2352:FreeRTOS/Source/queue.c **** 
2353:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2354:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2720               	.LM324:
 2721 08d2 928D      		ldd r25,Z+26
2355:FreeRTOS/Source/queue.c **** 	{
2356:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2357:FreeRTOS/Source/queue.c **** 	}
2358:FreeRTOS/Source/queue.c **** 	else
2359:FreeRTOS/Source/queue.c **** 	{
2360:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2361:FreeRTOS/Source/queue.c **** 	}
2362:FreeRTOS/Source/queue.c **** 
2363:FreeRTOS/Source/queue.c **** 	return xReturn;
 2723               	.LM325:
 2724 08d4 81E0      		ldi r24,lo8(1)
 2725 08d6 238D      		ldd r18,Z+27
 2726 08d8 2913      		cpse r18,r25
 2727 08da 80E0      		ldi r24,0
 2728               	.L207:
2364:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2730               	.LM326:
 2731 08dc 0895      		ret
 2733               	.Lscope21:
 2735               		.stabd	78,0,0
 2740               	.global	xQueueCRSend
 2742               	xQueueCRSend:
 2743               		.stabd	46,0,0
2365:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2366:FreeRTOS/Source/queue.c **** 
2367:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2368:FreeRTOS/Source/queue.c **** 
2369:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2370:FreeRTOS/Source/queue.c **** 	{
 2745               	.LM327:
 2746               	.LFBB22:
 2747 08de CF93      		push r28
 2748 08e0 DF93      		push r29
 2749               	/* prologue: function */
 2750               	/* frame size = 0 */
 2751               	/* stack size = 2 */
 2752               	.L__stack_usage = 2
 2753 08e2 EC01      		movw r28,r24
2371:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2372:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2373:FreeRTOS/Source/queue.c **** 
2374:FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2375:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2376:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2377:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2755               	.LM328:
 2756               	/* #APP */
 2757               	 ;  2377 "FreeRTOS/Source/queue.c" 1
 2758 08e4 F894      		cli
 2759               	 ;  0 "" 2
 2760               	/* #NOAPP */
 2761               	.LBB33:
 2762               	.LBB34:
2331:FreeRTOS/Source/queue.c **** 	{
 2764               	.LM329:
 2765               	/* #APP */
 2766               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 2767 08e6 0FB6      		in		__tmp_reg__, __SREG__
 2768               	 ;  0 "" 2
 2769               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 2770 08e8 F894      		cli
 2771               	 ;  0 "" 2
 2772               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 2773 08ea 0F92      		push	__tmp_reg__
 2774               	 ;  0 "" 2
2333:FreeRTOS/Source/queue.c **** 		{
 2776               	.LM330:
 2777               	/* #NOAPP */
 2778 08ec 8A8D      		ldd r24,Y+26
 2779 08ee 9B8D      		ldd r25,Y+27
2342:FreeRTOS/Source/queue.c **** 
 2781               	.LM331:
 2782               	/* #APP */
 2783               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 2784 08f0 0F90      		pop		__tmp_reg__
 2785               	 ;  0 "" 2
 2786               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 2787 08f2 0FBE      		out		__SREG__, __tmp_reg__
 2788               	 ;  0 "" 2
 2789               	/* #NOAPP */
 2790               	.LBE34:
 2791               	.LBE33:
2378:FreeRTOS/Source/queue.c **** 		{
2379:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 2793               	.LM332:
 2794 08f4 8913      		cpse r24,r25
 2795 08f6 00C0      		rjmp .L209
2380:FreeRTOS/Source/queue.c **** 			{
2381:FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2382:FreeRTOS/Source/queue.c **** 				posting? */
2383:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2797               	.LM333:
 2798 08f8 4115      		cp r20,__zero_reg__
 2799 08fa 5105      		cpc r21,__zero_reg__
 2800 08fc 01F0      		breq .L210
2384:FreeRTOS/Source/queue.c **** 				{
2385:FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2386:FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
2387:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 2802               	.LM334:
 2803 08fe BE01      		movw r22,r28
 2804 0900 685F      		subi r22,-8
 2805 0902 7F4F      		sbci r23,-1
 2806 0904 CA01      		movw r24,r20
 2807 0906 0E94 0000 		call vCoRoutineAddToDelayedList
2388:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2809               	.LM335:
 2810               	/* #APP */
 2811               	 ;  2388 "FreeRTOS/Source/queue.c" 1
 2812 090a 7894      		sei
 2813               	 ;  0 "" 2
2389:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2815               	.LM336:
 2816               	/* #NOAPP */
 2817 090c 8CEF      		ldi r24,lo8(-4)
 2818 090e 00C0      		rjmp .L211
 2819               	.L210:
2390:FreeRTOS/Source/queue.c **** 				}
2391:FreeRTOS/Source/queue.c **** 				else
2392:FreeRTOS/Source/queue.c **** 				{
2393:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2821               	.LM337:
 2822               	/* #APP */
 2823               	 ;  2393 "FreeRTOS/Source/queue.c" 1
 2824 0910 7894      		sei
 2825               	 ;  0 "" 2
2394:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2827               	.LM338:
 2828               	/* #NOAPP */
 2829 0912 80E0      		ldi r24,0
 2830 0914 00C0      		rjmp .L211
 2831               	.L209:
2395:FreeRTOS/Source/queue.c **** 				}
2396:FreeRTOS/Source/queue.c **** 			}
2397:FreeRTOS/Source/queue.c **** 		}
2398:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2833               	.LM339:
 2834               	/* #APP */
 2835               	 ;  2398 "FreeRTOS/Source/queue.c" 1
 2836 0916 7894      		sei
 2837               	 ;  0 "" 2
2399:FreeRTOS/Source/queue.c **** 
2400:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2839               	.LM340:
 2840               	 ;  2400 "FreeRTOS/Source/queue.c" 1
 2841 0918 F894      		cli
 2842               	 ;  0 "" 2
2401:FreeRTOS/Source/queue.c **** 		{
2402:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2844               	.LM341:
 2845               	/* #NOAPP */
 2846 091a 8A8D      		ldd r24,Y+26
 2847 091c 8917      		cp r24,r25
 2848 091e 00F4      		brsh .L215
2403:FreeRTOS/Source/queue.c **** 			{
2404:FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2405:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2850               	.LM342:
 2851 0920 40E0      		ldi r20,0
 2852 0922 CE01      		movw r24,r28
 2853 0924 0E94 0000 		call prvCopyDataToQueue
2406:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2407:FreeRTOS/Source/queue.c **** 
2408:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2409:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2855               	.LM343:
 2856 0928 8989      		ldd r24,Y+17
 2857 092a 8111      		cpse r24,__zero_reg__
 2858 092c 00C0      		rjmp .L213
 2859               	.L214:
2406:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
 2861               	.LM344:
 2862 092e 81E0      		ldi r24,lo8(1)
 2863 0930 00C0      		rjmp .L212
 2864               	.L213:
2410:FreeRTOS/Source/queue.c **** 				{
2411:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2412:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2413:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2414:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2415:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2866               	.LM345:
 2867 0932 CE01      		movw r24,r28
 2868 0934 4196      		adiw r24,17
 2869 0936 0E94 0000 		call xCoRoutineRemoveFromEventList
 2870 093a 8823      		tst r24
 2871 093c 01F0      		breq .L214
2416:FreeRTOS/Source/queue.c **** 					{
2417:FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2418:FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
2419:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2873               	.LM346:
 2874 093e 8BEF      		ldi r24,lo8(-5)
 2875 0940 00C0      		rjmp .L212
 2876               	.L215:
2420:FreeRTOS/Source/queue.c **** 					}
2421:FreeRTOS/Source/queue.c **** 					else
2422:FreeRTOS/Source/queue.c **** 					{
2423:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2424:FreeRTOS/Source/queue.c **** 					}
2425:FreeRTOS/Source/queue.c **** 				}
2426:FreeRTOS/Source/queue.c **** 				else
2427:FreeRTOS/Source/queue.c **** 				{
2428:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2429:FreeRTOS/Source/queue.c **** 				}
2430:FreeRTOS/Source/queue.c **** 			}
2431:FreeRTOS/Source/queue.c **** 			else
2432:FreeRTOS/Source/queue.c **** 			{
2433:FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
 2878               	.LM347:
 2879 0942 80E0      		ldi r24,0
 2880               	.L212:
2434:FreeRTOS/Source/queue.c **** 			}
2435:FreeRTOS/Source/queue.c **** 		}
2436:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2882               	.LM348:
 2883               	/* #APP */
 2884               	 ;  2436 "FreeRTOS/Source/queue.c" 1
 2885 0944 7894      		sei
 2886               	 ;  0 "" 2
 2887               	/* #NOAPP */
 2888               	.L211:
 2889               	/* epilogue start */
2437:FreeRTOS/Source/queue.c **** 
2438:FreeRTOS/Source/queue.c **** 		return xReturn;
2439:FreeRTOS/Source/queue.c **** 	}
 2891               	.LM349:
 2892 0946 DF91      		pop r29
 2893 0948 CF91      		pop r28
 2894 094a 0895      		ret
 2899               	.Lscope22:
 2901               		.stabd	78,0,0
 2906               	.global	xQueueCRReceive
 2908               	xQueueCRReceive:
 2909               		.stabd	46,0,0
2440:FreeRTOS/Source/queue.c **** 
2441:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2442:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2443:FreeRTOS/Source/queue.c **** 
2444:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2445:FreeRTOS/Source/queue.c **** 
2446:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2447:FreeRTOS/Source/queue.c **** 	{
 2911               	.LM350:
 2912               	.LFBB23:
 2913 094c CF93      		push r28
 2914 094e DF93      		push r29
 2915               	/* prologue: function */
 2916               	/* frame size = 0 */
 2917               	/* stack size = 2 */
 2918               	.L__stack_usage = 2
 2919 0950 EC01      		movw r28,r24
 2920 0952 FB01      		movw r30,r22
2448:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2449:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2450:FreeRTOS/Source/queue.c **** 
2451:FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2452:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2453:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2454:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2922               	.LM351:
 2923               	/* #APP */
 2924               	 ;  2454 "FreeRTOS/Source/queue.c" 1
 2925 0954 F894      		cli
 2926               	 ;  0 "" 2
2455:FreeRTOS/Source/queue.c **** 		{
2456:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2928               	.LM352:
 2929               	/* #NOAPP */
 2930 0956 8A8D      		ldd r24,Y+26
 2931 0958 8111      		cpse r24,__zero_reg__
 2932 095a 00C0      		rjmp .L220
2457:FreeRTOS/Source/queue.c **** 			{
2458:FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2459:FreeRTOS/Source/queue.c **** 				leave with nothing? */
2460:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2934               	.LM353:
 2935 095c 4115      		cp r20,__zero_reg__
 2936 095e 5105      		cpc r21,__zero_reg__
 2937 0960 01F0      		breq .L221
2461:FreeRTOS/Source/queue.c **** 				{
2462:FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2463:FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
2464:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2939               	.LM354:
 2940 0962 BE01      		movw r22,r28
 2941 0964 6F5E      		subi r22,-17
 2942 0966 7F4F      		sbci r23,-1
 2943 0968 CA01      		movw r24,r20
 2944 096a 0E94 0000 		call vCoRoutineAddToDelayedList
2465:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2946               	.LM355:
 2947               	/* #APP */
 2948               	 ;  2465 "FreeRTOS/Source/queue.c" 1
 2949 096e 7894      		sei
 2950               	 ;  0 "" 2
2466:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2952               	.LM356:
 2953               	/* #NOAPP */
 2954 0970 8CEF      		ldi r24,lo8(-4)
 2955 0972 00C0      		rjmp .L222
 2956               	.L221:
2467:FreeRTOS/Source/queue.c **** 				}
2468:FreeRTOS/Source/queue.c **** 				else
2469:FreeRTOS/Source/queue.c **** 				{
2470:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2958               	.LM357:
 2959               	/* #APP */
 2960               	 ;  2470 "FreeRTOS/Source/queue.c" 1
 2961 0974 7894      		sei
 2962               	 ;  0 "" 2
2471:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2964               	.LM358:
 2965               	/* #NOAPP */
 2966 0976 80E0      		ldi r24,0
 2967 0978 00C0      		rjmp .L222
 2968               	.L220:
2472:FreeRTOS/Source/queue.c **** 				}
2473:FreeRTOS/Source/queue.c **** 			}
2474:FreeRTOS/Source/queue.c **** 			else
2475:FreeRTOS/Source/queue.c **** 			{
2476:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2477:FreeRTOS/Source/queue.c **** 			}
2478:FreeRTOS/Source/queue.c **** 		}
2479:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2970               	.LM359:
 2971               	/* #APP */
 2972               	 ;  2479 "FreeRTOS/Source/queue.c" 1
 2973 097a 7894      		sei
 2974               	 ;  0 "" 2
2480:FreeRTOS/Source/queue.c **** 
2481:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2976               	.LM360:
 2977               	 ;  2481 "FreeRTOS/Source/queue.c" 1
 2978 097c F894      		cli
 2979               	 ;  0 "" 2
2482:FreeRTOS/Source/queue.c **** 		{
2483:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2981               	.LM361:
 2982               	/* #NOAPP */
 2983 097e 8A8D      		ldd r24,Y+26
 2984 0980 8823      		tst r24
 2985 0982 01F0      		breq .L227
2484:FreeRTOS/Source/queue.c **** 			{
2485:FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
2486:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2987               	.LM362:
 2988 0984 4C8D      		ldd r20,Y+28
 2989 0986 50E0      		ldi r21,0
 2990 0988 2E81      		ldd r18,Y+6
 2991 098a 3F81      		ldd r19,Y+7
 2992 098c 240F      		add r18,r20
 2993 098e 351F      		adc r19,r21
 2994 0990 3F83      		std Y+7,r19
 2995 0992 2E83      		std Y+6,r18
2487:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2997               	.LM363:
 2998 0994 8C81      		ldd r24,Y+4
 2999 0996 9D81      		ldd r25,Y+5
 3000 0998 2817      		cp r18,r24
 3001 099a 3907      		cpc r19,r25
 3002 099c 00F0      		brlo .L224
2488:FreeRTOS/Source/queue.c **** 				{
2489:FreeRTOS/Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 3004               	.LM364:
 3005 099e 8881      		ld r24,Y
 3006 09a0 9981      		ldd r25,Y+1
 3007 09a2 9F83      		std Y+7,r25
 3008 09a4 8E83      		std Y+6,r24
 3009               	.L224:
2490:FreeRTOS/Source/queue.c **** 				}
2491:FreeRTOS/Source/queue.c **** 				else
2492:FreeRTOS/Source/queue.c **** 				{
2493:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2494:FreeRTOS/Source/queue.c **** 				}
2495:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 3011               	.LM365:
 3012 09a6 9A8D      		ldd r25,Y+26
 3013 09a8 9150      		subi r25,lo8(-(-1))
 3014 09aa 9A8F      		std Y+26,r25
2496:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
 3016               	.LM366:
 3017 09ac 6E81      		ldd r22,Y+6
 3018 09ae 7F81      		ldd r23,Y+7
 3019 09b0 CF01      		movw r24,r30
 3020 09b2 0E94 0000 		call memcpy
2497:FreeRTOS/Source/queue.c **** 
2498:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2499:FreeRTOS/Source/queue.c **** 
2500:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2501:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 3022               	.LM367:
 3023 09b6 8885      		ldd r24,Y+8
 3024 09b8 8111      		cpse r24,__zero_reg__
 3025 09ba 00C0      		rjmp .L225
 3026               	.L226:
2498:FreeRTOS/Source/queue.c **** 
 3028               	.LM368:
 3029 09bc 81E0      		ldi r24,lo8(1)
 3030 09be 00C0      		rjmp .L223
 3031               	.L225:
2502:FreeRTOS/Source/queue.c **** 				{
2503:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2504:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2505:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2506:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2507:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 3033               	.LM369:
 3034 09c0 CE01      		movw r24,r28
 3035 09c2 0896      		adiw r24,8
 3036 09c4 0E94 0000 		call xCoRoutineRemoveFromEventList
 3037 09c8 8823      		tst r24
 3038 09ca 01F0      		breq .L226
2508:FreeRTOS/Source/queue.c **** 					{
2509:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 3040               	.LM370:
 3041 09cc 8BEF      		ldi r24,lo8(-5)
 3042 09ce 00C0      		rjmp .L223
 3043               	.L227:
2510:FreeRTOS/Source/queue.c **** 					}
2511:FreeRTOS/Source/queue.c **** 					else
2512:FreeRTOS/Source/queue.c **** 					{
2513:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2514:FreeRTOS/Source/queue.c **** 					}
2515:FreeRTOS/Source/queue.c **** 				}
2516:FreeRTOS/Source/queue.c **** 				else
2517:FreeRTOS/Source/queue.c **** 				{
2518:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2519:FreeRTOS/Source/queue.c **** 				}
2520:FreeRTOS/Source/queue.c **** 			}
2521:FreeRTOS/Source/queue.c **** 			else
2522:FreeRTOS/Source/queue.c **** 			{
2523:FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
 3045               	.LM371:
 3046 09d0 80E0      		ldi r24,0
 3047               	.L223:
2524:FreeRTOS/Source/queue.c **** 			}
2525:FreeRTOS/Source/queue.c **** 		}
2526:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 3049               	.LM372:
 3050               	/* #APP */
 3051               	 ;  2526 "FreeRTOS/Source/queue.c" 1
 3052 09d2 7894      		sei
 3053               	 ;  0 "" 2
 3054               	/* #NOAPP */
 3055               	.L222:
 3056               	/* epilogue start */
2527:FreeRTOS/Source/queue.c **** 
2528:FreeRTOS/Source/queue.c **** 		return xReturn;
2529:FreeRTOS/Source/queue.c **** 	}
 3058               	.LM373:
 3059 09d4 DF91      		pop r29
 3060 09d6 CF91      		pop r28
 3061 09d8 0895      		ret
 3066               	.Lscope23:
 3068               		.stabd	78,0,0
 3073               	.global	xQueueCRSendFromISR
 3075               	xQueueCRSendFromISR:
 3076               		.stabd	46,0,0
2530:FreeRTOS/Source/queue.c **** 
2531:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2532:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2533:FreeRTOS/Source/queue.c **** 
2534:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2535:FreeRTOS/Source/queue.c **** 
2536:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2537:FreeRTOS/Source/queue.c **** 	{
 3078               	.LM374:
 3079               	.LFBB24:
 3080 09da 0F93      		push r16
 3081 09dc 1F93      		push r17
 3082 09de CF93      		push r28
 3083               	/* prologue: function */
 3084               	/* frame size = 0 */
 3085               	/* stack size = 3 */
 3086               	.L__stack_usage = 3
 3087 09e0 8C01      		movw r16,r24
 3088 09e2 C42F      		mov r28,r20
2538:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2539:FreeRTOS/Source/queue.c **** 
2540:FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2541:FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2542:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 3090               	.LM375:
 3091 09e4 FC01      		movw r30,r24
 3092 09e6 928D      		ldd r25,Z+26
 3093 09e8 838D      		ldd r24,Z+27
 3094 09ea 9817      		cp r25,r24
 3095 09ec 00F0      		brlo .L232
 3096               	.L234:
 3097 09ee 4C2F      		mov r20,r28
 3098 09f0 00C0      		rjmp .L233
 3099               	.L232:
2543:FreeRTOS/Source/queue.c **** 		{
2544:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 3101               	.LM376:
 3102 09f2 40E0      		ldi r20,0
 3103 09f4 C801      		movw r24,r16
 3104 09f6 0E94 0000 		call prvCopyDataToQueue
2545:FreeRTOS/Source/queue.c **** 
2546:FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2547:FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2548:FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 3106               	.LM377:
 3107 09fa C111      		cpse r28,__zero_reg__
 3108 09fc 00C0      		rjmp .L234
2549:FreeRTOS/Source/queue.c **** 			{
2550:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 3110               	.LM378:
 3111 09fe F801      		movw r30,r16
 3112 0a00 8189      		ldd r24,Z+17
 3113 0a02 8823      		tst r24
 3114 0a04 01F0      		breq .L236
2551:FreeRTOS/Source/queue.c **** 				{
2552:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 3116               	.LM379:
 3117 0a06 C801      		movw r24,r16
 3118 0a08 4196      		adiw r24,17
 3119 0a0a 0E94 0000 		call xCoRoutineRemoveFromEventList
2553:FreeRTOS/Source/queue.c **** 					{
2554:FreeRTOS/Source/queue.c **** 						return pdTRUE;
 3121               	.LM380:
 3122 0a0e 41E0      		ldi r20,lo8(1)
 3123 0a10 8111      		cpse r24,__zero_reg__
 3124 0a12 00C0      		rjmp .L233
 3125               	.L236:
 3126 0a14 40E0      		ldi r20,0
 3127               	.L233:
2555:FreeRTOS/Source/queue.c **** 					}
2556:FreeRTOS/Source/queue.c **** 					else
2557:FreeRTOS/Source/queue.c **** 					{
2558:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2559:FreeRTOS/Source/queue.c **** 					}
2560:FreeRTOS/Source/queue.c **** 				}
2561:FreeRTOS/Source/queue.c **** 				else
2562:FreeRTOS/Source/queue.c **** 				{
2563:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2564:FreeRTOS/Source/queue.c **** 				}
2565:FreeRTOS/Source/queue.c **** 			}
2566:FreeRTOS/Source/queue.c **** 			else
2567:FreeRTOS/Source/queue.c **** 			{
2568:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2569:FreeRTOS/Source/queue.c **** 			}
2570:FreeRTOS/Source/queue.c **** 		}
2571:FreeRTOS/Source/queue.c **** 		else
2572:FreeRTOS/Source/queue.c **** 		{
2573:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2574:FreeRTOS/Source/queue.c **** 		}
2575:FreeRTOS/Source/queue.c **** 
2576:FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2577:FreeRTOS/Source/queue.c **** 	}
 3129               	.LM381:
 3130 0a16 842F      		mov r24,r20
 3131               	/* epilogue start */
 3132 0a18 CF91      		pop r28
 3133 0a1a 1F91      		pop r17
 3134 0a1c 0F91      		pop r16
 3135 0a1e 0895      		ret
 3137               	.Lscope24:
 3139               		.stabd	78,0,0
 3144               	.global	xQueueCRReceiveFromISR
 3146               	xQueueCRReceiveFromISR:
 3147               		.stabd	46,0,0
2578:FreeRTOS/Source/queue.c **** 
2579:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2580:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2581:FreeRTOS/Source/queue.c **** 
2582:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2583:FreeRTOS/Source/queue.c **** 
2584:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2585:FreeRTOS/Source/queue.c **** 	{
 3149               	.LM382:
 3150               	.LFBB25:
 3151 0a20 0F93      		push r16
 3152 0a22 1F93      		push r17
 3153 0a24 CF93      		push r28
 3154 0a26 DF93      		push r29
 3155               	/* prologue: function */
 3156               	/* frame size = 0 */
 3157               	/* stack size = 4 */
 3158               	.L__stack_usage = 4
 3159 0a28 FC01      		movw r30,r24
2586:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2587:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2588:FreeRTOS/Source/queue.c **** 
2589:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2590:FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2591:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 3161               	.LM383:
 3162 0a2a 828D      		ldd r24,Z+26
 3163 0a2c 8823      		tst r24
 3164 0a2e 01F0      		breq .L242
2592:FreeRTOS/Source/queue.c **** 		{
2593:FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2594:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 3166               	.LM384:
 3167 0a30 248D      		ldd r18,Z+28
 3168 0a32 30E0      		ldi r19,0
 3169 0a34 A681      		ldd r26,Z+6
 3170 0a36 B781      		ldd r27,Z+7
 3171 0a38 A20F      		add r26,r18
 3172 0a3a B31F      		adc r27,r19
 3173 0a3c B783      		std Z+7,r27
 3174 0a3e A683      		std Z+6,r26
2595:FreeRTOS/Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 3176               	.LM385:
 3177 0a40 8481      		ldd r24,Z+4
 3178 0a42 9581      		ldd r25,Z+5
 3179 0a44 A817      		cp r26,r24
 3180 0a46 B907      		cpc r27,r25
 3181 0a48 00F0      		brlo .L239
2596:FreeRTOS/Source/queue.c **** 			{
2597:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 3183               	.LM386:
 3184 0a4a 8081      		ld r24,Z
 3185 0a4c 9181      		ldd r25,Z+1
 3186 0a4e 9783      		std Z+7,r25
 3187 0a50 8683      		std Z+6,r24
 3188               	.L239:
 3189 0a52 8A01      		movw r16,r20
 3190 0a54 CB01      		movw r24,r22
 3191 0a56 EF01      		movw r28,r30
2598:FreeRTOS/Source/queue.c **** 			}
2599:FreeRTOS/Source/queue.c **** 			else
2600:FreeRTOS/Source/queue.c **** 			{
2601:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2602:FreeRTOS/Source/queue.c **** 			}
2603:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 3193               	.LM387:
 3194 0a58 428D      		ldd r20,Z+26
 3195 0a5a 4150      		subi r20,lo8(-(-1))
 3196 0a5c 428F      		std Z+26,r20
2604:FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
 3198               	.LM388:
 3199 0a5e 6681      		ldd r22,Z+6
 3200 0a60 7781      		ldd r23,Z+7
 3201 0a62 A901      		movw r20,r18
 3202 0a64 0E94 0000 		call memcpy
2605:FreeRTOS/Source/queue.c **** 
2606:FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 3204               	.LM389:
 3205 0a68 F801      		movw r30,r16
 3206 0a6a 8081      		ld r24,Z
 3207 0a6c 8823      		tst r24
 3208 0a6e 01F0      		breq .L240
 3209               	.L241:
2607:FreeRTOS/Source/queue.c **** 			{
2608:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2609:FreeRTOS/Source/queue.c **** 				{
2610:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2611:FreeRTOS/Source/queue.c **** 					{
2612:FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2613:FreeRTOS/Source/queue.c **** 					}
2614:FreeRTOS/Source/queue.c **** 					else
2615:FreeRTOS/Source/queue.c **** 					{
2616:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2617:FreeRTOS/Source/queue.c **** 					}
2618:FreeRTOS/Source/queue.c **** 				}
2619:FreeRTOS/Source/queue.c **** 				else
2620:FreeRTOS/Source/queue.c **** 				{
2621:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2622:FreeRTOS/Source/queue.c **** 				}
2623:FreeRTOS/Source/queue.c **** 			}
2624:FreeRTOS/Source/queue.c **** 			else
2625:FreeRTOS/Source/queue.c **** 			{
2626:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2627:FreeRTOS/Source/queue.c **** 			}
2628:FreeRTOS/Source/queue.c **** 
2629:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 3211               	.LM390:
 3212 0a70 81E0      		ldi r24,lo8(1)
 3213 0a72 00C0      		rjmp .L238
 3214               	.L240:
2608:FreeRTOS/Source/queue.c **** 				{
 3216               	.LM391:
 3217 0a74 8885      		ldd r24,Y+8
 3218 0a76 8823      		tst r24
 3219 0a78 01F0      		breq .L241
2610:FreeRTOS/Source/queue.c **** 					{
 3221               	.LM392:
 3222 0a7a CE01      		movw r24,r28
 3223 0a7c 0896      		adiw r24,8
 3224 0a7e 0E94 0000 		call xCoRoutineRemoveFromEventList
 3225 0a82 8823      		tst r24
 3226 0a84 01F0      		breq .L241
2612:FreeRTOS/Source/queue.c **** 					}
 3228               	.LM393:
 3229 0a86 81E0      		ldi r24,lo8(1)
 3230 0a88 F801      		movw r30,r16
 3231 0a8a 8083      		st Z,r24
 3232 0a8c 00C0      		rjmp .L238
 3233               	.L242:
2630:FreeRTOS/Source/queue.c **** 		}
2631:FreeRTOS/Source/queue.c **** 		else
2632:FreeRTOS/Source/queue.c **** 		{
2633:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 3235               	.LM394:
 3236 0a8e 80E0      		ldi r24,0
 3237               	.L238:
 3238               	/* epilogue start */
2634:FreeRTOS/Source/queue.c **** 		}
2635:FreeRTOS/Source/queue.c **** 
2636:FreeRTOS/Source/queue.c **** 		return xReturn;
2637:FreeRTOS/Source/queue.c **** 	}
 3240               	.LM395:
 3241 0a90 DF91      		pop r29
 3242 0a92 CF91      		pop r28
 3243 0a94 1F91      		pop r17
 3244 0a96 0F91      		pop r16
 3245 0a98 0895      		ret
 3250               	.Lscope25:
 3252               		.stabd	78,0,0
 3254               	.Letext0:
 3255               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccVGO08k.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccVGO08k.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccVGO08k.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccVGO08k.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccVGO08k.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccVGO08k.s:198    .text:0000000000000000 prvIsQueueEmpty
     /tmp/ccVGO08k.s:252    .text:0000000000000016 prvCopyDataToQueue
     /tmp/ccVGO08k.s:399    .text:00000000000000bc prvCopyDataFromQueue
     /tmp/ccVGO08k.s:452    .text:00000000000000f0 prvUnlockQueue
     /tmp/ccVGO08k.s:609    .text:000000000000016c xQueueGenericReset
     /tmp/ccVGO08k.s:734    .text:00000000000001ea xQueueGenericCreate
     /tmp/ccVGO08k.s:829    .text:000000000000023a xQueueGenericSend
     /tmp/ccVGO08k.s:1135   .text:0000000000000366 xQueueCreateMutex
     /tmp/ccVGO08k.s:1202   .text:000000000000039a xQueueGenericSendFromISR
     /tmp/ccVGO08k.s:1305   .text:00000000000003f8 xQueueGiveFromISR
     /tmp/ccVGO08k.s:1402   .text:000000000000043e xQueueReceive
     /tmp/ccVGO08k.s:1685   .text:0000000000000562 xQueueSemaphoreTake
     /tmp/ccVGO08k.s:2075   .text:00000000000006e6 xQueuePeek
     /tmp/ccVGO08k.s:2362   .text:000000000000080a xQueueReceiveFromISR
     /tmp/ccVGO08k.s:2471   .text:0000000000000868 xQueuePeekFromISR
     /tmp/ccVGO08k.s:2531   .text:0000000000000896 uxQueueMessagesWaiting
     /tmp/ccVGO08k.s:2581   .text:00000000000008a6 uxQueueSpacesAvailable
     /tmp/ccVGO08k.s:2632   .text:00000000000008ba uxQueueMessagesWaitingFromISR
     /tmp/ccVGO08k.s:2659   .text:00000000000008c0 vQueueDelete
     /tmp/ccVGO08k.s:2679   .text:00000000000008c4 xQueueIsQueueEmptyFromISR
     /tmp/ccVGO08k.s:2709   .text:00000000000008d0 xQueueIsQueueFullFromISR
     /tmp/ccVGO08k.s:2742   .text:00000000000008de xQueueCRSend
     /tmp/ccVGO08k.s:2908   .text:000000000000094c xQueueCRReceive
     /tmp/ccVGO08k.s:3075   .text:00000000000009da xQueueCRSendFromISR
     /tmp/ccVGO08k.s:3146   .text:0000000000000a20 xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
xTaskPriorityDisinherit
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
