   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 198               	prvIsQueueEmpty:
 199               		.stabd	46,0,0
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/Source/queue.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/queue.c ****  *
   5:FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/queue.c ****  *
  12:FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/queue.c ****  *
  15:FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/queue.c ****  *
  22:FreeRTOS/Source/queue.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/queue.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/queue.c ****  *
  25:FreeRTOS/Source/queue.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/queue.c ****  */
  27:FreeRTOS/Source/queue.c **** 
  28:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  29:FreeRTOS/Source/queue.c **** #include <string.h>
  30:FreeRTOS/Source/queue.c **** 
  31:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  34:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:FreeRTOS/Source/queue.c **** 
  36:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  37:FreeRTOS/Source/queue.c **** #include "task.h"
  38:FreeRTOS/Source/queue.c **** #include "queue.h"
  39:FreeRTOS/Source/queue.c **** 
  40:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  42:FreeRTOS/Source/queue.c **** #endif
  43:FreeRTOS/Source/queue.c **** 
  44:FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:FreeRTOS/Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:FreeRTOS/Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:FreeRTOS/Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:FreeRTOS/Source/queue.c **** 
  50:FreeRTOS/Source/queue.c **** 
  51:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:FreeRTOS/Source/queue.c **** 
  55:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:FreeRTOS/Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:FreeRTOS/Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:FreeRTOS/Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:FreeRTOS/Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:FreeRTOS/Source/queue.c **** being used for. */
  64:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  65:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:FreeRTOS/Source/queue.c **** 
  67:FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  68:FreeRTOS/Source/queue.c **** {
  69:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:FreeRTOS/Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:FreeRTOS/Source/queue.c **** } QueuePointers_t;
  72:FreeRTOS/Source/queue.c **** 
  73:FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  74:FreeRTOS/Source/queue.c **** {
  75:FreeRTOS/Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:FreeRTOS/Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  78:FreeRTOS/Source/queue.c **** 
  79:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:FreeRTOS/Source/queue.c **** zero. */
  81:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:FreeRTOS/Source/queue.c **** 
  84:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:FreeRTOS/Source/queue.c **** #else
  89:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:FreeRTOS/Source/queue.c **** #endif
  91:FreeRTOS/Source/queue.c **** 
  92:FreeRTOS/Source/queue.c **** /*
  93:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:FreeRTOS/Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:FreeRTOS/Source/queue.c ****  */
  97:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
  98:FreeRTOS/Source/queue.c **** {
  99:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:FreeRTOS/Source/queue.c **** 
 102:FreeRTOS/Source/queue.c **** 	union
 103:FreeRTOS/Source/queue.c **** 	{
 104:FreeRTOS/Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:FreeRTOS/Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:FreeRTOS/Source/queue.c **** 	} u;
 107:FreeRTOS/Source/queue.c **** 
 108:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:FreeRTOS/Source/queue.c **** 
 111:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:FreeRTOS/Source/queue.c **** 
 115:FreeRTOS/Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:FreeRTOS/Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:FreeRTOS/Source/queue.c **** 
 118:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:FreeRTOS/Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:FreeRTOS/Source/queue.c **** 	#endif
 121:FreeRTOS/Source/queue.c **** 
 122:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:FreeRTOS/Source/queue.c **** 	#endif
 125:FreeRTOS/Source/queue.c **** 
 126:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 129:FreeRTOS/Source/queue.c **** 	#endif
 130:FreeRTOS/Source/queue.c **** 
 131:FreeRTOS/Source/queue.c **** } xQUEUE;
 132:FreeRTOS/Source/queue.c **** 
 133:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 136:FreeRTOS/Source/queue.c **** 
 137:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 138:FreeRTOS/Source/queue.c **** 
 139:FreeRTOS/Source/queue.c **** /*
 140:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:FreeRTOS/Source/queue.c ****  */
 143:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:FreeRTOS/Source/queue.c **** 
 145:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:FreeRTOS/Source/queue.c **** 	more user friendly. */
 148:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:FreeRTOS/Source/queue.c **** 	{
 150:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 152:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 153:FreeRTOS/Source/queue.c **** 
 154:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:FreeRTOS/Source/queue.c **** 	debuggers. */
 157:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:FreeRTOS/Source/queue.c **** 
 159:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 162:FreeRTOS/Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:FreeRTOS/Source/queue.c **** 
 164:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:FreeRTOS/Source/queue.c **** 
 166:FreeRTOS/Source/queue.c **** /*
 167:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:FreeRTOS/Source/queue.c ****  */
 174:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:FreeRTOS/Source/queue.c **** 
 176:FreeRTOS/Source/queue.c **** /*
 177:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:FreeRTOS/Source/queue.c ****  *
 179:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:FreeRTOS/Source/queue.c ****  */
 181:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** /*
 184:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:FreeRTOS/Source/queue.c ****  *
 186:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:FreeRTOS/Source/queue.c ****  */
 188:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:FreeRTOS/Source/queue.c **** 
 190:FreeRTOS/Source/queue.c **** /*
 191:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:FreeRTOS/Source/queue.c ****  * back of the queue.
 193:FreeRTOS/Source/queue.c ****  */
 194:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:FreeRTOS/Source/queue.c **** 
 196:FreeRTOS/Source/queue.c **** /*
 197:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 198:FreeRTOS/Source/queue.c ****  */
 199:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:FreeRTOS/Source/queue.c **** 
 201:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:FreeRTOS/Source/queue.c **** 	/*
 203:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 205:FreeRTOS/Source/queue.c **** 	 */
 206:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 207:FreeRTOS/Source/queue.c **** #endif
 208:FreeRTOS/Source/queue.c **** 
 209:FreeRTOS/Source/queue.c **** /*
 210:FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 212:FreeRTOS/Source/queue.c ****  */
 213:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:FreeRTOS/Source/queue.c **** 
 215:FreeRTOS/Source/queue.c **** /*
 216:FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:FreeRTOS/Source/queue.c ****  * as a mutex.
 219:FreeRTOS/Source/queue.c ****  */
 220:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:FreeRTOS/Source/queue.c **** #endif
 223:FreeRTOS/Source/queue.c **** 
 224:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:FreeRTOS/Source/queue.c **** 	/*
 226:FreeRTOS/Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:FreeRTOS/Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:FreeRTOS/Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:FreeRTOS/Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:FreeRTOS/Source/queue.c **** 	 * that priority.
 231:FreeRTOS/Source/queue.c **** 	 */
 232:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:FreeRTOS/Source/queue.c **** #endif
 234:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 235:FreeRTOS/Source/queue.c **** 
 236:FreeRTOS/Source/queue.c **** /*
 237:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 239:FreeRTOS/Source/queue.c ****  */
 240:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:FreeRTOS/Source/queue.c **** 	{														\
 243:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:FreeRTOS/Source/queue.c **** 		{													\
 245:FreeRTOS/Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:FreeRTOS/Source/queue.c **** 		}													\
 247:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:FreeRTOS/Source/queue.c **** 		{													\
 249:FreeRTOS/Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:FreeRTOS/Source/queue.c **** 		}													\
 251:FreeRTOS/Source/queue.c **** 	}														\
 252:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 253:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 254:FreeRTOS/Source/queue.c **** 
 255:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:FreeRTOS/Source/queue.c **** {
 257:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 258:FreeRTOS/Source/queue.c **** 
 259:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 260:FreeRTOS/Source/queue.c **** 
 261:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 262:FreeRTOS/Source/queue.c **** 	{
 263:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
 264:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 265:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 266:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 268:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 269:FreeRTOS/Source/queue.c **** 
 270:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 271:FreeRTOS/Source/queue.c **** 		{
 272:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 277:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 278:FreeRTOS/Source/queue.c **** 			{
 279:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 280:FreeRTOS/Source/queue.c **** 				{
 281:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 282:FreeRTOS/Source/queue.c **** 				}
 283:FreeRTOS/Source/queue.c **** 				else
 284:FreeRTOS/Source/queue.c **** 				{
 285:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:FreeRTOS/Source/queue.c **** 				}
 287:FreeRTOS/Source/queue.c **** 			}
 288:FreeRTOS/Source/queue.c **** 			else
 289:FreeRTOS/Source/queue.c **** 			{
 290:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/Source/queue.c **** 			}
 292:FreeRTOS/Source/queue.c **** 		}
 293:FreeRTOS/Source/queue.c **** 		else
 294:FreeRTOS/Source/queue.c **** 		{
 295:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 297:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 298:FreeRTOS/Source/queue.c **** 		}
 299:FreeRTOS/Source/queue.c **** 	}
 300:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 301:FreeRTOS/Source/queue.c **** 
 302:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:FreeRTOS/Source/queue.c **** 	versions. */
 304:FreeRTOS/Source/queue.c **** 	return pdPASS;
 305:FreeRTOS/Source/queue.c **** }
 306:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 307:FreeRTOS/Source/queue.c **** 
 308:FreeRTOS/Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:FreeRTOS/Source/queue.c **** 
 310:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:FreeRTOS/Source/queue.c **** 	{
 312:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 313:FreeRTOS/Source/queue.c **** 
 314:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:FreeRTOS/Source/queue.c **** 
 316:FreeRTOS/Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:FreeRTOS/Source/queue.c **** 		supplied. */
 318:FreeRTOS/Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:FreeRTOS/Source/queue.c **** 
 320:FreeRTOS/Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:FreeRTOS/Source/queue.c **** 		should not be provided if the item size is 0. */
 322:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:FreeRTOS/Source/queue.c **** 
 325:FreeRTOS/Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:FreeRTOS/Source/queue.c **** 		{
 327:FreeRTOS/Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:FreeRTOS/Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:FreeRTOS/Source/queue.c **** 			the real queue and semaphore structures. */
 330:FreeRTOS/Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:FreeRTOS/Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:FreeRTOS/Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:FreeRTOS/Source/queue.c **** 		}
 334:FreeRTOS/Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:FreeRTOS/Source/queue.c **** 
 336:FreeRTOS/Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:FreeRTOS/Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:FreeRTOS/Source/queue.c **** 		but is already set. */
 339:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:FreeRTOS/Source/queue.c **** 
 341:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 342:FreeRTOS/Source/queue.c **** 		{
 343:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:FreeRTOS/Source/queue.c **** 			{
 345:FreeRTOS/Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:FreeRTOS/Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:FreeRTOS/Source/queue.c **** 				later deleted. */
 348:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:FreeRTOS/Source/queue.c **** 			}
 350:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:FreeRTOS/Source/queue.c **** 
 352:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:FreeRTOS/Source/queue.c **** 		}
 354:FreeRTOS/Source/queue.c **** 		else
 355:FreeRTOS/Source/queue.c **** 		{
 356:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:FreeRTOS/Source/queue.c **** 		}
 359:FreeRTOS/Source/queue.c **** 
 360:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 361:FreeRTOS/Source/queue.c **** 	}
 362:FreeRTOS/Source/queue.c **** 
 363:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 365:FreeRTOS/Source/queue.c **** 
 366:FreeRTOS/Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:FreeRTOS/Source/queue.c **** 
 368:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:FreeRTOS/Source/queue.c **** 	{
 370:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 371:FreeRTOS/Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:FreeRTOS/Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:FreeRTOS/Source/queue.c **** 
 374:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:FreeRTOS/Source/queue.c **** 
 376:FreeRTOS/Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 377:FreeRTOS/Source/queue.c **** 		{
 378:FreeRTOS/Source/queue.c **** 			/* There is not going to be a queue storage area. */
 379:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 380:FreeRTOS/Source/queue.c **** 		}
 381:FreeRTOS/Source/queue.c **** 		else
 382:FreeRTOS/Source/queue.c **** 		{
 383:FreeRTOS/Source/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 384:FreeRTOS/Source/queue.c **** 			can be in the queue at any time. */
 385:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 386:FreeRTOS/Source/queue.c **** 		}
 387:FreeRTOS/Source/queue.c **** 
 388:FreeRTOS/Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 389:FreeRTOS/Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 390:FreeRTOS/Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 391:FreeRTOS/Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 392:FreeRTOS/Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 393:FreeRTOS/Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 394:FreeRTOS/Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 395:FreeRTOS/Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 396:FreeRTOS/Source/queue.c **** 		two bytes). */
 397:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 398:FreeRTOS/Source/queue.c **** 
 399:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 400:FreeRTOS/Source/queue.c **** 		{
 401:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 402:FreeRTOS/Source/queue.c **** 			storage area. */
 403:FreeRTOS/Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 404:FreeRTOS/Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 405:FreeRTOS/Source/queue.c **** 
 406:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 407:FreeRTOS/Source/queue.c **** 			{
 408:FreeRTOS/Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 409:FreeRTOS/Source/queue.c **** 				note this task was created dynamically in case it is later
 410:FreeRTOS/Source/queue.c **** 				deleted. */
 411:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 412:FreeRTOS/Source/queue.c **** 			}
 413:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 414:FreeRTOS/Source/queue.c **** 
 415:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 416:FreeRTOS/Source/queue.c **** 		}
 417:FreeRTOS/Source/queue.c **** 		else
 418:FreeRTOS/Source/queue.c **** 		{
 419:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 420:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 421:FreeRTOS/Source/queue.c **** 		}
 422:FreeRTOS/Source/queue.c **** 
 423:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 424:FreeRTOS/Source/queue.c **** 	}
 425:FreeRTOS/Source/queue.c **** 
 426:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 427:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 428:FreeRTOS/Source/queue.c **** 
 429:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 430:FreeRTOS/Source/queue.c **** {
 431:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 432:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 433:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 434:FreeRTOS/Source/queue.c **** 
 435:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 436:FreeRTOS/Source/queue.c **** 	{
 437:FreeRTOS/Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 438:FreeRTOS/Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 439:FreeRTOS/Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 440:FreeRTOS/Source/queue.c **** 		value that is known to be within the memory map. */
 441:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 442:FreeRTOS/Source/queue.c **** 	}
 443:FreeRTOS/Source/queue.c **** 	else
 444:FreeRTOS/Source/queue.c **** 	{
 445:FreeRTOS/Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 446:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 447:FreeRTOS/Source/queue.c **** 	}
 448:FreeRTOS/Source/queue.c **** 
 449:FreeRTOS/Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 450:FreeRTOS/Source/queue.c **** 	defined. */
 451:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 452:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 453:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 454:FreeRTOS/Source/queue.c **** 
 455:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 456:FreeRTOS/Source/queue.c **** 	{
 457:FreeRTOS/Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 458:FreeRTOS/Source/queue.c **** 	}
 459:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 460:FreeRTOS/Source/queue.c **** 
 461:FreeRTOS/Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 462:FreeRTOS/Source/queue.c **** 	{
 463:FreeRTOS/Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 464:FreeRTOS/Source/queue.c **** 	}
 465:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 466:FreeRTOS/Source/queue.c **** 
 467:FreeRTOS/Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 468:FreeRTOS/Source/queue.c **** }
 469:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 470:FreeRTOS/Source/queue.c **** 
 471:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 472:FreeRTOS/Source/queue.c **** 
 473:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 474:FreeRTOS/Source/queue.c **** 	{
 475:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 476:FreeRTOS/Source/queue.c **** 		{
 477:FreeRTOS/Source/queue.c **** 			/* The queue create function will set all the queue structure members
 478:FreeRTOS/Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 479:FreeRTOS/Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 480:FreeRTOS/Source/queue.c **** 			in particular the information required for priority inheritance. */
 481:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 482:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 483:FreeRTOS/Source/queue.c **** 
 484:FreeRTOS/Source/queue.c **** 			/* In case this is a recursive mutex. */
 485:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 486:FreeRTOS/Source/queue.c **** 
 487:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 488:FreeRTOS/Source/queue.c **** 
 489:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 490:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 491:FreeRTOS/Source/queue.c **** 		}
 492:FreeRTOS/Source/queue.c **** 		else
 493:FreeRTOS/Source/queue.c **** 		{
 494:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 495:FreeRTOS/Source/queue.c **** 		}
 496:FreeRTOS/Source/queue.c **** 	}
 497:FreeRTOS/Source/queue.c **** 
 498:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 499:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 500:FreeRTOS/Source/queue.c **** 
 501:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 502:FreeRTOS/Source/queue.c **** 
 503:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 504:FreeRTOS/Source/queue.c **** 	{
 505:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 506:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 507:FreeRTOS/Source/queue.c **** 
 508:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 509:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 510:FreeRTOS/Source/queue.c **** 
 511:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 512:FreeRTOS/Source/queue.c **** 	}
 513:FreeRTOS/Source/queue.c **** 
 514:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 515:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 516:FreeRTOS/Source/queue.c **** 
 517:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 518:FreeRTOS/Source/queue.c **** 
 519:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 520:FreeRTOS/Source/queue.c **** 	{
 521:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 522:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 523:FreeRTOS/Source/queue.c **** 
 524:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 525:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 526:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 527:FreeRTOS/Source/queue.c **** 
 528:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 529:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 530:FreeRTOS/Source/queue.c **** 
 531:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 532:FreeRTOS/Source/queue.c **** 	}
 533:FreeRTOS/Source/queue.c **** 
 534:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 535:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 536:FreeRTOS/Source/queue.c **** 
 537:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 538:FreeRTOS/Source/queue.c **** 
 539:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 540:FreeRTOS/Source/queue.c **** 	{
 541:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 542:FreeRTOS/Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 543:FreeRTOS/Source/queue.c **** 
 544:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 545:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 546:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 547:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 548:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 549:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 550:FreeRTOS/Source/queue.c **** 		{
 551:FreeRTOS/Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 552:FreeRTOS/Source/queue.c **** 			{
 553:FreeRTOS/Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 554:FreeRTOS/Source/queue.c **** 			}
 555:FreeRTOS/Source/queue.c **** 			else
 556:FreeRTOS/Source/queue.c **** 			{
 557:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 558:FreeRTOS/Source/queue.c **** 			}
 559:FreeRTOS/Source/queue.c **** 		}
 560:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 561:FreeRTOS/Source/queue.c **** 
 562:FreeRTOS/Source/queue.c **** 		return pxReturn;
 563:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 564:FreeRTOS/Source/queue.c **** 
 565:FreeRTOS/Source/queue.c **** #endif
 566:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 567:FreeRTOS/Source/queue.c **** 
 568:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 569:FreeRTOS/Source/queue.c **** 
 570:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 571:FreeRTOS/Source/queue.c **** 	{
 572:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 573:FreeRTOS/Source/queue.c **** 
 574:FreeRTOS/Source/queue.c **** 		configASSERT( xSemaphore );
 575:FreeRTOS/Source/queue.c **** 
 576:FreeRTOS/Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 577:FreeRTOS/Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 578:FreeRTOS/Source/queue.c **** 		not required here. */
 579:FreeRTOS/Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 580:FreeRTOS/Source/queue.c **** 		{
 581:FreeRTOS/Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 582:FreeRTOS/Source/queue.c **** 		}
 583:FreeRTOS/Source/queue.c **** 		else
 584:FreeRTOS/Source/queue.c **** 		{
 585:FreeRTOS/Source/queue.c **** 			pxReturn = NULL;
 586:FreeRTOS/Source/queue.c **** 		}
 587:FreeRTOS/Source/queue.c **** 
 588:FreeRTOS/Source/queue.c **** 		return pxReturn;
 589:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 590:FreeRTOS/Source/queue.c **** 
 591:FreeRTOS/Source/queue.c **** #endif
 592:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 593:FreeRTOS/Source/queue.c **** 
 594:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 595:FreeRTOS/Source/queue.c **** 
 596:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 597:FreeRTOS/Source/queue.c **** 	{
 598:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 599:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 600:FreeRTOS/Source/queue.c **** 
 601:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 602:FreeRTOS/Source/queue.c **** 
 603:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 604:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 605:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 606:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 607:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 608:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 609:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 610:FreeRTOS/Source/queue.c **** 		{
 611:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 612:FreeRTOS/Source/queue.c **** 
 613:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 614:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 615:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 616:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 617:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 618:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 619:FreeRTOS/Source/queue.c **** 
 620:FreeRTOS/Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 621:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 622:FreeRTOS/Source/queue.c **** 			{
 623:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 624:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 625:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 626:FreeRTOS/Source/queue.c **** 			}
 627:FreeRTOS/Source/queue.c **** 			else
 628:FreeRTOS/Source/queue.c **** 			{
 629:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 630:FreeRTOS/Source/queue.c **** 			}
 631:FreeRTOS/Source/queue.c **** 
 632:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 633:FreeRTOS/Source/queue.c **** 		}
 634:FreeRTOS/Source/queue.c **** 		else
 635:FreeRTOS/Source/queue.c **** 		{
 636:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 637:FreeRTOS/Source/queue.c **** 			holder. */
 638:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 639:FreeRTOS/Source/queue.c **** 
 640:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 641:FreeRTOS/Source/queue.c **** 		}
 642:FreeRTOS/Source/queue.c **** 
 643:FreeRTOS/Source/queue.c **** 		return xReturn;
 644:FreeRTOS/Source/queue.c **** 	}
 645:FreeRTOS/Source/queue.c **** 
 646:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 647:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 648:FreeRTOS/Source/queue.c **** 
 649:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 650:FreeRTOS/Source/queue.c **** 
 651:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 652:FreeRTOS/Source/queue.c **** 	{
 653:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 654:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 655:FreeRTOS/Source/queue.c **** 
 656:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 657:FreeRTOS/Source/queue.c **** 
 658:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 659:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 660:FreeRTOS/Source/queue.c **** 
 661:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 662:FreeRTOS/Source/queue.c **** 
 663:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 664:FreeRTOS/Source/queue.c **** 		{
 665:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 666:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 667:FreeRTOS/Source/queue.c **** 		}
 668:FreeRTOS/Source/queue.c **** 		else
 669:FreeRTOS/Source/queue.c **** 		{
 670:FreeRTOS/Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 671:FreeRTOS/Source/queue.c **** 
 672:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 673:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 674:FreeRTOS/Source/queue.c **** 			before reaching here. */
 675:FreeRTOS/Source/queue.c **** 			if( xReturn != pdFAIL )
 676:FreeRTOS/Source/queue.c **** 			{
 677:FreeRTOS/Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 678:FreeRTOS/Source/queue.c **** 			}
 679:FreeRTOS/Source/queue.c **** 			else
 680:FreeRTOS/Source/queue.c **** 			{
 681:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 682:FreeRTOS/Source/queue.c **** 			}
 683:FreeRTOS/Source/queue.c **** 		}
 684:FreeRTOS/Source/queue.c **** 
 685:FreeRTOS/Source/queue.c **** 		return xReturn;
 686:FreeRTOS/Source/queue.c **** 	}
 687:FreeRTOS/Source/queue.c **** 
 688:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 689:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 690:FreeRTOS/Source/queue.c **** 
 691:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 692:FreeRTOS/Source/queue.c **** 
 693:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 694:FreeRTOS/Source/queue.c **** 	{
 695:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 696:FreeRTOS/Source/queue.c **** 
 697:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 698:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 699:FreeRTOS/Source/queue.c **** 
 700:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 701:FreeRTOS/Source/queue.c **** 
 702:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 703:FreeRTOS/Source/queue.c **** 		{
 704:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 705:FreeRTOS/Source/queue.c **** 
 706:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 707:FreeRTOS/Source/queue.c **** 		}
 708:FreeRTOS/Source/queue.c **** 		else
 709:FreeRTOS/Source/queue.c **** 		{
 710:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 711:FreeRTOS/Source/queue.c **** 		}
 712:FreeRTOS/Source/queue.c **** 
 713:FreeRTOS/Source/queue.c **** 		return xHandle;
 714:FreeRTOS/Source/queue.c **** 	}
 715:FreeRTOS/Source/queue.c **** 
 716:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 717:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 718:FreeRTOS/Source/queue.c **** 
 719:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 720:FreeRTOS/Source/queue.c **** 
 721:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 722:FreeRTOS/Source/queue.c **** 	{
 723:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 724:FreeRTOS/Source/queue.c **** 
 725:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 726:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 727:FreeRTOS/Source/queue.c **** 
 728:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 729:FreeRTOS/Source/queue.c **** 
 730:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 731:FreeRTOS/Source/queue.c **** 		{
 732:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 733:FreeRTOS/Source/queue.c **** 
 734:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 735:FreeRTOS/Source/queue.c **** 		}
 736:FreeRTOS/Source/queue.c **** 		else
 737:FreeRTOS/Source/queue.c **** 		{
 738:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 739:FreeRTOS/Source/queue.c **** 		}
 740:FreeRTOS/Source/queue.c **** 
 741:FreeRTOS/Source/queue.c **** 		return xHandle;
 742:FreeRTOS/Source/queue.c **** 	}
 743:FreeRTOS/Source/queue.c **** 
 744:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 745:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 746:FreeRTOS/Source/queue.c **** 
 747:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 748:FreeRTOS/Source/queue.c **** {
 749:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 750:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 751:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 752:FreeRTOS/Source/queue.c **** 
 753:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 754:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 755:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 756:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 757:FreeRTOS/Source/queue.c **** 	{
 758:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 759:FreeRTOS/Source/queue.c **** 	}
 760:FreeRTOS/Source/queue.c **** 	#endif
 761:FreeRTOS/Source/queue.c **** 
 762:FreeRTOS/Source/queue.c **** 
 763:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 764:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 765:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
 766:FreeRTOS/Source/queue.c **** 	for( ;; )
 767:FreeRTOS/Source/queue.c **** 	{
 768:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 769:FreeRTOS/Source/queue.c **** 		{
 770:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 771:FreeRTOS/Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 772:FreeRTOS/Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 773:FreeRTOS/Source/queue.c **** 			queue is full. */
 774:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 775:FreeRTOS/Source/queue.c **** 			{
 776:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 777:FreeRTOS/Source/queue.c **** 
 778:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 779:FreeRTOS/Source/queue.c **** 				{
 780:FreeRTOS/Source/queue.c **** 				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 781:FreeRTOS/Source/queue.c **** 
 782:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 783:FreeRTOS/Source/queue.c **** 
 784:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 785:FreeRTOS/Source/queue.c **** 					{
 786:FreeRTOS/Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 787:FreeRTOS/Source/queue.c **** 						{
 788:FreeRTOS/Source/queue.c **** 							/* Do not notify the queue set as an existing item
 789:FreeRTOS/Source/queue.c **** 							was overwritten in the queue so the number of items
 790:FreeRTOS/Source/queue.c **** 							in the queue has not changed. */
 791:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 792:FreeRTOS/Source/queue.c **** 						}
 793:FreeRTOS/Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 794:FreeRTOS/Source/queue.c **** 						{
 795:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 796:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 797:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 798:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 799:FreeRTOS/Source/queue.c **** 						}
 800:FreeRTOS/Source/queue.c **** 						else
 801:FreeRTOS/Source/queue.c **** 						{
 802:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 803:FreeRTOS/Source/queue.c **** 						}
 804:FreeRTOS/Source/queue.c **** 					}
 805:FreeRTOS/Source/queue.c **** 					else
 806:FreeRTOS/Source/queue.c **** 					{
 807:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 808:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 809:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 810:FreeRTOS/Source/queue.c **** 						{
 811:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 812:FreeRTOS/Source/queue.c **** 							{
 813:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 814:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 815:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 816:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 817:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 818:FreeRTOS/Source/queue.c **** 							}
 819:FreeRTOS/Source/queue.c **** 							else
 820:FreeRTOS/Source/queue.c **** 							{
 821:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 822:FreeRTOS/Source/queue.c **** 							}
 823:FreeRTOS/Source/queue.c **** 						}
 824:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 825:FreeRTOS/Source/queue.c **** 						{
 826:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 827:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 828:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 829:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 830:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 831:FreeRTOS/Source/queue.c **** 						}
 832:FreeRTOS/Source/queue.c **** 						else
 833:FreeRTOS/Source/queue.c **** 						{
 834:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 835:FreeRTOS/Source/queue.c **** 						}
 836:FreeRTOS/Source/queue.c **** 					}
 837:FreeRTOS/Source/queue.c **** 				}
 838:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 839:FreeRTOS/Source/queue.c **** 				{
 840:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 841:FreeRTOS/Source/queue.c **** 
 842:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 843:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 844:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 845:FreeRTOS/Source/queue.c **** 					{
 846:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 847:FreeRTOS/Source/queue.c **** 						{
 848:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 849:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 850:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 851:FreeRTOS/Source/queue.c **** 							takes care of that. */
 852:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 853:FreeRTOS/Source/queue.c **** 						}
 854:FreeRTOS/Source/queue.c **** 						else
 855:FreeRTOS/Source/queue.c **** 						{
 856:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 857:FreeRTOS/Source/queue.c **** 						}
 858:FreeRTOS/Source/queue.c **** 					}
 859:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 860:FreeRTOS/Source/queue.c **** 					{
 861:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 862:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 863:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 864:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 865:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 866:FreeRTOS/Source/queue.c **** 					}
 867:FreeRTOS/Source/queue.c **** 					else
 868:FreeRTOS/Source/queue.c **** 					{
 869:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 870:FreeRTOS/Source/queue.c **** 					}
 871:FreeRTOS/Source/queue.c **** 				}
 872:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 873:FreeRTOS/Source/queue.c **** 
 874:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 875:FreeRTOS/Source/queue.c **** 				return pdPASS;
 876:FreeRTOS/Source/queue.c **** 			}
 877:FreeRTOS/Source/queue.c **** 			else
 878:FreeRTOS/Source/queue.c **** 			{
 879:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 880:FreeRTOS/Source/queue.c **** 				{
 881:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 882:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 883:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 884:FreeRTOS/Source/queue.c **** 
 885:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 886:FreeRTOS/Source/queue.c **** 					the function. */
 887:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 888:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 889:FreeRTOS/Source/queue.c **** 				}
 890:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 891:FreeRTOS/Source/queue.c **** 				{
 892:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 893:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 894:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 895:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 896:FreeRTOS/Source/queue.c **** 				}
 897:FreeRTOS/Source/queue.c **** 				else
 898:FreeRTOS/Source/queue.c **** 				{
 899:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 900:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 901:FreeRTOS/Source/queue.c **** 				}
 902:FreeRTOS/Source/queue.c **** 			}
 903:FreeRTOS/Source/queue.c **** 		}
 904:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 905:FreeRTOS/Source/queue.c **** 
 906:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 907:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 908:FreeRTOS/Source/queue.c **** 
 909:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 910:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 911:FreeRTOS/Source/queue.c **** 
 912:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 913:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 914:FreeRTOS/Source/queue.c **** 		{
 915:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 916:FreeRTOS/Source/queue.c **** 			{
 917:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 918:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 919:FreeRTOS/Source/queue.c **** 
 920:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 921:FreeRTOS/Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 922:FreeRTOS/Source/queue.c **** 				remove this task from the event list again - but as the
 923:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 924:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 925:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 926:FreeRTOS/Source/queue.c **** 
 927:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 928:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 929:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 930:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 931:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 932:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 933:FreeRTOS/Source/queue.c **** 				{
 934:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 935:FreeRTOS/Source/queue.c **** 				}
 936:FreeRTOS/Source/queue.c **** 			}
 937:FreeRTOS/Source/queue.c **** 			else
 938:FreeRTOS/Source/queue.c **** 			{
 939:FreeRTOS/Source/queue.c **** 				/* Try again. */
 940:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 941:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 942:FreeRTOS/Source/queue.c **** 			}
 943:FreeRTOS/Source/queue.c **** 		}
 944:FreeRTOS/Source/queue.c **** 		else
 945:FreeRTOS/Source/queue.c **** 		{
 946:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 947:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 948:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 949:FreeRTOS/Source/queue.c **** 
 950:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 951:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 952:FreeRTOS/Source/queue.c **** 		}
 953:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
 954:FreeRTOS/Source/queue.c **** }
 955:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 956:FreeRTOS/Source/queue.c **** 
 957:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 958:FreeRTOS/Source/queue.c **** {
 959:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 960:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 961:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 962:FreeRTOS/Source/queue.c **** 
 963:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 964:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 965:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 966:FreeRTOS/Source/queue.c **** 
 967:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 968:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 969:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 970:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 971:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 972:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 973:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 974:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 975:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 976:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 977:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 978:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 979:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 980:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 981:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 982:FreeRTOS/Source/queue.c **** 
 983:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 984:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 985:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 986:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 987:FreeRTOS/Source/queue.c **** 	post). */
 988:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 989:FreeRTOS/Source/queue.c **** 	{
 990:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 991:FreeRTOS/Source/queue.c **** 		{
 992:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 993:FreeRTOS/Source/queue.c **** 
 994:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 995:FreeRTOS/Source/queue.c **** 
 996:FreeRTOS/Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 997:FreeRTOS/Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 998:FreeRTOS/Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 999:FreeRTOS/Source/queue.c **** 			called here even though the disinherit function does not check if
1000:FreeRTOS/Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
1001:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1002:FreeRTOS/Source/queue.c **** 
1003:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1004:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1005:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1006:FreeRTOS/Source/queue.c **** 			{
1007:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1008:FreeRTOS/Source/queue.c **** 				{
1009:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1010:FreeRTOS/Source/queue.c **** 					{
1011:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
1012:FreeRTOS/Source/queue.c **** 						{
1013:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1014:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1015:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1016:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1017:FreeRTOS/Source/queue.c **** 							{
1018:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1019:FreeRTOS/Source/queue.c **** 							}
1020:FreeRTOS/Source/queue.c **** 							else
1021:FreeRTOS/Source/queue.c **** 							{
1022:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1023:FreeRTOS/Source/queue.c **** 							}
1024:FreeRTOS/Source/queue.c **** 						}
1025:FreeRTOS/Source/queue.c **** 						else
1026:FreeRTOS/Source/queue.c **** 						{
1027:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1028:FreeRTOS/Source/queue.c **** 						}
1029:FreeRTOS/Source/queue.c **** 					}
1030:FreeRTOS/Source/queue.c **** 					else
1031:FreeRTOS/Source/queue.c **** 					{
1032:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1033:FreeRTOS/Source/queue.c **** 						{
1034:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1035:FreeRTOS/Source/queue.c **** 							{
1036:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1037:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1038:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1039:FreeRTOS/Source/queue.c **** 								{
1040:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1041:FreeRTOS/Source/queue.c **** 								}
1042:FreeRTOS/Source/queue.c **** 								else
1043:FreeRTOS/Source/queue.c **** 								{
1044:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1045:FreeRTOS/Source/queue.c **** 								}
1046:FreeRTOS/Source/queue.c **** 							}
1047:FreeRTOS/Source/queue.c **** 							else
1048:FreeRTOS/Source/queue.c **** 							{
1049:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1050:FreeRTOS/Source/queue.c **** 							}
1051:FreeRTOS/Source/queue.c **** 						}
1052:FreeRTOS/Source/queue.c **** 						else
1053:FreeRTOS/Source/queue.c **** 						{
1054:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1055:FreeRTOS/Source/queue.c **** 						}
1056:FreeRTOS/Source/queue.c **** 					}
1057:FreeRTOS/Source/queue.c **** 				}
1058:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1059:FreeRTOS/Source/queue.c **** 				{
1060:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1061:FreeRTOS/Source/queue.c **** 					{
1062:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1063:FreeRTOS/Source/queue.c **** 						{
1064:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1065:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1066:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1067:FreeRTOS/Source/queue.c **** 							{
1068:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1069:FreeRTOS/Source/queue.c **** 							}
1070:FreeRTOS/Source/queue.c **** 							else
1071:FreeRTOS/Source/queue.c **** 							{
1072:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1073:FreeRTOS/Source/queue.c **** 							}
1074:FreeRTOS/Source/queue.c **** 						}
1075:FreeRTOS/Source/queue.c **** 						else
1076:FreeRTOS/Source/queue.c **** 						{
1077:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1078:FreeRTOS/Source/queue.c **** 						}
1079:FreeRTOS/Source/queue.c **** 					}
1080:FreeRTOS/Source/queue.c **** 					else
1081:FreeRTOS/Source/queue.c **** 					{
1082:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1083:FreeRTOS/Source/queue.c **** 					}
1084:FreeRTOS/Source/queue.c **** 				}
1085:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1086:FreeRTOS/Source/queue.c **** 			}
1087:FreeRTOS/Source/queue.c **** 			else
1088:FreeRTOS/Source/queue.c **** 			{
1089:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1090:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1091:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1092:FreeRTOS/Source/queue.c **** 			}
1093:FreeRTOS/Source/queue.c **** 
1094:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1095:FreeRTOS/Source/queue.c **** 		}
1096:FreeRTOS/Source/queue.c **** 		else
1097:FreeRTOS/Source/queue.c **** 		{
1098:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1099:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1100:FreeRTOS/Source/queue.c **** 		}
1101:FreeRTOS/Source/queue.c **** 	}
1102:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1103:FreeRTOS/Source/queue.c **** 
1104:FreeRTOS/Source/queue.c **** 	return xReturn;
1105:FreeRTOS/Source/queue.c **** }
1106:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1107:FreeRTOS/Source/queue.c **** 
1108:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1109:FreeRTOS/Source/queue.c **** {
1110:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1111:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1112:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1113:FreeRTOS/Source/queue.c **** 
1114:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1115:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1116:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1117:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1118:FreeRTOS/Source/queue.c **** 	post). */
1119:FreeRTOS/Source/queue.c **** 
1120:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1121:FreeRTOS/Source/queue.c **** 
1122:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1123:FreeRTOS/Source/queue.c **** 	if the item size is not 0. */
1124:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1125:FreeRTOS/Source/queue.c **** 
1126:FreeRTOS/Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1127:FreeRTOS/Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1128:FreeRTOS/Source/queue.c **** 	interrupts, only tasks. */
1129:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1130:FreeRTOS/Source/queue.c **** 
1131:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1132:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1133:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1134:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1135:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1136:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1137:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1138:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1139:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1140:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1141:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1142:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1143:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1144:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1145:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1146:FreeRTOS/Source/queue.c **** 
1147:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1148:FreeRTOS/Source/queue.c **** 	{
1149:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1150:FreeRTOS/Source/queue.c **** 
1151:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1152:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1153:FreeRTOS/Source/queue.c **** 		space'. */
1154:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
1155:FreeRTOS/Source/queue.c **** 		{
1156:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
1157:FreeRTOS/Source/queue.c **** 
1158:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1159:FreeRTOS/Source/queue.c **** 
1160:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1161:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1162:FreeRTOS/Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1163:FreeRTOS/Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1164:FreeRTOS/Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1165:FreeRTOS/Source/queue.c **** 			messages (semaphores) available. */
1166:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1167:FreeRTOS/Source/queue.c **** 
1168:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1169:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1170:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1171:FreeRTOS/Source/queue.c **** 			{
1172:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1173:FreeRTOS/Source/queue.c **** 				{
1174:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1175:FreeRTOS/Source/queue.c **** 					{
1176:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1177:FreeRTOS/Source/queue.c **** 						{
1178:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1179:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1180:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1181:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1182:FreeRTOS/Source/queue.c **** 							{
1183:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1184:FreeRTOS/Source/queue.c **** 							}
1185:FreeRTOS/Source/queue.c **** 							else
1186:FreeRTOS/Source/queue.c **** 							{
1187:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1188:FreeRTOS/Source/queue.c **** 							}
1189:FreeRTOS/Source/queue.c **** 						}
1190:FreeRTOS/Source/queue.c **** 						else
1191:FreeRTOS/Source/queue.c **** 						{
1192:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1193:FreeRTOS/Source/queue.c **** 						}
1194:FreeRTOS/Source/queue.c **** 					}
1195:FreeRTOS/Source/queue.c **** 					else
1196:FreeRTOS/Source/queue.c **** 					{
1197:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1198:FreeRTOS/Source/queue.c **** 						{
1199:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1200:FreeRTOS/Source/queue.c **** 							{
1201:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1202:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1203:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1204:FreeRTOS/Source/queue.c **** 								{
1205:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1206:FreeRTOS/Source/queue.c **** 								}
1207:FreeRTOS/Source/queue.c **** 								else
1208:FreeRTOS/Source/queue.c **** 								{
1209:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1210:FreeRTOS/Source/queue.c **** 								}
1211:FreeRTOS/Source/queue.c **** 							}
1212:FreeRTOS/Source/queue.c **** 							else
1213:FreeRTOS/Source/queue.c **** 							{
1214:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1215:FreeRTOS/Source/queue.c **** 							}
1216:FreeRTOS/Source/queue.c **** 						}
1217:FreeRTOS/Source/queue.c **** 						else
1218:FreeRTOS/Source/queue.c **** 						{
1219:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1220:FreeRTOS/Source/queue.c **** 						}
1221:FreeRTOS/Source/queue.c **** 					}
1222:FreeRTOS/Source/queue.c **** 				}
1223:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1224:FreeRTOS/Source/queue.c **** 				{
1225:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1226:FreeRTOS/Source/queue.c **** 					{
1227:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1228:FreeRTOS/Source/queue.c **** 						{
1229:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1230:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1231:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1232:FreeRTOS/Source/queue.c **** 							{
1233:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1234:FreeRTOS/Source/queue.c **** 							}
1235:FreeRTOS/Source/queue.c **** 							else
1236:FreeRTOS/Source/queue.c **** 							{
1237:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1238:FreeRTOS/Source/queue.c **** 							}
1239:FreeRTOS/Source/queue.c **** 						}
1240:FreeRTOS/Source/queue.c **** 						else
1241:FreeRTOS/Source/queue.c **** 						{
1242:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1243:FreeRTOS/Source/queue.c **** 						}
1244:FreeRTOS/Source/queue.c **** 					}
1245:FreeRTOS/Source/queue.c **** 					else
1246:FreeRTOS/Source/queue.c **** 					{
1247:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1248:FreeRTOS/Source/queue.c **** 					}
1249:FreeRTOS/Source/queue.c **** 				}
1250:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1251:FreeRTOS/Source/queue.c **** 			}
1252:FreeRTOS/Source/queue.c **** 			else
1253:FreeRTOS/Source/queue.c **** 			{
1254:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1255:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1256:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1257:FreeRTOS/Source/queue.c **** 			}
1258:FreeRTOS/Source/queue.c **** 
1259:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1260:FreeRTOS/Source/queue.c **** 		}
1261:FreeRTOS/Source/queue.c **** 		else
1262:FreeRTOS/Source/queue.c **** 		{
1263:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1264:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1265:FreeRTOS/Source/queue.c **** 		}
1266:FreeRTOS/Source/queue.c **** 	}
1267:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1268:FreeRTOS/Source/queue.c **** 
1269:FreeRTOS/Source/queue.c **** 	return xReturn;
1270:FreeRTOS/Source/queue.c **** }
1271:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1272:FreeRTOS/Source/queue.c **** 
1273:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1274:FreeRTOS/Source/queue.c **** {
1275:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1276:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1277:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1278:FreeRTOS/Source/queue.c **** 
1279:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1280:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1281:FreeRTOS/Source/queue.c **** 
1282:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1283:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1284:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1285:FreeRTOS/Source/queue.c **** 
1286:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1287:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1288:FreeRTOS/Source/queue.c **** 	{
1289:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1290:FreeRTOS/Source/queue.c **** 	}
1291:FreeRTOS/Source/queue.c **** 	#endif
1292:FreeRTOS/Source/queue.c **** 
1293:FreeRTOS/Source/queue.c **** 
1294:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1295:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1296:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1297:FreeRTOS/Source/queue.c **** 	for( ;; )
1298:FreeRTOS/Source/queue.c **** 	{
1299:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1300:FreeRTOS/Source/queue.c **** 		{
1301:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1302:FreeRTOS/Source/queue.c **** 
1303:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1304:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1305:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1306:FreeRTOS/Source/queue.c **** 			{
1307:FreeRTOS/Source/queue.c **** 				/* Data available, remove one item. */
1308:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1309:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1310:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1311:FreeRTOS/Source/queue.c **** 
1312:FreeRTOS/Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1313:FreeRTOS/Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1314:FreeRTOS/Source/queue.c **** 				task. */
1315:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1316:FreeRTOS/Source/queue.c **** 				{
1317:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1318:FreeRTOS/Source/queue.c **** 					{
1319:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1320:FreeRTOS/Source/queue.c **** 					}
1321:FreeRTOS/Source/queue.c **** 					else
1322:FreeRTOS/Source/queue.c **** 					{
1323:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1324:FreeRTOS/Source/queue.c **** 					}
1325:FreeRTOS/Source/queue.c **** 				}
1326:FreeRTOS/Source/queue.c **** 				else
1327:FreeRTOS/Source/queue.c **** 				{
1328:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1329:FreeRTOS/Source/queue.c **** 				}
1330:FreeRTOS/Source/queue.c **** 
1331:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1332:FreeRTOS/Source/queue.c **** 				return pdPASS;
1333:FreeRTOS/Source/queue.c **** 			}
1334:FreeRTOS/Source/queue.c **** 			else
1335:FreeRTOS/Source/queue.c **** 			{
1336:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1337:FreeRTOS/Source/queue.c **** 				{
1338:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1339:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1340:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1341:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1342:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1343:FreeRTOS/Source/queue.c **** 				}
1344:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1345:FreeRTOS/Source/queue.c **** 				{
1346:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1347:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1348:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1349:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1350:FreeRTOS/Source/queue.c **** 				}
1351:FreeRTOS/Source/queue.c **** 				else
1352:FreeRTOS/Source/queue.c **** 				{
1353:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1354:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1355:FreeRTOS/Source/queue.c **** 				}
1356:FreeRTOS/Source/queue.c **** 			}
1357:FreeRTOS/Source/queue.c **** 		}
1358:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1359:FreeRTOS/Source/queue.c **** 
1360:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1361:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1362:FreeRTOS/Source/queue.c **** 
1363:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1364:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1365:FreeRTOS/Source/queue.c **** 
1366:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1367:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1368:FreeRTOS/Source/queue.c **** 		{
1369:FreeRTOS/Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1370:FreeRTOS/Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1371:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1372:FreeRTOS/Source/queue.c **** 			{
1373:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1374:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1375:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1376:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1377:FreeRTOS/Source/queue.c **** 				{
1378:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1379:FreeRTOS/Source/queue.c **** 				}
1380:FreeRTOS/Source/queue.c **** 				else
1381:FreeRTOS/Source/queue.c **** 				{
1382:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1383:FreeRTOS/Source/queue.c **** 				}
1384:FreeRTOS/Source/queue.c **** 			}
1385:FreeRTOS/Source/queue.c **** 			else
1386:FreeRTOS/Source/queue.c **** 			{
1387:FreeRTOS/Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1388:FreeRTOS/Source/queue.c **** 				data. */
1389:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1390:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1391:FreeRTOS/Source/queue.c **** 			}
1392:FreeRTOS/Source/queue.c **** 		}
1393:FreeRTOS/Source/queue.c **** 		else
1394:FreeRTOS/Source/queue.c **** 		{
1395:FreeRTOS/Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1396:FreeRTOS/Source/queue.c **** 			back and attempt to read the data. */
1397:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1398:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1399:FreeRTOS/Source/queue.c **** 
1400:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1401:FreeRTOS/Source/queue.c **** 			{
1402:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1403:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1404:FreeRTOS/Source/queue.c **** 			}
1405:FreeRTOS/Source/queue.c **** 			else
1406:FreeRTOS/Source/queue.c **** 			{
1407:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1408:FreeRTOS/Source/queue.c **** 			}
1409:FreeRTOS/Source/queue.c **** 		}
1410:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1411:FreeRTOS/Source/queue.c **** }
1412:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1413:FreeRTOS/Source/queue.c **** 
1414:FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1415:FreeRTOS/Source/queue.c **** {
1416:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1417:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1418:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1419:FreeRTOS/Source/queue.c **** 
1420:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1421:FreeRTOS/Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1422:FreeRTOS/Source/queue.c **** #endif
1423:FreeRTOS/Source/queue.c **** 
1424:FreeRTOS/Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1425:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1426:FreeRTOS/Source/queue.c **** 
1427:FreeRTOS/Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1428:FreeRTOS/Source/queue.c **** 	0. */
1429:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1430:FreeRTOS/Source/queue.c **** 
1431:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1432:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1433:FreeRTOS/Source/queue.c **** 	{
1434:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1435:FreeRTOS/Source/queue.c **** 	}
1436:FreeRTOS/Source/queue.c **** 	#endif
1437:FreeRTOS/Source/queue.c **** 
1438:FreeRTOS/Source/queue.c **** 
1439:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1440:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1441:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1442:FreeRTOS/Source/queue.c **** 	for( ;; )
1443:FreeRTOS/Source/queue.c **** 	{
1444:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1445:FreeRTOS/Source/queue.c **** 		{
1446:FreeRTOS/Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1447:FreeRTOS/Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1448:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1449:FreeRTOS/Source/queue.c **** 
1450:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1451:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1452:FreeRTOS/Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1453:FreeRTOS/Source/queue.c **** 			{
1454:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1455:FreeRTOS/Source/queue.c **** 
1456:FreeRTOS/Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1457:FreeRTOS/Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1458:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1459:FreeRTOS/Source/queue.c **** 
1460:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1461:FreeRTOS/Source/queue.c **** 				{
1462:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1463:FreeRTOS/Source/queue.c **** 					{
1464:FreeRTOS/Source/queue.c **** 						/* Record the information required to implement
1465:FreeRTOS/Source/queue.c **** 						priority inheritance should it become necessary. */
1466:FreeRTOS/Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1467:FreeRTOS/Source/queue.c **** 					}
1468:FreeRTOS/Source/queue.c **** 					else
1469:FreeRTOS/Source/queue.c **** 					{
1470:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1471:FreeRTOS/Source/queue.c **** 					}
1472:FreeRTOS/Source/queue.c **** 				}
1473:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1474:FreeRTOS/Source/queue.c **** 
1475:FreeRTOS/Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1476:FreeRTOS/Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1477:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1478:FreeRTOS/Source/queue.c **** 				{
1479:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1480:FreeRTOS/Source/queue.c **** 					{
1481:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1482:FreeRTOS/Source/queue.c **** 					}
1483:FreeRTOS/Source/queue.c **** 					else
1484:FreeRTOS/Source/queue.c **** 					{
1485:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1486:FreeRTOS/Source/queue.c **** 					}
1487:FreeRTOS/Source/queue.c **** 				}
1488:FreeRTOS/Source/queue.c **** 				else
1489:FreeRTOS/Source/queue.c **** 				{
1490:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1491:FreeRTOS/Source/queue.c **** 				}
1492:FreeRTOS/Source/queue.c **** 
1493:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1494:FreeRTOS/Source/queue.c **** 				return pdPASS;
1495:FreeRTOS/Source/queue.c **** 			}
1496:FreeRTOS/Source/queue.c **** 			else
1497:FreeRTOS/Source/queue.c **** 			{
1498:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1499:FreeRTOS/Source/queue.c **** 				{
1500:FreeRTOS/Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1501:FreeRTOS/Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1502:FreeRTOS/Source/queue.c **** 					if it were 0 the function would have exited. */
1503:FreeRTOS/Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1504:FreeRTOS/Source/queue.c **** 					{
1505:FreeRTOS/Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1506:FreeRTOS/Source/queue.c **** 					}
1507:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1508:FreeRTOS/Source/queue.c **** 
1509:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1510:FreeRTOS/Source/queue.c **** 					(or the block time has expired) so exit now. */
1511:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1512:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1513:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1514:FreeRTOS/Source/queue.c **** 				}
1515:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1516:FreeRTOS/Source/queue.c **** 				{
1517:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1518:FreeRTOS/Source/queue.c **** 					so configure the timeout structure ready to block. */
1519:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1520:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1521:FreeRTOS/Source/queue.c **** 				}
1522:FreeRTOS/Source/queue.c **** 				else
1523:FreeRTOS/Source/queue.c **** 				{
1524:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1525:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1526:FreeRTOS/Source/queue.c **** 				}
1527:FreeRTOS/Source/queue.c **** 			}
1528:FreeRTOS/Source/queue.c **** 		}
1529:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1530:FreeRTOS/Source/queue.c **** 
1531:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1532:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1533:FreeRTOS/Source/queue.c **** 
1534:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1535:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1536:FreeRTOS/Source/queue.c **** 
1537:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1538:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1539:FreeRTOS/Source/queue.c **** 		{
1540:FreeRTOS/Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1541:FreeRTOS/Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1542:FreeRTOS/Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1543:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1544:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1545:FreeRTOS/Source/queue.c **** 			{
1546:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1547:FreeRTOS/Source/queue.c **** 
1548:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1549:FreeRTOS/Source/queue.c **** 				{
1550:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1551:FreeRTOS/Source/queue.c **** 					{
1552:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1553:FreeRTOS/Source/queue.c **** 						{
1554:FreeRTOS/Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1555:FreeRTOS/Source/queue.c **** 						}
1556:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1557:FreeRTOS/Source/queue.c **** 					}
1558:FreeRTOS/Source/queue.c **** 					else
1559:FreeRTOS/Source/queue.c **** 					{
1560:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1561:FreeRTOS/Source/queue.c **** 					}
1562:FreeRTOS/Source/queue.c **** 				}
1563:FreeRTOS/Source/queue.c **** 				#endif
1564:FreeRTOS/Source/queue.c **** 
1565:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1566:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1567:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1568:FreeRTOS/Source/queue.c **** 				{
1569:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1570:FreeRTOS/Source/queue.c **** 				}
1571:FreeRTOS/Source/queue.c **** 				else
1572:FreeRTOS/Source/queue.c **** 				{
1573:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1574:FreeRTOS/Source/queue.c **** 				}
1575:FreeRTOS/Source/queue.c **** 			}
1576:FreeRTOS/Source/queue.c **** 			else
1577:FreeRTOS/Source/queue.c **** 			{
1578:FreeRTOS/Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1579:FreeRTOS/Source/queue.c **** 				attempt to take the semaphore again. */
1580:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1581:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1582:FreeRTOS/Source/queue.c **** 			}
1583:FreeRTOS/Source/queue.c **** 		}
1584:FreeRTOS/Source/queue.c **** 		else
1585:FreeRTOS/Source/queue.c **** 		{
1586:FreeRTOS/Source/queue.c **** 			/* Timed out. */
1587:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1588:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1589:FreeRTOS/Source/queue.c **** 
1590:FreeRTOS/Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1591:FreeRTOS/Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1592:FreeRTOS/Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1593:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1594:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1595:FreeRTOS/Source/queue.c **** 			{
1596:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1597:FreeRTOS/Source/queue.c **** 				{
1598:FreeRTOS/Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1599:FreeRTOS/Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1600:FreeRTOS/Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1601:FreeRTOS/Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1602:FreeRTOS/Source/queue.c **** 					{
1603:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1604:FreeRTOS/Source/queue.c **** 						{
1605:FreeRTOS/Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1606:FreeRTOS/Source/queue.c **** 
1607:FreeRTOS/Source/queue.c **** 							/* This task blocking on the mutex caused another
1608:FreeRTOS/Source/queue.c **** 							task to inherit this task's priority.  Now this task
1609:FreeRTOS/Source/queue.c **** 							has timed out the priority should be disinherited
1610:FreeRTOS/Source/queue.c **** 							again, but only as low as the next highest priority
1611:FreeRTOS/Source/queue.c **** 							task that is waiting for the same mutex. */
1612:FreeRTOS/Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1613:FreeRTOS/Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
1614:FreeRTOS/Source/queue.c **** 						}
1615:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1616:FreeRTOS/Source/queue.c **** 					}
1617:FreeRTOS/Source/queue.c **** 				}
1618:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1619:FreeRTOS/Source/queue.c **** 
1620:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1621:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1622:FreeRTOS/Source/queue.c **** 			}
1623:FreeRTOS/Source/queue.c **** 			else
1624:FreeRTOS/Source/queue.c **** 			{
1625:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1626:FreeRTOS/Source/queue.c **** 			}
1627:FreeRTOS/Source/queue.c **** 		}
1628:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1629:FreeRTOS/Source/queue.c **** }
1630:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1631:FreeRTOS/Source/queue.c **** 
1632:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1633:FreeRTOS/Source/queue.c **** {
1634:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1635:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1636:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1637:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1638:FreeRTOS/Source/queue.c **** 
1639:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1640:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1641:FreeRTOS/Source/queue.c **** 
1642:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1643:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1644:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1645:FreeRTOS/Source/queue.c **** 
1646:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1647:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1648:FreeRTOS/Source/queue.c **** 	{
1649:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1650:FreeRTOS/Source/queue.c **** 	}
1651:FreeRTOS/Source/queue.c **** 	#endif
1652:FreeRTOS/Source/queue.c **** 
1653:FreeRTOS/Source/queue.c **** 
1654:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1655:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1656:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1657:FreeRTOS/Source/queue.c **** 	for( ;; )
1658:FreeRTOS/Source/queue.c **** 	{
1659:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1660:FreeRTOS/Source/queue.c **** 		{
1661:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1662:FreeRTOS/Source/queue.c **** 
1663:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1664:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1665:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1666:FreeRTOS/Source/queue.c **** 			{
1667:FreeRTOS/Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1668:FreeRTOS/Source/queue.c **** 				is read from the queue as this function is only peeking the
1669:FreeRTOS/Source/queue.c **** 				data, not removing it. */
1670:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1671:FreeRTOS/Source/queue.c **** 
1672:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1673:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1674:FreeRTOS/Source/queue.c **** 
1675:FreeRTOS/Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1676:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1677:FreeRTOS/Source/queue.c **** 
1678:FreeRTOS/Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1679:FreeRTOS/Source/queue.c **** 				any other tasks waiting for the data. */
1680:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1681:FreeRTOS/Source/queue.c **** 				{
1682:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1683:FreeRTOS/Source/queue.c **** 					{
1684:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1685:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1686:FreeRTOS/Source/queue.c **** 					}
1687:FreeRTOS/Source/queue.c **** 					else
1688:FreeRTOS/Source/queue.c **** 					{
1689:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1690:FreeRTOS/Source/queue.c **** 					}
1691:FreeRTOS/Source/queue.c **** 				}
1692:FreeRTOS/Source/queue.c **** 				else
1693:FreeRTOS/Source/queue.c **** 				{
1694:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1695:FreeRTOS/Source/queue.c **** 				}
1696:FreeRTOS/Source/queue.c **** 
1697:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1698:FreeRTOS/Source/queue.c **** 				return pdPASS;
1699:FreeRTOS/Source/queue.c **** 			}
1700:FreeRTOS/Source/queue.c **** 			else
1701:FreeRTOS/Source/queue.c **** 			{
1702:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1703:FreeRTOS/Source/queue.c **** 				{
1704:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1705:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1706:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1707:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1708:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1709:FreeRTOS/Source/queue.c **** 				}
1710:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1711:FreeRTOS/Source/queue.c **** 				{
1712:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1713:FreeRTOS/Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1714:FreeRTOS/Source/queue.c **** 					state. */
1715:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1716:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1717:FreeRTOS/Source/queue.c **** 				}
1718:FreeRTOS/Source/queue.c **** 				else
1719:FreeRTOS/Source/queue.c **** 				{
1720:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1721:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1722:FreeRTOS/Source/queue.c **** 				}
1723:FreeRTOS/Source/queue.c **** 			}
1724:FreeRTOS/Source/queue.c **** 		}
1725:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1726:FreeRTOS/Source/queue.c **** 
1727:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1728:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1729:FreeRTOS/Source/queue.c **** 
1730:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1731:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1732:FreeRTOS/Source/queue.c **** 
1733:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1734:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1735:FreeRTOS/Source/queue.c **** 		{
1736:FreeRTOS/Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1737:FreeRTOS/Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1738:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1739:FreeRTOS/Source/queue.c **** 			{
1740:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1741:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1742:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1743:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1744:FreeRTOS/Source/queue.c **** 				{
1745:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1746:FreeRTOS/Source/queue.c **** 				}
1747:FreeRTOS/Source/queue.c **** 				else
1748:FreeRTOS/Source/queue.c **** 				{
1749:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1750:FreeRTOS/Source/queue.c **** 				}
1751:FreeRTOS/Source/queue.c **** 			}
1752:FreeRTOS/Source/queue.c **** 			else
1753:FreeRTOS/Source/queue.c **** 			{
1754:FreeRTOS/Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1755:FreeRTOS/Source/queue.c **** 				state, instead return to try and obtain the data. */
1756:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1757:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1758:FreeRTOS/Source/queue.c **** 			}
1759:FreeRTOS/Source/queue.c **** 		}
1760:FreeRTOS/Source/queue.c **** 		else
1761:FreeRTOS/Source/queue.c **** 		{
1762:FreeRTOS/Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1763:FreeRTOS/Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1764:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1765:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1766:FreeRTOS/Source/queue.c **** 
1767:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1768:FreeRTOS/Source/queue.c **** 			{
1769:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1770:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1771:FreeRTOS/Source/queue.c **** 			}
1772:FreeRTOS/Source/queue.c **** 			else
1773:FreeRTOS/Source/queue.c **** 			{
1774:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1775:FreeRTOS/Source/queue.c **** 			}
1776:FreeRTOS/Source/queue.c **** 		}
1777:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1778:FreeRTOS/Source/queue.c **** }
1779:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1780:FreeRTOS/Source/queue.c **** 
1781:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1782:FreeRTOS/Source/queue.c **** {
1783:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1784:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1785:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1786:FreeRTOS/Source/queue.c **** 
1787:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1788:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1789:FreeRTOS/Source/queue.c **** 
1790:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1791:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1792:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1793:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1794:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1795:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1796:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1797:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1798:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1799:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1800:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1801:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1802:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1803:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1804:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1805:FreeRTOS/Source/queue.c **** 
1806:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1807:FreeRTOS/Source/queue.c **** 	{
1808:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1809:FreeRTOS/Source/queue.c **** 
1810:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1811:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1812:FreeRTOS/Source/queue.c **** 		{
1813:FreeRTOS/Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
1814:FreeRTOS/Source/queue.c **** 
1815:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1816:FreeRTOS/Source/queue.c **** 
1817:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1818:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1819:FreeRTOS/Source/queue.c **** 
1820:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1821:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1822:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1823:FreeRTOS/Source/queue.c **** 			locked. */
1824:FreeRTOS/Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
1825:FreeRTOS/Source/queue.c **** 			{
1826:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1827:FreeRTOS/Source/queue.c **** 				{
1828:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1829:FreeRTOS/Source/queue.c **** 					{
1830:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1831:FreeRTOS/Source/queue.c **** 						force a context switch. */
1832:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1833:FreeRTOS/Source/queue.c **** 						{
1834:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1835:FreeRTOS/Source/queue.c **** 						}
1836:FreeRTOS/Source/queue.c **** 						else
1837:FreeRTOS/Source/queue.c **** 						{
1838:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1839:FreeRTOS/Source/queue.c **** 						}
1840:FreeRTOS/Source/queue.c **** 					}
1841:FreeRTOS/Source/queue.c **** 					else
1842:FreeRTOS/Source/queue.c **** 					{
1843:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1844:FreeRTOS/Source/queue.c **** 					}
1845:FreeRTOS/Source/queue.c **** 				}
1846:FreeRTOS/Source/queue.c **** 				else
1847:FreeRTOS/Source/queue.c **** 				{
1848:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1849:FreeRTOS/Source/queue.c **** 				}
1850:FreeRTOS/Source/queue.c **** 			}
1851:FreeRTOS/Source/queue.c **** 			else
1852:FreeRTOS/Source/queue.c **** 			{
1853:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1854:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1855:FreeRTOS/Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1856:FreeRTOS/Source/queue.c **** 			}
1857:FreeRTOS/Source/queue.c **** 
1858:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1859:FreeRTOS/Source/queue.c **** 		}
1860:FreeRTOS/Source/queue.c **** 		else
1861:FreeRTOS/Source/queue.c **** 		{
1862:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1863:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1864:FreeRTOS/Source/queue.c **** 		}
1865:FreeRTOS/Source/queue.c **** 	}
1866:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1867:FreeRTOS/Source/queue.c **** 
1868:FreeRTOS/Source/queue.c **** 	return xReturn;
1869:FreeRTOS/Source/queue.c **** }
1870:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1871:FreeRTOS/Source/queue.c **** 
1872:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1873:FreeRTOS/Source/queue.c **** {
1874:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1875:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1876:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1877:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1878:FreeRTOS/Source/queue.c **** 
1879:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1880:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1881:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1882:FreeRTOS/Source/queue.c **** 
1883:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1884:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1885:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1886:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1887:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1888:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1889:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1890:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1891:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1892:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1893:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1894:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1895:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1896:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1897:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1898:FreeRTOS/Source/queue.c **** 
1899:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1900:FreeRTOS/Source/queue.c **** 	{
1901:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1902:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1903:FreeRTOS/Source/queue.c **** 		{
1904:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1905:FreeRTOS/Source/queue.c **** 
1906:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1907:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1908:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1909:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1910:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1911:FreeRTOS/Source/queue.c **** 
1912:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1913:FreeRTOS/Source/queue.c **** 		}
1914:FreeRTOS/Source/queue.c **** 		else
1915:FreeRTOS/Source/queue.c **** 		{
1916:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1917:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1918:FreeRTOS/Source/queue.c **** 		}
1919:FreeRTOS/Source/queue.c **** 	}
1920:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1921:FreeRTOS/Source/queue.c **** 
1922:FreeRTOS/Source/queue.c **** 	return xReturn;
1923:FreeRTOS/Source/queue.c **** }
1924:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1925:FreeRTOS/Source/queue.c **** 
1926:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1927:FreeRTOS/Source/queue.c **** {
1928:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1929:FreeRTOS/Source/queue.c **** 
1930:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1931:FreeRTOS/Source/queue.c **** 
1932:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1933:FreeRTOS/Source/queue.c **** 	{
1934:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1935:FreeRTOS/Source/queue.c **** 	}
1936:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1937:FreeRTOS/Source/queue.c **** 
1938:FreeRTOS/Source/queue.c **** 	return uxReturn;
1939:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1940:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1941:FreeRTOS/Source/queue.c **** 
1942:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1943:FreeRTOS/Source/queue.c **** {
1944:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1945:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1946:FreeRTOS/Source/queue.c **** 
1947:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1948:FreeRTOS/Source/queue.c **** 
1949:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1950:FreeRTOS/Source/queue.c **** 	{
1951:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1952:FreeRTOS/Source/queue.c **** 	}
1953:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1954:FreeRTOS/Source/queue.c **** 
1955:FreeRTOS/Source/queue.c **** 	return uxReturn;
1956:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1957:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1958:FreeRTOS/Source/queue.c **** 
1959:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1960:FreeRTOS/Source/queue.c **** {
1961:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1962:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1963:FreeRTOS/Source/queue.c **** 
1964:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1965:FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1966:FreeRTOS/Source/queue.c **** 
1967:FreeRTOS/Source/queue.c **** 	return uxReturn;
1968:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1969:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1970:FreeRTOS/Source/queue.c **** 
1971:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1972:FreeRTOS/Source/queue.c **** {
1973:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1974:FreeRTOS/Source/queue.c **** 
1975:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1976:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1977:FreeRTOS/Source/queue.c **** 
1978:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1979:FreeRTOS/Source/queue.c **** 	{
1980:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1981:FreeRTOS/Source/queue.c **** 	}
1982:FreeRTOS/Source/queue.c **** 	#endif
1983:FreeRTOS/Source/queue.c **** 
1984:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1985:FreeRTOS/Source/queue.c **** 	{
1986:FreeRTOS/Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1987:FreeRTOS/Source/queue.c **** 		again. */
1988:FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue );
1989:FreeRTOS/Source/queue.c **** 	}
1990:FreeRTOS/Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1991:FreeRTOS/Source/queue.c **** 	{
1992:FreeRTOS/Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1993:FreeRTOS/Source/queue.c **** 		check before attempting to free the memory. */
1994:FreeRTOS/Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1995:FreeRTOS/Source/queue.c **** 		{
1996:FreeRTOS/Source/queue.c **** 			vPortFree( pxQueue );
1997:FreeRTOS/Source/queue.c **** 		}
1998:FreeRTOS/Source/queue.c **** 		else
1999:FreeRTOS/Source/queue.c **** 		{
2000:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2001:FreeRTOS/Source/queue.c **** 		}
2002:FreeRTOS/Source/queue.c **** 	}
2003:FreeRTOS/Source/queue.c **** 	#else
2004:FreeRTOS/Source/queue.c **** 	{
2005:FreeRTOS/Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2006:FreeRTOS/Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2007:FreeRTOS/Source/queue.c **** 		( void ) pxQueue;
2008:FreeRTOS/Source/queue.c **** 	}
2009:FreeRTOS/Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2010:FreeRTOS/Source/queue.c **** }
2011:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2012:FreeRTOS/Source/queue.c **** 
2013:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2014:FreeRTOS/Source/queue.c **** 
2015:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2016:FreeRTOS/Source/queue.c **** 	{
2017:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2018:FreeRTOS/Source/queue.c **** 	}
2019:FreeRTOS/Source/queue.c **** 
2020:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2021:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2022:FreeRTOS/Source/queue.c **** 
2023:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2024:FreeRTOS/Source/queue.c **** 
2025:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2026:FreeRTOS/Source/queue.c **** 	{
2027:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2028:FreeRTOS/Source/queue.c **** 	}
2029:FreeRTOS/Source/queue.c **** 
2030:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2031:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2032:FreeRTOS/Source/queue.c **** 
2033:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2034:FreeRTOS/Source/queue.c **** 
2035:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2036:FreeRTOS/Source/queue.c **** 	{
2037:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2038:FreeRTOS/Source/queue.c **** 	}
2039:FreeRTOS/Source/queue.c **** 
2040:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2041:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2042:FreeRTOS/Source/queue.c **** 
2043:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2044:FreeRTOS/Source/queue.c **** 
2045:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2046:FreeRTOS/Source/queue.c **** 	{
2047:FreeRTOS/Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2048:FreeRTOS/Source/queue.c **** 
2049:FreeRTOS/Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2050:FreeRTOS/Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2051:FreeRTOS/Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2052:FreeRTOS/Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2053:FreeRTOS/Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2054:FreeRTOS/Source/queue.c **** 		mutex. */
2055:FreeRTOS/Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2056:FreeRTOS/Source/queue.c **** 		{
2057:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
2058:FreeRTOS/Source/queue.c **** 		}
2059:FreeRTOS/Source/queue.c **** 		else
2060:FreeRTOS/Source/queue.c **** 		{
2061:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2062:FreeRTOS/Source/queue.c **** 		}
2063:FreeRTOS/Source/queue.c **** 
2064:FreeRTOS/Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2065:FreeRTOS/Source/queue.c **** 	}
2066:FreeRTOS/Source/queue.c **** 
2067:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2068:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2069:FreeRTOS/Source/queue.c **** 
2070:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2071:FreeRTOS/Source/queue.c **** {
2072:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
2073:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
2074:FreeRTOS/Source/queue.c **** 
2075:FreeRTOS/Source/queue.c **** 	/* This function is called from a critical section. */
2076:FreeRTOS/Source/queue.c **** 
2077:FreeRTOS/Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2078:FreeRTOS/Source/queue.c **** 
2079:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2080:FreeRTOS/Source/queue.c **** 	{
2081:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2082:FreeRTOS/Source/queue.c **** 		{
2083:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2084:FreeRTOS/Source/queue.c **** 			{
2085:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
2086:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2087:FreeRTOS/Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2088:FreeRTOS/Source/queue.c **** 			}
2089:FreeRTOS/Source/queue.c **** 			else
2090:FreeRTOS/Source/queue.c **** 			{
2091:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2092:FreeRTOS/Source/queue.c **** 			}
2093:FreeRTOS/Source/queue.c **** 		}
2094:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2095:FreeRTOS/Source/queue.c **** 	}
2096:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
2097:FreeRTOS/Source/queue.c **** 	{
2098:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
2099:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
2100:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
2101:FreeRTOS/Source/queue.c **** 		{
2102:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
2103:FreeRTOS/Source/queue.c **** 		}
2104:FreeRTOS/Source/queue.c **** 		else
2105:FreeRTOS/Source/queue.c **** 		{
2106:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2107:FreeRTOS/Source/queue.c **** 		}
2108:FreeRTOS/Source/queue.c **** 	}
2109:FreeRTOS/Source/queue.c **** 	else
2110:FreeRTOS/Source/queue.c **** 	{
2111:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
2112:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2113:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
2114:FreeRTOS/Source/queue.c **** 		{
2115:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2116:FreeRTOS/Source/queue.c **** 		}
2117:FreeRTOS/Source/queue.c **** 		else
2118:FreeRTOS/Source/queue.c **** 		{
2119:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2120:FreeRTOS/Source/queue.c **** 		}
2121:FreeRTOS/Source/queue.c **** 
2122:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
2123:FreeRTOS/Source/queue.c **** 		{
2124:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2125:FreeRTOS/Source/queue.c **** 			{
2126:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2127:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
2128:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
2129:FreeRTOS/Source/queue.c **** 				correct. */
2130:FreeRTOS/Source/queue.c **** 				--uxMessagesWaiting;
2131:FreeRTOS/Source/queue.c **** 			}
2132:FreeRTOS/Source/queue.c **** 			else
2133:FreeRTOS/Source/queue.c **** 			{
2134:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2135:FreeRTOS/Source/queue.c **** 			}
2136:FreeRTOS/Source/queue.c **** 		}
2137:FreeRTOS/Source/queue.c **** 		else
2138:FreeRTOS/Source/queue.c **** 		{
2139:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2140:FreeRTOS/Source/queue.c **** 		}
2141:FreeRTOS/Source/queue.c **** 	}
2142:FreeRTOS/Source/queue.c **** 
2143:FreeRTOS/Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2144:FreeRTOS/Source/queue.c **** 
2145:FreeRTOS/Source/queue.c **** 	return xReturn;
2146:FreeRTOS/Source/queue.c **** }
2147:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2148:FreeRTOS/Source/queue.c **** 
2149:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2150:FreeRTOS/Source/queue.c **** {
2151:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2152:FreeRTOS/Source/queue.c **** 	{
2153:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
2154:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
2155:FreeRTOS/Source/queue.c **** 		{
2156:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2157:FreeRTOS/Source/queue.c **** 		}
2158:FreeRTOS/Source/queue.c **** 		else
2159:FreeRTOS/Source/queue.c **** 		{
2160:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2161:FreeRTOS/Source/queue.c **** 		}
2162:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
2163:FreeRTOS/Source/queue.c **** 	}
2164:FreeRTOS/Source/queue.c **** }
2165:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2166:FreeRTOS/Source/queue.c **** 
2167:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2168:FreeRTOS/Source/queue.c **** {
2169:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2170:FreeRTOS/Source/queue.c **** 
2171:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2172:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2173:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2174:FreeRTOS/Source/queue.c **** 	updated. */
2175:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2176:FreeRTOS/Source/queue.c **** 	{
2177:FreeRTOS/Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
2178:FreeRTOS/Source/queue.c **** 
2179:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2180:FreeRTOS/Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
2181:FreeRTOS/Source/queue.c **** 		{
2182:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2183:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
2184:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2185:FreeRTOS/Source/queue.c **** 			{
2186:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2187:FreeRTOS/Source/queue.c **** 				{
2188:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
2189:FreeRTOS/Source/queue.c **** 					{
2190:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2191:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2192:FreeRTOS/Source/queue.c **** 						A context switch is required. */
2193:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2194:FreeRTOS/Source/queue.c **** 					}
2195:FreeRTOS/Source/queue.c **** 					else
2196:FreeRTOS/Source/queue.c **** 					{
2197:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2198:FreeRTOS/Source/queue.c **** 					}
2199:FreeRTOS/Source/queue.c **** 				}
2200:FreeRTOS/Source/queue.c **** 				else
2201:FreeRTOS/Source/queue.c **** 				{
2202:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get
2203:FreeRTOS/Source/queue.c **** 					added to the pending ready list as the scheduler is still
2204:FreeRTOS/Source/queue.c **** 					suspended. */
2205:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2206:FreeRTOS/Source/queue.c **** 					{
2207:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2208:FreeRTOS/Source/queue.c **** 						{
2209:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2210:FreeRTOS/Source/queue.c **** 							context	switch is required. */
2211:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
2212:FreeRTOS/Source/queue.c **** 						}
2213:FreeRTOS/Source/queue.c **** 						else
2214:FreeRTOS/Source/queue.c **** 						{
2215:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2216:FreeRTOS/Source/queue.c **** 						}
2217:FreeRTOS/Source/queue.c **** 					}
2218:FreeRTOS/Source/queue.c **** 					else
2219:FreeRTOS/Source/queue.c **** 					{
2220:FreeRTOS/Source/queue.c **** 						break;
2221:FreeRTOS/Source/queue.c **** 					}
2222:FreeRTOS/Source/queue.c **** 				}
2223:FreeRTOS/Source/queue.c **** 			}
2224:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2225:FreeRTOS/Source/queue.c **** 			{
2226:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2227:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2228:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2229:FreeRTOS/Source/queue.c **** 				{
2230:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2231:FreeRTOS/Source/queue.c **** 					{
2232:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that
2233:FreeRTOS/Source/queue.c **** 						a context switch is required. */
2234:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2235:FreeRTOS/Source/queue.c **** 					}
2236:FreeRTOS/Source/queue.c **** 					else
2237:FreeRTOS/Source/queue.c **** 					{
2238:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2239:FreeRTOS/Source/queue.c **** 					}
2240:FreeRTOS/Source/queue.c **** 				}
2241:FreeRTOS/Source/queue.c **** 				else
2242:FreeRTOS/Source/queue.c **** 				{
2243:FreeRTOS/Source/queue.c **** 					break;
2244:FreeRTOS/Source/queue.c **** 				}
2245:FreeRTOS/Source/queue.c **** 			}
2246:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2247:FreeRTOS/Source/queue.c **** 
2248:FreeRTOS/Source/queue.c **** 			--cTxLock;
2249:FreeRTOS/Source/queue.c **** 		}
2250:FreeRTOS/Source/queue.c **** 
2251:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
2252:FreeRTOS/Source/queue.c **** 	}
2253:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2254:FreeRTOS/Source/queue.c **** 
2255:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
2256:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2257:FreeRTOS/Source/queue.c **** 	{
2258:FreeRTOS/Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
2259:FreeRTOS/Source/queue.c **** 
2260:FreeRTOS/Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
2261:FreeRTOS/Source/queue.c **** 		{
2262:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2263:FreeRTOS/Source/queue.c **** 			{
2264:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2265:FreeRTOS/Source/queue.c **** 				{
2266:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
2267:FreeRTOS/Source/queue.c **** 				}
2268:FreeRTOS/Source/queue.c **** 				else
2269:FreeRTOS/Source/queue.c **** 				{
2270:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2271:FreeRTOS/Source/queue.c **** 				}
2272:FreeRTOS/Source/queue.c **** 
2273:FreeRTOS/Source/queue.c **** 				--cRxLock;
2274:FreeRTOS/Source/queue.c **** 			}
2275:FreeRTOS/Source/queue.c **** 			else
2276:FreeRTOS/Source/queue.c **** 			{
2277:FreeRTOS/Source/queue.c **** 				break;
2278:FreeRTOS/Source/queue.c **** 			}
2279:FreeRTOS/Source/queue.c **** 		}
2280:FreeRTOS/Source/queue.c **** 
2281:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
2282:FreeRTOS/Source/queue.c **** 	}
2283:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2284:FreeRTOS/Source/queue.c **** }
2285:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2286:FreeRTOS/Source/queue.c **** 
2287:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2288:FreeRTOS/Source/queue.c **** {
 201               	.LM0:
 202               	.LFBB1:
 203               	/* prologue: function */
 204               	/* frame size = 0 */
 205               	/* stack size = 0 */
 206               	.L__stack_usage = 0
2289:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2290:FreeRTOS/Source/queue.c **** 
2291:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 208               	.LM1:
 209               	/* #APP */
 210               	 ;  2291 "FreeRTOS/Source/queue.c" 1
 211 0000 0FB6      		in		__tmp_reg__, __SREG__
 212               	 ;  0 "" 2
 213               	 ;  2291 "FreeRTOS/Source/queue.c" 1
 214 0002 F894      		cli
 215               	 ;  0 "" 2
 216               	 ;  2291 "FreeRTOS/Source/queue.c" 1
 217 0004 0F92      		push	__tmp_reg__
 218               	 ;  0 "" 2
2292:FreeRTOS/Source/queue.c **** 	{
2293:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 220               	.LM2:
 221               	/* #NOAPP */
 222 0006 FC01      		movw r30,r24
 223 0008 928D      		ldd r25,Z+26
2294:FreeRTOS/Source/queue.c **** 		{
2295:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2296:FreeRTOS/Source/queue.c **** 		}
2297:FreeRTOS/Source/queue.c **** 		else
2298:FreeRTOS/Source/queue.c **** 		{
2299:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2300:FreeRTOS/Source/queue.c **** 		}
2301:FreeRTOS/Source/queue.c **** 	}
2302:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 225               	.LM3:
 226               	/* #APP */
 227               	 ;  2302 "FreeRTOS/Source/queue.c" 1
 228 000a 0F90      		pop		__tmp_reg__
 229               	 ;  0 "" 2
 230               	 ;  2302 "FreeRTOS/Source/queue.c" 1
 231 000c 0FBE      		out		__SREG__, __tmp_reg__
 232               	 ;  0 "" 2
2303:FreeRTOS/Source/queue.c **** 
2304:FreeRTOS/Source/queue.c **** 	return xReturn;
 234               	.LM4:
 235               	/* #NOAPP */
 236 000e 81E0      		ldi r24,lo8(1)
 237 0010 9111      		cpse r25,__zero_reg__
 238 0012 80E0      		ldi r24,0
 239               	.L2:
2305:FreeRTOS/Source/queue.c **** }
 241               	.LM5:
 242 0014 0895      		ret
 244               	.Lscope1:
 246               		.stabd	78,0,0
 252               	prvCopyDataToQueue:
 253               		.stabd	46,0,0
2071:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
 255               	.LM6:
 256               	.LFBB2:
 257 0016 0F93      		push r16
 258 0018 1F93      		push r17
 259 001a CF93      		push r28
 260 001c DF93      		push r29
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 4 */
 264               	.L__stack_usage = 4
 265 001e EC01      		movw r28,r24
 266 0020 042F      		mov r16,r20
2077:FreeRTOS/Source/queue.c **** 
 268               	.LM7:
 269 0022 1A8D      		ldd r17,Y+26
2079:FreeRTOS/Source/queue.c **** 	{
 271               	.LM8:
 272 0024 4C8D      		ldd r20,Y+28
 273 0026 4423      		tst r20
 274 0028 01F0      		breq .L8
 275 002a 50E0      		ldi r21,0
2096:FreeRTOS/Source/queue.c **** 	{
 277               	.LM9:
 278 002c 0111      		cpse r16,__zero_reg__
 279 002e 00C0      		rjmp .L9
2098:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 281               	.LM10:
 282 0030 8A81      		ldd r24,Y+2
 283 0032 9B81      		ldd r25,Y+3
 284 0034 0E94 0000 		call memcpy
2099:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 286               	.LM11:
 287 0038 2C8D      		ldd r18,Y+28
 288 003a 8A81      		ldd r24,Y+2
 289 003c 9B81      		ldd r25,Y+3
 290 003e 820F      		add r24,r18
 291 0040 911D      		adc r25,__zero_reg__
 292 0042 9B83      		std Y+3,r25
 293 0044 8A83      		std Y+2,r24
2100:FreeRTOS/Source/queue.c **** 		{
 295               	.LM12:
 296 0046 2C81      		ldd r18,Y+4
 297 0048 3D81      		ldd r19,Y+5
 298 004a 8217      		cp r24,r18
 299 004c 9307      		cpc r25,r19
 300 004e 00F0      		brlo .L8
2102:FreeRTOS/Source/queue.c **** 		}
 302               	.LM13:
 303 0050 8881      		ld r24,Y
 304 0052 9981      		ldd r25,Y+1
 305 0054 9B83      		std Y+3,r25
 306 0056 8A83      		std Y+2,r24
 307 0058 00C0      		rjmp .L8
 308               	.L9:
2111:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 310               	.LM14:
 311 005a 8E81      		ldd r24,Y+6
 312 005c 9F81      		ldd r25,Y+7
 313 005e 0E94 0000 		call memcpy
2112:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 315               	.LM15:
 316 0062 8C8D      		ldd r24,Y+28
 317 0064 90E0      		ldi r25,0
 318 0066 9195      		neg r25
 319 0068 8195      		neg r24
 320 006a 9109      		sbc r25,__zero_reg__
 321 006c 2E81      		ldd r18,Y+6
 322 006e 3F81      		ldd r19,Y+7
 323 0070 280F      		add r18,r24
 324 0072 391F      		adc r19,r25
 325 0074 3F83      		std Y+7,r19
 326 0076 2E83      		std Y+6,r18
2113:FreeRTOS/Source/queue.c **** 		{
 328               	.LM16:
 329 0078 4881      		ld r20,Y
 330 007a 5981      		ldd r21,Y+1
 331 007c 2417      		cp r18,r20
 332 007e 3507      		cpc r19,r21
 333 0080 00F4      		brsh .L10
2115:FreeRTOS/Source/queue.c **** 		}
 335               	.LM17:
 336 0082 2C81      		ldd r18,Y+4
 337 0084 3D81      		ldd r19,Y+5
 338 0086 820F      		add r24,r18
 339 0088 931F      		adc r25,r19
 340 008a 9F83      		std Y+7,r25
 341 008c 8E83      		std Y+6,r24
 342               	.L10:
2122:FreeRTOS/Source/queue.c **** 		{
 344               	.LM18:
 345 008e 0230      		cpi r16,lo8(2)
 346 0090 01F4      		brne .L8
2124:FreeRTOS/Source/queue.c **** 			{
 348               	.LM19:
 349 0092 1111      		cpse r17,__zero_reg__
2130:FreeRTOS/Source/queue.c **** 			}
 351               	.LM20:
 352 0094 1150      		subi r17,lo8(-(-1))
 353               	.L8:
2143:FreeRTOS/Source/queue.c **** 
 355               	.LM21:
 356 0096 1F5F      		subi r17,lo8(-(1))
 357 0098 1A8F      		std Y+26,r17
2146:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 359               	.LM22:
 360 009a 80E0      		ldi r24,0
 361               	/* epilogue start */
 362 009c DF91      		pop r29
 363 009e CF91      		pop r28
 364 00a0 1F91      		pop r17
 365 00a2 0F91      		pop r16
 366 00a4 0895      		ret
 371               	.Lscope2:
 373               		.stabd	78,0,0
 378               	prvCopyDataFromQueue:
 379               		.stabd	46,0,0
2150:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 381               	.LM23:
 382               	.LFBB3:
 383               	/* prologue: function */
 384               	/* frame size = 0 */
 385               	/* stack size = 0 */
 386               	.L__stack_usage = 0
 387 00a6 FC01      		movw r30,r24
 388 00a8 CB01      		movw r24,r22
2151:FreeRTOS/Source/queue.c **** 	{
 390               	.LM24:
 391 00aa 448D      		ldd r20,Z+28
 392 00ac 4423      		tst r20
 393 00ae 01F0      		breq .L17
2153:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 395               	.LM25:
 396 00b0 50E0      		ldi r21,0
 397 00b2 2681      		ldd r18,Z+6
 398 00b4 3781      		ldd r19,Z+7
 399 00b6 240F      		add r18,r20
 400 00b8 351F      		adc r19,r21
 401 00ba 3783      		std Z+7,r19
 402 00bc 2683      		std Z+6,r18
2154:FreeRTOS/Source/queue.c **** 		{
 404               	.LM26:
 405 00be 6481      		ldd r22,Z+4
 406 00c0 7581      		ldd r23,Z+5
 407 00c2 2617      		cp r18,r22
 408 00c4 3707      		cpc r19,r23
 409 00c6 00F0      		brlo .L19
2156:FreeRTOS/Source/queue.c **** 		}
 411               	.LM27:
 412 00c8 2081      		ld r18,Z
 413 00ca 3181      		ldd r19,Z+1
 414 00cc 3783      		std Z+7,r19
 415 00ce 2683      		std Z+6,r18
 416               	.L19:
2162:FreeRTOS/Source/queue.c **** 	}
 418               	.LM28:
 419 00d0 6681      		ldd r22,Z+6
 420 00d2 7781      		ldd r23,Z+7
 421 00d4 0C94 0000 		jmp memcpy
 422               	.L17:
 423 00d8 0895      		ret
 425               	.Lscope3:
 427               		.stabd	78,0,0
 431               	prvUnlockQueue:
 432               		.stabd	46,0,0
2168:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 434               	.LM29:
 435               	.LFBB4:
 436 00da EF92      		push r14
 437 00dc FF92      		push r15
 438 00de 1F93      		push r17
 439 00e0 CF93      		push r28
 440 00e2 DF93      		push r29
 441               	/* prologue: function */
 442               	/* frame size = 0 */
 443               	/* stack size = 5 */
 444               	.L__stack_usage = 5
 445 00e4 EC01      		movw r28,r24
2175:FreeRTOS/Source/queue.c **** 	{
 447               	.LM30:
 448               	/* #APP */
 449               	 ;  2175 "FreeRTOS/Source/queue.c" 1
 450 00e6 0FB6      		in		__tmp_reg__, __SREG__
 451               	 ;  0 "" 2
 452               	 ;  2175 "FreeRTOS/Source/queue.c" 1
 453 00e8 F894      		cli
 454               	 ;  0 "" 2
 455               	 ;  2175 "FreeRTOS/Source/queue.c" 1
 456 00ea 0F92      		push	__tmp_reg__
 457               	 ;  0 "" 2
 458               	/* #NOAPP */
 459               	.LBB2:
2177:FreeRTOS/Source/queue.c **** 
 461               	.LM31:
 462 00ec 1E8D      		ldd r17,Y+30
2230:FreeRTOS/Source/queue.c **** 					{
 464               	.LM32:
 465 00ee 7C01      		movw r14,r24
 466 00f0 81E1      		ldi r24,17
 467 00f2 E80E      		add r14,r24
 468 00f4 F11C      		adc r15,__zero_reg__
 469               	.L21:
2180:FreeRTOS/Source/queue.c **** 		{
 471               	.LM33:
 472 00f6 1116      		cp __zero_reg__,r17
 473 00f8 04F4      		brge .L22
2228:FreeRTOS/Source/queue.c **** 				{
 475               	.LM34:
 476 00fa 8989      		ldd r24,Y+17
 477 00fc 8823      		tst r24
 478 00fe 01F0      		breq .L22
2230:FreeRTOS/Source/queue.c **** 					{
 480               	.LM35:
 481 0100 C701      		movw r24,r14
 482 0102 0E94 0000 		call xTaskRemoveFromEventList
 483 0106 8111      		cpse r24,__zero_reg__
2234:FreeRTOS/Source/queue.c **** 					}
 485               	.LM36:
 486 0108 0E94 0000 		call vTaskMissedYield
 487               	.L23:
 488 010c 1150      		subi r17,lo8(-(-1))
 489 010e 00C0      		rjmp .L21
 490               	.L22:
2251:FreeRTOS/Source/queue.c **** 	}
 492               	.LM37:
 493 0110 8FEF      		ldi r24,lo8(-1)
 494 0112 8E8F      		std Y+30,r24
 495               	.LBE2:
2253:FreeRTOS/Source/queue.c **** 
 497               	.LM38:
 498               	/* #APP */
 499               	 ;  2253 "FreeRTOS/Source/queue.c" 1
 500 0114 0F90      		pop		__tmp_reg__
 501               	 ;  0 "" 2
 502               	 ;  2253 "FreeRTOS/Source/queue.c" 1
 503 0116 0FBE      		out		__SREG__, __tmp_reg__
 504               	 ;  0 "" 2
2256:FreeRTOS/Source/queue.c **** 	{
 506               	.LM39:
 507               	 ;  2256 "FreeRTOS/Source/queue.c" 1
 508 0118 0FB6      		in		__tmp_reg__, __SREG__
 509               	 ;  0 "" 2
 510               	 ;  2256 "FreeRTOS/Source/queue.c" 1
 511 011a F894      		cli
 512               	 ;  0 "" 2
 513               	 ;  2256 "FreeRTOS/Source/queue.c" 1
 514 011c 0F92      		push	__tmp_reg__
 515               	 ;  0 "" 2
 516               	/* #NOAPP */
 517               	.LBB3:
2258:FreeRTOS/Source/queue.c **** 
 519               	.LM40:
 520 011e 1D8D      		ldd r17,Y+29
2264:FreeRTOS/Source/queue.c **** 				{
 522               	.LM41:
 523 0120 7E01      		movw r14,r28
 524 0122 88E0      		ldi r24,8
 525 0124 E80E      		add r14,r24
 526 0126 F11C      		adc r15,__zero_reg__
 527               	.L25:
2260:FreeRTOS/Source/queue.c **** 		{
 529               	.LM42:
 530 0128 1116      		cp __zero_reg__,r17
 531 012a 04F4      		brge .L26
2262:FreeRTOS/Source/queue.c **** 			{
 533               	.LM43:
 534 012c 8885      		ldd r24,Y+8
 535 012e 8823      		tst r24
 536 0130 01F0      		breq .L26
2264:FreeRTOS/Source/queue.c **** 				{
 538               	.LM44:
 539 0132 C701      		movw r24,r14
 540 0134 0E94 0000 		call xTaskRemoveFromEventList
 541 0138 8111      		cpse r24,__zero_reg__
2266:FreeRTOS/Source/queue.c **** 				}
 543               	.LM45:
 544 013a 0E94 0000 		call vTaskMissedYield
 545               	.L27:
 546 013e 1150      		subi r17,lo8(-(-1))
 547 0140 00C0      		rjmp .L25
 548               	.L26:
2281:FreeRTOS/Source/queue.c **** 	}
 550               	.LM46:
 551 0142 8FEF      		ldi r24,lo8(-1)
 552 0144 8D8F      		std Y+29,r24
 553               	.LBE3:
2283:FreeRTOS/Source/queue.c **** }
 555               	.LM47:
 556               	/* #APP */
 557               	 ;  2283 "FreeRTOS/Source/queue.c" 1
 558 0146 0F90      		pop		__tmp_reg__
 559               	 ;  0 "" 2
 560               	 ;  2283 "FreeRTOS/Source/queue.c" 1
 561 0148 0FBE      		out		__SREG__, __tmp_reg__
 562               	 ;  0 "" 2
 563               	/* epilogue start */
2284:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 565               	.LM48:
 566               	/* #NOAPP */
 567 014a DF91      		pop r29
 568 014c CF91      		pop r28
 569 014e 1F91      		pop r17
 570 0150 FF90      		pop r15
 571 0152 EF90      		pop r14
 572 0154 0895      		ret
 580               	.Lscope4:
 582               		.stabd	78,0,0
 586               	.global	xQueueGenericReset
 588               	xQueueGenericReset:
 589               		.stabd	46,0,0
 256:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 591               	.LM49:
 592               	.LFBB5:
 593 0156 CF93      		push r28
 594 0158 DF93      		push r29
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 2 */
 598               	.L__stack_usage = 2
 599 015a EC01      		movw r28,r24
 261:FreeRTOS/Source/queue.c **** 	{
 601               	.LM50:
 602               	/* #APP */
 603               	 ;  261 "FreeRTOS/Source/queue.c" 1
 604 015c 0FB6      		in		__tmp_reg__, __SREG__
 605               	 ;  0 "" 2
 606               	 ;  261 "FreeRTOS/Source/queue.c" 1
 607 015e F894      		cli
 608               	 ;  0 "" 2
 609               	 ;  261 "FreeRTOS/Source/queue.c" 1
 610 0160 0F92      		push	__tmp_reg__
 611               	 ;  0 "" 2
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 613               	.LM51:
 614               	/* #NOAPP */
 615 0162 4881      		ld r20,Y
 616 0164 5981      		ldd r21,Y+1
 617 0166 8B8D      		ldd r24,Y+27
 618 0168 7C8D      		ldd r23,Y+28
 619 016a 9A01      		movw r18,r20
 620 016c 879F      		mul r24,r23
 621 016e 200D      		add r18,r0
 622 0170 311D      		adc r19,r1
 623 0172 1124      		clr __zero_reg__
 624 0174 3D83      		std Y+5,r19
 625 0176 2C83      		std Y+4,r18
 264:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 627               	.LM52:
 628 0178 1A8E      		std Y+26,__zero_reg__
 265:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 630               	.LM53:
 631 017a 5B83      		std Y+3,r21
 632 017c 4A83      		std Y+2,r20
 266:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 634               	.LM54:
 635 017e 90E0      		ldi r25,0
 636 0180 0197      		sbiw r24,1
 637 0182 789F      		mul r23,r24
 638 0184 9001      		movw r18,r0
 639 0186 799F      		mul r23,r25
 640 0188 300D      		add r19,r0
 641 018a 1124      		clr __zero_reg__
 642 018c CA01      		movw r24,r20
 643 018e 820F      		add r24,r18
 644 0190 931F      		adc r25,r19
 645 0192 9F83      		std Y+7,r25
 646 0194 8E83      		std Y+6,r24
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 648               	.LM55:
 649 0196 8FEF      		ldi r24,lo8(-1)
 650 0198 8D8F      		std Y+29,r24
 268:FreeRTOS/Source/queue.c **** 
 652               	.LM56:
 653 019a 8E8F      		std Y+30,r24
 270:FreeRTOS/Source/queue.c **** 		{
 655               	.LM57:
 656 019c 6111      		cpse r22,__zero_reg__
 657 019e 00C0      		rjmp .L42
 277:FreeRTOS/Source/queue.c **** 			{
 659               	.LM58:
 660 01a0 8885      		ldd r24,Y+8
 661 01a2 8823      		tst r24
 662 01a4 01F0      		breq .L44
 279:FreeRTOS/Source/queue.c **** 				{
 664               	.LM59:
 665 01a6 CE01      		movw r24,r28
 666 01a8 0896      		adiw r24,8
 667 01aa 0E94 0000 		call xTaskRemoveFromEventList
 668 01ae 8823      		tst r24
 669 01b0 01F0      		breq .L44
 281:FreeRTOS/Source/queue.c **** 				}
 671               	.LM60:
 672 01b2 0E94 0000 		call vPortYield
 673 01b6 00C0      		rjmp .L44
 674               	.L42:
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 676               	.LM61:
 677 01b8 CE01      		movw r24,r28
 678 01ba 0896      		adiw r24,8
 679 01bc 0E94 0000 		call vListInitialise
 297:FreeRTOS/Source/queue.c **** 		}
 681               	.LM62:
 682 01c0 CE01      		movw r24,r28
 683 01c2 4196      		adiw r24,17
 684 01c4 0E94 0000 		call vListInitialise
 685               	.L44:
 300:FreeRTOS/Source/queue.c **** 
 687               	.LM63:
 688               	/* #APP */
 689               	 ;  300 "FreeRTOS/Source/queue.c" 1
 690 01c8 0F90      		pop		__tmp_reg__
 691               	 ;  0 "" 2
 692               	 ;  300 "FreeRTOS/Source/queue.c" 1
 693 01ca 0FBE      		out		__SREG__, __tmp_reg__
 694               	 ;  0 "" 2
 305:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 696               	.LM64:
 697               	/* #NOAPP */
 698 01cc 81E0      		ldi r24,lo8(1)
 699               	/* epilogue start */
 700 01ce DF91      		pop r29
 701 01d0 CF91      		pop r28
 702 01d2 0895      		ret
 704               	.Lscope5:
 706               		.stabd	78,0,0
 711               	.global	xQueueGenericCreate
 713               	xQueueGenericCreate:
 714               		.stabd	46,0,0
 369:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 716               	.LM65:
 717               	.LFBB6:
 718 01d4 0F93      		push r16
 719 01d6 1F93      		push r17
 720 01d8 CF93      		push r28
 721 01da DF93      		push r29
 722               	/* prologue: function */
 723               	/* frame size = 0 */
 724               	/* stack size = 4 */
 725               	.L__stack_usage = 4
 726 01dc 082F      		mov r16,r24
 727 01de 162F      		mov r17,r22
 376:FreeRTOS/Source/queue.c **** 		{
 729               	.LM66:
 730 01e0 6623      		tst r22
 731 01e2 01F0      		breq .L54
 385:FreeRTOS/Source/queue.c **** 		}
 733               	.LM67:
 734 01e4 869F      		mul r24,r22
 735 01e6 C001      		movw r24,r0
 736 01e8 1124      		clr __zero_reg__
 737 01ea 00C0      		rjmp .L50
 738               	.L54:
 379:FreeRTOS/Source/queue.c **** 		}
 740               	.LM68:
 741 01ec 80E0      		ldi r24,0
 742 01ee 90E0      		ldi r25,0
 743               	.L50:
 397:FreeRTOS/Source/queue.c **** 
 745               	.LM69:
 746 01f0 4F96      		adiw r24,31
 747 01f2 0E94 0000 		call pvPortMalloc
 748 01f6 EC01      		movw r28,r24
 399:FreeRTOS/Source/queue.c **** 		{
 750               	.LM70:
 751 01f8 0097      		sbiw r24,0
 752 01fa 01F0      		breq .L51
 753               	.LBB6:
 754               	.LBB7:
 435:FreeRTOS/Source/queue.c **** 	{
 756               	.LM71:
 757 01fc 1111      		cpse r17,__zero_reg__
 758 01fe 00C0      		rjmp .L52
 441:FreeRTOS/Source/queue.c **** 	}
 760               	.LM72:
 761 0200 9983      		std Y+1,r25
 762 0202 8883      		st Y,r24
 763 0204 00C0      		rjmp .L53
 764               	.L52:
 446:FreeRTOS/Source/queue.c **** 	}
 766               	.LM73:
 767 0206 4F96      		adiw r24,31
 768 0208 9983      		std Y+1,r25
 769 020a 8883      		st Y,r24
 770               	.L53:
 451:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 772               	.LM74:
 773 020c 0B8F      		std Y+27,r16
 452:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 775               	.LM75:
 776 020e 1C8F      		std Y+28,r17
 453:FreeRTOS/Source/queue.c **** 
 778               	.LM76:
 779 0210 61E0      		ldi r22,lo8(1)
 780 0212 CE01      		movw r24,r28
 781 0214 0E94 0000 		call xQueueGenericReset
 782               	.L51:
 783               	.LBE7:
 784               	.LBE6:
 424:FreeRTOS/Source/queue.c **** 
 786               	.LM77:
 787 0218 CE01      		movw r24,r28
 788               	/* epilogue start */
 789 021a DF91      		pop r29
 790 021c CF91      		pop r28
 791 021e 1F91      		pop r17
 792 0220 0F91      		pop r16
 793 0222 0895      		ret
 798               	.Lscope6:
 800               		.stabd	78,0,0
 806               	.global	xQueueGenericSend
 808               	xQueueGenericSend:
 809               		.stabd	46,0,0
 748:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 811               	.LM78:
 812               	.LFBB7:
 813 0224 AF92      		push r10
 814 0226 BF92      		push r11
 815 0228 CF92      		push r12
 816 022a DF92      		push r13
 817 022c FF92      		push r15
 818 022e 0F93      		push r16
 819 0230 1F93      		push r17
 820 0232 CF93      		push r28
 821 0234 DF93      		push r29
 822 0236 00D0      		rcall .
 823 0238 00D0      		rcall .
 824 023a 1F92      		push __zero_reg__
 825 023c CDB7      		in r28,__SP_L__
 826 023e DEB7      		in r29,__SP_H__
 827               	/* prologue: function */
 828               	/* frame size = 5 */
 829               	/* stack size = 14 */
 830               	.L__stack_usage = 14
 831 0240 8C01      		movw r16,r24
 832 0242 6B01      		movw r12,r22
 833 0244 5D83      		std Y+5,r21
 834 0246 4C83      		std Y+4,r20
 835 0248 F22E      		mov r15,r18
 749:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 837               	.LM79:
 838 024a 80E0      		ldi r24,0
 918:FreeRTOS/Source/queue.c **** 
 840               	.LM80:
 841 024c 5801      		movw r10,r16
 842 024e 98E0      		ldi r25,8
 843 0250 A90E      		add r10,r25
 844 0252 B11C      		adc r11,__zero_reg__
 845               	.L59:
 768:FreeRTOS/Source/queue.c **** 		{
 847               	.LM81:
 848               	/* #APP */
 849               	 ;  768 "FreeRTOS/Source/queue.c" 1
 850 0254 0FB6      		in		__tmp_reg__, __SREG__
 851               	 ;  0 "" 2
 852               	 ;  768 "FreeRTOS/Source/queue.c" 1
 853 0256 F894      		cli
 854               	 ;  0 "" 2
 855               	 ;  768 "FreeRTOS/Source/queue.c" 1
 856 0258 0F92      		push	__tmp_reg__
 857               	 ;  0 "" 2
 774:FreeRTOS/Source/queue.c **** 			{
 859               	.LM82:
 860               	/* #NOAPP */
 861 025a F801      		movw r30,r16
 862 025c 228D      		ldd r18,Z+26
 863 025e 938D      		ldd r25,Z+27
 864 0260 2917      		cp r18,r25
 865 0262 00F0      		brlo .L60
 774:FreeRTOS/Source/queue.c **** 			{
 867               	.LM83:
 868 0264 F2E0      		ldi r31,lo8(2)
 869 0266 FF12      		cpse r15,r31
 870 0268 00C0      		rjmp .L61
 871               	.L60:
 840:FreeRTOS/Source/queue.c **** 
 873               	.LM84:
 874 026a 4F2D      		mov r20,r15
 875 026c B601      		movw r22,r12
 876 026e C801      		movw r24,r16
 877 0270 0E94 0000 		call prvCopyDataToQueue
 844:FreeRTOS/Source/queue.c **** 					{
 879               	.LM85:
 880 0274 F801      		movw r30,r16
 881 0276 9189      		ldd r25,Z+17
 882 0278 9923      		tst r25
 883 027a 01F0      		breq .L74
 846:FreeRTOS/Source/queue.c **** 						{
 885               	.LM86:
 886 027c C801      		movw r24,r16
 887 027e 4196      		adiw r24,17
 888 0280 0E94 0000 		call xTaskRemoveFromEventList
 889               	.L74:
 890 0284 8111      		cpse r24,__zero_reg__
 852:FreeRTOS/Source/queue.c **** 						}
 892               	.LM87:
 893 0286 0E94 0000 		call vPortYield
 894               	.L64:
 874:FreeRTOS/Source/queue.c **** 				return pdPASS;
 896               	.LM88:
 897               	/* #APP */
 898               	 ;  874 "FreeRTOS/Source/queue.c" 1
 899 028a 0F90      		pop		__tmp_reg__
 900               	 ;  0 "" 2
 901               	 ;  874 "FreeRTOS/Source/queue.c" 1
 902 028c 0FBE      		out		__SREG__, __tmp_reg__
 903               	 ;  0 "" 2
 875:FreeRTOS/Source/queue.c **** 			}
 905               	.LM89:
 906               	/* #NOAPP */
 907 028e 81E0      		ldi r24,lo8(1)
 908 0290 00C0      		rjmp .L66
 909               	.L61:
 879:FreeRTOS/Source/queue.c **** 				{
 911               	.LM90:
 912 0292 2C81      		ldd r18,Y+4
 913 0294 3D81      		ldd r19,Y+5
 914 0296 232B      		or r18,r19
 915 0298 01F4      		brne .L67
 883:FreeRTOS/Source/queue.c **** 
 917               	.LM91:
 918               	/* #APP */
 919               	 ;  883 "FreeRTOS/Source/queue.c" 1
 920 029a 0F90      		pop		__tmp_reg__
 921               	 ;  0 "" 2
 922               	 ;  883 "FreeRTOS/Source/queue.c" 1
 923 029c 0FBE      		out		__SREG__, __tmp_reg__
 924               	 ;  0 "" 2
 925               	/* #NOAPP */
 926 029e 00C0      		rjmp .L75
 927               	.L67:
 890:FreeRTOS/Source/queue.c **** 				{
 929               	.LM92:
 930 02a0 8111      		cpse r24,__zero_reg__
 931 02a2 00C0      		rjmp .L68
 894:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 933               	.LM93:
 934 02a4 CE01      		movw r24,r28
 935 02a6 0196      		adiw r24,1
 936 02a8 0E94 0000 		call vTaskInternalSetTimeOutState
 937               	.L68:
 904:FreeRTOS/Source/queue.c **** 
 939               	.LM94:
 940               	/* #APP */
 941               	 ;  904 "FreeRTOS/Source/queue.c" 1
 942 02ac 0F90      		pop		__tmp_reg__
 943               	 ;  0 "" 2
 944               	 ;  904 "FreeRTOS/Source/queue.c" 1
 945 02ae 0FBE      		out		__SREG__, __tmp_reg__
 946               	 ;  0 "" 2
 909:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 948               	.LM95:
 949               	/* #NOAPP */
 950 02b0 0E94 0000 		call vTaskSuspendAll
 910:FreeRTOS/Source/queue.c **** 
 952               	.LM96:
 953               	/* #APP */
 954               	 ;  910 "FreeRTOS/Source/queue.c" 1
 955 02b4 0FB6      		in		__tmp_reg__, __SREG__
 956               	 ;  0 "" 2
 957               	 ;  910 "FreeRTOS/Source/queue.c" 1
 958 02b6 F894      		cli
 959               	 ;  0 "" 2
 960               	 ;  910 "FreeRTOS/Source/queue.c" 1
 961 02b8 0F92      		push	__tmp_reg__
 962               	 ;  0 "" 2
 963               	/* #NOAPP */
 964 02ba F801      		movw r30,r16
 965 02bc 858D      		ldd r24,Z+29
 966 02be 8F3F      		cpi r24,lo8(-1)
 967 02c0 01F4      		brne .L69
 910:FreeRTOS/Source/queue.c **** 
 969               	.LM97:
 970 02c2 158E      		std Z+29,__zero_reg__
 971               	.L69:
 910:FreeRTOS/Source/queue.c **** 
 973               	.LM98:
 974 02c4 F801      		movw r30,r16
 975 02c6 868D      		ldd r24,Z+30
 976 02c8 8F3F      		cpi r24,lo8(-1)
 977 02ca 01F4      		brne .L70
 910:FreeRTOS/Source/queue.c **** 
 979               	.LM99:
 980 02cc 168E      		std Z+30,__zero_reg__
 981               	.L70:
 910:FreeRTOS/Source/queue.c **** 
 983               	.LM100:
 984               	/* #APP */
 985               	 ;  910 "FreeRTOS/Source/queue.c" 1
 986 02ce 0F90      		pop		__tmp_reg__
 987               	 ;  0 "" 2
 988               	 ;  910 "FreeRTOS/Source/queue.c" 1
 989 02d0 0FBE      		out		__SREG__, __tmp_reg__
 990               	 ;  0 "" 2
 913:FreeRTOS/Source/queue.c **** 		{
 992               	.LM101:
 993               	/* #NOAPP */
 994 02d2 BE01      		movw r22,r28
 995 02d4 6C5F      		subi r22,-4
 996 02d6 7F4F      		sbci r23,-1
 997 02d8 CE01      		movw r24,r28
 998 02da 0196      		adiw r24,1
 999 02dc 0E94 0000 		call xTaskCheckForTimeOut
 1000 02e0 8111      		cpse r24,__zero_reg__
 1001 02e2 00C0      		rjmp .L71
 1002               	.LBB10:
 1003               	.LBB11:
2306:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2307:FreeRTOS/Source/queue.c **** 
2308:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2309:FreeRTOS/Source/queue.c **** {
2310:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2311:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
2312:FreeRTOS/Source/queue.c **** 
2313:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2314:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2315:FreeRTOS/Source/queue.c **** 	{
2316:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2317:FreeRTOS/Source/queue.c **** 	}
2318:FreeRTOS/Source/queue.c **** 	else
2319:FreeRTOS/Source/queue.c **** 	{
2320:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2321:FreeRTOS/Source/queue.c **** 	}
2322:FreeRTOS/Source/queue.c **** 
2323:FreeRTOS/Source/queue.c **** 	return xReturn;
2324:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2325:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2326:FreeRTOS/Source/queue.c **** 
2327:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2328:FreeRTOS/Source/queue.c **** {
2329:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2330:FreeRTOS/Source/queue.c **** 
2331:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1005               	.LM102:
 1006               	/* #APP */
 1007               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 1008 02e4 0FB6      		in		__tmp_reg__, __SREG__
 1009               	 ;  0 "" 2
 1010               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 1011 02e6 F894      		cli
 1012               	 ;  0 "" 2
 1013               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 1014 02e8 0F92      		push	__tmp_reg__
 1015               	 ;  0 "" 2
2332:FreeRTOS/Source/queue.c **** 	{
2333:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1017               	.LM103:
 1018               	/* #NOAPP */
 1019 02ea F801      		movw r30,r16
 1020 02ec 928D      		ldd r25,Z+26
2334:FreeRTOS/Source/queue.c **** 		{
2335:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2336:FreeRTOS/Source/queue.c **** 		}
2337:FreeRTOS/Source/queue.c **** 		else
2338:FreeRTOS/Source/queue.c **** 		{
2339:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2340:FreeRTOS/Source/queue.c **** 		}
2341:FreeRTOS/Source/queue.c **** 	}
2342:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1022               	.LM104:
 1023               	/* #APP */
 1024               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 1025 02ee 0F90      		pop		__tmp_reg__
 1026               	 ;  0 "" 2
 1027               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 1028 02f0 0FBE      		out		__SREG__, __tmp_reg__
 1029               	 ;  0 "" 2
 1030               	/* #NOAPP */
 1031               	.LBE11:
 1032               	.LBE10:
 915:FreeRTOS/Source/queue.c **** 			{
 1034               	.LM105:
 1035 02f2 838D      		ldd r24,Z+27
 1036 02f4 9813      		cpse r25,r24
 1037 02f6 00C0      		rjmp .L72
 918:FreeRTOS/Source/queue.c **** 
 1039               	.LM106:
 1040 02f8 6C81      		ldd r22,Y+4
 1041 02fa 7D81      		ldd r23,Y+5
 1042 02fc C501      		movw r24,r10
 1043 02fe 0E94 0000 		call vTaskPlaceOnEventList
 925:FreeRTOS/Source/queue.c **** 
 1045               	.LM107:
 1046 0302 C801      		movw r24,r16
 1047 0304 0E94 0000 		call prvUnlockQueue
 932:FreeRTOS/Source/queue.c **** 				{
 1049               	.LM108:
 1050 0308 0E94 0000 		call xTaskResumeAll
 1051 030c 8823      		tst r24
 1052 030e 01F0      		breq .L76
 1053               	.L73:
 1054 0310 81E0      		ldi r24,lo8(1)
 1055 0312 00C0      		rjmp .L59
 1056               	.L76:
 934:FreeRTOS/Source/queue.c **** 				}
 1058               	.LM109:
 1059 0314 0E94 0000 		call vPortYield
 1060 0318 00C0      		rjmp .L73
 1061               	.L72:
 940:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1063               	.LM110:
 1064 031a C801      		movw r24,r16
 1065 031c 0E94 0000 		call prvUnlockQueue
 941:FreeRTOS/Source/queue.c **** 			}
 1067               	.LM111:
 1068 0320 0E94 0000 		call xTaskResumeAll
 1069 0324 00C0      		rjmp .L73
 1070               	.L71:
 947:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1072               	.LM112:
 1073 0326 C801      		movw r24,r16
 1074 0328 0E94 0000 		call prvUnlockQueue
 948:FreeRTOS/Source/queue.c **** 
 1076               	.LM113:
 1077 032c 0E94 0000 		call xTaskResumeAll
 1078               	.L75:
 951:FreeRTOS/Source/queue.c **** 		}
 1080               	.LM114:
 1081 0330 80E0      		ldi r24,0
 1082               	.L66:
 1083               	/* epilogue start */
 954:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1085               	.LM115:
 1086 0332 0F90      		pop __tmp_reg__
 1087 0334 0F90      		pop __tmp_reg__
 1088 0336 0F90      		pop __tmp_reg__
 1089 0338 0F90      		pop __tmp_reg__
 1090 033a 0F90      		pop __tmp_reg__
 1091 033c DF91      		pop r29
 1092 033e CF91      		pop r28
 1093 0340 1F91      		pop r17
 1094 0342 0F91      		pop r16
 1095 0344 FF90      		pop r15
 1096 0346 DF90      		pop r13
 1097 0348 CF90      		pop r12
 1098 034a BF90      		pop r11
 1099 034c AF90      		pop r10
 1100 034e 0895      		ret
 1107               	.Lscope7:
 1109               		.stabd	78,0,0
 1115               	.global	xQueueGenericSendFromISR
 1117               	xQueueGenericSendFromISR:
 1118               		.stabd	46,0,0
 958:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1120               	.LM116:
 1121               	.LFBB8:
 1122 0350 EF92      		push r14
 1123 0352 FF92      		push r15
 1124 0354 1F93      		push r17
 1125 0356 CF93      		push r28
 1126 0358 DF93      		push r29
 1127               	/* prologue: function */
 1128               	/* frame size = 0 */
 1129               	/* stack size = 5 */
 1130               	.L__stack_usage = 5
 1131 035a EC01      		movw r28,r24
 990:FreeRTOS/Source/queue.c **** 		{
 1133               	.LM117:
 1134 035c 9A8D      		ldd r25,Y+26
 1135 035e 8B8D      		ldd r24,Y+27
 1136 0360 9817      		cp r25,r24
 1137 0362 00F0      		brlo .L78
 990:FreeRTOS/Source/queue.c **** 		{
 1139               	.LM118:
 1140 0364 2230      		cpi r18,lo8(2)
 1141 0366 01F4      		brne .L83
 1142               	.L78:
 1143 0368 7A01      		movw r14,r20
 1144               	.LBB12:
 992:FreeRTOS/Source/queue.c **** 
 1146               	.LM119:
 1147 036a 1E8D      		ldd r17,Y+30
1001:FreeRTOS/Source/queue.c **** 
 1149               	.LM120:
 1150 036c 422F      		mov r20,r18
 1151 036e CE01      		movw r24,r28
 1152 0370 0E94 0000 		call prvCopyDataToQueue
1005:FreeRTOS/Source/queue.c **** 			{
 1154               	.LM121:
 1155 0374 1F3F      		cpi r17,lo8(-1)
 1156 0376 01F4      		brne .L80
1060:FreeRTOS/Source/queue.c **** 					{
 1158               	.LM122:
 1159 0378 8989      		ldd r24,Y+17
 1160 037a 8823      		tst r24
 1161 037c 01F0      		breq .L90
1062:FreeRTOS/Source/queue.c **** 						{
 1163               	.LM123:
 1164 037e CE01      		movw r24,r28
 1165 0380 4196      		adiw r24,17
 1166 0382 0E94 0000 		call xTaskRemoveFromEventList
 1167 0386 8823      		tst r24
 1168 0388 01F0      		breq .L90
1066:FreeRTOS/Source/queue.c **** 							{
 1170               	.LM124:
 1171 038a E114      		cp r14,__zero_reg__
 1172 038c F104      		cpc r15,__zero_reg__
 1173 038e 01F0      		breq .L90
1068:FreeRTOS/Source/queue.c **** 							}
 1175               	.LM125:
 1176 0390 81E0      		ldi r24,lo8(1)
 1177 0392 F701      		movw r30,r14
 1178 0394 8083      		st Z,r24
 1179 0396 00C0      		rjmp .L79
 1180               	.L80:
1091:FreeRTOS/Source/queue.c **** 			}
 1182               	.LM126:
 1183 0398 1F5F      		subi r17,lo8(-(1))
 1184 039a 1E8F      		std Y+30,r17
 1185               	.L90:
1094:FreeRTOS/Source/queue.c **** 		}
 1187               	.LM127:
 1188 039c 81E0      		ldi r24,lo8(1)
 1189 039e 00C0      		rjmp .L79
 1190               	.L83:
 1191               	.LBE12:
1099:FreeRTOS/Source/queue.c **** 		}
 1193               	.LM128:
 1194 03a0 80E0      		ldi r24,0
 1195               	.L79:
 1196               	/* epilogue start */
1105:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1198               	.LM129:
 1199 03a2 DF91      		pop r29
 1200 03a4 CF91      		pop r28
 1201 03a6 1F91      		pop r17
 1202 03a8 FF90      		pop r15
 1203 03aa EF90      		pop r14
 1204 03ac 0895      		ret
 1212               	.Lscope8:
 1214               		.stabd	78,0,0
 1218               	.global	xQueueGiveFromISR
 1220               	xQueueGiveFromISR:
 1221               		.stabd	46,0,0
1109:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1223               	.LM130:
 1224               	.LFBB9:
 1225 03ae CF93      		push r28
 1226 03b0 DF93      		push r29
 1227               	/* prologue: function */
 1228               	/* frame size = 0 */
 1229               	/* stack size = 2 */
 1230               	.L__stack_usage = 2
 1231 03b2 FC01      		movw r30,r24
 1232               	.LBB13:
1149:FreeRTOS/Source/queue.c **** 
 1234               	.LM131:
 1235 03b4 928D      		ldd r25,Z+26
1154:FreeRTOS/Source/queue.c **** 		{
 1237               	.LM132:
 1238 03b6 838D      		ldd r24,Z+27
 1239 03b8 9817      		cp r25,r24
 1240 03ba 00F4      		brsh .L96
 1241               	.LBB14:
1156:FreeRTOS/Source/queue.c **** 
 1243               	.LM133:
 1244 03bc 868D      		ldd r24,Z+30
1166:FreeRTOS/Source/queue.c **** 
 1246               	.LM134:
 1247 03be 9F5F      		subi r25,lo8(-(1))
 1248 03c0 928F      		std Z+26,r25
1170:FreeRTOS/Source/queue.c **** 			{
 1250               	.LM135:
 1251 03c2 8F3F      		cpi r24,lo8(-1)
 1252 03c4 01F4      		brne .L93
1225:FreeRTOS/Source/queue.c **** 					{
 1254               	.LM136:
 1255 03c6 8189      		ldd r24,Z+17
 1256 03c8 8823      		tst r24
 1257 03ca 01F0      		breq .L103
 1258 03cc EB01      		movw r28,r22
 1259 03ce CF01      		movw r24,r30
1227:FreeRTOS/Source/queue.c **** 						{
 1261               	.LM137:
 1262 03d0 4196      		adiw r24,17
 1263 03d2 0E94 0000 		call xTaskRemoveFromEventList
 1264 03d6 8823      		tst r24
 1265 03d8 01F0      		breq .L103
1231:FreeRTOS/Source/queue.c **** 							{
 1267               	.LM138:
 1268 03da 2097      		sbiw r28,0
 1269 03dc 01F0      		breq .L103
1233:FreeRTOS/Source/queue.c **** 							}
 1271               	.LM139:
 1272 03de 81E0      		ldi r24,lo8(1)
 1273 03e0 8883      		st Y,r24
 1274 03e2 00C0      		rjmp .L92
 1275               	.L93:
1256:FreeRTOS/Source/queue.c **** 			}
 1277               	.LM140:
 1278 03e4 8F5F      		subi r24,lo8(-(1))
 1279 03e6 868F      		std Z+30,r24
 1280               	.L103:
1259:FreeRTOS/Source/queue.c **** 		}
 1282               	.LM141:
 1283 03e8 81E0      		ldi r24,lo8(1)
 1284 03ea 00C0      		rjmp .L92
 1285               	.L96:
 1286               	.LBE14:
1264:FreeRTOS/Source/queue.c **** 		}
 1288               	.LM142:
 1289 03ec 80E0      		ldi r24,0
 1290               	.L92:
 1291               	/* epilogue start */
 1292               	.LBE13:
1270:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1294               	.LM143:
 1295 03ee DF91      		pop r29
 1296 03f0 CF91      		pop r28
 1297 03f2 0895      		ret
 1308               	.Lscope9:
 1310               		.stabd	78,0,0
 1315               	.global	xQueueReceive
 1317               	xQueueReceive:
 1318               		.stabd	46,0,0
1274:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1320               	.LM144:
 1321               	.LFBB10:
 1322 03f4 AF92      		push r10
 1323 03f6 BF92      		push r11
 1324 03f8 CF92      		push r12
 1325 03fa DF92      		push r13
 1326 03fc FF92      		push r15
 1327 03fe 0F93      		push r16
 1328 0400 1F93      		push r17
 1329 0402 CF93      		push r28
 1330 0404 DF93      		push r29
 1331 0406 00D0      		rcall .
 1332 0408 00D0      		rcall .
 1333 040a 1F92      		push __zero_reg__
 1334 040c CDB7      		in r28,__SP_L__
 1335 040e DEB7      		in r29,__SP_H__
 1336               	/* prologue: function */
 1337               	/* frame size = 5 */
 1338               	/* stack size = 14 */
 1339               	.L__stack_usage = 14
 1340 0410 8C01      		movw r16,r24
 1341 0412 6B01      		movw r12,r22
 1342 0414 5D83      		std Y+5,r21
 1343 0416 4C83      		std Y+4,r20
1275:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1345               	.LM145:
 1346 0418 80E0      		ldi r24,0
1374:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1348               	.LM146:
 1349 041a 5801      		movw r10,r16
 1350 041c 91E1      		ldi r25,17
 1351 041e A90E      		add r10,r25
 1352 0420 B11C      		adc r11,__zero_reg__
 1353               	.L105:
1299:FreeRTOS/Source/queue.c **** 		{
 1355               	.LM147:
 1356               	/* #APP */
 1357               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1358 0422 0FB6      		in		__tmp_reg__, __SREG__
 1359               	 ;  0 "" 2
 1360               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1361 0424 F894      		cli
 1362               	 ;  0 "" 2
 1363               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1364 0426 0F92      		push	__tmp_reg__
 1365               	 ;  0 "" 2
 1366               	/* #NOAPP */
 1367               	.LBB15:
1301:FreeRTOS/Source/queue.c **** 
 1369               	.LM148:
 1370 0428 F801      		movw r30,r16
 1371 042a F28C      		ldd r15,Z+26
1305:FreeRTOS/Source/queue.c **** 			{
 1373               	.LM149:
 1374 042c FF20      		tst r15
 1375 042e 01F0      		breq .L106
1308:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
 1377               	.LM150:
 1378 0430 B601      		movw r22,r12
 1379 0432 C801      		movw r24,r16
 1380 0434 0E94 0000 		call prvCopyDataFromQueue
1310:FreeRTOS/Source/queue.c **** 
 1382               	.LM151:
 1383 0438 FA94      		dec r15
 1384 043a F801      		movw r30,r16
 1385 043c F28E      		std Z+26,r15
1315:FreeRTOS/Source/queue.c **** 				{
 1387               	.LM152:
 1388 043e 8085      		ldd r24,Z+8
 1389 0440 8823      		tst r24
 1390 0442 01F0      		breq .L108
1317:FreeRTOS/Source/queue.c **** 					{
 1392               	.LM153:
 1393 0444 C801      		movw r24,r16
 1394 0446 0896      		adiw r24,8
 1395 0448 0E94 0000 		call xTaskRemoveFromEventList
 1396 044c 8111      		cpse r24,__zero_reg__
1319:FreeRTOS/Source/queue.c **** 					}
 1398               	.LM154:
 1399 044e 0E94 0000 		call vPortYield
 1400               	.L108:
1331:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1402               	.LM155:
 1403               	/* #APP */
 1404               	 ;  1331 "FreeRTOS/Source/queue.c" 1
 1405 0452 0F90      		pop		__tmp_reg__
 1406               	 ;  0 "" 2
 1407               	 ;  1331 "FreeRTOS/Source/queue.c" 1
 1408 0454 0FBE      		out		__SREG__, __tmp_reg__
 1409               	 ;  0 "" 2
1332:FreeRTOS/Source/queue.c **** 			}
 1411               	.LM156:
 1412               	/* #NOAPP */
 1413 0456 81E0      		ldi r24,lo8(1)
 1414 0458 00C0      		rjmp .L110
 1415               	.L106:
1336:FreeRTOS/Source/queue.c **** 				{
 1417               	.LM157:
 1418 045a 2C81      		ldd r18,Y+4
 1419 045c 3D81      		ldd r19,Y+5
 1420 045e 232B      		or r18,r19
 1421 0460 01F4      		brne .L111
1340:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1423               	.LM158:
 1424               	/* #APP */
 1425               	 ;  1340 "FreeRTOS/Source/queue.c" 1
 1426 0462 0F90      		pop		__tmp_reg__
 1427               	 ;  0 "" 2
 1428               	 ;  1340 "FreeRTOS/Source/queue.c" 1
 1429 0464 0FBE      		out		__SREG__, __tmp_reg__
 1430               	 ;  0 "" 2
 1431               	/* #NOAPP */
 1432 0466 00C0      		rjmp .L125
 1433               	.L111:
1344:FreeRTOS/Source/queue.c **** 				{
 1435               	.LM159:
 1436 0468 8111      		cpse r24,__zero_reg__
 1437 046a 00C0      		rjmp .L112
1348:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1439               	.LM160:
 1440 046c CE01      		movw r24,r28
 1441 046e 0196      		adiw r24,1
 1442 0470 0E94 0000 		call vTaskInternalSetTimeOutState
 1443               	.L112:
 1444               	.LBE15:
1358:FreeRTOS/Source/queue.c **** 
 1446               	.LM161:
 1447               	/* #APP */
 1448               	 ;  1358 "FreeRTOS/Source/queue.c" 1
 1449 0474 0F90      		pop		__tmp_reg__
 1450               	 ;  0 "" 2
 1451               	 ;  1358 "FreeRTOS/Source/queue.c" 1
 1452 0476 0FBE      		out		__SREG__, __tmp_reg__
 1453               	 ;  0 "" 2
1363:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1455               	.LM162:
 1456               	/* #NOAPP */
 1457 0478 0E94 0000 		call vTaskSuspendAll
1364:FreeRTOS/Source/queue.c **** 
 1459               	.LM163:
 1460               	/* #APP */
 1461               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1462 047c 0FB6      		in		__tmp_reg__, __SREG__
 1463               	 ;  0 "" 2
 1464               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1465 047e F894      		cli
 1466               	 ;  0 "" 2
 1467               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1468 0480 0F92      		push	__tmp_reg__
 1469               	 ;  0 "" 2
 1470               	/* #NOAPP */
 1471 0482 F801      		movw r30,r16
 1472 0484 858D      		ldd r24,Z+29
 1473 0486 8F3F      		cpi r24,lo8(-1)
 1474 0488 01F4      		brne .L113
1364:FreeRTOS/Source/queue.c **** 
 1476               	.LM164:
 1477 048a 158E      		std Z+29,__zero_reg__
 1478               	.L113:
1364:FreeRTOS/Source/queue.c **** 
 1480               	.LM165:
 1481 048c F801      		movw r30,r16
 1482 048e 868D      		ldd r24,Z+30
 1483 0490 8F3F      		cpi r24,lo8(-1)
 1484 0492 01F4      		brne .L114
1364:FreeRTOS/Source/queue.c **** 
 1486               	.LM166:
 1487 0494 168E      		std Z+30,__zero_reg__
 1488               	.L114:
1364:FreeRTOS/Source/queue.c **** 
 1490               	.LM167:
 1491               	/* #APP */
 1492               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1493 0496 0F90      		pop		__tmp_reg__
 1494               	 ;  0 "" 2
 1495               	 ;  1364 "FreeRTOS/Source/queue.c" 1
 1496 0498 0FBE      		out		__SREG__, __tmp_reg__
 1497               	 ;  0 "" 2
1367:FreeRTOS/Source/queue.c **** 		{
 1499               	.LM168:
 1500               	/* #NOAPP */
 1501 049a BE01      		movw r22,r28
 1502 049c 6C5F      		subi r22,-4
 1503 049e 7F4F      		sbci r23,-1
 1504 04a0 CE01      		movw r24,r28
 1505 04a2 0196      		adiw r24,1
 1506 04a4 0E94 0000 		call xTaskCheckForTimeOut
 1507 04a8 8111      		cpse r24,__zero_reg__
 1508 04aa 00C0      		rjmp .L115
1371:FreeRTOS/Source/queue.c **** 			{
 1510               	.LM169:
 1511 04ac C801      		movw r24,r16
 1512 04ae 0E94 0000 		call prvIsQueueEmpty
 1513 04b2 8823      		tst r24
 1514 04b4 01F0      		breq .L116
1374:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1516               	.LM170:
 1517 04b6 6C81      		ldd r22,Y+4
 1518 04b8 7D81      		ldd r23,Y+5
 1519 04ba C501      		movw r24,r10
 1520 04bc 0E94 0000 		call vTaskPlaceOnEventList
1375:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1522               	.LM171:
 1523 04c0 C801      		movw r24,r16
 1524 04c2 0E94 0000 		call prvUnlockQueue
1376:FreeRTOS/Source/queue.c **** 				{
 1526               	.LM172:
 1527 04c6 0E94 0000 		call xTaskResumeAll
 1528 04ca 8823      		tst r24
 1529 04cc 01F0      		breq .L126
 1530               	.L118:
 1531 04ce 81E0      		ldi r24,lo8(1)
 1532 04d0 00C0      		rjmp .L105
 1533               	.L126:
1378:FreeRTOS/Source/queue.c **** 				}
 1535               	.LM173:
 1536 04d2 0E94 0000 		call vPortYield
 1537 04d6 00C0      		rjmp .L118
 1538               	.L116:
1389:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1540               	.LM174:
 1541 04d8 C801      		movw r24,r16
 1542 04da 0E94 0000 		call prvUnlockQueue
1390:FreeRTOS/Source/queue.c **** 			}
 1544               	.LM175:
 1545 04de 0E94 0000 		call xTaskResumeAll
 1546 04e2 00C0      		rjmp .L118
 1547               	.L115:
1397:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1549               	.LM176:
 1550 04e4 C801      		movw r24,r16
 1551 04e6 0E94 0000 		call prvUnlockQueue
1398:FreeRTOS/Source/queue.c **** 
 1553               	.LM177:
 1554 04ea 0E94 0000 		call xTaskResumeAll
1400:FreeRTOS/Source/queue.c **** 			{
 1556               	.LM178:
 1557 04ee C801      		movw r24,r16
 1558 04f0 0E94 0000 		call prvIsQueueEmpty
 1559 04f4 8823      		tst r24
 1560 04f6 01F0      		breq .L118
 1561               	.L125:
1403:FreeRTOS/Source/queue.c **** 			}
 1563               	.LM179:
 1564 04f8 80E0      		ldi r24,0
 1565               	.L110:
 1566               	/* epilogue start */
1411:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1568               	.LM180:
 1569 04fa 0F90      		pop __tmp_reg__
 1570 04fc 0F90      		pop __tmp_reg__
 1571 04fe 0F90      		pop __tmp_reg__
 1572 0500 0F90      		pop __tmp_reg__
 1573 0502 0F90      		pop __tmp_reg__
 1574 0504 DF91      		pop r29
 1575 0506 CF91      		pop r28
 1576 0508 1F91      		pop r17
 1577 050a 0F91      		pop r16
 1578 050c FF90      		pop r15
 1579 050e DF90      		pop r13
 1580 0510 CF90      		pop r12
 1581 0512 BF90      		pop r11
 1582 0514 AF90      		pop r10
 1583 0516 0895      		ret
 1592               	.Lscope10:
 1594               		.stabd	78,0,0
 1598               	.global	xQueueSemaphoreTake
 1600               	xQueueSemaphoreTake:
 1601               		.stabd	46,0,0
1415:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1603               	.LM181:
 1604               	.LFBB11:
 1605 0518 EF92      		push r14
 1606 051a FF92      		push r15
 1607 051c 0F93      		push r16
 1608 051e 1F93      		push r17
 1609 0520 CF93      		push r28
 1610 0522 DF93      		push r29
 1611 0524 00D0      		rcall .
 1612 0526 00D0      		rcall .
 1613 0528 1F92      		push __zero_reg__
 1614 052a CDB7      		in r28,__SP_L__
 1615 052c DEB7      		in r29,__SP_H__
 1616               	/* prologue: function */
 1617               	/* frame size = 5 */
 1618               	/* stack size = 11 */
 1619               	.L__stack_usage = 11
 1620 052e 8C01      		movw r16,r24
 1621 0530 7D83      		std Y+5,r23
 1622 0532 6C83      		std Y+4,r22
1416:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1624               	.LM182:
 1625 0534 90E0      		ldi r25,0
1565:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1627               	.LM183:
 1628 0536 7801      		movw r14,r16
 1629 0538 81E1      		ldi r24,17
 1630 053a E80E      		add r14,r24
 1631 053c F11C      		adc r15,__zero_reg__
 1632               	.L128:
1444:FreeRTOS/Source/queue.c **** 		{
 1634               	.LM184:
 1635               	/* #APP */
 1636               	 ;  1444 "FreeRTOS/Source/queue.c" 1
 1637 053e 0FB6      		in		__tmp_reg__, __SREG__
 1638               	 ;  0 "" 2
 1639               	 ;  1444 "FreeRTOS/Source/queue.c" 1
 1640 0540 F894      		cli
 1641               	 ;  0 "" 2
 1642               	 ;  1444 "FreeRTOS/Source/queue.c" 1
 1643 0542 0F92      		push	__tmp_reg__
 1644               	 ;  0 "" 2
 1645               	/* #NOAPP */
 1646               	.LBB16:
1448:FreeRTOS/Source/queue.c **** 
 1648               	.LM185:
 1649 0544 F801      		movw r30,r16
 1650 0546 828D      		ldd r24,Z+26
1452:FreeRTOS/Source/queue.c **** 			{
 1652               	.LM186:
 1653 0548 8823      		tst r24
 1654 054a 01F0      		breq .L129
1458:FreeRTOS/Source/queue.c **** 
 1656               	.LM187:
 1657 054c 8150      		subi r24,lo8(-(-1))
 1658 054e 828F      		std Z+26,r24
1477:FreeRTOS/Source/queue.c **** 				{
 1660               	.LM188:
 1661 0550 8085      		ldd r24,Z+8
 1662 0552 8823      		tst r24
 1663 0554 01F0      		breq .L131
1479:FreeRTOS/Source/queue.c **** 					{
 1665               	.LM189:
 1666 0556 C801      		movw r24,r16
 1667 0558 0896      		adiw r24,8
 1668 055a 0E94 0000 		call xTaskRemoveFromEventList
 1669 055e 8111      		cpse r24,__zero_reg__
1481:FreeRTOS/Source/queue.c **** 					}
 1671               	.LM190:
 1672 0560 0E94 0000 		call vPortYield
 1673               	.L131:
1493:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1675               	.LM191:
 1676               	/* #APP */
 1677               	 ;  1493 "FreeRTOS/Source/queue.c" 1
 1678 0564 0F90      		pop		__tmp_reg__
 1679               	 ;  0 "" 2
 1680               	 ;  1493 "FreeRTOS/Source/queue.c" 1
 1681 0566 0FBE      		out		__SREG__, __tmp_reg__
 1682               	 ;  0 "" 2
1494:FreeRTOS/Source/queue.c **** 			}
 1684               	.LM192:
 1685               	/* #NOAPP */
 1686 0568 81E0      		ldi r24,lo8(1)
 1687 056a 00C0      		rjmp .L133
 1688               	.L129:
1498:FreeRTOS/Source/queue.c **** 				{
 1690               	.LM193:
 1691 056c 2C81      		ldd r18,Y+4
 1692 056e 3D81      		ldd r19,Y+5
 1693 0570 232B      		or r18,r19
 1694 0572 01F4      		brne .L134
1511:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1696               	.LM194:
 1697               	/* #APP */
 1698               	 ;  1511 "FreeRTOS/Source/queue.c" 1
 1699 0574 0F90      		pop		__tmp_reg__
 1700               	 ;  0 "" 2
 1701               	 ;  1511 "FreeRTOS/Source/queue.c" 1
 1702 0576 0FBE      		out		__SREG__, __tmp_reg__
 1703               	 ;  0 "" 2
 1704               	/* #NOAPP */
 1705 0578 00C0      		rjmp .L148
 1706               	.L134:
1515:FreeRTOS/Source/queue.c **** 				{
 1708               	.LM195:
 1709 057a 9111      		cpse r25,__zero_reg__
 1710 057c 00C0      		rjmp .L135
1519:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1712               	.LM196:
 1713 057e CE01      		movw r24,r28
 1714 0580 0196      		adiw r24,1
 1715 0582 0E94 0000 		call vTaskInternalSetTimeOutState
 1716               	.L135:
 1717               	.LBE16:
1529:FreeRTOS/Source/queue.c **** 
 1719               	.LM197:
 1720               	/* #APP */
 1721               	 ;  1529 "FreeRTOS/Source/queue.c" 1
 1722 0586 0F90      		pop		__tmp_reg__
 1723               	 ;  0 "" 2
 1724               	 ;  1529 "FreeRTOS/Source/queue.c" 1
 1725 0588 0FBE      		out		__SREG__, __tmp_reg__
 1726               	 ;  0 "" 2
1534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1728               	.LM198:
 1729               	/* #NOAPP */
 1730 058a 0E94 0000 		call vTaskSuspendAll
1535:FreeRTOS/Source/queue.c **** 
 1732               	.LM199:
 1733               	/* #APP */
 1734               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1735 058e 0FB6      		in		__tmp_reg__, __SREG__
 1736               	 ;  0 "" 2
 1737               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1738 0590 F894      		cli
 1739               	 ;  0 "" 2
 1740               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1741 0592 0F92      		push	__tmp_reg__
 1742               	 ;  0 "" 2
 1743               	/* #NOAPP */
 1744 0594 F801      		movw r30,r16
 1745 0596 858D      		ldd r24,Z+29
 1746 0598 8F3F      		cpi r24,lo8(-1)
 1747 059a 01F4      		brne .L136
1535:FreeRTOS/Source/queue.c **** 
 1749               	.LM200:
 1750 059c 158E      		std Z+29,__zero_reg__
 1751               	.L136:
1535:FreeRTOS/Source/queue.c **** 
 1753               	.LM201:
 1754 059e F801      		movw r30,r16
 1755 05a0 868D      		ldd r24,Z+30
 1756 05a2 8F3F      		cpi r24,lo8(-1)
 1757 05a4 01F4      		brne .L137
1535:FreeRTOS/Source/queue.c **** 
 1759               	.LM202:
 1760 05a6 168E      		std Z+30,__zero_reg__
 1761               	.L137:
1535:FreeRTOS/Source/queue.c **** 
 1763               	.LM203:
 1764               	/* #APP */
 1765               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1766 05a8 0F90      		pop		__tmp_reg__
 1767               	 ;  0 "" 2
 1768               	 ;  1535 "FreeRTOS/Source/queue.c" 1
 1769 05aa 0FBE      		out		__SREG__, __tmp_reg__
 1770               	 ;  0 "" 2
1538:FreeRTOS/Source/queue.c **** 		{
 1772               	.LM204:
 1773               	/* #NOAPP */
 1774 05ac BE01      		movw r22,r28
 1775 05ae 6C5F      		subi r22,-4
 1776 05b0 7F4F      		sbci r23,-1
 1777 05b2 CE01      		movw r24,r28
 1778 05b4 0196      		adiw r24,1
 1779 05b6 0E94 0000 		call xTaskCheckForTimeOut
 1780 05ba 8111      		cpse r24,__zero_reg__
 1781 05bc 00C0      		rjmp .L138
1544:FreeRTOS/Source/queue.c **** 			{
 1783               	.LM205:
 1784 05be C801      		movw r24,r16
 1785 05c0 0E94 0000 		call prvIsQueueEmpty
 1786 05c4 8823      		tst r24
 1787 05c6 01F0      		breq .L139
1565:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1789               	.LM206:
 1790 05c8 6C81      		ldd r22,Y+4
 1791 05ca 7D81      		ldd r23,Y+5
 1792 05cc C701      		movw r24,r14
 1793 05ce 0E94 0000 		call vTaskPlaceOnEventList
1566:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1795               	.LM207:
 1796 05d2 C801      		movw r24,r16
 1797 05d4 0E94 0000 		call prvUnlockQueue
1567:FreeRTOS/Source/queue.c **** 				{
 1799               	.LM208:
 1800 05d8 0E94 0000 		call xTaskResumeAll
 1801 05dc 8823      		tst r24
 1802 05de 01F0      		breq .L149
 1803               	.L141:
 1804 05e0 91E0      		ldi r25,lo8(1)
 1805 05e2 00C0      		rjmp .L128
 1806               	.L149:
1569:FreeRTOS/Source/queue.c **** 				}
 1808               	.LM209:
 1809 05e4 0E94 0000 		call vPortYield
 1810 05e8 00C0      		rjmp .L141
 1811               	.L139:
1580:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1813               	.LM210:
 1814 05ea C801      		movw r24,r16
 1815 05ec 0E94 0000 		call prvUnlockQueue
1581:FreeRTOS/Source/queue.c **** 			}
 1817               	.LM211:
 1818 05f0 0E94 0000 		call xTaskResumeAll
 1819 05f4 00C0      		rjmp .L141
 1820               	.L138:
1587:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1822               	.LM212:
 1823 05f6 C801      		movw r24,r16
 1824 05f8 0E94 0000 		call prvUnlockQueue
1588:FreeRTOS/Source/queue.c **** 
 1826               	.LM213:
 1827 05fc 0E94 0000 		call xTaskResumeAll
1594:FreeRTOS/Source/queue.c **** 			{
 1829               	.LM214:
 1830 0600 C801      		movw r24,r16
 1831 0602 0E94 0000 		call prvIsQueueEmpty
 1832 0606 8823      		tst r24
 1833 0608 01F0      		breq .L141
 1834               	.L148:
1621:FreeRTOS/Source/queue.c **** 			}
 1836               	.LM215:
 1837 060a 80E0      		ldi r24,0
 1838               	.L133:
 1839               	/* epilogue start */
1629:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1841               	.LM216:
 1842 060c 0F90      		pop __tmp_reg__
 1843 060e 0F90      		pop __tmp_reg__
 1844 0610 0F90      		pop __tmp_reg__
 1845 0612 0F90      		pop __tmp_reg__
 1846 0614 0F90      		pop __tmp_reg__
 1847 0616 DF91      		pop r29
 1848 0618 CF91      		pop r28
 1849 061a 1F91      		pop r17
 1850 061c 0F91      		pop r16
 1851 061e FF90      		pop r15
 1852 0620 EF90      		pop r14
 1853 0622 0895      		ret
 1862               	.Lscope11:
 1864               		.stabd	78,0,0
 1869               	.global	xQueuePeek
 1871               	xQueuePeek:
 1872               		.stabd	46,0,0
1633:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1874               	.LM217:
 1875               	.LFBB12:
 1876 0624 CF92      		push r12
 1877 0626 DF92      		push r13
 1878 0628 EF92      		push r14
 1879 062a FF92      		push r15
 1880 062c 0F93      		push r16
 1881 062e 1F93      		push r17
 1882 0630 CF93      		push r28
 1883 0632 DF93      		push r29
 1884 0634 00D0      		rcall .
 1885 0636 00D0      		rcall .
 1886 0638 1F92      		push __zero_reg__
 1887 063a CDB7      		in r28,__SP_L__
 1888 063c DEB7      		in r29,__SP_H__
 1889               	/* prologue: function */
 1890               	/* frame size = 5 */
 1891               	/* stack size = 13 */
 1892               	.L__stack_usage = 13
 1893 063e 8C01      		movw r16,r24
 1894 0640 7B01      		movw r14,r22
 1895 0642 5D83      		std Y+5,r21
 1896 0644 4C83      		std Y+4,r20
1634:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1898               	.LM218:
 1899 0646 80E0      		ldi r24,0
1741:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1901               	.LM219:
 1902 0648 6801      		movw r12,r16
 1903 064a 91E1      		ldi r25,17
 1904 064c C90E      		add r12,r25
 1905 064e D11C      		adc r13,__zero_reg__
 1906               	.L151:
1659:FreeRTOS/Source/queue.c **** 		{
 1908               	.LM220:
 1909               	/* #APP */
 1910               	 ;  1659 "FreeRTOS/Source/queue.c" 1
 1911 0650 0FB6      		in		__tmp_reg__, __SREG__
 1912               	 ;  0 "" 2
 1913               	 ;  1659 "FreeRTOS/Source/queue.c" 1
 1914 0652 F894      		cli
 1915               	 ;  0 "" 2
 1916               	 ;  1659 "FreeRTOS/Source/queue.c" 1
 1917 0654 0F92      		push	__tmp_reg__
 1918               	 ;  0 "" 2
 1919               	/* #NOAPP */
 1920               	.LBB17:
1661:FreeRTOS/Source/queue.c **** 
 1922               	.LM221:
 1923 0656 F801      		movw r30,r16
 1924 0658 928D      		ldd r25,Z+26
1665:FreeRTOS/Source/queue.c **** 			{
 1926               	.LM222:
 1927 065a 9923      		tst r25
 1928 065c 01F0      		breq .L152
1670:FreeRTOS/Source/queue.c **** 
 1930               	.LM223:
 1931 065e C680      		ldd r12,Z+6
 1932 0660 D780      		ldd r13,Z+7
1672:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
 1934               	.LM224:
 1935 0662 B701      		movw r22,r14
 1936 0664 C801      		movw r24,r16
 1937 0666 0E94 0000 		call prvCopyDataFromQueue
1676:FreeRTOS/Source/queue.c **** 
 1939               	.LM225:
 1940 066a F801      		movw r30,r16
 1941 066c D782      		std Z+7,r13
 1942 066e C682      		std Z+6,r12
1680:FreeRTOS/Source/queue.c **** 				{
 1944               	.LM226:
 1945 0670 8189      		ldd r24,Z+17
 1946 0672 8823      		tst r24
 1947 0674 01F0      		breq .L154
1682:FreeRTOS/Source/queue.c **** 					{
 1949               	.LM227:
 1950 0676 C801      		movw r24,r16
 1951 0678 4196      		adiw r24,17
 1952 067a 0E94 0000 		call xTaskRemoveFromEventList
 1953 067e 8111      		cpse r24,__zero_reg__
1685:FreeRTOS/Source/queue.c **** 					}
 1955               	.LM228:
 1956 0680 0E94 0000 		call vPortYield
 1957               	.L154:
1697:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1959               	.LM229:
 1960               	/* #APP */
 1961               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 1962 0684 0F90      		pop		__tmp_reg__
 1963               	 ;  0 "" 2
 1964               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 1965 0686 0FBE      		out		__SREG__, __tmp_reg__
 1966               	 ;  0 "" 2
1698:FreeRTOS/Source/queue.c **** 			}
 1968               	.LM230:
 1969               	/* #NOAPP */
 1970 0688 81E0      		ldi r24,lo8(1)
 1971 068a 00C0      		rjmp .L156
 1972               	.L152:
1702:FreeRTOS/Source/queue.c **** 				{
 1974               	.LM231:
 1975 068c 2C81      		ldd r18,Y+4
 1976 068e 3D81      		ldd r19,Y+5
 1977 0690 232B      		or r18,r19
 1978 0692 01F4      		brne .L157
1706:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
 1980               	.LM232:
 1981               	/* #APP */
 1982               	 ;  1706 "FreeRTOS/Source/queue.c" 1
 1983 0694 0F90      		pop		__tmp_reg__
 1984               	 ;  0 "" 2
 1985               	 ;  1706 "FreeRTOS/Source/queue.c" 1
 1986 0696 0FBE      		out		__SREG__, __tmp_reg__
 1987               	 ;  0 "" 2
 1988               	/* #NOAPP */
 1989 0698 00C0      		rjmp .L171
 1990               	.L157:
1710:FreeRTOS/Source/queue.c **** 				{
 1992               	.LM233:
 1993 069a 8111      		cpse r24,__zero_reg__
 1994 069c 00C0      		rjmp .L158
1715:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1996               	.LM234:
 1997 069e CE01      		movw r24,r28
 1998 06a0 0196      		adiw r24,1
 1999 06a2 0E94 0000 		call vTaskInternalSetTimeOutState
 2000               	.L158:
 2001               	.LBE17:
1725:FreeRTOS/Source/queue.c **** 
 2003               	.LM235:
 2004               	/* #APP */
 2005               	 ;  1725 "FreeRTOS/Source/queue.c" 1
 2006 06a6 0F90      		pop		__tmp_reg__
 2007               	 ;  0 "" 2
 2008               	 ;  1725 "FreeRTOS/Source/queue.c" 1
 2009 06a8 0FBE      		out		__SREG__, __tmp_reg__
 2010               	 ;  0 "" 2
1730:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 2012               	.LM236:
 2013               	/* #NOAPP */
 2014 06aa 0E94 0000 		call vTaskSuspendAll
1731:FreeRTOS/Source/queue.c **** 
 2016               	.LM237:
 2017               	/* #APP */
 2018               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2019 06ae 0FB6      		in		__tmp_reg__, __SREG__
 2020               	 ;  0 "" 2
 2021               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2022 06b0 F894      		cli
 2023               	 ;  0 "" 2
 2024               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2025 06b2 0F92      		push	__tmp_reg__
 2026               	 ;  0 "" 2
 2027               	/* #NOAPP */
 2028 06b4 F801      		movw r30,r16
 2029 06b6 858D      		ldd r24,Z+29
 2030 06b8 8F3F      		cpi r24,lo8(-1)
 2031 06ba 01F4      		brne .L159
1731:FreeRTOS/Source/queue.c **** 
 2033               	.LM238:
 2034 06bc 158E      		std Z+29,__zero_reg__
 2035               	.L159:
1731:FreeRTOS/Source/queue.c **** 
 2037               	.LM239:
 2038 06be F801      		movw r30,r16
 2039 06c0 868D      		ldd r24,Z+30
 2040 06c2 8F3F      		cpi r24,lo8(-1)
 2041 06c4 01F4      		brne .L160
1731:FreeRTOS/Source/queue.c **** 
 2043               	.LM240:
 2044 06c6 168E      		std Z+30,__zero_reg__
 2045               	.L160:
1731:FreeRTOS/Source/queue.c **** 
 2047               	.LM241:
 2048               	/* #APP */
 2049               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2050 06c8 0F90      		pop		__tmp_reg__
 2051               	 ;  0 "" 2
 2052               	 ;  1731 "FreeRTOS/Source/queue.c" 1
 2053 06ca 0FBE      		out		__SREG__, __tmp_reg__
 2054               	 ;  0 "" 2
1734:FreeRTOS/Source/queue.c **** 		{
 2056               	.LM242:
 2057               	/* #NOAPP */
 2058 06cc BE01      		movw r22,r28
 2059 06ce 6C5F      		subi r22,-4
 2060 06d0 7F4F      		sbci r23,-1
 2061 06d2 CE01      		movw r24,r28
 2062 06d4 0196      		adiw r24,1
 2063 06d6 0E94 0000 		call xTaskCheckForTimeOut
 2064 06da 8111      		cpse r24,__zero_reg__
 2065 06dc 00C0      		rjmp .L161
1738:FreeRTOS/Source/queue.c **** 			{
 2067               	.LM243:
 2068 06de C801      		movw r24,r16
 2069 06e0 0E94 0000 		call prvIsQueueEmpty
 2070 06e4 8823      		tst r24
 2071 06e6 01F0      		breq .L162
1741:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2073               	.LM244:
 2074 06e8 6C81      		ldd r22,Y+4
 2075 06ea 7D81      		ldd r23,Y+5
 2076 06ec C601      		movw r24,r12
 2077 06ee 0E94 0000 		call vTaskPlaceOnEventList
1742:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2079               	.LM245:
 2080 06f2 C801      		movw r24,r16
 2081 06f4 0E94 0000 		call prvUnlockQueue
1743:FreeRTOS/Source/queue.c **** 				{
 2083               	.LM246:
 2084 06f8 0E94 0000 		call xTaskResumeAll
 2085 06fc 8823      		tst r24
 2086 06fe 01F0      		breq .L172
 2087               	.L164:
 2088 0700 81E0      		ldi r24,lo8(1)
 2089 0702 00C0      		rjmp .L151
 2090               	.L172:
1745:FreeRTOS/Source/queue.c **** 				}
 2092               	.LM247:
 2093 0704 0E94 0000 		call vPortYield
 2094 0708 00C0      		rjmp .L164
 2095               	.L162:
1756:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 2097               	.LM248:
 2098 070a C801      		movw r24,r16
 2099 070c 0E94 0000 		call prvUnlockQueue
1757:FreeRTOS/Source/queue.c **** 			}
 2101               	.LM249:
 2102 0710 0E94 0000 		call xTaskResumeAll
 2103 0714 00C0      		rjmp .L164
 2104               	.L161:
1764:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 2106               	.LM250:
 2107 0716 C801      		movw r24,r16
 2108 0718 0E94 0000 		call prvUnlockQueue
1765:FreeRTOS/Source/queue.c **** 
 2110               	.LM251:
 2111 071c 0E94 0000 		call xTaskResumeAll
1767:FreeRTOS/Source/queue.c **** 			{
 2113               	.LM252:
 2114 0720 C801      		movw r24,r16
 2115 0722 0E94 0000 		call prvIsQueueEmpty
 2116 0726 8823      		tst r24
 2117 0728 01F0      		breq .L164
 2118               	.L171:
1770:FreeRTOS/Source/queue.c **** 			}
 2120               	.LM253:
 2121 072a 80E0      		ldi r24,0
 2122               	.L156:
 2123               	/* epilogue start */
1778:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2125               	.LM254:
 2126 072c 0F90      		pop __tmp_reg__
 2127 072e 0F90      		pop __tmp_reg__
 2128 0730 0F90      		pop __tmp_reg__
 2129 0732 0F90      		pop __tmp_reg__
 2130 0734 0F90      		pop __tmp_reg__
 2131 0736 DF91      		pop r29
 2132 0738 CF91      		pop r28
 2133 073a 1F91      		pop r17
 2134 073c 0F91      		pop r16
 2135 073e FF90      		pop r15
 2136 0740 EF90      		pop r14
 2137 0742 DF90      		pop r13
 2138 0744 CF90      		pop r12
 2139 0746 0895      		ret
 2149               	.Lscope12:
 2151               		.stabd	78,0,0
 2156               	.global	xQueueReceiveFromISR
 2158               	xQueueReceiveFromISR:
 2159               		.stabd	46,0,0
1782:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2161               	.LM255:
 2162               	.LFBB13:
 2163 0748 EF92      		push r14
 2164 074a FF92      		push r15
 2165 074c 0F93      		push r16
 2166 074e 1F93      		push r17
 2167 0750 CF93      		push r28
 2168 0752 DF93      		push r29
 2169               	/* prologue: function */
 2170               	/* frame size = 0 */
 2171               	/* stack size = 6 */
 2172               	.L__stack_usage = 6
 2173               	.LBB18:
1808:FreeRTOS/Source/queue.c **** 
 2175               	.LM256:
 2176 0754 FC01      		movw r30,r24
 2177 0756 028D      		ldd r16,Z+26
1811:FreeRTOS/Source/queue.c **** 		{
 2179               	.LM257:
 2180 0758 0023      		tst r16
 2181 075a 01F0      		breq .L178
 2182 075c 7A01      		movw r14,r20
 2183 075e EC01      		movw r28,r24
 2184               	.LBB19:
1813:FreeRTOS/Source/queue.c **** 
 2186               	.LM258:
 2187 0760 158D      		ldd r17,Z+29
1817:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2189               	.LM259:
 2190 0762 0E94 0000 		call prvCopyDataFromQueue
1818:FreeRTOS/Source/queue.c **** 
 2192               	.LM260:
 2193 0766 0150      		subi r16,lo8(-(-1))
 2194 0768 0A8F      		std Y+26,r16
1824:FreeRTOS/Source/queue.c **** 			{
 2196               	.LM261:
 2197 076a 1F3F      		cpi r17,lo8(-1)
 2198 076c 01F4      		brne .L175
1826:FreeRTOS/Source/queue.c **** 				{
 2200               	.LM262:
 2201 076e 8885      		ldd r24,Y+8
 2202 0770 8823      		tst r24
 2203 0772 01F0      		breq .L185
1828:FreeRTOS/Source/queue.c **** 					{
 2205               	.LM263:
 2206 0774 CE01      		movw r24,r28
 2207 0776 0896      		adiw r24,8
 2208 0778 0E94 0000 		call xTaskRemoveFromEventList
 2209 077c 8823      		tst r24
 2210 077e 01F0      		breq .L185
1832:FreeRTOS/Source/queue.c **** 						{
 2212               	.LM264:
 2213 0780 E114      		cp r14,__zero_reg__
 2214 0782 F104      		cpc r15,__zero_reg__
 2215 0784 01F0      		breq .L185
1834:FreeRTOS/Source/queue.c **** 						}
 2217               	.LM265:
 2218 0786 81E0      		ldi r24,lo8(1)
 2219 0788 F701      		movw r30,r14
 2220 078a 8083      		st Z,r24
 2221 078c 00C0      		rjmp .L174
 2222               	.L175:
1855:FreeRTOS/Source/queue.c **** 			}
 2224               	.LM266:
 2225 078e 1F5F      		subi r17,lo8(-(1))
 2226 0790 1D8F      		std Y+29,r17
 2227               	.L185:
1858:FreeRTOS/Source/queue.c **** 		}
 2229               	.LM267:
 2230 0792 81E0      		ldi r24,lo8(1)
 2231 0794 00C0      		rjmp .L174
 2232               	.L178:
 2233               	.LBE19:
1862:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2235               	.LM268:
 2236 0796 80E0      		ldi r24,0
 2237               	.L174:
 2238               	/* epilogue start */
 2239               	.LBE18:
1869:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2241               	.LM269:
 2242 0798 DF91      		pop r29
 2243 079a CF91      		pop r28
 2244 079c 1F91      		pop r17
 2245 079e 0F91      		pop r16
 2246 07a0 FF90      		pop r15
 2247 07a2 EF90      		pop r14
 2248 07a4 0895      		ret
 2259               	.Lscope13:
 2261               		.stabd	78,0,0
 2265               	.global	xQueuePeekFromISR
 2267               	xQueuePeekFromISR:
 2268               		.stabd	46,0,0
1873:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2270               	.LM270:
 2271               	.LFBB14:
 2272 07a6 0F93      		push r16
 2273 07a8 1F93      		push r17
 2274 07aa CF93      		push r28
 2275 07ac DF93      		push r29
 2276               	/* prologue: function */
 2277               	/* frame size = 0 */
 2278               	/* stack size = 4 */
 2279               	.L__stack_usage = 4
1902:FreeRTOS/Source/queue.c **** 		{
 2281               	.LM271:
 2282 07ae FC01      		movw r30,r24
 2283 07b0 228D      		ldd r18,Z+26
 2284 07b2 2223      		tst r18
 2285 07b4 01F0      		breq .L188
 2286 07b6 EC01      		movw r28,r24
1908:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2288               	.LM272:
 2289 07b8 0681      		ldd r16,Z+6
 2290 07ba 1781      		ldd r17,Z+7
1909:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2292               	.LM273:
 2293 07bc 0E94 0000 		call prvCopyDataFromQueue
1910:FreeRTOS/Source/queue.c **** 
 2295               	.LM274:
 2296 07c0 1F83      		std Y+7,r17
 2297 07c2 0E83      		std Y+6,r16
1912:FreeRTOS/Source/queue.c **** 		}
 2299               	.LM275:
 2300 07c4 81E0      		ldi r24,lo8(1)
 2301 07c6 00C0      		rjmp .L187
 2302               	.L188:
1916:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2304               	.LM276:
 2305 07c8 80E0      		ldi r24,0
 2306               	.L187:
 2307               	/* epilogue start */
1923:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2309               	.LM277:
 2310 07ca DF91      		pop r29
 2311 07cc CF91      		pop r28
 2312 07ce 1F91      		pop r17
 2313 07d0 0F91      		pop r16
 2314 07d2 0895      		ret
 2320               	.Lscope14:
 2322               		.stabd	78,0,0
 2325               	.global	uxQueueMessagesWaiting
 2327               	uxQueueMessagesWaiting:
 2328               		.stabd	46,0,0
1927:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2330               	.LM278:
 2331               	.LFBB15:
 2332               	/* prologue: function */
 2333               	/* frame size = 0 */
 2334               	/* stack size = 0 */
 2335               	.L__stack_usage = 0
1932:FreeRTOS/Source/queue.c **** 	{
 2337               	.LM279:
 2338               	/* #APP */
 2339               	 ;  1932 "FreeRTOS/Source/queue.c" 1
 2340 07d4 0FB6      		in		__tmp_reg__, __SREG__
 2341               	 ;  0 "" 2
 2342               	 ;  1932 "FreeRTOS/Source/queue.c" 1
 2343 07d6 F894      		cli
 2344               	 ;  0 "" 2
 2345               	 ;  1932 "FreeRTOS/Source/queue.c" 1
 2346 07d8 0F92      		push	__tmp_reg__
 2347               	 ;  0 "" 2
1934:FreeRTOS/Source/queue.c **** 	}
 2349               	.LM280:
 2350               	/* #NOAPP */
 2351 07da FC01      		movw r30,r24
 2352 07dc 828D      		ldd r24,Z+26
1936:FreeRTOS/Source/queue.c **** 
 2354               	.LM281:
 2355               	/* #APP */
 2356               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2357 07de 0F90      		pop		__tmp_reg__
 2358               	 ;  0 "" 2
 2359               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2360 07e0 0FBE      		out		__SREG__, __tmp_reg__
 2361               	 ;  0 "" 2
1939:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2363               	.LM282:
 2364               	/* #NOAPP */
 2365 07e2 0895      		ret
 2370               	.Lscope15:
 2372               		.stabd	78,0,0
 2375               	.global	uxQueueSpacesAvailable
 2377               	uxQueueSpacesAvailable:
 2378               		.stabd	46,0,0
1943:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2380               	.LM283:
 2381               	.LFBB16:
 2382               	/* prologue: function */
 2383               	/* frame size = 0 */
 2384               	/* stack size = 0 */
 2385               	.L__stack_usage = 0
1949:FreeRTOS/Source/queue.c **** 	{
 2387               	.LM284:
 2388               	/* #APP */
 2389               	 ;  1949 "FreeRTOS/Source/queue.c" 1
 2390 07e4 0FB6      		in		__tmp_reg__, __SREG__
 2391               	 ;  0 "" 2
 2392               	 ;  1949 "FreeRTOS/Source/queue.c" 1
 2393 07e6 F894      		cli
 2394               	 ;  0 "" 2
 2395               	 ;  1949 "FreeRTOS/Source/queue.c" 1
 2396 07e8 0F92      		push	__tmp_reg__
 2397               	 ;  0 "" 2
1951:FreeRTOS/Source/queue.c **** 	}
 2399               	.LM285:
 2400               	/* #NOAPP */
 2401 07ea FC01      		movw r30,r24
 2402 07ec 228D      		ldd r18,Z+26
1953:FreeRTOS/Source/queue.c **** 
 2404               	.LM286:
 2405               	/* #APP */
 2406               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2407 07ee 0F90      		pop		__tmp_reg__
 2408               	 ;  0 "" 2
 2409               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2410 07f0 0FBE      		out		__SREG__, __tmp_reg__
 2411               	 ;  0 "" 2
1955:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2413               	.LM287:
 2414               	/* #NOAPP */
 2415 07f2 838D      		ldd r24,Z+27
1956:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2417               	.LM288:
 2418 07f4 821B      		sub r24,r18
 2419 07f6 0895      		ret
 2421               	.Lscope16:
 2423               		.stabd	78,0,0
 2426               	.global	uxQueueMessagesWaitingFromISR
 2428               	uxQueueMessagesWaitingFromISR:
 2429               		.stabd	46,0,0
1960:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2431               	.LM289:
 2432               	.LFBB17:
 2433               	/* prologue: function */
 2434               	/* frame size = 0 */
 2435               	/* stack size = 0 */
 2436               	.L__stack_usage = 0
1965:FreeRTOS/Source/queue.c **** 
 2438               	.LM290:
 2439 07f8 FC01      		movw r30,r24
 2440 07fa 828D      		ldd r24,Z+26
1968:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2442               	.LM291:
 2443 07fc 0895      		ret
 2448               	.Lscope17:
 2450               		.stabd	78,0,0
 2453               	.global	vQueueDelete
 2455               	vQueueDelete:
 2456               		.stabd	46,0,0
1972:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2458               	.LM292:
 2459               	.LFBB18:
 2460               	/* prologue: function */
 2461               	/* frame size = 0 */
 2462               	/* stack size = 0 */
 2463               	.L__stack_usage = 0
1988:FreeRTOS/Source/queue.c **** 	}
 2465               	.LM293:
 2466 07fe 0C94 0000 		jmp vPortFree
 2468               	.Lscope18:
 2470               		.stabd	78,0,0
 2473               	.global	xQueueIsQueueEmptyFromISR
 2475               	xQueueIsQueueEmptyFromISR:
 2476               		.stabd	46,0,0
2309:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2478               	.LM294:
 2479               	.LFBB19:
 2480               	/* prologue: function */
 2481               	/* frame size = 0 */
 2482               	/* stack size = 0 */
 2483               	.L__stack_usage = 0
2314:FreeRTOS/Source/queue.c **** 	{
 2485               	.LM295:
 2486 0802 FC01      		movw r30,r24
 2487 0804 928D      		ldd r25,Z+26
2323:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2489               	.LM296:
 2490 0806 81E0      		ldi r24,lo8(1)
 2491 0808 9111      		cpse r25,__zero_reg__
 2492 080a 80E0      		ldi r24,0
 2493               	.L194:
2324:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2495               	.LM297:
 2496 080c 0895      		ret
 2498               	.Lscope19:
 2500               		.stabd	78,0,0
 2503               	.global	xQueueIsQueueFullFromISR
 2505               	xQueueIsQueueFullFromISR:
 2506               		.stabd	46,0,0
2343:FreeRTOS/Source/queue.c **** 
2344:FreeRTOS/Source/queue.c **** 	return xReturn;
2345:FreeRTOS/Source/queue.c **** }
2346:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2347:FreeRTOS/Source/queue.c **** 
2348:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2349:FreeRTOS/Source/queue.c **** {
 2508               	.LM298:
 2509               	.LFBB20:
 2510               	/* prologue: function */
 2511               	/* frame size = 0 */
 2512               	/* stack size = 0 */
 2513               	.L__stack_usage = 0
 2514 080e FC01      		movw r30,r24
2350:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2351:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
2352:FreeRTOS/Source/queue.c **** 
2353:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2354:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2516               	.LM299:
 2517 0810 928D      		ldd r25,Z+26
2355:FreeRTOS/Source/queue.c **** 	{
2356:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2357:FreeRTOS/Source/queue.c **** 	}
2358:FreeRTOS/Source/queue.c **** 	else
2359:FreeRTOS/Source/queue.c **** 	{
2360:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2361:FreeRTOS/Source/queue.c **** 	}
2362:FreeRTOS/Source/queue.c **** 
2363:FreeRTOS/Source/queue.c **** 	return xReturn;
 2519               	.LM300:
 2520 0812 81E0      		ldi r24,lo8(1)
 2521 0814 238D      		ldd r18,Z+27
 2522 0816 2913      		cpse r18,r25
 2523 0818 80E0      		ldi r24,0
 2524               	.L199:
2364:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2526               	.LM301:
 2527 081a 0895      		ret
 2529               	.Lscope20:
 2531               		.stabd	78,0,0
 2536               	.global	xQueueCRSend
 2538               	xQueueCRSend:
 2539               		.stabd	46,0,0
2365:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2366:FreeRTOS/Source/queue.c **** 
2367:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2368:FreeRTOS/Source/queue.c **** 
2369:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2370:FreeRTOS/Source/queue.c **** 	{
 2541               	.LM302:
 2542               	.LFBB21:
 2543 081c CF93      		push r28
 2544 081e DF93      		push r29
 2545               	/* prologue: function */
 2546               	/* frame size = 0 */
 2547               	/* stack size = 2 */
 2548               	.L__stack_usage = 2
 2549 0820 EC01      		movw r28,r24
2371:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2372:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2373:FreeRTOS/Source/queue.c **** 
2374:FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2375:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2376:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2377:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2551               	.LM303:
 2552               	/* #APP */
 2553               	 ;  2377 "FreeRTOS/Source/queue.c" 1
 2554 0822 F894      		cli
 2555               	 ;  0 "" 2
 2556               	/* #NOAPP */
 2557               	.LBB22:
 2558               	.LBB23:
2331:FreeRTOS/Source/queue.c **** 	{
 2560               	.LM304:
 2561               	/* #APP */
 2562               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 2563 0824 0FB6      		in		__tmp_reg__, __SREG__
 2564               	 ;  0 "" 2
 2565               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 2566 0826 F894      		cli
 2567               	 ;  0 "" 2
 2568               	 ;  2331 "FreeRTOS/Source/queue.c" 1
 2569 0828 0F92      		push	__tmp_reg__
 2570               	 ;  0 "" 2
2333:FreeRTOS/Source/queue.c **** 		{
 2572               	.LM305:
 2573               	/* #NOAPP */
 2574 082a 8A8D      		ldd r24,Y+26
 2575 082c 9B8D      		ldd r25,Y+27
2342:FreeRTOS/Source/queue.c **** 
 2577               	.LM306:
 2578               	/* #APP */
 2579               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 2580 082e 0F90      		pop		__tmp_reg__
 2581               	 ;  0 "" 2
 2582               	 ;  2342 "FreeRTOS/Source/queue.c" 1
 2583 0830 0FBE      		out		__SREG__, __tmp_reg__
 2584               	 ;  0 "" 2
 2585               	/* #NOAPP */
 2586               	.LBE23:
 2587               	.LBE22:
2378:FreeRTOS/Source/queue.c **** 		{
2379:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 2589               	.LM307:
 2590 0832 8913      		cpse r24,r25
 2591 0834 00C0      		rjmp .L201
2380:FreeRTOS/Source/queue.c **** 			{
2381:FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2382:FreeRTOS/Source/queue.c **** 				posting? */
2383:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2593               	.LM308:
 2594 0836 4115      		cp r20,__zero_reg__
 2595 0838 5105      		cpc r21,__zero_reg__
 2596 083a 01F0      		breq .L202
2384:FreeRTOS/Source/queue.c **** 				{
2385:FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2386:FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
2387:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 2598               	.LM309:
 2599 083c BE01      		movw r22,r28
 2600 083e 685F      		subi r22,-8
 2601 0840 7F4F      		sbci r23,-1
 2602 0842 CA01      		movw r24,r20
 2603 0844 0E94 0000 		call vCoRoutineAddToDelayedList
2388:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2605               	.LM310:
 2606               	/* #APP */
 2607               	 ;  2388 "FreeRTOS/Source/queue.c" 1
 2608 0848 7894      		sei
 2609               	 ;  0 "" 2
2389:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2611               	.LM311:
 2612               	/* #NOAPP */
 2613 084a 8CEF      		ldi r24,lo8(-4)
 2614 084c 00C0      		rjmp .L203
 2615               	.L202:
2390:FreeRTOS/Source/queue.c **** 				}
2391:FreeRTOS/Source/queue.c **** 				else
2392:FreeRTOS/Source/queue.c **** 				{
2393:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2617               	.LM312:
 2618               	/* #APP */
 2619               	 ;  2393 "FreeRTOS/Source/queue.c" 1
 2620 084e 7894      		sei
 2621               	 ;  0 "" 2
2394:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2623               	.LM313:
 2624               	/* #NOAPP */
 2625 0850 80E0      		ldi r24,0
 2626 0852 00C0      		rjmp .L203
 2627               	.L201:
2395:FreeRTOS/Source/queue.c **** 				}
2396:FreeRTOS/Source/queue.c **** 			}
2397:FreeRTOS/Source/queue.c **** 		}
2398:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2629               	.LM314:
 2630               	/* #APP */
 2631               	 ;  2398 "FreeRTOS/Source/queue.c" 1
 2632 0854 7894      		sei
 2633               	 ;  0 "" 2
2399:FreeRTOS/Source/queue.c **** 
2400:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2635               	.LM315:
 2636               	 ;  2400 "FreeRTOS/Source/queue.c" 1
 2637 0856 F894      		cli
 2638               	 ;  0 "" 2
2401:FreeRTOS/Source/queue.c **** 		{
2402:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2640               	.LM316:
 2641               	/* #NOAPP */
 2642 0858 8A8D      		ldd r24,Y+26
 2643 085a 8917      		cp r24,r25
 2644 085c 00F4      		brsh .L207
2403:FreeRTOS/Source/queue.c **** 			{
2404:FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2405:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2646               	.LM317:
 2647 085e 40E0      		ldi r20,0
 2648 0860 CE01      		movw r24,r28
 2649 0862 0E94 0000 		call prvCopyDataToQueue
2406:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2407:FreeRTOS/Source/queue.c **** 
2408:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2409:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2651               	.LM318:
 2652 0866 8989      		ldd r24,Y+17
 2653 0868 8111      		cpse r24,__zero_reg__
 2654 086a 00C0      		rjmp .L205
 2655               	.L206:
2406:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
 2657               	.LM319:
 2658 086c 81E0      		ldi r24,lo8(1)
 2659 086e 00C0      		rjmp .L204
 2660               	.L205:
2410:FreeRTOS/Source/queue.c **** 				{
2411:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2412:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2413:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2414:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2415:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2662               	.LM320:
 2663 0870 CE01      		movw r24,r28
 2664 0872 4196      		adiw r24,17
 2665 0874 0E94 0000 		call xCoRoutineRemoveFromEventList
 2666 0878 8823      		tst r24
 2667 087a 01F0      		breq .L206
2416:FreeRTOS/Source/queue.c **** 					{
2417:FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2418:FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
2419:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2669               	.LM321:
 2670 087c 8BEF      		ldi r24,lo8(-5)
 2671 087e 00C0      		rjmp .L204
 2672               	.L207:
2420:FreeRTOS/Source/queue.c **** 					}
2421:FreeRTOS/Source/queue.c **** 					else
2422:FreeRTOS/Source/queue.c **** 					{
2423:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2424:FreeRTOS/Source/queue.c **** 					}
2425:FreeRTOS/Source/queue.c **** 				}
2426:FreeRTOS/Source/queue.c **** 				else
2427:FreeRTOS/Source/queue.c **** 				{
2428:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2429:FreeRTOS/Source/queue.c **** 				}
2430:FreeRTOS/Source/queue.c **** 			}
2431:FreeRTOS/Source/queue.c **** 			else
2432:FreeRTOS/Source/queue.c **** 			{
2433:FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
 2674               	.LM322:
 2675 0880 80E0      		ldi r24,0
 2676               	.L204:
2434:FreeRTOS/Source/queue.c **** 			}
2435:FreeRTOS/Source/queue.c **** 		}
2436:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2678               	.LM323:
 2679               	/* #APP */
 2680               	 ;  2436 "FreeRTOS/Source/queue.c" 1
 2681 0882 7894      		sei
 2682               	 ;  0 "" 2
 2683               	/* #NOAPP */
 2684               	.L203:
 2685               	/* epilogue start */
2437:FreeRTOS/Source/queue.c **** 
2438:FreeRTOS/Source/queue.c **** 		return xReturn;
2439:FreeRTOS/Source/queue.c **** 	}
 2687               	.LM324:
 2688 0884 DF91      		pop r29
 2689 0886 CF91      		pop r28
 2690 0888 0895      		ret
 2695               	.Lscope21:
 2697               		.stabd	78,0,0
 2702               	.global	xQueueCRReceive
 2704               	xQueueCRReceive:
 2705               		.stabd	46,0,0
2440:FreeRTOS/Source/queue.c **** 
2441:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2442:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2443:FreeRTOS/Source/queue.c **** 
2444:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2445:FreeRTOS/Source/queue.c **** 
2446:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2447:FreeRTOS/Source/queue.c **** 	{
 2707               	.LM325:
 2708               	.LFBB22:
 2709 088a CF93      		push r28
 2710 088c DF93      		push r29
 2711               	/* prologue: function */
 2712               	/* frame size = 0 */
 2713               	/* stack size = 2 */
 2714               	.L__stack_usage = 2
 2715 088e EC01      		movw r28,r24
 2716 0890 FB01      		movw r30,r22
2448:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2449:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2450:FreeRTOS/Source/queue.c **** 
2451:FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2452:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2453:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2454:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2718               	.LM326:
 2719               	/* #APP */
 2720               	 ;  2454 "FreeRTOS/Source/queue.c" 1
 2721 0892 F894      		cli
 2722               	 ;  0 "" 2
2455:FreeRTOS/Source/queue.c **** 		{
2456:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2724               	.LM327:
 2725               	/* #NOAPP */
 2726 0894 8A8D      		ldd r24,Y+26
 2727 0896 8111      		cpse r24,__zero_reg__
 2728 0898 00C0      		rjmp .L212
2457:FreeRTOS/Source/queue.c **** 			{
2458:FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2459:FreeRTOS/Source/queue.c **** 				leave with nothing? */
2460:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2730               	.LM328:
 2731 089a 4115      		cp r20,__zero_reg__
 2732 089c 5105      		cpc r21,__zero_reg__
 2733 089e 01F0      		breq .L213
2461:FreeRTOS/Source/queue.c **** 				{
2462:FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2463:FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
2464:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2735               	.LM329:
 2736 08a0 BE01      		movw r22,r28
 2737 08a2 6F5E      		subi r22,-17
 2738 08a4 7F4F      		sbci r23,-1
 2739 08a6 CA01      		movw r24,r20
 2740 08a8 0E94 0000 		call vCoRoutineAddToDelayedList
2465:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2742               	.LM330:
 2743               	/* #APP */
 2744               	 ;  2465 "FreeRTOS/Source/queue.c" 1
 2745 08ac 7894      		sei
 2746               	 ;  0 "" 2
2466:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2748               	.LM331:
 2749               	/* #NOAPP */
 2750 08ae 8CEF      		ldi r24,lo8(-4)
 2751 08b0 00C0      		rjmp .L214
 2752               	.L213:
2467:FreeRTOS/Source/queue.c **** 				}
2468:FreeRTOS/Source/queue.c **** 				else
2469:FreeRTOS/Source/queue.c **** 				{
2470:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2754               	.LM332:
 2755               	/* #APP */
 2756               	 ;  2470 "FreeRTOS/Source/queue.c" 1
 2757 08b2 7894      		sei
 2758               	 ;  0 "" 2
2471:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2760               	.LM333:
 2761               	/* #NOAPP */
 2762 08b4 80E0      		ldi r24,0
 2763 08b6 00C0      		rjmp .L214
 2764               	.L212:
2472:FreeRTOS/Source/queue.c **** 				}
2473:FreeRTOS/Source/queue.c **** 			}
2474:FreeRTOS/Source/queue.c **** 			else
2475:FreeRTOS/Source/queue.c **** 			{
2476:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2477:FreeRTOS/Source/queue.c **** 			}
2478:FreeRTOS/Source/queue.c **** 		}
2479:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2766               	.LM334:
 2767               	/* #APP */
 2768               	 ;  2479 "FreeRTOS/Source/queue.c" 1
 2769 08b8 7894      		sei
 2770               	 ;  0 "" 2
2480:FreeRTOS/Source/queue.c **** 
2481:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2772               	.LM335:
 2773               	 ;  2481 "FreeRTOS/Source/queue.c" 1
 2774 08ba F894      		cli
 2775               	 ;  0 "" 2
2482:FreeRTOS/Source/queue.c **** 		{
2483:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2777               	.LM336:
 2778               	/* #NOAPP */
 2779 08bc 8A8D      		ldd r24,Y+26
 2780 08be 8823      		tst r24
 2781 08c0 01F0      		breq .L219
2484:FreeRTOS/Source/queue.c **** 			{
2485:FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
2486:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2783               	.LM337:
 2784 08c2 4C8D      		ldd r20,Y+28
 2785 08c4 50E0      		ldi r21,0
 2786 08c6 2E81      		ldd r18,Y+6
 2787 08c8 3F81      		ldd r19,Y+7
 2788 08ca 240F      		add r18,r20
 2789 08cc 351F      		adc r19,r21
 2790 08ce 3F83      		std Y+7,r19
 2791 08d0 2E83      		std Y+6,r18
2487:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2793               	.LM338:
 2794 08d2 8C81      		ldd r24,Y+4
 2795 08d4 9D81      		ldd r25,Y+5
 2796 08d6 2817      		cp r18,r24
 2797 08d8 3907      		cpc r19,r25
 2798 08da 00F0      		brlo .L216
2488:FreeRTOS/Source/queue.c **** 				{
2489:FreeRTOS/Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2800               	.LM339:
 2801 08dc 8881      		ld r24,Y
 2802 08de 9981      		ldd r25,Y+1
 2803 08e0 9F83      		std Y+7,r25
 2804 08e2 8E83      		std Y+6,r24
 2805               	.L216:
2490:FreeRTOS/Source/queue.c **** 				}
2491:FreeRTOS/Source/queue.c **** 				else
2492:FreeRTOS/Source/queue.c **** 				{
2493:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2494:FreeRTOS/Source/queue.c **** 				}
2495:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2807               	.LM340:
 2808 08e4 9A8D      		ldd r25,Y+26
 2809 08e6 9150      		subi r25,lo8(-(-1))
 2810 08e8 9A8F      		std Y+26,r25
2496:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
 2812               	.LM341:
 2813 08ea 6E81      		ldd r22,Y+6
 2814 08ec 7F81      		ldd r23,Y+7
 2815 08ee CF01      		movw r24,r30
 2816 08f0 0E94 0000 		call memcpy
2497:FreeRTOS/Source/queue.c **** 
2498:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2499:FreeRTOS/Source/queue.c **** 
2500:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2501:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2818               	.LM342:
 2819 08f4 8885      		ldd r24,Y+8
 2820 08f6 8111      		cpse r24,__zero_reg__
 2821 08f8 00C0      		rjmp .L217
 2822               	.L218:
2498:FreeRTOS/Source/queue.c **** 
 2824               	.LM343:
 2825 08fa 81E0      		ldi r24,lo8(1)
 2826 08fc 00C0      		rjmp .L215
 2827               	.L217:
2502:FreeRTOS/Source/queue.c **** 				{
2503:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2504:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2505:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2506:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2507:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2829               	.LM344:
 2830 08fe CE01      		movw r24,r28
 2831 0900 0896      		adiw r24,8
 2832 0902 0E94 0000 		call xCoRoutineRemoveFromEventList
 2833 0906 8823      		tst r24
 2834 0908 01F0      		breq .L218
2508:FreeRTOS/Source/queue.c **** 					{
2509:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2836               	.LM345:
 2837 090a 8BEF      		ldi r24,lo8(-5)
 2838 090c 00C0      		rjmp .L215
 2839               	.L219:
2510:FreeRTOS/Source/queue.c **** 					}
2511:FreeRTOS/Source/queue.c **** 					else
2512:FreeRTOS/Source/queue.c **** 					{
2513:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2514:FreeRTOS/Source/queue.c **** 					}
2515:FreeRTOS/Source/queue.c **** 				}
2516:FreeRTOS/Source/queue.c **** 				else
2517:FreeRTOS/Source/queue.c **** 				{
2518:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2519:FreeRTOS/Source/queue.c **** 				}
2520:FreeRTOS/Source/queue.c **** 			}
2521:FreeRTOS/Source/queue.c **** 			else
2522:FreeRTOS/Source/queue.c **** 			{
2523:FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
 2841               	.LM346:
 2842 090e 80E0      		ldi r24,0
 2843               	.L215:
2524:FreeRTOS/Source/queue.c **** 			}
2525:FreeRTOS/Source/queue.c **** 		}
2526:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2845               	.LM347:
 2846               	/* #APP */
 2847               	 ;  2526 "FreeRTOS/Source/queue.c" 1
 2848 0910 7894      		sei
 2849               	 ;  0 "" 2
 2850               	/* #NOAPP */
 2851               	.L214:
 2852               	/* epilogue start */
2527:FreeRTOS/Source/queue.c **** 
2528:FreeRTOS/Source/queue.c **** 		return xReturn;
2529:FreeRTOS/Source/queue.c **** 	}
 2854               	.LM348:
 2855 0912 DF91      		pop r29
 2856 0914 CF91      		pop r28
 2857 0916 0895      		ret
 2862               	.Lscope22:
 2864               		.stabd	78,0,0
 2869               	.global	xQueueCRSendFromISR
 2871               	xQueueCRSendFromISR:
 2872               		.stabd	46,0,0
2530:FreeRTOS/Source/queue.c **** 
2531:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2532:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2533:FreeRTOS/Source/queue.c **** 
2534:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2535:FreeRTOS/Source/queue.c **** 
2536:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2537:FreeRTOS/Source/queue.c **** 	{
 2874               	.LM349:
 2875               	.LFBB23:
 2876 0918 0F93      		push r16
 2877 091a 1F93      		push r17
 2878 091c CF93      		push r28
 2879               	/* prologue: function */
 2880               	/* frame size = 0 */
 2881               	/* stack size = 3 */
 2882               	.L__stack_usage = 3
 2883 091e 8C01      		movw r16,r24
 2884 0920 C42F      		mov r28,r20
2538:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2539:FreeRTOS/Source/queue.c **** 
2540:FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2541:FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2542:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2886               	.LM350:
 2887 0922 FC01      		movw r30,r24
 2888 0924 928D      		ldd r25,Z+26
 2889 0926 838D      		ldd r24,Z+27
 2890 0928 9817      		cp r25,r24
 2891 092a 00F0      		brlo .L224
 2892               	.L226:
 2893 092c 4C2F      		mov r20,r28
 2894 092e 00C0      		rjmp .L225
 2895               	.L224:
2543:FreeRTOS/Source/queue.c **** 		{
2544:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2897               	.LM351:
 2898 0930 40E0      		ldi r20,0
 2899 0932 C801      		movw r24,r16
 2900 0934 0E94 0000 		call prvCopyDataToQueue
2545:FreeRTOS/Source/queue.c **** 
2546:FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2547:FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2548:FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 2902               	.LM352:
 2903 0938 C111      		cpse r28,__zero_reg__
 2904 093a 00C0      		rjmp .L226
2549:FreeRTOS/Source/queue.c **** 			{
2550:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2906               	.LM353:
 2907 093c F801      		movw r30,r16
 2908 093e 8189      		ldd r24,Z+17
 2909 0940 8823      		tst r24
 2910 0942 01F0      		breq .L228
2551:FreeRTOS/Source/queue.c **** 				{
2552:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2912               	.LM354:
 2913 0944 C801      		movw r24,r16
 2914 0946 4196      		adiw r24,17
 2915 0948 0E94 0000 		call xCoRoutineRemoveFromEventList
2553:FreeRTOS/Source/queue.c **** 					{
2554:FreeRTOS/Source/queue.c **** 						return pdTRUE;
 2917               	.LM355:
 2918 094c 41E0      		ldi r20,lo8(1)
 2919 094e 8111      		cpse r24,__zero_reg__
 2920 0950 00C0      		rjmp .L225
 2921               	.L228:
 2922 0952 40E0      		ldi r20,0
 2923               	.L225:
2555:FreeRTOS/Source/queue.c **** 					}
2556:FreeRTOS/Source/queue.c **** 					else
2557:FreeRTOS/Source/queue.c **** 					{
2558:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2559:FreeRTOS/Source/queue.c **** 					}
2560:FreeRTOS/Source/queue.c **** 				}
2561:FreeRTOS/Source/queue.c **** 				else
2562:FreeRTOS/Source/queue.c **** 				{
2563:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2564:FreeRTOS/Source/queue.c **** 				}
2565:FreeRTOS/Source/queue.c **** 			}
2566:FreeRTOS/Source/queue.c **** 			else
2567:FreeRTOS/Source/queue.c **** 			{
2568:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2569:FreeRTOS/Source/queue.c **** 			}
2570:FreeRTOS/Source/queue.c **** 		}
2571:FreeRTOS/Source/queue.c **** 		else
2572:FreeRTOS/Source/queue.c **** 		{
2573:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2574:FreeRTOS/Source/queue.c **** 		}
2575:FreeRTOS/Source/queue.c **** 
2576:FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2577:FreeRTOS/Source/queue.c **** 	}
 2925               	.LM356:
 2926 0954 842F      		mov r24,r20
 2927               	/* epilogue start */
 2928 0956 CF91      		pop r28
 2929 0958 1F91      		pop r17
 2930 095a 0F91      		pop r16
 2931 095c 0895      		ret
 2933               	.Lscope23:
 2935               		.stabd	78,0,0
 2940               	.global	xQueueCRReceiveFromISR
 2942               	xQueueCRReceiveFromISR:
 2943               		.stabd	46,0,0
2578:FreeRTOS/Source/queue.c **** 
2579:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2580:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2581:FreeRTOS/Source/queue.c **** 
2582:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2583:FreeRTOS/Source/queue.c **** 
2584:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2585:FreeRTOS/Source/queue.c **** 	{
 2945               	.LM357:
 2946               	.LFBB24:
 2947 095e 0F93      		push r16
 2948 0960 1F93      		push r17
 2949 0962 CF93      		push r28
 2950 0964 DF93      		push r29
 2951               	/* prologue: function */
 2952               	/* frame size = 0 */
 2953               	/* stack size = 4 */
 2954               	.L__stack_usage = 4
 2955 0966 FC01      		movw r30,r24
2586:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2587:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2588:FreeRTOS/Source/queue.c **** 
2589:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2590:FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2591:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2957               	.LM358:
 2958 0968 828D      		ldd r24,Z+26
 2959 096a 8823      		tst r24
 2960 096c 01F0      		breq .L234
2592:FreeRTOS/Source/queue.c **** 		{
2593:FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2594:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2962               	.LM359:
 2963 096e 248D      		ldd r18,Z+28
 2964 0970 30E0      		ldi r19,0
 2965 0972 A681      		ldd r26,Z+6
 2966 0974 B781      		ldd r27,Z+7
 2967 0976 A20F      		add r26,r18
 2968 0978 B31F      		adc r27,r19
 2969 097a B783      		std Z+7,r27
 2970 097c A683      		std Z+6,r26
2595:FreeRTOS/Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2972               	.LM360:
 2973 097e 8481      		ldd r24,Z+4
 2974 0980 9581      		ldd r25,Z+5
 2975 0982 A817      		cp r26,r24
 2976 0984 B907      		cpc r27,r25
 2977 0986 00F0      		brlo .L231
2596:FreeRTOS/Source/queue.c **** 			{
2597:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2979               	.LM361:
 2980 0988 8081      		ld r24,Z
 2981 098a 9181      		ldd r25,Z+1
 2982 098c 9783      		std Z+7,r25
 2983 098e 8683      		std Z+6,r24
 2984               	.L231:
 2985 0990 8A01      		movw r16,r20
 2986 0992 CB01      		movw r24,r22
 2987 0994 EF01      		movw r28,r30
2598:FreeRTOS/Source/queue.c **** 			}
2599:FreeRTOS/Source/queue.c **** 			else
2600:FreeRTOS/Source/queue.c **** 			{
2601:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2602:FreeRTOS/Source/queue.c **** 			}
2603:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2989               	.LM362:
 2990 0996 428D      		ldd r20,Z+26
 2991 0998 4150      		subi r20,lo8(-(-1))
 2992 099a 428F      		std Z+26,r20
2604:FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
 2994               	.LM363:
 2995 099c 6681      		ldd r22,Z+6
 2996 099e 7781      		ldd r23,Z+7
 2997 09a0 A901      		movw r20,r18
 2998 09a2 0E94 0000 		call memcpy
2605:FreeRTOS/Source/queue.c **** 
2606:FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 3000               	.LM364:
 3001 09a6 F801      		movw r30,r16
 3002 09a8 8081      		ld r24,Z
 3003 09aa 8823      		tst r24
 3004 09ac 01F0      		breq .L232
 3005               	.L233:
2607:FreeRTOS/Source/queue.c **** 			{
2608:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2609:FreeRTOS/Source/queue.c **** 				{
2610:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2611:FreeRTOS/Source/queue.c **** 					{
2612:FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2613:FreeRTOS/Source/queue.c **** 					}
2614:FreeRTOS/Source/queue.c **** 					else
2615:FreeRTOS/Source/queue.c **** 					{
2616:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2617:FreeRTOS/Source/queue.c **** 					}
2618:FreeRTOS/Source/queue.c **** 				}
2619:FreeRTOS/Source/queue.c **** 				else
2620:FreeRTOS/Source/queue.c **** 				{
2621:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2622:FreeRTOS/Source/queue.c **** 				}
2623:FreeRTOS/Source/queue.c **** 			}
2624:FreeRTOS/Source/queue.c **** 			else
2625:FreeRTOS/Source/queue.c **** 			{
2626:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2627:FreeRTOS/Source/queue.c **** 			}
2628:FreeRTOS/Source/queue.c **** 
2629:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 3007               	.LM365:
 3008 09ae 81E0      		ldi r24,lo8(1)
 3009 09b0 00C0      		rjmp .L230
 3010               	.L232:
2608:FreeRTOS/Source/queue.c **** 				{
 3012               	.LM366:
 3013 09b2 8885      		ldd r24,Y+8
 3014 09b4 8823      		tst r24
 3015 09b6 01F0      		breq .L233
2610:FreeRTOS/Source/queue.c **** 					{
 3017               	.LM367:
 3018 09b8 CE01      		movw r24,r28
 3019 09ba 0896      		adiw r24,8
 3020 09bc 0E94 0000 		call xCoRoutineRemoveFromEventList
 3021 09c0 8823      		tst r24
 3022 09c2 01F0      		breq .L233
2612:FreeRTOS/Source/queue.c **** 					}
 3024               	.LM368:
 3025 09c4 81E0      		ldi r24,lo8(1)
 3026 09c6 F801      		movw r30,r16
 3027 09c8 8083      		st Z,r24
 3028 09ca 00C0      		rjmp .L230
 3029               	.L234:
2630:FreeRTOS/Source/queue.c **** 		}
2631:FreeRTOS/Source/queue.c **** 		else
2632:FreeRTOS/Source/queue.c **** 		{
2633:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 3031               	.LM369:
 3032 09cc 80E0      		ldi r24,0
 3033               	.L230:
 3034               	/* epilogue start */
2634:FreeRTOS/Source/queue.c **** 		}
2635:FreeRTOS/Source/queue.c **** 
2636:FreeRTOS/Source/queue.c **** 		return xReturn;
2637:FreeRTOS/Source/queue.c **** 	}
 3036               	.LM370:
 3037 09ce DF91      		pop r29
 3038 09d0 CF91      		pop r28
 3039 09d2 1F91      		pop r17
 3040 09d4 0F91      		pop r16
 3041 09d6 0895      		ret
 3046               	.Lscope24:
 3048               		.stabd	78,0,0
 3050               	.Letext0:
 3051               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccUCXDmP.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccUCXDmP.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccUCXDmP.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccUCXDmP.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccUCXDmP.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccUCXDmP.s:198    .text:0000000000000000 prvIsQueueEmpty
     /tmp/ccUCXDmP.s:252    .text:0000000000000016 prvCopyDataToQueue
     /tmp/ccUCXDmP.s:378    .text:00000000000000a6 prvCopyDataFromQueue
     /tmp/ccUCXDmP.s:431    .text:00000000000000da prvUnlockQueue
     /tmp/ccUCXDmP.s:588    .text:0000000000000156 xQueueGenericReset
     /tmp/ccUCXDmP.s:713    .text:00000000000001d4 xQueueGenericCreate
     /tmp/ccUCXDmP.s:808    .text:0000000000000224 xQueueGenericSend
     /tmp/ccUCXDmP.s:1117   .text:0000000000000350 xQueueGenericSendFromISR
     /tmp/ccUCXDmP.s:1220   .text:00000000000003ae xQueueGiveFromISR
     /tmp/ccUCXDmP.s:1317   .text:00000000000003f4 xQueueReceive
     /tmp/ccUCXDmP.s:1600   .text:0000000000000518 xQueueSemaphoreTake
     /tmp/ccUCXDmP.s:1871   .text:0000000000000624 xQueuePeek
     /tmp/ccUCXDmP.s:2158   .text:0000000000000748 xQueueReceiveFromISR
     /tmp/ccUCXDmP.s:2267   .text:00000000000007a6 xQueuePeekFromISR
     /tmp/ccUCXDmP.s:2327   .text:00000000000007d4 uxQueueMessagesWaiting
     /tmp/ccUCXDmP.s:2377   .text:00000000000007e4 uxQueueSpacesAvailable
     /tmp/ccUCXDmP.s:2428   .text:00000000000007f8 uxQueueMessagesWaitingFromISR
     /tmp/ccUCXDmP.s:2455   .text:00000000000007fe vQueueDelete
     /tmp/ccUCXDmP.s:2475   .text:0000000000000802 xQueueIsQueueEmptyFromISR
     /tmp/ccUCXDmP.s:2505   .text:000000000000080e xQueueIsQueueFullFromISR
     /tmp/ccUCXDmP.s:2538   .text:000000000000081c xQueueCRSend
     /tmp/ccUCXDmP.s:2704   .text:000000000000088a xQueueCRReceive
     /tmp/ccUCXDmP.s:2871   .text:0000000000000918 xQueueCRSendFromISR
     /tmp/ccUCXDmP.s:2942   .text:000000000000095e xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
