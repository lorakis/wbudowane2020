
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  0000242c  000024c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000242c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006e6  00800120  00800120  000024e0  2**0
                  ALLOC
  3 .stab         0000762c  00000000  00000000  000024e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004371  00000000  00000000  00009b0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000de7d  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000de90  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000ded0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000e4c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000ea66  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000ea80  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 82 11 	jmp	0x2304	; 0x2304 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec e2       	ldi	r30, 0x2C	; 44
      7c:	f4 e2       	ldi	r31, 0x24	; 36
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 32       	cpi	r26, 0x20	; 32
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a0 e2       	ldi	r26, 0x20	; 32
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a6 30       	cpi	r26, 0x06	; 6
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 b0 11 	call	0x2360	; 0x2360 <main>
      9e:	0c 94 14 12 	jmp	0x2428	; 0x2428 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
  BTN_PORT |= _BV(BTN);
      a6:	2c 9a       	sbi	0x05, 4	; 5
  LED_DDR |= _BV(LED);
      a8:	25 9a       	sbi	0x04, 5	; 4
  int i = 0;
      aa:	20 e0       	ldi	r18, 0x00	; 0
      ac:	30 e0       	ldi	r19, 0x00	; 0
  while(1)
  {

    if( tab[(i+1) % 101] == true)
      ae:	05 e6       	ldi	r16, 0x65	; 101
      b0:	10 e0       	ldi	r17, 0x00	; 0
      LED_PORT &= ~_BV(LED);
    else
      LED_PORT |= _BV(LED);

    if (BTN_PIN & _BV(BTN))
      tab[i] = true;
      b2:	ff 24       	eor	r15, r15
      b4:	f3 94       	inc	r15
  LED_DDR |= _BV(LED);
  int i = 0;
  while(1)
  {

    if( tab[(i+1) % 101] == true)
      b6:	e9 01       	movw	r28, r18
      b8:	21 96       	adiw	r28, 0x01	; 1
      ba:	ce 01       	movw	r24, r28
      bc:	b8 01       	movw	r22, r16
      be:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <__divmodhi4>
      c2:	fc 01       	movw	r30, r24
      c4:	e0 56       	subi	r30, 0x60	; 96
      c6:	f8 4f       	sbci	r31, 0xF8	; 248
      c8:	80 81       	ld	r24, Z
      ca:	88 23       	and	r24, r24
      cc:	11 f0       	breq	.+4      	; 0xd2 <vSerial+0x2c>
      LED_PORT &= ~_BV(LED);
      ce:	2d 98       	cbi	0x05, 5	; 5
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <vSerial+0x2e>
    else
      LED_PORT |= _BV(LED);
      d2:	2d 9a       	sbi	0x05, 5	; 5
      d4:	f9 01       	movw	r30, r18
      d6:	e0 56       	subi	r30, 0x60	; 96
      d8:	f8 4f       	sbci	r31, 0xF8	; 248

    if (BTN_PIN & _BV(BTN))
      da:	1c 9b       	sbis	0x03, 4	; 3
      dc:	02 c0       	rjmp	.+4      	; 0xe2 <vSerial+0x3c>
      tab[i] = true;
      de:	f0 82       	st	Z, r15
      e0:	01 c0       	rjmp	.+2      	; 0xe4 <vSerial+0x3e>
    else
      tab[i] = false;
      e2:	10 82       	st	Z, r1
    i++;
    if( i >= 101 )
      e4:	c5 36       	cpi	r28, 0x65	; 101
      e6:	d1 05       	cpc	r29, r1
      e8:	14 f0       	brlt	.+4      	; 0xee <vSerial+0x48>
    {
      i = 0;
      ea:	c0 e0       	ldi	r28, 0x00	; 0
      ec:	d0 e0       	ldi	r29, 0x00	; 0
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
      ee:	8a e0       	ldi	r24, 0x0A	; 10
      f0:	90 e0       	ldi	r25, 0x00	; 0
      f2:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
  }
      f6:	9e 01       	movw	r18, r28
      f8:	de cf       	rjmp	.-68     	; 0xb6 <vSerial+0x10>

000000fa <vBlinkLed>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
  UCSR0B &= ~_BV(RXEN0) & ~_BV(TXEN0);
      fa:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
      fe:	87 7e       	andi	r24, 0xE7	; 231
     100:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  LED_DDR1 |= 0b11111111;
     104:	8a b1       	in	r24, 0x0a	; 10
     106:	8f ef       	ldi	r24, 0xFF	; 255
     108:	8a b9       	out	0x0a, r24	; 10
  LED_PORT1 |= 0b00000001;
     10a:	58 9a       	sbi	0x0b, 0	; 11
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
     10c:	c7 e0       	ldi	r28, 0x07	; 7
     10e:	d0 e0       	ldi	r29, 0x00	; 0
  LED_PORT1 |= 0b00000001;
  while(1)
  {
    for(int i = 0; i < 7; i++)
    {
      vTaskDelay(200 / portTICK_PERIOD_MS);
     110:	88 ec       	ldi	r24, 0xC8	; 200
     112:	90 e0       	ldi	r25, 0x00	; 0
     114:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
      LED_PORT1 <<= 1;
     118:	8b b1       	in	r24, 0x0b	; 11
     11a:	88 0f       	add	r24, r24
     11c:	8b b9       	out	0x0b, r24	; 11
     11e:	21 97       	sbiw	r28, 0x01	; 1
  UCSR0B &= ~_BV(RXEN0) & ~_BV(TXEN0);
  LED_DDR1 |= 0b11111111;
  LED_PORT1 |= 0b00000001;
  while(1)
  {
    for(int i = 0; i < 7; i++)
     120:	b9 f7       	brne	.-18     	; 0x110 <vBlinkLed+0x16>
     122:	c7 e0       	ldi	r28, 0x07	; 7
     124:	d0 e0       	ldi	r29, 0x00	; 0
      vTaskDelay(200 / portTICK_PERIOD_MS);
      LED_PORT1 <<= 1;
    }
    for(int i = 0; i < 7; i++)
    {
      vTaskDelay(200 / portTICK_PERIOD_MS);
     126:	88 ec       	ldi	r24, 0xC8	; 200
     128:	90 e0       	ldi	r25, 0x00	; 0
     12a:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
      LED_PORT1 >>= 1;
     12e:	8b b1       	in	r24, 0x0b	; 11
     130:	86 95       	lsr	r24
     132:	8b b9       	out	0x0b, r24	; 11
     134:	21 97       	sbiw	r28, 0x01	; 1
    for(int i = 0; i < 7; i++)
    {
      vTaskDelay(200 / portTICK_PERIOD_MS);
      LED_PORT1 <<= 1;
    }
    for(int i = 0; i < 7; i++)
     136:	b9 f7       	brne	.-18     	; 0x126 <vBlinkLed+0x2c>
     138:	e9 cf       	rjmp	.-46     	; 0x10c <vBlinkLed+0x12>

0000013a <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     13a:	08 95       	ret

0000013c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     13c:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     140:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     144:	80 81       	ld	r24, Z
     146:	81 11       	cpse	r24, r1
     148:	03 c0       	rjmp	.+6      	; 0x150 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     14a:	8f ef       	ldi	r24, 0xFF	; 255
     14c:	9f ef       	ldi	r25, 0xFF	; 255
     14e:	0c c0       	rjmp	.+24     	; 0x168 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     150:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     154:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     158:	05 80       	ldd	r0, Z+5	; 0x05
     15a:	f6 81       	ldd	r31, Z+6	; 0x06
     15c:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     15e:	06 80       	ldd	r0, Z+6	; 0x06
     160:	f7 81       	ldd	r31, Z+7	; 0x07
     162:	e0 2d       	mov	r30, r0
     164:	82 81       	ldd	r24, Z+2	; 0x02
     166:	93 81       	ldd	r25, Z+3	; 0x03
     168:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <xNextTaskUnblockTime+0x1>
     16c:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <xNextTaskUnblockTime>
     170:	08 95       	ret

00000172 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     172:	ff 92       	push	r15
     174:	0f 93       	push	r16
     176:	1f 93       	push	r17
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	ec 01       	movw	r28, r24
     17e:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     180:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <xTickCount>
     184:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     188:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     18c:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     190:	02 96       	adiw	r24, 0x02	; 2
     192:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     196:	cf 3f       	cpi	r28, 0xFF	; 255
     198:	8f ef       	ldi	r24, 0xFF	; 255
     19a:	d8 07       	cpc	r29, r24
     19c:	89 f4       	brne	.+34     	; 0x1c0 <prvAddCurrentTaskToDelayedList+0x4e>
     19e:	ff 20       	and	r15, r15
     1a0:	79 f0       	breq	.+30     	; 0x1c0 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1a2:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     1a6:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     1aa:	6e 5f       	subi	r22, 0xFE	; 254
     1ac:	7f 4f       	sbci	r23, 0xFF	; 255
     1ae:	80 e3       	ldi	r24, 0x30	; 48
     1b0:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	1f 91       	pop	r17
     1b8:	0f 91       	pop	r16
     1ba:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1bc:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     1c0:	c0 0f       	add	r28, r16
     1c2:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     1c4:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     1c8:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     1cc:	d3 83       	std	Z+3, r29	; 0x03
     1ce:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1d0:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     1d4:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     1d8:	c0 17       	cp	r28, r16
     1da:	d1 07       	cpc	r29, r17
     1dc:	68 f4       	brcc	.+26     	; 0x1f8 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1de:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <pxOverflowDelayedTaskList>
     1e2:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     1e6:	6e 5f       	subi	r22, 0xFE	; 254
     1e8:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1f4:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1f8:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <pxDelayedTaskList>
     1fc:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     200:	6e 5f       	subi	r22, 0xFE	; 254
     202:	7f 4f       	sbci	r23, 0xFF	; 255
     204:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     208:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <xNextTaskUnblockTime>
     20c:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <xNextTaskUnblockTime+0x1>
     210:	c8 17       	cp	r28, r24
     212:	d9 07       	cpc	r29, r25
     214:	20 f4       	brcc	.+8      	; 0x21e <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     216:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <xNextTaskUnblockTime+0x1>
     21a:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     21e:	df 91       	pop	r29
     220:	cf 91       	pop	r28
     222:	1f 91       	pop	r17
     224:	0f 91       	pop	r16
     226:	ff 90       	pop	r15
     228:	08 95       	ret

0000022a <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     22a:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     22e:	88 23       	and	r24, r24
     230:	09 f1       	breq	.+66     	; 0x274 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     232:	0f b6       	in	r0, 0x3f	; 63
     234:	f8 94       	cli
     236:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     238:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <xTasksWaitingTermination+0x5>
     23c:	f0 91 40 01 	lds	r31, 0x0140	; 0x800140 <xTasksWaitingTermination+0x6>
     240:	c6 81       	ldd	r28, Z+6	; 0x06
     242:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     244:	ce 01       	movw	r24, r28
     246:	02 96       	adiw	r24, 0x02	; 2
     248:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
				--uxCurrentNumberOfTasks;
     24c:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     250:	81 50       	subi	r24, 0x01	; 1
     252:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     256:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     25a:	81 50       	subi	r24, 0x01	; 1
     25c:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     260:	0f 90       	pop	r0
     262:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     264:	8f 89       	ldd	r24, Y+23	; 0x17
     266:	98 8d       	ldd	r25, Y+24	; 0x18
     268:	0e 94 11 10 	call	0x2022	; 0x2022 <vPortFree>
			vPortFree( pxTCB );
     26c:	ce 01       	movw	r24, r28
     26e:	0e 94 11 10 	call	0x2022	; 0x2022 <vPortFree>
     272:	db cf       	rjmp	.-74     	; 0x22a <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     274:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxReadyTasksLists>
     278:	82 30       	cpi	r24, 0x02	; 2
     27a:	10 f0       	brcs	.+4      	; 0x280 <prvIdleTask+0x56>
			{
				taskYIELD();
     27c:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     280:	0e 94 9d 00 	call	0x13a	; 0x13a <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     284:	d2 cf       	rjmp	.-92     	; 0x22a <prvIdleTask>

00000286 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     286:	3f 92       	push	r3
     288:	4f 92       	push	r4
     28a:	5f 92       	push	r5
     28c:	6f 92       	push	r6
     28e:	7f 92       	push	r7
     290:	8f 92       	push	r8
     292:	9f 92       	push	r9
     294:	af 92       	push	r10
     296:	bf 92       	push	r11
     298:	cf 92       	push	r12
     29a:	df 92       	push	r13
     29c:	ef 92       	push	r14
     29e:	ff 92       	push	r15
     2a0:	0f 93       	push	r16
     2a2:	1f 93       	push	r17
     2a4:	cf 93       	push	r28
     2a6:	df 93       	push	r29
     2a8:	4c 01       	movw	r8, r24
     2aa:	16 2f       	mov	r17, r22
     2ac:	37 2e       	mov	r3, r23
     2ae:	6a 01       	movw	r12, r20
     2b0:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     2b2:	ca 01       	movw	r24, r20
     2b4:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <pvPortMalloc>
     2b8:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     2ba:	89 2b       	or	r24, r25
     2bc:	09 f4       	brne	.+2      	; 0x2c0 <xTaskCreate+0x3a>
     2be:	d1 c0       	rjmp	.+418    	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     2c0:	86 e2       	ldi	r24, 0x26	; 38
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <pvPortMalloc>
     2c8:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     2ca:	89 2b       	or	r24, r25
     2cc:	79 f0       	breq	.+30     	; 0x2ec <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     2ce:	58 8e       	std	Y+24, r5	; 0x18
     2d0:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     2d2:	c6 01       	movw	r24, r12
     2d4:	01 97       	sbiw	r24, 0x01	; 1
     2d6:	32 01       	movw	r6, r4
     2d8:	68 0e       	add	r6, r24
     2da:	79 1e       	adc	r7, r25
     2dc:	be 01       	movw	r22, r28
     2de:	67 5e       	subi	r22, 0xE7	; 231
     2e0:	7f 4f       	sbci	r23, 0xFF	; 255
     2e2:	e1 2f       	mov	r30, r17
     2e4:	f3 2d       	mov	r31, r3
     2e6:	cf 01       	movw	r24, r30
     2e8:	08 96       	adiw	r24, 0x08	; 8
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     2ec:	c2 01       	movw	r24, r4
     2ee:	0e 94 11 10 	call	0x2022	; 0x2022 <vPortFree>
     2f2:	b7 c0       	rjmp	.+366    	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2f4:	e8 17       	cp	r30, r24
     2f6:	f9 07       	cpc	r31, r25
     2f8:	49 f0       	breq	.+18     	; 0x30c <xTaskCreate+0x86>
     2fa:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2fc:	41 91       	ld	r20, Z+
     2fe:	db 01       	movw	r26, r22
     300:	4d 93       	st	X+, r20
     302:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     304:	d9 01       	movw	r26, r18
     306:	2c 91       	ld	r18, X
     308:	21 11       	cpse	r18, r1
     30a:	f4 cf       	rjmp	.-24     	; 0x2f4 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     30c:	18 a2       	std	Y+32, r1	; 0x20
     30e:	04 30       	cpi	r16, 0x04	; 4
     310:	08 f0       	brcs	.+2      	; 0x314 <xTaskCreate+0x8e>
     312:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     314:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     316:	6e 01       	movw	r12, r28
     318:	b2 e0       	ldi	r27, 0x02	; 2
     31a:	cb 0e       	add	r12, r27
     31c:	d1 1c       	adc	r13, r1
     31e:	c6 01       	movw	r24, r12
     320:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     324:	ce 01       	movw	r24, r28
     326:	0c 96       	adiw	r24, 0x0c	; 12
     328:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     32c:	d9 87       	std	Y+9, r29	; 0x09
     32e:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     330:	84 e0       	ldi	r24, 0x04	; 4
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	80 1b       	sub	r24, r16
     336:	91 09       	sbc	r25, r1
     338:	9d 87       	std	Y+13, r25	; 0x0d
     33a:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     33c:	db 8b       	std	Y+19, r29	; 0x13
     33e:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     340:	19 a2       	std	Y+33, r1	; 0x21
     342:	1a a2       	std	Y+34, r1	; 0x22
     344:	1b a2       	std	Y+35, r1	; 0x23
     346:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     348:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     34a:	a5 01       	movw	r20, r10
     34c:	b4 01       	movw	r22, r8
     34e:	c3 01       	movw	r24, r6
     350:	0e 94 20 10 	call	0x2040	; 0x2040 <pxPortInitialiseStack>
     354:	99 83       	std	Y+1, r25	; 0x01
     356:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     358:	e1 14       	cp	r14, r1
     35a:	f1 04       	cpc	r15, r1
     35c:	19 f0       	breq	.+6      	; 0x364 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     35e:	f7 01       	movw	r30, r14
     360:	d1 83       	std	Z+1, r29	; 0x01
     362:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     364:	0f b6       	in	r0, 0x3f	; 63
     366:	f8 94       	cli
     368:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     36a:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     36e:	8f 5f       	subi	r24, 0xFF	; 255
     370:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     374:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     378:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     37c:	89 2b       	or	r24, r25
     37e:	d1 f5       	brne	.+116    	; 0x3f4 <xTaskCreate+0x16e>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     380:	d0 93 21 01 	sts	0x0121, r29	; 0x800121 <__data_end+0x1>
     384:	c0 93 20 01 	sts	0x0120, r28	; 0x800120 <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     388:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     38c:	81 30       	cpi	r24, 0x01	; 1
     38e:	09 f0       	breq	.+2      	; 0x392 <xTaskCreate+0x10c>
     390:	41 c0       	rjmp	.+130    	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     392:	82 e6       	ldi	r24, 0x62	; 98
     394:	91 e0       	ldi	r25, 0x01	; 1
     396:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
     39a:	8b e6       	ldi	r24, 0x6B	; 107
     39c:	91 e0       	ldi	r25, 0x01	; 1
     39e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
     3a2:	84 e7       	ldi	r24, 0x74	; 116
     3a4:	91 e0       	ldi	r25, 0x01	; 1
     3a6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
     3aa:	8d e7       	ldi	r24, 0x7D	; 125
     3ac:	91 e0       	ldi	r25, 0x01	; 1
     3ae:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     3b2:	89 e5       	ldi	r24, 0x59	; 89
     3b4:	91 e0       	ldi	r25, 0x01	; 1
     3b6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     3ba:	80 e5       	ldi	r24, 0x50	; 80
     3bc:	91 e0       	ldi	r25, 0x01	; 1
     3be:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     3c2:	83 e4       	ldi	r24, 0x43	; 67
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     3ca:	8a e3       	ldi	r24, 0x3A	; 58
     3cc:	91 e0       	ldi	r25, 0x01	; 1
     3ce:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     3d2:	80 e3       	ldi	r24, 0x30	; 48
     3d4:	91 e0       	ldi	r25, 0x01	; 1
     3d6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     3da:	89 e5       	ldi	r24, 0x59	; 89
     3dc:	91 e0       	ldi	r25, 0x01	; 1
     3de:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <pxDelayedTaskList+0x1>
     3e2:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     3e6:	80 e5       	ldi	r24, 0x50	; 80
     3e8:	91 e0       	ldi	r25, 0x01	; 1
     3ea:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     3ee:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <pxOverflowDelayedTaskList>
     3f2:	10 c0       	rjmp	.+32     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     3f4:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     3f8:	81 11       	cpse	r24, r1
     3fa:	0c c0       	rjmp	.+24     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     3fc:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     400:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     404:	96 89       	ldd	r25, Z+22	; 0x16
     406:	8e 89       	ldd	r24, Y+22	; 0x16
     408:	89 17       	cp	r24, r25
     40a:	20 f0       	brcs	.+8      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
				{
					pxCurrentTCB = pxNewTCB;
     40c:	d0 93 21 01 	sts	0x0121, r29	; 0x800121 <__data_end+0x1>
     410:	c0 93 20 01 	sts	0x0120, r28	; 0x800120 <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     414:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxTaskNumber>
     418:	8f 5f       	subi	r24, 0xFF	; 255
     41a:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     41e:	8e 89       	ldd	r24, Y+22	; 0x16
     420:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     424:	98 17       	cp	r25, r24
     426:	10 f4       	brcc	.+4      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
     428:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     42c:	f9 e0       	ldi	r31, 0x09	; 9
     42e:	8f 9f       	mul	r24, r31
     430:	c0 01       	movw	r24, r0
     432:	11 24       	eor	r1, r1
     434:	b6 01       	movw	r22, r12
     436:	8e 59       	subi	r24, 0x9E	; 158
     438:	9e 4f       	sbci	r25, 0xFE	; 254
     43a:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     43e:	0f 90       	pop	r0
     440:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     442:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     446:	88 23       	and	r24, r24
     448:	51 f0       	breq	.+20     	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     44a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     44e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     452:	96 89       	ldd	r25, Z+22	; 0x16
     454:	8e 89       	ldd	r24, Y+22	; 0x16
     456:	98 17       	cp	r25, r24
     458:	10 f4       	brcc	.+4      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
		{
			taskYIELD_IF_USING_PREEMPTION();
     45a:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     45e:	81 e0       	ldi	r24, 0x01	; 1
     460:	01 c0       	rjmp	.+2      	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     462:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     464:	df 91       	pop	r29
     466:	cf 91       	pop	r28
     468:	1f 91       	pop	r17
     46a:	0f 91       	pop	r16
     46c:	ff 90       	pop	r15
     46e:	ef 90       	pop	r14
     470:	df 90       	pop	r13
     472:	cf 90       	pop	r12
     474:	bf 90       	pop	r11
     476:	af 90       	pop	r10
     478:	9f 90       	pop	r9
     47a:	8f 90       	pop	r8
     47c:	7f 90       	pop	r7
     47e:	6f 90       	pop	r6
     480:	5f 90       	pop	r5
     482:	4f 90       	pop	r4
     484:	3f 90       	pop	r3
     486:	08 95       	ret

00000488 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     488:	0f 93       	push	r16
     48a:	1f 93       	push	r17
     48c:	cf 93       	push	r28
     48e:	df 93       	push	r29
     490:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     492:	0f b6       	in	r0, 0x3f	; 63
     494:	f8 94       	cli
     496:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     498:	89 2b       	or	r24, r25
     49a:	21 f4       	brne	.+8      	; 0x4a4 <vTaskDelete+0x1c>
     49c:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
     4a0:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     4a4:	8e 01       	movw	r16, r28
     4a6:	0e 5f       	subi	r16, 0xFE	; 254
     4a8:	1f 4f       	sbci	r17, 0xFF	; 255
     4aa:	c8 01       	movw	r24, r16
     4ac:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     4b0:	8c 89       	ldd	r24, Y+20	; 0x14
     4b2:	9d 89       	ldd	r25, Y+21	; 0x15
     4b4:	89 2b       	or	r24, r25
     4b6:	21 f0       	breq	.+8      	; 0x4c0 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     4b8:	ce 01       	movw	r24, r28
     4ba:	0c 96       	adiw	r24, 0x0c	; 12
     4bc:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     4c0:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxTaskNumber>
     4c4:	8f 5f       	subi	r24, 0xFF	; 255
     4c6:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     4ca:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     4ce:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     4d2:	c8 17       	cp	r28, r24
     4d4:	d9 07       	cpc	r29, r25
     4d6:	59 f4       	brne	.+22     	; 0x4ee <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     4d8:	b8 01       	movw	r22, r16
     4da:	8a e3       	ldi	r24, 0x3A	; 58
     4dc:	91 e0       	ldi	r25, 0x01	; 1
     4de:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     4e2:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     4e6:	8f 5f       	subi	r24, 0xFF	; 255
     4e8:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     4ec:	0e c0       	rjmp	.+28     	; 0x50a <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     4ee:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     4f2:	81 50       	subi	r24, 0x01	; 1
     4f4:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     4f8:	8f 89       	ldd	r24, Y+23	; 0x17
     4fa:	98 8d       	ldd	r25, Y+24	; 0x18
     4fc:	0e 94 11 10 	call	0x2022	; 0x2022 <vPortFree>
			vPortFree( pxTCB );
     500:	ce 01       	movw	r24, r28
     502:	0e 94 11 10 	call	0x2022	; 0x2022 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     506:	0e 94 9e 00 	call	0x13c	; 0x13c <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     50a:	0f 90       	pop	r0
     50c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     50e:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     512:	88 23       	and	r24, r24
     514:	49 f0       	breq	.+18     	; 0x528 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     516:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     51a:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     51e:	c8 17       	cp	r28, r24
     520:	d9 07       	cpc	r29, r25
     522:	11 f4       	brne	.+4      	; 0x528 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     524:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     528:	df 91       	pop	r29
     52a:	cf 91       	pop	r28
     52c:	1f 91       	pop	r17
     52e:	0f 91       	pop	r16
     530:	08 95       	ret

00000532 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     532:	0f 93       	push	r16
     534:	1f 93       	push	r17
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     53a:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <__data_end>
     53e:	30 91 21 01 	lds	r19, 0x0121	; 0x800121 <__data_end+0x1>
     542:	82 17       	cp	r24, r18
     544:	93 07       	cpc	r25, r19
     546:	b9 f1       	breq	.+110    	; 0x5b6 <vTaskResume+0x84>
     548:	00 97       	sbiw	r24, 0x00	; 0
     54a:	a9 f1       	breq	.+106    	; 0x5b6 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     54c:	0f b6       	in	r0, 0x3f	; 63
     54e:	f8 94       	cli
     550:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     552:	fc 01       	movw	r30, r24
     554:	22 85       	ldd	r18, Z+10	; 0x0a
     556:	33 85       	ldd	r19, Z+11	; 0x0b
     558:	20 53       	subi	r18, 0x30	; 48
     55a:	31 40       	sbci	r19, 0x01	; 1
     55c:	51 f5       	brne	.+84     	; 0x5b2 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     55e:	fc 01       	movw	r30, r24
     560:	24 89       	ldd	r18, Z+20	; 0x14
     562:	35 89       	ldd	r19, Z+21	; 0x15
     564:	f1 e0       	ldi	r31, 0x01	; 1
     566:	23 34       	cpi	r18, 0x43	; 67
     568:	3f 07       	cpc	r19, r31
     56a:	19 f1       	breq	.+70     	; 0x5b2 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     56c:	23 2b       	or	r18, r19
     56e:	09 f5       	brne	.+66     	; 0x5b2 <vTaskResume+0x80>
     570:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     572:	8c 01       	movw	r16, r24
     574:	0e 5f       	subi	r16, 0xFE	; 254
     576:	1f 4f       	sbci	r17, 0xFF	; 255
     578:	c8 01       	movw	r24, r16
     57a:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     57e:	8e 89       	ldd	r24, Y+22	; 0x16
     580:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     584:	98 17       	cp	r25, r24
     586:	10 f4       	brcc	.+4      	; 0x58c <vTaskResume+0x5a>
     588:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     58c:	29 e0       	ldi	r18, 0x09	; 9
     58e:	82 9f       	mul	r24, r18
     590:	c0 01       	movw	r24, r0
     592:	11 24       	eor	r1, r1
     594:	b8 01       	movw	r22, r16
     596:	8e 59       	subi	r24, 0x9E	; 158
     598:	9e 4f       	sbci	r25, 0xFE	; 254
     59a:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     59e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     5a2:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     5a6:	9e 89       	ldd	r25, Y+22	; 0x16
     5a8:	86 89       	ldd	r24, Z+22	; 0x16
     5aa:	98 17       	cp	r25, r24
     5ac:	10 f0       	brcs	.+4      	; 0x5b2 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     5ae:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     5b2:	0f 90       	pop	r0
     5b4:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     5b6:	df 91       	pop	r29
     5b8:	cf 91       	pop	r28
     5ba:	1f 91       	pop	r17
     5bc:	0f 91       	pop	r16
     5be:	08 95       	ret

000005c0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     5c0:	ef 92       	push	r14
     5c2:	ff 92       	push	r15
     5c4:	1f 93       	push	r17
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     5cc:	8a 85       	ldd	r24, Y+10	; 0x0a
     5ce:	9b 85       	ldd	r25, Y+11	; 0x0b
     5d0:	80 53       	subi	r24, 0x30	; 48
     5d2:	91 40       	sbci	r25, 0x01	; 1
     5d4:	99 f4       	brne	.+38     	; 0x5fc <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     5d6:	8c 89       	ldd	r24, Y+20	; 0x14
     5d8:	9d 89       	ldd	r25, Y+21	; 0x15
     5da:	21 e0       	ldi	r18, 0x01	; 1
     5dc:	83 34       	cpi	r24, 0x43	; 67
     5de:	92 07       	cpc	r25, r18
     5e0:	69 f0       	breq	.+26     	; 0x5fc <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     5e2:	89 2b       	or	r24, r25
     5e4:	59 f4       	brne	.+22     	; 0x5fc <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     5e6:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     5ea:	88 23       	and	r24, r24
     5ec:	49 f0       	breq	.+18     	; 0x600 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     5ee:	be 01       	movw	r22, r28
     5f0:	64 5f       	subi	r22, 0xF4	; 244
     5f2:	7f 4f       	sbci	r23, 0xFF	; 255
     5f4:	83 e4       	ldi	r24, 0x43	; 67
     5f6:	91 e0       	ldi	r25, 0x01	; 1
     5f8:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     5fc:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     5fe:	21 c0       	rjmp	.+66     	; 0x642 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     600:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     604:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     608:	11 e0       	ldi	r17, 0x01	; 1
     60a:	9e 89       	ldd	r25, Y+22	; 0x16
     60c:	86 89       	ldd	r24, Z+22	; 0x16
     60e:	98 17       	cp	r25, r24
     610:	08 f4       	brcc	.+2      	; 0x614 <xTaskResumeFromISR+0x54>
     612:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     614:	7e 01       	movw	r14, r28
     616:	82 e0       	ldi	r24, 0x02	; 2
     618:	e8 0e       	add	r14, r24
     61a:	f1 1c       	adc	r15, r1
     61c:	c7 01       	movw	r24, r14
     61e:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     622:	8e 89       	ldd	r24, Y+22	; 0x16
     624:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     628:	98 17       	cp	r25, r24
     62a:	10 f4       	brcc	.+4      	; 0x630 <xTaskResumeFromISR+0x70>
     62c:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     630:	29 e0       	ldi	r18, 0x09	; 9
     632:	82 9f       	mul	r24, r18
     634:	c0 01       	movw	r24, r0
     636:	11 24       	eor	r1, r1
     638:	b7 01       	movw	r22, r14
     63a:	8e 59       	subi	r24, 0x9E	; 158
     63c:	9e 4f       	sbci	r25, 0xFE	; 254
     63e:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     642:	81 2f       	mov	r24, r17
     644:	df 91       	pop	r29
     646:	cf 91       	pop	r28
     648:	1f 91       	pop	r17
     64a:	ff 90       	pop	r15
     64c:	ef 90       	pop	r14
     64e:	08 95       	ret

00000650 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     650:	ef 92       	push	r14
     652:	ff 92       	push	r15
     654:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     656:	83 e2       	ldi	r24, 0x23	; 35
     658:	e8 2e       	mov	r14, r24
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	f8 2e       	mov	r15, r24
     65e:	00 e0       	ldi	r16, 0x00	; 0
     660:	20 e0       	ldi	r18, 0x00	; 0
     662:	30 e0       	ldi	r19, 0x00	; 0
     664:	45 e5       	ldi	r20, 0x55	; 85
     666:	50 e0       	ldi	r21, 0x00	; 0
     668:	6b e1       	ldi	r22, 0x1B	; 27
     66a:	71 e0       	ldi	r23, 0x01	; 1
     66c:	85 e1       	ldi	r24, 0x15	; 21
     66e:	91 e0       	ldi	r25, 0x01	; 1
     670:	0e 94 43 01 	call	0x286	; 0x286 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     674:	81 30       	cpi	r24, 0x01	; 1
     676:	91 f4       	brne	.+36     	; 0x69c <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     678:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     67a:	2f ef       	ldi	r18, 0xFF	; 255
     67c:	3f ef       	ldi	r19, 0xFF	; 255
     67e:	30 93 26 01 	sts	0x0126, r19	; 0x800126 <xNextTaskUnblockTime+0x1>
     682:	20 93 25 01 	sts	0x0125, r18	; 0x800125 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     686:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     68a:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <xTickCount+0x1>
     68e:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     692:	0f 91       	pop	r16
     694:	ff 90       	pop	r15
     696:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     698:	0c 94 8c 10 	jmp	0x2118	; 0x2118 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     69c:	0f 91       	pop	r16
     69e:	ff 90       	pop	r15
     6a0:	ef 90       	pop	r14
     6a2:	08 95       	ret

000006a4 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     6a4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     6a6:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <xSchedulerRunning>
	vPortEndScheduler();
     6aa:	0c 94 cc 10 	jmp	0x2198	; 0x2198 <vPortEndScheduler>

000006ae <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     6ae:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     6b2:	8f 5f       	subi	r24, 0xFF	; 255
     6b4:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <uxSchedulerSuspended>
     6b8:	08 95       	ret

000006ba <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     6ba:	0f b6       	in	r0, 0x3f	; 63
     6bc:	f8 94       	cli
     6be:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     6c0:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xTickCount>
     6c4:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     6c8:	0f 90       	pop	r0
     6ca:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     6cc:	08 95       	ret

000006ce <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     6ce:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xTickCount>
     6d2:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6d6:	08 95       	ret

000006d8 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     6d8:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
}
     6dc:	08 95       	ret

000006de <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     6de:	00 97       	sbiw	r24, 0x00	; 0
     6e0:	21 f4       	brne	.+8      	; 0x6ea <pcTaskGetName+0xc>
     6e2:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     6e6:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     6ea:	49 96       	adiw	r24, 0x19	; 25
     6ec:	08 95       	ret

000006ee <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     6ee:	cf 92       	push	r12
     6f0:	df 92       	push	r13
     6f2:	ef 92       	push	r14
     6f4:	ff 92       	push	r15
     6f6:	0f 93       	push	r16
     6f8:	1f 93       	push	r17
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     6fe:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     702:	81 11       	cpse	r24, r1
     704:	8c c0       	rjmp	.+280    	; 0x81e <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     706:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <xTickCount>
     70a:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <xTickCount+0x1>
     70e:	0f 5f       	subi	r16, 0xFF	; 255
     710:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     712:	10 93 2e 01 	sts	0x012E, r17	; 0x80012e <xTickCount+0x1>
     716:	00 93 2d 01 	sts	0x012D, r16	; 0x80012d <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     71a:	01 15       	cp	r16, r1
     71c:	11 05       	cpc	r17, r1
     71e:	b9 f4       	brne	.+46     	; 0x74e <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     720:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <pxDelayedTaskList>
     724:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     728:	20 91 4c 01 	lds	r18, 0x014C	; 0x80014c <pxOverflowDelayedTaskList>
     72c:	30 91 4d 01 	lds	r19, 0x014D	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     730:	30 93 4f 01 	sts	0x014F, r19	; 0x80014f <pxDelayedTaskList+0x1>
     734:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <pxDelayedTaskList>
     738:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     73c:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <pxOverflowDelayedTaskList>
     740:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <xNumOfOverflows>
     744:	8f 5f       	subi	r24, 0xFF	; 255
     746:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <xNumOfOverflows>
     74a:	0e 94 9e 00 	call	0x13c	; 0x13c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     74e:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <xNextTaskUnblockTime>
     752:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <xNextTaskUnblockTime+0x1>
     756:	c0 e0       	ldi	r28, 0x00	; 0
     758:	08 17       	cp	r16, r24
     75a:	19 07       	cpc	r17, r25
     75c:	08 f4       	brcc	.+2      	; 0x760 <xTaskIncrementTick+0x72>
     75e:	4f c0       	rjmp	.+158    	; 0x7fe <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     760:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     762:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     766:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     76a:	80 81       	ld	r24, Z
     76c:	81 11       	cpse	r24, r1
     76e:	03 c0       	rjmp	.+6      	; 0x776 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     770:	8f ef       	ldi	r24, 0xFF	; 255
     772:	9f ef       	ldi	r25, 0xFF	; 255
     774:	11 c0       	rjmp	.+34     	; 0x798 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     776:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     77a:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     77e:	05 80       	ldd	r0, Z+5	; 0x05
     780:	f6 81       	ldd	r31, Z+6	; 0x06
     782:	e0 2d       	mov	r30, r0
     784:	e6 80       	ldd	r14, Z+6	; 0x06
     786:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     788:	d7 01       	movw	r26, r14
     78a:	12 96       	adiw	r26, 0x02	; 2
     78c:	8d 91       	ld	r24, X+
     78e:	9c 91       	ld	r25, X
     790:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     792:	08 17       	cp	r16, r24
     794:	19 07       	cpc	r17, r25
     796:	28 f4       	brcc	.+10     	; 0x7a2 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     798:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <xNextTaskUnblockTime+0x1>
     79c:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     7a0:	2e c0       	rjmp	.+92     	; 0x7fe <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7a2:	67 01       	movw	r12, r14
     7a4:	b2 e0       	ldi	r27, 0x02	; 2
     7a6:	cb 0e       	add	r12, r27
     7a8:	d1 1c       	adc	r13, r1
     7aa:	c6 01       	movw	r24, r12
     7ac:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     7b0:	f7 01       	movw	r30, r14
     7b2:	84 89       	ldd	r24, Z+20	; 0x14
     7b4:	95 89       	ldd	r25, Z+21	; 0x15
     7b6:	89 2b       	or	r24, r25
     7b8:	21 f0       	breq	.+8      	; 0x7c2 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     7ba:	c7 01       	movw	r24, r14
     7bc:	0c 96       	adiw	r24, 0x0c	; 12
     7be:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     7c2:	d7 01       	movw	r26, r14
     7c4:	56 96       	adiw	r26, 0x16	; 22
     7c6:	8c 91       	ld	r24, X
     7c8:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     7cc:	98 17       	cp	r25, r24
     7ce:	10 f4       	brcc	.+4      	; 0x7d4 <xTaskIncrementTick+0xe6>
     7d0:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     7d4:	d8 9f       	mul	r29, r24
     7d6:	c0 01       	movw	r24, r0
     7d8:	11 24       	eor	r1, r1
     7da:	b6 01       	movw	r22, r12
     7dc:	8e 59       	subi	r24, 0x9E	; 158
     7de:	9e 4f       	sbci	r25, 0xFE	; 254
     7e0:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     7e4:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     7e8:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     7ec:	d7 01       	movw	r26, r14
     7ee:	56 96       	adiw	r26, 0x16	; 22
     7f0:	9c 91       	ld	r25, X
     7f2:	86 89       	ldd	r24, Z+22	; 0x16
     7f4:	98 17       	cp	r25, r24
     7f6:	08 f4       	brcc	.+2      	; 0x7fa <xTaskIncrementTick+0x10c>
     7f8:	b4 cf       	rjmp	.-152    	; 0x762 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     7fa:	c1 e0       	ldi	r28, 0x01	; 1
     7fc:	b2 cf       	rjmp	.-156    	; 0x762 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     7fe:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     802:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     806:	e6 89       	ldd	r30, Z+22	; 0x16
     808:	b9 e0       	ldi	r27, 0x09	; 9
     80a:	eb 9f       	mul	r30, r27
     80c:	f0 01       	movw	r30, r0
     80e:	11 24       	eor	r1, r1
     810:	ee 59       	subi	r30, 0x9E	; 158
     812:	fe 4f       	sbci	r31, 0xFE	; 254
     814:	80 81       	ld	r24, Z
     816:	82 30       	cpi	r24, 0x02	; 2
     818:	40 f0       	brcs	.+16     	; 0x82a <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     81a:	c1 e0       	ldi	r28, 0x01	; 1
     81c:	06 c0       	rjmp	.+12     	; 0x82a <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     81e:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <uxPendedTicks>
     822:	8f 5f       	subi	r24, 0xFF	; 255
     824:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     828:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     82a:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <xYieldPending>
     82e:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     830:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     832:	8c 2f       	mov	r24, r28
     834:	df 91       	pop	r29
     836:	cf 91       	pop	r28
     838:	1f 91       	pop	r17
     83a:	0f 91       	pop	r16
     83c:	ff 90       	pop	r15
     83e:	ef 90       	pop	r14
     840:	df 90       	pop	r13
     842:	cf 90       	pop	r12
     844:	08 95       	ret

00000846 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     846:	ef 92       	push	r14
     848:	ff 92       	push	r15
     84a:	0f 93       	push	r16
     84c:	1f 93       	push	r17
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     858:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     85c:	81 50       	subi	r24, 0x01	; 1
     85e:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     862:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     866:	88 23       	and	r24, r24
     868:	11 f0       	breq	.+4      	; 0x86e <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     86a:	80 e0       	ldi	r24, 0x00	; 0
     86c:	52 c0       	rjmp	.+164    	; 0x912 <__stack+0x13>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     86e:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     872:	88 23       	and	r24, r24
     874:	d1 f3       	breq	.-12     	; 0x86a <xTaskResumeAll+0x24>
     876:	c0 e0       	ldi	r28, 0x00	; 0
     878:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     87a:	89 e0       	ldi	r24, 0x09	; 9
     87c:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     87e:	ee 24       	eor	r14, r14
     880:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     882:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xPendingReadyList>
     886:	88 23       	and	r24, r24
     888:	51 f1       	breq	.+84     	; 0x8de <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     88a:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <xPendingReadyList+0x5>
     88e:	f0 91 49 01 	lds	r31, 0x0149	; 0x800149 <xPendingReadyList+0x6>
     892:	c6 81       	ldd	r28, Z+6	; 0x06
     894:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     896:	ce 01       	movw	r24, r28
     898:	0c 96       	adiw	r24, 0x0c	; 12
     89a:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     89e:	8e 01       	movw	r16, r28
     8a0:	0e 5f       	subi	r16, 0xFE	; 254
     8a2:	1f 4f       	sbci	r17, 0xFF	; 255
     8a4:	c8 01       	movw	r24, r16
     8a6:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     8aa:	8e 89       	ldd	r24, Y+22	; 0x16
     8ac:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     8b0:	98 17       	cp	r25, r24
     8b2:	10 f4       	brcc	.+4      	; 0x8b8 <xTaskResumeAll+0x72>
     8b4:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     8b8:	f8 9e       	mul	r15, r24
     8ba:	c0 01       	movw	r24, r0
     8bc:	11 24       	eor	r1, r1
     8be:	b8 01       	movw	r22, r16
     8c0:	8e 59       	subi	r24, 0x9E	; 158
     8c2:	9e 4f       	sbci	r25, 0xFE	; 254
     8c4:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     8c8:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     8cc:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     8d0:	9e 89       	ldd	r25, Y+22	; 0x16
     8d2:	86 89       	ldd	r24, Z+22	; 0x16
     8d4:	98 17       	cp	r25, r24
     8d6:	a8 f2       	brcs	.-86     	; 0x882 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     8d8:	e0 92 29 01 	sts	0x0129, r14	; 0x800129 <xYieldPending>
     8dc:	d2 cf       	rjmp	.-92     	; 0x882 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     8de:	cd 2b       	or	r28, r29
     8e0:	11 f0       	breq	.+4      	; 0x8e6 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     8e2:	0e 94 9e 00 	call	0x13c	; 0x13c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     8e6:	c0 91 2a 01 	lds	r28, 0x012A	; 0x80012a <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     8ea:	cc 23       	and	r28, r28
     8ec:	51 f0       	breq	.+20     	; 0x902 <__stack+0x3>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     8ee:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     8f0:	0e 94 77 03 	call	0x6ee	; 0x6ee <xTaskIncrementTick>
     8f4:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     8f6:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     8fa:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     8fc:	c9 f7       	brne	.-14     	; 0x8f0 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     8fe:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     902:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <xYieldPending>
     906:	88 23       	and	r24, r24
     908:	09 f4       	brne	.+2      	; 0x90c <__stack+0xd>
     90a:	af cf       	rjmp	.-162    	; 0x86a <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     90c:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     910:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     912:	0f 90       	pop	r0
     914:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	08 95       	ret

00000924 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     924:	0f 93       	push	r16
     926:	1f 93       	push	r17
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	8c 01       	movw	r16, r24
     92e:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     930:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     934:	40 91 2d 01 	lds	r20, 0x012D	; 0x80012d <xTickCount>
     938:	50 91 2e 01 	lds	r21, 0x012E	; 0x80012e <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     93c:	f8 01       	movw	r30, r16
     93e:	20 81       	ld	r18, Z
     940:	31 81       	ldd	r19, Z+1	; 0x01
     942:	c9 01       	movw	r24, r18
     944:	8c 0f       	add	r24, r28
     946:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     948:	42 17       	cp	r20, r18
     94a:	53 07       	cpc	r21, r19
     94c:	20 f4       	brcc	.+8      	; 0x956 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     94e:	82 17       	cp	r24, r18
     950:	93 07       	cpc	r25, r19
     952:	40 f4       	brcc	.+16     	; 0x964 <vTaskDelayUntil+0x40>
     954:	03 c0       	rjmp	.+6      	; 0x95c <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     956:	82 17       	cp	r24, r18
     958:	93 07       	cpc	r25, r19
     95a:	30 f0       	brcs	.+12     	; 0x968 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     95c:	21 e0       	ldi	r18, 0x01	; 1
     95e:	48 17       	cp	r20, r24
     960:	59 07       	cpc	r21, r25
     962:	18 f0       	brcs	.+6      	; 0x96a <vTaskDelayUntil+0x46>
     964:	20 e0       	ldi	r18, 0x00	; 0
     966:	01 c0       	rjmp	.+2      	; 0x96a <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     968:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     96a:	f8 01       	movw	r30, r16
     96c:	91 83       	std	Z+1, r25	; 0x01
     96e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     970:	22 23       	and	r18, r18
     972:	29 f0       	breq	.+10     	; 0x97e <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     974:	60 e0       	ldi	r22, 0x00	; 0
     976:	84 1b       	sub	r24, r20
     978:	95 0b       	sbc	r25, r21
     97a:	0e 94 b9 00 	call	0x172	; 0x172 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     97e:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     982:	81 11       	cpse	r24, r1
     984:	02 c0       	rjmp	.+4      	; 0x98a <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     986:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     98a:	df 91       	pop	r29
     98c:	cf 91       	pop	r28
     98e:	1f 91       	pop	r17
     990:	0f 91       	pop	r16
     992:	08 95       	ret

00000994 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     99a:	89 2b       	or	r24, r25
     99c:	19 f4       	brne	.+6      	; 0x9a4 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     99e:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
     9a2:	0a c0       	rjmp	.+20     	; 0x9b8 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     9a4:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     9a8:	60 e0       	ldi	r22, 0x00	; 0
     9aa:	ce 01       	movw	r24, r28
     9ac:	0e 94 b9 00 	call	0x172	; 0x172 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     9b0:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9b4:	88 23       	and	r24, r24
     9b6:	99 f3       	breq	.-26     	; 0x99e <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	08 95       	ret

000009be <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     9be:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     9c2:	88 23       	and	r24, r24
     9c4:	21 f0       	breq	.+8      	; 0x9ce <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     9c6:	81 e0       	ldi	r24, 0x01	; 1
     9c8:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     9cc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     9ce:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     9d2:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTopReadyPriority>
     9d6:	69 e0       	ldi	r22, 0x09	; 9
     9d8:	48 2f       	mov	r20, r24
     9da:	50 e0       	ldi	r21, 0x00	; 0
     9dc:	64 9f       	mul	r22, r20
     9de:	90 01       	movw	r18, r0
     9e0:	65 9f       	mul	r22, r21
     9e2:	30 0d       	add	r19, r0
     9e4:	11 24       	eor	r1, r1
     9e6:	f9 01       	movw	r30, r18
     9e8:	ee 59       	subi	r30, 0x9E	; 158
     9ea:	fe 4f       	sbci	r31, 0xFE	; 254
     9ec:	90 81       	ld	r25, Z
     9ee:	91 11       	cpse	r25, r1
     9f0:	02 c0       	rjmp	.+4      	; 0x9f6 <vTaskSwitchContext+0x38>
     9f2:	81 50       	subi	r24, 0x01	; 1
     9f4:	f1 cf       	rjmp	.-30     	; 0x9d8 <vTaskSwitchContext+0x1a>
     9f6:	a1 81       	ldd	r26, Z+1	; 0x01
     9f8:	b2 81       	ldd	r27, Z+2	; 0x02
     9fa:	12 96       	adiw	r26, 0x02	; 2
     9fc:	0d 90       	ld	r0, X+
     9fe:	bc 91       	ld	r27, X
     a00:	a0 2d       	mov	r26, r0
     a02:	b2 83       	std	Z+2, r27	; 0x02
     a04:	a1 83       	std	Z+1, r26	; 0x01
     a06:	2b 59       	subi	r18, 0x9B	; 155
     a08:	3e 4f       	sbci	r19, 0xFE	; 254
     a0a:	a2 17       	cp	r26, r18
     a0c:	b3 07       	cpc	r27, r19
     a0e:	31 f4       	brne	.+12     	; 0xa1c <vTaskSwitchContext+0x5e>
     a10:	12 96       	adiw	r26, 0x02	; 2
     a12:	2d 91       	ld	r18, X+
     a14:	3c 91       	ld	r19, X
     a16:	13 97       	sbiw	r26, 0x03	; 3
     a18:	32 83       	std	Z+2, r19	; 0x02
     a1a:	21 83       	std	Z+1, r18	; 0x01
     a1c:	99 e0       	ldi	r25, 0x09	; 9
     a1e:	94 9f       	mul	r25, r20
     a20:	f0 01       	movw	r30, r0
     a22:	95 9f       	mul	r25, r21
     a24:	f0 0d       	add	r31, r0
     a26:	11 24       	eor	r1, r1
     a28:	ee 59       	subi	r30, 0x9E	; 158
     a2a:	fe 4f       	sbci	r31, 0xFE	; 254
     a2c:	01 80       	ldd	r0, Z+1	; 0x01
     a2e:	f2 81       	ldd	r31, Z+2	; 0x02
     a30:	e0 2d       	mov	r30, r0
     a32:	26 81       	ldd	r18, Z+6	; 0x06
     a34:	37 81       	ldd	r19, Z+7	; 0x07
     a36:	30 93 21 01 	sts	0x0121, r19	; 0x800121 <__data_end+0x1>
     a3a:	20 93 20 01 	sts	0x0120, r18	; 0x800120 <__data_end>
     a3e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     a42:	08 95       	ret

00000a44 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     a44:	0f 93       	push	r16
     a46:	1f 93       	push	r17
     a48:	cf 93       	push	r28
     a4a:	df 93       	push	r29
     a4c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     a4e:	0f b6       	in	r0, 0x3f	; 63
     a50:	f8 94       	cli
     a52:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     a54:	89 2b       	or	r24, r25
     a56:	21 f4       	brne	.+8      	; 0xa60 <vTaskSuspend+0x1c>
     a58:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
     a5c:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     a60:	8e 01       	movw	r16, r28
     a62:	0e 5f       	subi	r16, 0xFE	; 254
     a64:	1f 4f       	sbci	r17, 0xFF	; 255
     a66:	c8 01       	movw	r24, r16
     a68:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     a6c:	8c 89       	ldd	r24, Y+20	; 0x14
     a6e:	9d 89       	ldd	r25, Y+21	; 0x15
     a70:	89 2b       	or	r24, r25
     a72:	21 f0       	breq	.+8      	; 0xa7c <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     a74:	ce 01       	movw	r24, r28
     a76:	0c 96       	adiw	r24, 0x0c	; 12
     a78:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     a7c:	b8 01       	movw	r22, r16
     a7e:	80 e3       	ldi	r24, 0x30	; 48
     a80:	91 e0       	ldi	r25, 0x01	; 1
     a82:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     a86:	8d a1       	ldd	r24, Y+37	; 0x25
     a88:	81 30       	cpi	r24, 0x01	; 1
     a8a:	09 f4       	brne	.+2      	; 0xa8e <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     a8c:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     a8e:	0f 90       	pop	r0
     a90:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     a92:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     a96:	88 23       	and	r24, r24
     a98:	39 f0       	breq	.+14     	; 0xaa8 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	f8 94       	cli
     a9e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     aa0:	0e 94 9e 00 	call	0x13c	; 0x13c <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     aa4:	0f 90       	pop	r0
     aa6:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     aa8:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     aac:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     ab0:	c8 17       	cp	r28, r24
     ab2:	d9 07       	cpc	r29, r25
     ab4:	c1 f4       	brne	.+48     	; 0xae6 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     ab6:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     aba:	88 23       	and	r24, r24
     abc:	19 f0       	breq	.+6      	; 0xac4 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     abe:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
     ac2:	11 c0       	rjmp	.+34     	; 0xae6 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     ac4:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <xSuspendedTaskList>
     ac8:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     acc:	98 13       	cpse	r25, r24
     ace:	05 c0       	rjmp	.+10     	; 0xada <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     ad0:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <__data_end+0x1>
     ad4:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__data_end>
     ad8:	06 c0       	rjmp	.+12     	; 0xae6 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	1f 91       	pop	r17
     ae0:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     ae2:	0c 94 df 04 	jmp	0x9be	; 0x9be <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ae6:	df 91       	pop	r29
     ae8:	cf 91       	pop	r28
     aea:	1f 91       	pop	r17
     aec:	0f 91       	pop	r16
     aee:	08 95       	ret

00000af0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     af0:	cf 93       	push	r28
     af2:	df 93       	push	r29
     af4:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     af6:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     afa:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     afe:	64 5f       	subi	r22, 0xF4	; 244
     b00:	7f 4f       	sbci	r23, 0xFF	; 255
     b02:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b06:	61 e0       	ldi	r22, 0x01	; 1
     b08:	ce 01       	movw	r24, r28
}
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b0e:	0c 94 b9 00 	jmp	0x172	; 0x172 <prvAddCurrentTaskToDelayedList>

00000b12 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     b12:	cf 93       	push	r28
     b14:	df 93       	push	r29
     b16:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b18:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     b1c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     b20:	70 68       	ori	r23, 0x80	; 128
     b22:	75 87       	std	Z+13, r23	; 0x0d
     b24:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b26:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     b2a:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     b2e:	64 5f       	subi	r22, 0xF4	; 244
     b30:	7f 4f       	sbci	r23, 0xFF	; 255
     b32:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b36:	61 e0       	ldi	r22, 0x01	; 1
     b38:	ce 01       	movw	r24, r28
}
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b3e:	0c 94 b9 00 	jmp	0x172	; 0x172 <prvAddCurrentTaskToDelayedList>

00000b42 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	cf 93       	push	r28
     b48:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b4a:	dc 01       	movw	r26, r24
     b4c:	15 96       	adiw	r26, 0x05	; 5
     b4e:	ed 91       	ld	r30, X+
     b50:	fc 91       	ld	r31, X
     b52:	16 97       	sbiw	r26, 0x06	; 6
     b54:	c6 81       	ldd	r28, Z+6	; 0x06
     b56:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     b58:	8e 01       	movw	r16, r28
     b5a:	04 5f       	subi	r16, 0xF4	; 244
     b5c:	1f 4f       	sbci	r17, 0xFF	; 255
     b5e:	c8 01       	movw	r24, r16
     b60:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b64:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     b68:	81 11       	cpse	r24, r1
     b6a:	14 c0       	rjmp	.+40     	; 0xb94 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     b6c:	0a 50       	subi	r16, 0x0A	; 10
     b6e:	11 09       	sbc	r17, r1
     b70:	c8 01       	movw	r24, r16
     b72:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     b76:	8e 89       	ldd	r24, Y+22	; 0x16
     b78:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     b7c:	98 17       	cp	r25, r24
     b7e:	10 f4       	brcc	.+4      	; 0xb84 <xTaskRemoveFromEventList+0x42>
     b80:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     b84:	b9 e0       	ldi	r27, 0x09	; 9
     b86:	8b 9f       	mul	r24, r27
     b88:	c0 01       	movw	r24, r0
     b8a:	11 24       	eor	r1, r1
     b8c:	b8 01       	movw	r22, r16
     b8e:	8e 59       	subi	r24, 0x9E	; 158
     b90:	9e 4f       	sbci	r25, 0xFE	; 254
     b92:	03 c0       	rjmp	.+6      	; 0xb9a <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     b94:	b8 01       	movw	r22, r16
     b96:	83 e4       	ldi	r24, 0x43	; 67
     b98:	91 e0       	ldi	r25, 0x01	; 1
     b9a:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     b9e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     ba2:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     ba6:	9e 89       	ldd	r25, Y+22	; 0x16
     ba8:	86 89       	ldd	r24, Z+22	; 0x16
     baa:	89 17       	cp	r24, r25
     bac:	20 f4       	brcc	.+8      	; 0xbb6 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     bb4:	01 c0       	rjmp	.+2      	; 0xbb8 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     bb6:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     bb8:	df 91       	pop	r29
     bba:	cf 91       	pop	r28
     bbc:	1f 91       	pop	r17
     bbe:	0f 91       	pop	r16
     bc0:	08 95       	ret

00000bc2 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     bc2:	0f 93       	push	r16
     bc4:	1f 93       	push	r17
     bc6:	cf 93       	push	r28
     bc8:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     bca:	70 68       	ori	r23, 0x80	; 128
     bcc:	fc 01       	movw	r30, r24
     bce:	71 83       	std	Z+1, r23	; 0x01
     bd0:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     bd2:	c6 81       	ldd	r28, Z+6	; 0x06
     bd4:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     bd6:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     bda:	8e 01       	movw	r16, r28
     bdc:	0e 5f       	subi	r16, 0xFE	; 254
     bde:	1f 4f       	sbci	r17, 0xFF	; 255
     be0:	c8 01       	movw	r24, r16
     be2:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     be6:	8e 89       	ldd	r24, Y+22	; 0x16
     be8:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     bec:	98 17       	cp	r25, r24
     bee:	10 f4       	brcc	.+4      	; 0xbf4 <vTaskRemoveFromUnorderedEventList+0x32>
     bf0:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     bf4:	f9 e0       	ldi	r31, 0x09	; 9
     bf6:	8f 9f       	mul	r24, r31
     bf8:	c0 01       	movw	r24, r0
     bfa:	11 24       	eor	r1, r1
     bfc:	b8 01       	movw	r22, r16
     bfe:	8e 59       	subi	r24, 0x9E	; 158
     c00:	9e 4f       	sbci	r25, 0xFE	; 254
     c02:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c06:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     c0a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     c0e:	9e 89       	ldd	r25, Y+22	; 0x16
     c10:	86 89       	ldd	r24, Z+22	; 0x16
     c12:	89 17       	cp	r24, r25
     c14:	18 f4       	brcc	.+6      	; 0xc1c <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
	}
}
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	08 95       	ret

00000c26 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     c2c:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <xNumOfOverflows>
     c30:	fc 01       	movw	r30, r24
     c32:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     c34:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xTickCount>
     c38:	30 91 2e 01 	lds	r19, 0x012E	; 0x80012e <xTickCount+0x1>
     c3c:	32 83       	std	Z+2, r19	; 0x02
     c3e:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     c40:	0f 90       	pop	r0
     c42:	0f be       	out	0x3f, r0	; 63
     c44:	08 95       	ret

00000c46 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     c46:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <xNumOfOverflows>
     c4a:	fc 01       	movw	r30, r24
     c4c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     c4e:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xTickCount>
     c52:	30 91 2e 01 	lds	r19, 0x012E	; 0x80012e <xTickCount+0x1>
     c56:	32 83       	std	Z+2, r19	; 0x02
     c58:	21 83       	std	Z+1, r18	; 0x01
     c5a:	08 95       	ret

00000c5c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     c66:	40 91 2d 01 	lds	r20, 0x012D	; 0x80012d <xTickCount>
     c6a:	50 91 2e 01 	lds	r21, 0x012E	; 0x80012e <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     c6e:	db 01       	movw	r26, r22
     c70:	2d 91       	ld	r18, X+
     c72:	3c 91       	ld	r19, X
     c74:	2f 3f       	cpi	r18, 0xFF	; 255
     c76:	bf ef       	ldi	r27, 0xFF	; 255
     c78:	3b 07       	cpc	r19, r27
     c7a:	d9 f0       	breq	.+54     	; 0xcb2 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     c7c:	ec 01       	movw	r28, r24
     c7e:	e9 81       	ldd	r30, Y+1	; 0x01
     c80:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     c82:	a0 91 28 01 	lds	r26, 0x0128	; 0x800128 <xNumOfOverflows>
     c86:	b8 81       	ld	r27, Y
     c88:	ba 17       	cp	r27, r26
     c8a:	19 f0       	breq	.+6      	; 0xc92 <xTaskCheckForTimeOut+0x36>
     c8c:	4e 17       	cp	r20, r30
     c8e:	5f 07       	cpc	r21, r31
     c90:	90 f4       	brcc	.+36     	; 0xcb6 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     c92:	4e 1b       	sub	r20, r30
     c94:	5f 0b       	sbc	r21, r31
     c96:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     c98:	42 17       	cp	r20, r18
     c9a:	53 07       	cpc	r21, r19
     c9c:	38 f4       	brcc	.+14     	; 0xcac <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     c9e:	24 1b       	sub	r18, r20
     ca0:	35 0b       	sbc	r19, r21
     ca2:	31 83       	std	Z+1, r19	; 0x01
     ca4:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     ca6:	0e 94 23 06 	call	0xc46	; 0xc46 <vTaskInternalSetTimeOutState>
     caa:	03 c0       	rjmp	.+6      	; 0xcb2 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     cac:	11 82       	std	Z+1, r1	; 0x01
     cae:	10 82       	st	Z, r1
     cb0:	02 c0       	rjmp	.+4      	; 0xcb6 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	01 c0       	rjmp	.+2      	; 0xcb8 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     cb6:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     cb8:	0f 90       	pop	r0
     cba:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	08 95       	ret

00000cc2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     cc8:	08 95       	ret

00000cca <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     cca:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     cce:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     cd2:	84 85       	ldd	r24, Z+12	; 0x0c
     cd4:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cd6:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     cda:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     cde:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
     ce2:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
     ce6:	56 96       	adiw	r26, 0x16	; 22
     ce8:	4c 91       	ld	r20, X
     cea:	24 e0       	ldi	r18, 0x04	; 4
     cec:	30 e0       	ldi	r19, 0x00	; 0
     cee:	24 1b       	sub	r18, r20
     cf0:	31 09       	sbc	r19, r1
     cf2:	35 87       	std	Z+13, r19	; 0x0d
     cf4:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     cf6:	08 95       	ret

00000cf8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     cf8:	0f 93       	push	r16
     cfa:	1f 93       	push	r17
     cfc:	18 2f       	mov	r17, r24
     cfe:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     d00:	0f b6       	in	r0, 0x3f	; 63
     d02:	f8 94       	cli
     d04:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     d06:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d0a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d0e:	41 a1       	ldd	r20, Z+33	; 0x21
     d10:	52 a1       	ldd	r21, Z+34	; 0x22
     d12:	63 a1       	ldd	r22, Z+35	; 0x23
     d14:	74 a1       	ldd	r23, Z+36	; 0x24
     d16:	45 2b       	or	r20, r21
     d18:	46 2b       	or	r20, r22
     d1a:	47 2b       	or	r20, r23
     d1c:	69 f4       	brne	.+26     	; 0xd38 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     d1e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d22:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d26:	21 e0       	ldi	r18, 0x01	; 1
     d28:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     d2a:	00 97       	sbiw	r24, 0x00	; 0
     d2c:	29 f0       	breq	.+10     	; 0xd38 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     d2e:	61 e0       	ldi	r22, 0x01	; 1
     d30:	0e 94 b9 00 	call	0x172	; 0x172 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     d34:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     d38:	0f 90       	pop	r0
     d3a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     d3c:	0f b6       	in	r0, 0x3f	; 63
     d3e:	f8 94       	cli
     d40:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     d42:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d46:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d4a:	61 a1       	ldd	r22, Z+33	; 0x21
     d4c:	72 a1       	ldd	r23, Z+34	; 0x22
     d4e:	83 a1       	ldd	r24, Z+35	; 0x23
     d50:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     d52:	61 15       	cp	r22, r1
     d54:	71 05       	cpc	r23, r1
     d56:	81 05       	cpc	r24, r1
     d58:	91 05       	cpc	r25, r1
     d5a:	a9 f0       	breq	.+42     	; 0xd86 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     d5c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d60:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     d64:	11 23       	and	r17, r17
     d66:	29 f0       	breq	.+10     	; 0xd72 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     d68:	11 a2       	std	Z+33, r1	; 0x21
     d6a:	12 a2       	std	Z+34, r1	; 0x22
     d6c:	13 a2       	std	Z+35, r1	; 0x23
     d6e:	14 a2       	std	Z+36, r1	; 0x24
     d70:	0a c0       	rjmp	.+20     	; 0xd86 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     d72:	8b 01       	movw	r16, r22
     d74:	9c 01       	movw	r18, r24
     d76:	01 50       	subi	r16, 0x01	; 1
     d78:	11 09       	sbc	r17, r1
     d7a:	21 09       	sbc	r18, r1
     d7c:	31 09       	sbc	r19, r1
     d7e:	01 a3       	std	Z+33, r16	; 0x21
     d80:	12 a3       	std	Z+34, r17	; 0x22
     d82:	23 a3       	std	Z+35, r18	; 0x23
     d84:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     d86:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d8a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d8e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     d90:	0f 90       	pop	r0
     d92:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	08 95       	ret

00000d9a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     d9a:	4f 92       	push	r4
     d9c:	5f 92       	push	r5
     d9e:	6f 92       	push	r6
     da0:	7f 92       	push	r7
     da2:	8f 92       	push	r8
     da4:	9f 92       	push	r9
     da6:	af 92       	push	r10
     da8:	bf 92       	push	r11
     daa:	ef 92       	push	r14
     dac:	ff 92       	push	r15
     dae:	0f 93       	push	r16
     db0:	1f 93       	push	r17
     db2:	49 01       	movw	r8, r18
     db4:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	f8 94       	cli
     dba:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     dbc:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     dc0:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     dc4:	25 a1       	ldd	r18, Z+37	; 0x25
     dc6:	22 30       	cpi	r18, 0x02	; 2
     dc8:	39 f1       	breq	.+78     	; 0xe18 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     dca:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     dce:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     dd2:	21 a1       	ldd	r18, Z+33	; 0x21
     dd4:	32 a1       	ldd	r19, Z+34	; 0x22
     dd6:	43 a1       	ldd	r20, Z+35	; 0x23
     dd8:	54 a1       	ldd	r21, Z+36	; 0x24
     dda:	2b 01       	movw	r4, r22
     ddc:	3c 01       	movw	r6, r24
     dde:	40 94       	com	r4
     de0:	50 94       	com	r5
     de2:	60 94       	com	r6
     de4:	70 94       	com	r7
     de6:	d3 01       	movw	r26, r6
     de8:	c2 01       	movw	r24, r4
     dea:	82 23       	and	r24, r18
     dec:	93 23       	and	r25, r19
     dee:	a4 23       	and	r26, r20
     df0:	b5 23       	and	r27, r21
     df2:	81 a3       	std	Z+33, r24	; 0x21
     df4:	92 a3       	std	Z+34, r25	; 0x22
     df6:	a3 a3       	std	Z+35, r26	; 0x23
     df8:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     dfa:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     dfe:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e02:	81 e0       	ldi	r24, 0x01	; 1
     e04:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e06:	e1 14       	cp	r14, r1
     e08:	f1 04       	cpc	r15, r1
     e0a:	31 f0       	breq	.+12     	; 0xe18 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e0c:	61 e0       	ldi	r22, 0x01	; 1
     e0e:	c7 01       	movw	r24, r14
     e10:	0e 94 b9 00 	call	0x172	; 0x172 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e14:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e18:	0f 90       	pop	r0
     e1a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     e22:	01 15       	cp	r16, r1
     e24:	11 05       	cpc	r17, r1
     e26:	69 f0       	breq	.+26     	; 0xe42 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     e28:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e2c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e30:	81 a1       	ldd	r24, Z+33	; 0x21
     e32:	92 a1       	ldd	r25, Z+34	; 0x22
     e34:	a3 a1       	ldd	r26, Z+35	; 0x23
     e36:	b4 a1       	ldd	r27, Z+36	; 0x24
     e38:	f8 01       	movw	r30, r16
     e3a:	80 83       	st	Z, r24
     e3c:	91 83       	std	Z+1, r25	; 0x01
     e3e:	a2 83       	std	Z+2, r26	; 0x02
     e40:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e42:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e46:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e4a:	85 a1       	ldd	r24, Z+37	; 0x25
     e4c:	82 30       	cpi	r24, 0x02	; 2
     e4e:	c1 f4       	brne	.+48     	; 0xe80 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     e50:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e54:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e58:	41 a1       	ldd	r20, Z+33	; 0x21
     e5a:	52 a1       	ldd	r21, Z+34	; 0x22
     e5c:	63 a1       	ldd	r22, Z+35	; 0x23
     e5e:	74 a1       	ldd	r23, Z+36	; 0x24
     e60:	d5 01       	movw	r26, r10
     e62:	c4 01       	movw	r24, r8
     e64:	80 95       	com	r24
     e66:	90 95       	com	r25
     e68:	a0 95       	com	r26
     e6a:	b0 95       	com	r27
     e6c:	84 23       	and	r24, r20
     e6e:	95 23       	and	r25, r21
     e70:	a6 23       	and	r26, r22
     e72:	b7 23       	and	r27, r23
     e74:	81 a3       	std	Z+33, r24	; 0x21
     e76:	92 a3       	std	Z+34, r25	; 0x22
     e78:	a3 a3       	std	Z+35, r26	; 0x23
     e7a:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	01 c0       	rjmp	.+2      	; 0xe82 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     e80:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e82:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e86:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e8a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     e90:	1f 91       	pop	r17
     e92:	0f 91       	pop	r16
     e94:	ff 90       	pop	r15
     e96:	ef 90       	pop	r14
     e98:	bf 90       	pop	r11
     e9a:	af 90       	pop	r10
     e9c:	9f 90       	pop	r9
     e9e:	8f 90       	pop	r8
     ea0:	7f 90       	pop	r7
     ea2:	6f 90       	pop	r6
     ea4:	5f 90       	pop	r5
     ea6:	4f 90       	pop	r4
     ea8:	08 95       	ret

00000eaa <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     eaa:	0f 93       	push	r16
     eac:	1f 93       	push	r17
     eae:	cf 93       	push	r28
     eb0:	df 93       	push	r29
     eb2:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     eba:	01 15       	cp	r16, r1
     ebc:	11 05       	cpc	r17, r1
     ebe:	49 f0       	breq	.+18     	; 0xed2 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     ec0:	81 a1       	ldd	r24, Z+33	; 0x21
     ec2:	92 a1       	ldd	r25, Z+34	; 0x22
     ec4:	a3 a1       	ldd	r26, Z+35	; 0x23
     ec6:	b4 a1       	ldd	r27, Z+36	; 0x24
     ec8:	e8 01       	movw	r28, r16
     eca:	88 83       	st	Y, r24
     ecc:	99 83       	std	Y+1, r25	; 0x01
     ece:	aa 83       	std	Y+2, r26	; 0x02
     ed0:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     ed2:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     ed4:	82 e0       	ldi	r24, 0x02	; 2
     ed6:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     ed8:	22 30       	cpi	r18, 0x02	; 2
     eda:	89 f0       	breq	.+34     	; 0xefe <xTaskGenericNotify+0x54>
     edc:	58 f4       	brcc	.+22     	; 0xef4 <xTaskGenericNotify+0x4a>
     ede:	21 30       	cpi	r18, 0x01	; 1
     ee0:	01 f5       	brne	.+64     	; 0xf22 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     ee2:	81 a1       	ldd	r24, Z+33	; 0x21
     ee4:	92 a1       	ldd	r25, Z+34	; 0x22
     ee6:	a3 a1       	ldd	r26, Z+35	; 0x23
     ee8:	b4 a1       	ldd	r27, Z+36	; 0x24
     eea:	48 2b       	or	r20, r24
     eec:	59 2b       	or	r21, r25
     eee:	6a 2b       	or	r22, r26
     ef0:	7b 2b       	or	r23, r27
     ef2:	13 c0       	rjmp	.+38     	; 0xf1a <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     ef4:	23 30       	cpi	r18, 0x03	; 3
     ef6:	89 f0       	breq	.+34     	; 0xf1a <xTaskGenericNotify+0x70>
     ef8:	24 30       	cpi	r18, 0x04	; 4
     efa:	69 f0       	breq	.+26     	; 0xf16 <xTaskGenericNotify+0x6c>
     efc:	12 c0       	rjmp	.+36     	; 0xf22 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     efe:	81 a1       	ldd	r24, Z+33	; 0x21
     f00:	92 a1       	ldd	r25, Z+34	; 0x22
     f02:	a3 a1       	ldd	r26, Z+35	; 0x23
     f04:	b4 a1       	ldd	r27, Z+36	; 0x24
     f06:	01 96       	adiw	r24, 0x01	; 1
     f08:	a1 1d       	adc	r26, r1
     f0a:	b1 1d       	adc	r27, r1
     f0c:	81 a3       	std	Z+33, r24	; 0x21
     f0e:	92 a3       	std	Z+34, r25	; 0x22
     f10:	a3 a3       	std	Z+35, r26	; 0x23
     f12:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     f14:	06 c0       	rjmp	.+12     	; 0xf22 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     f16:	32 30       	cpi	r19, 0x02	; 2
     f18:	49 f1       	breq	.+82     	; 0xf6c <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     f1a:	41 a3       	std	Z+33, r20	; 0x21
     f1c:	52 a3       	std	Z+34, r21	; 0x22
     f1e:	63 a3       	std	Z+35, r22	; 0x23
     f20:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     f22:	31 30       	cpi	r19, 0x01	; 1
     f24:	09 f5       	brne	.+66     	; 0xf68 <xTaskGenericNotify+0xbe>
     f26:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     f28:	8f 01       	movw	r16, r30
     f2a:	0e 5f       	subi	r16, 0xFE	; 254
     f2c:	1f 4f       	sbci	r17, 0xFF	; 255
     f2e:	c8 01       	movw	r24, r16
     f30:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     f34:	8e 89       	ldd	r24, Y+22	; 0x16
     f36:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     f3a:	98 17       	cp	r25, r24
     f3c:	10 f4       	brcc	.+4      	; 0xf42 <xTaskGenericNotify+0x98>
     f3e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     f42:	29 e0       	ldi	r18, 0x09	; 9
     f44:	82 9f       	mul	r24, r18
     f46:	c0 01       	movw	r24, r0
     f48:	11 24       	eor	r1, r1
     f4a:	b8 01       	movw	r22, r16
     f4c:	8e 59       	subi	r24, 0x9E	; 158
     f4e:	9e 4f       	sbci	r25, 0xFE	; 254
     f50:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     f54:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f58:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f5c:	9e 89       	ldd	r25, Y+22	; 0x16
     f5e:	86 89       	ldd	r24, Z+22	; 0x16
     f60:	89 17       	cp	r24, r25
     f62:	10 f4       	brcc	.+4      	; 0xf68 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     f64:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	01 c0       	rjmp	.+2      	; 0xf6e <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     f6c:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     f6e:	0f 90       	pop	r0
     f70:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f72:	df 91       	pop	r29
     f74:	cf 91       	pop	r28
     f76:	1f 91       	pop	r17
     f78:	0f 91       	pop	r16
     f7a:	08 95       	ret

00000f7c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     f7c:	ef 92       	push	r14
     f7e:	ff 92       	push	r15
     f80:	0f 93       	push	r16
     f82:	1f 93       	push	r17
     f84:	cf 93       	push	r28
     f86:	df 93       	push	r29
     f88:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
     f8a:	01 15       	cp	r16, r1
     f8c:	11 05       	cpc	r17, r1
     f8e:	49 f0       	breq	.+18     	; 0xfa2 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f90:	81 a1       	ldd	r24, Z+33	; 0x21
     f92:	92 a1       	ldd	r25, Z+34	; 0x22
     f94:	a3 a1       	ldd	r26, Z+35	; 0x23
     f96:	b4 a1       	ldd	r27, Z+36	; 0x24
     f98:	e8 01       	movw	r28, r16
     f9a:	88 83       	st	Y, r24
     f9c:	99 83       	std	Y+1, r25	; 0x01
     f9e:	aa 83       	std	Y+2, r26	; 0x02
     fa0:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     fa2:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     fa4:	82 e0       	ldi	r24, 0x02	; 2
     fa6:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     fa8:	22 30       	cpi	r18, 0x02	; 2
     faa:	89 f0       	breq	.+34     	; 0xfce <xTaskGenericNotifyFromISR+0x52>
     fac:	58 f4       	brcc	.+22     	; 0xfc4 <xTaskGenericNotifyFromISR+0x48>
     fae:	21 30       	cpi	r18, 0x01	; 1
     fb0:	01 f5       	brne	.+64     	; 0xff2 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     fb2:	81 a1       	ldd	r24, Z+33	; 0x21
     fb4:	92 a1       	ldd	r25, Z+34	; 0x22
     fb6:	a3 a1       	ldd	r26, Z+35	; 0x23
     fb8:	b4 a1       	ldd	r27, Z+36	; 0x24
     fba:	48 2b       	or	r20, r24
     fbc:	59 2b       	or	r21, r25
     fbe:	6a 2b       	or	r22, r26
     fc0:	7b 2b       	or	r23, r27
     fc2:	13 c0       	rjmp	.+38     	; 0xfea <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     fc4:	23 30       	cpi	r18, 0x03	; 3
     fc6:	89 f0       	breq	.+34     	; 0xfea <xTaskGenericNotifyFromISR+0x6e>
     fc8:	24 30       	cpi	r18, 0x04	; 4
     fca:	69 f0       	breq	.+26     	; 0xfe6 <xTaskGenericNotifyFromISR+0x6a>
     fcc:	12 c0       	rjmp	.+36     	; 0xff2 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     fce:	81 a1       	ldd	r24, Z+33	; 0x21
     fd0:	92 a1       	ldd	r25, Z+34	; 0x22
     fd2:	a3 a1       	ldd	r26, Z+35	; 0x23
     fd4:	b4 a1       	ldd	r27, Z+36	; 0x24
     fd6:	01 96       	adiw	r24, 0x01	; 1
     fd8:	a1 1d       	adc	r26, r1
     fda:	b1 1d       	adc	r27, r1
     fdc:	81 a3       	std	Z+33, r24	; 0x21
     fde:	92 a3       	std	Z+34, r25	; 0x22
     fe0:	a3 a3       	std	Z+35, r26	; 0x23
     fe2:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     fe4:	06 c0       	rjmp	.+12     	; 0xff2 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     fe6:	32 30       	cpi	r19, 0x02	; 2
     fe8:	d9 f1       	breq	.+118    	; 0x1060 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
     fea:	41 a3       	std	Z+33, r20	; 0x21
     fec:	52 a3       	std	Z+34, r21	; 0x22
     fee:	63 a3       	std	Z+35, r22	; 0x23
     ff0:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     ff2:	31 30       	cpi	r19, 0x01	; 1
     ff4:	11 f0       	breq	.+4      	; 0xffa <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     ff6:	81 e0       	ldi	r24, 0x01	; 1
     ff8:	34 c0       	rjmp	.+104    	; 0x1062 <xTaskGenericNotifyFromISR+0xe6>
     ffa:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ffc:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
    1000:	81 11       	cpse	r24, r1
    1002:	15 c0       	rjmp	.+42     	; 0x102e <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1004:	8f 01       	movw	r16, r30
    1006:	0e 5f       	subi	r16, 0xFE	; 254
    1008:	1f 4f       	sbci	r17, 0xFF	; 255
    100a:	c8 01       	movw	r24, r16
    100c:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1010:	8e 89       	ldd	r24, Y+22	; 0x16
    1012:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    1016:	98 17       	cp	r25, r24
    1018:	10 f4       	brcc	.+4      	; 0x101e <xTaskGenericNotifyFromISR+0xa2>
    101a:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    101e:	e9 e0       	ldi	r30, 0x09	; 9
    1020:	8e 9f       	mul	r24, r30
    1022:	c0 01       	movw	r24, r0
    1024:	11 24       	eor	r1, r1
    1026:	b8 01       	movw	r22, r16
    1028:	8e 59       	subi	r24, 0x9E	; 158
    102a:	9e 4f       	sbci	r25, 0xFE	; 254
    102c:	05 c0       	rjmp	.+10     	; 0x1038 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    102e:	bf 01       	movw	r22, r30
    1030:	64 5f       	subi	r22, 0xF4	; 244
    1032:	7f 4f       	sbci	r23, 0xFF	; 255
    1034:	83 e4       	ldi	r24, 0x43	; 67
    1036:	91 e0       	ldi	r25, 0x01	; 1
    1038:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    103c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    1040:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    1044:	9e 89       	ldd	r25, Y+22	; 0x16
    1046:	86 89       	ldd	r24, Z+22	; 0x16
    1048:	89 17       	cp	r24, r25
    104a:	a8 f6       	brcc	.-86     	; 0xff6 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    104c:	e1 14       	cp	r14, r1
    104e:	f1 04       	cpc	r15, r1
    1050:	19 f0       	breq	.+6      	; 0x1058 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	e7 01       	movw	r28, r14
    1056:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
    105e:	01 c0       	rjmp	.+2      	; 0x1062 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1060:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	1f 91       	pop	r17
    1068:	0f 91       	pop	r16
    106a:	ff 90       	pop	r15
    106c:	ef 90       	pop	r14
    106e:	08 95       	ret

00001070 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1070:	ef 92       	push	r14
    1072:	ff 92       	push	r15
    1074:	0f 93       	push	r16
    1076:	1f 93       	push	r17
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    107e:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1080:	82 e0       	ldi	r24, 0x02	; 2
    1082:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1084:	81 a1       	ldd	r24, Z+33	; 0x21
    1086:	92 a1       	ldd	r25, Z+34	; 0x22
    1088:	a3 a1       	ldd	r26, Z+35	; 0x23
    108a:	b4 a1       	ldd	r27, Z+36	; 0x24
    108c:	01 96       	adiw	r24, 0x01	; 1
    108e:	a1 1d       	adc	r26, r1
    1090:	b1 1d       	adc	r27, r1
    1092:	81 a3       	std	Z+33, r24	; 0x21
    1094:	92 a3       	std	Z+34, r25	; 0x22
    1096:	a3 a3       	std	Z+35, r26	; 0x23
    1098:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    109a:	21 30       	cpi	r18, 0x01	; 1
    109c:	a1 f5       	brne	.+104    	; 0x1106 <vTaskNotifyGiveFromISR+0x96>
    109e:	8b 01       	movw	r16, r22
    10a0:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10a2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
    10a6:	81 11       	cpse	r24, r1
    10a8:	16 c0       	rjmp	.+44     	; 0x10d6 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10aa:	7f 01       	movw	r14, r30
    10ac:	22 e0       	ldi	r18, 0x02	; 2
    10ae:	e2 0e       	add	r14, r18
    10b0:	f1 1c       	adc	r15, r1
    10b2:	c7 01       	movw	r24, r14
    10b4:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    10b8:	8e 89       	ldd	r24, Y+22	; 0x16
    10ba:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    10be:	98 17       	cp	r25, r24
    10c0:	10 f4       	brcc	.+4      	; 0x10c6 <vTaskNotifyGiveFromISR+0x56>
    10c2:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    10c6:	e9 e0       	ldi	r30, 0x09	; 9
    10c8:	8e 9f       	mul	r24, r30
    10ca:	c0 01       	movw	r24, r0
    10cc:	11 24       	eor	r1, r1
    10ce:	b7 01       	movw	r22, r14
    10d0:	8e 59       	subi	r24, 0x9E	; 158
    10d2:	9e 4f       	sbci	r25, 0xFE	; 254
    10d4:	05 c0       	rjmp	.+10     	; 0x10e0 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    10d6:	bf 01       	movw	r22, r30
    10d8:	64 5f       	subi	r22, 0xF4	; 244
    10da:	7f 4f       	sbci	r23, 0xFF	; 255
    10dc:	83 e4       	ldi	r24, 0x43	; 67
    10de:	91 e0       	ldi	r25, 0x01	; 1
    10e0:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10e4:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    10e8:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    10ec:	9e 89       	ldd	r25, Y+22	; 0x16
    10ee:	86 89       	ldd	r24, Z+22	; 0x16
    10f0:	89 17       	cp	r24, r25
    10f2:	48 f4       	brcc	.+18     	; 0x1106 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    10f4:	01 15       	cp	r16, r1
    10f6:	11 05       	cpc	r17, r1
    10f8:	19 f0       	breq	.+6      	; 0x1100 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	f8 01       	movw	r30, r16
    10fe:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	ff 90       	pop	r15
    1110:	ef 90       	pop	r14
    1112:	08 95       	ret

00001114 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1114:	00 97       	sbiw	r24, 0x00	; 0
    1116:	21 f4       	brne	.+8      	; 0x1120 <xTaskNotifyStateClear+0xc>
    1118:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
    111c:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>

		taskENTER_CRITICAL();
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1126:	fc 01       	movw	r30, r24
    1128:	25 a1       	ldd	r18, Z+37	; 0x25
    112a:	22 30       	cpi	r18, 0x02	; 2
    112c:	19 f4       	brne	.+6      	; 0x1134 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    112e:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    1130:	81 e0       	ldi	r24, 0x01	; 1
    1132:	01 c0       	rjmp	.+2      	; 0x1136 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1134:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1136:	0f 90       	pop	r0
    1138:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    113a:	08 95       	ret

0000113c <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1142:	fc 01       	movw	r30, r24
    1144:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1146:	0f 90       	pop	r0
    1148:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	91 11       	cpse	r25, r1
    114e:	80 e0       	ldi	r24, 0x00	; 0
}
    1150:	08 95       	ret

00001152 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1152:	0f 93       	push	r16
    1154:	1f 93       	push	r17
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	ec 01       	movw	r28, r24
    115c:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    115e:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1160:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1162:	44 23       	and	r20, r20
    1164:	b1 f1       	breq	.+108    	; 0x11d2 <prvCopyDataToQueue+0x80>
    1166:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1168:	01 11       	cpse	r16, r1
    116a:	15 c0       	rjmp	.+42     	; 0x1196 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    116c:	8a 81       	ldd	r24, Y+2	; 0x02
    116e:	9b 81       	ldd	r25, Y+3	; 0x03
    1170:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1174:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1176:	8a 81       	ldd	r24, Y+2	; 0x02
    1178:	9b 81       	ldd	r25, Y+3	; 0x03
    117a:	82 0f       	add	r24, r18
    117c:	91 1d       	adc	r25, r1
    117e:	9b 83       	std	Y+3, r25	; 0x03
    1180:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1182:	2c 81       	ldd	r18, Y+4	; 0x04
    1184:	3d 81       	ldd	r19, Y+5	; 0x05
    1186:	82 17       	cp	r24, r18
    1188:	93 07       	cpc	r25, r19
    118a:	18 f1       	brcs	.+70     	; 0x11d2 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    118c:	88 81       	ld	r24, Y
    118e:	99 81       	ldd	r25, Y+1	; 0x01
    1190:	9b 83       	std	Y+3, r25	; 0x03
    1192:	8a 83       	std	Y+2, r24	; 0x02
    1194:	1e c0       	rjmp	.+60     	; 0x11d2 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1196:	8e 81       	ldd	r24, Y+6	; 0x06
    1198:	9f 81       	ldd	r25, Y+7	; 0x07
    119a:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    119e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	91 95       	neg	r25
    11a4:	81 95       	neg	r24
    11a6:	91 09       	sbc	r25, r1
    11a8:	2e 81       	ldd	r18, Y+6	; 0x06
    11aa:	3f 81       	ldd	r19, Y+7	; 0x07
    11ac:	28 0f       	add	r18, r24
    11ae:	39 1f       	adc	r19, r25
    11b0:	3f 83       	std	Y+7, r19	; 0x07
    11b2:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11b4:	48 81       	ld	r20, Y
    11b6:	59 81       	ldd	r21, Y+1	; 0x01
    11b8:	24 17       	cp	r18, r20
    11ba:	35 07       	cpc	r19, r21
    11bc:	30 f4       	brcc	.+12     	; 0x11ca <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    11be:	2c 81       	ldd	r18, Y+4	; 0x04
    11c0:	3d 81       	ldd	r19, Y+5	; 0x05
    11c2:	82 0f       	add	r24, r18
    11c4:	93 1f       	adc	r25, r19
    11c6:	9f 83       	std	Y+7, r25	; 0x07
    11c8:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    11ca:	02 30       	cpi	r16, 0x02	; 2
    11cc:	11 f4       	brne	.+4      	; 0x11d2 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    11ce:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    11d0:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    11d2:	1f 5f       	subi	r17, 0xFF	; 255
    11d4:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    11d6:	80 e0       	ldi	r24, 0x00	; 0
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	1f 91       	pop	r17
    11de:	0f 91       	pop	r16
    11e0:	08 95       	ret

000011e2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    11e2:	fc 01       	movw	r30, r24
    11e4:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    11e6:	44 8d       	ldd	r20, Z+28	; 0x1c
    11e8:	44 23       	and	r20, r20
    11ea:	a1 f0       	breq	.+40     	; 0x1214 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    11ec:	50 e0       	ldi	r21, 0x00	; 0
    11ee:	26 81       	ldd	r18, Z+6	; 0x06
    11f0:	37 81       	ldd	r19, Z+7	; 0x07
    11f2:	24 0f       	add	r18, r20
    11f4:	35 1f       	adc	r19, r21
    11f6:	37 83       	std	Z+7, r19	; 0x07
    11f8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    11fa:	64 81       	ldd	r22, Z+4	; 0x04
    11fc:	75 81       	ldd	r23, Z+5	; 0x05
    11fe:	26 17       	cp	r18, r22
    1200:	37 07       	cpc	r19, r23
    1202:	20 f0       	brcs	.+8      	; 0x120c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1204:	20 81       	ld	r18, Z
    1206:	31 81       	ldd	r19, Z+1	; 0x01
    1208:	37 83       	std	Z+7, r19	; 0x07
    120a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    120c:	66 81       	ldd	r22, Z+6	; 0x06
    120e:	77 81       	ldd	r23, Z+7	; 0x07
    1210:	0c 94 0b 12 	jmp	0x2416	; 0x2416 <memcpy>
    1214:	08 95       	ret

00001216 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1216:	ef 92       	push	r14
    1218:	ff 92       	push	r15
    121a:	1f 93       	push	r17
    121c:	cf 93       	push	r28
    121e:	df 93       	push	r29
    1220:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	f8 94       	cli
    1226:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1228:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    122a:	7c 01       	movw	r14, r24
    122c:	81 e1       	ldi	r24, 0x11	; 17
    122e:	e8 0e       	add	r14, r24
    1230:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1232:	11 16       	cp	r1, r17
    1234:	5c f4       	brge	.+22     	; 0x124c <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1236:	89 89       	ldd	r24, Y+17	; 0x11
    1238:	88 23       	and	r24, r24
    123a:	41 f0       	breq	.+16     	; 0x124c <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    123c:	c7 01       	movw	r24, r14
    123e:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    1242:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1244:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskMissedYield>
    1248:	11 50       	subi	r17, 0x01	; 1
    124a:	f3 cf       	rjmp	.-26     	; 0x1232 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    124c:	8f ef       	ldi	r24, 0xFF	; 255
    124e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1250:	0f 90       	pop	r0
    1252:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1254:	0f b6       	in	r0, 0x3f	; 63
    1256:	f8 94       	cli
    1258:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    125a:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    125c:	7e 01       	movw	r14, r28
    125e:	88 e0       	ldi	r24, 0x08	; 8
    1260:	e8 0e       	add	r14, r24
    1262:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1264:	11 16       	cp	r1, r17
    1266:	5c f4       	brge	.+22     	; 0x127e <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1268:	88 85       	ldd	r24, Y+8	; 0x08
    126a:	88 23       	and	r24, r24
    126c:	41 f0       	breq	.+16     	; 0x127e <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    126e:	c7 01       	movw	r24, r14
    1270:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    1274:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1276:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vTaskMissedYield>
    127a:	11 50       	subi	r17, 0x01	; 1
    127c:	f3 cf       	rjmp	.-26     	; 0x1264 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    127e:	8f ef       	ldi	r24, 0xFF	; 255
    1280:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1282:	0f 90       	pop	r0
    1284:	0f be       	out	0x3f, r0	; 63
}
    1286:	df 91       	pop	r29
    1288:	cf 91       	pop	r28
    128a:	1f 91       	pop	r17
    128c:	ff 90       	pop	r15
    128e:	ef 90       	pop	r14
    1290:	08 95       	ret

00001292 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    129e:	48 81       	ld	r20, Y
    12a0:	59 81       	ldd	r21, Y+1	; 0x01
    12a2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    12a4:	7c 8d       	ldd	r23, Y+28	; 0x1c
    12a6:	9a 01       	movw	r18, r20
    12a8:	87 9f       	mul	r24, r23
    12aa:	20 0d       	add	r18, r0
    12ac:	31 1d       	adc	r19, r1
    12ae:	11 24       	eor	r1, r1
    12b0:	3d 83       	std	Y+5, r19	; 0x05
    12b2:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    12b4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    12b6:	5b 83       	std	Y+3, r21	; 0x03
    12b8:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	01 97       	sbiw	r24, 0x01	; 1
    12be:	78 9f       	mul	r23, r24
    12c0:	90 01       	movw	r18, r0
    12c2:	79 9f       	mul	r23, r25
    12c4:	30 0d       	add	r19, r0
    12c6:	11 24       	eor	r1, r1
    12c8:	ca 01       	movw	r24, r20
    12ca:	82 0f       	add	r24, r18
    12cc:	93 1f       	adc	r25, r19
    12ce:	9f 83       	std	Y+7, r25	; 0x07
    12d0:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    12d2:	8f ef       	ldi	r24, 0xFF	; 255
    12d4:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    12d6:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    12d8:	61 11       	cpse	r22, r1
    12da:	0c c0       	rjmp	.+24     	; 0x12f4 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12dc:	88 85       	ldd	r24, Y+8	; 0x08
    12de:	88 23       	and	r24, r24
    12e0:	89 f0       	breq	.+34     	; 0x1304 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12e2:	ce 01       	movw	r24, r28
    12e4:	08 96       	adiw	r24, 0x08	; 8
    12e6:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    12ea:	88 23       	and	r24, r24
    12ec:	59 f0       	breq	.+22     	; 0x1304 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    12ee:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    12f2:	08 c0       	rjmp	.+16     	; 0x1304 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    12f4:	ce 01       	movw	r24, r28
    12f6:	08 96       	adiw	r24, 0x08	; 8
    12f8:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    12fc:	ce 01       	movw	r24, r28
    12fe:	41 96       	adiw	r24, 0x11	; 17
    1300:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1304:	0f 90       	pop	r0
    1306:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	df 91       	pop	r29
    130c:	cf 91       	pop	r28
    130e:	08 95       	ret

00001310 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1310:	0f 93       	push	r16
    1312:	1f 93       	push	r17
    1314:	cf 93       	push	r28
    1316:	df 93       	push	r29
    1318:	08 2f       	mov	r16, r24
    131a:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    131c:	66 23       	and	r22, r22
    131e:	21 f0       	breq	.+8      	; 0x1328 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1320:	86 9f       	mul	r24, r22
    1322:	c0 01       	movw	r24, r0
    1324:	11 24       	eor	r1, r1
    1326:	02 c0       	rjmp	.+4      	; 0x132c <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1328:	80 e0       	ldi	r24, 0x00	; 0
    132a:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    132c:	4f 96       	adiw	r24, 0x1f	; 31
    132e:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <pvPortMalloc>
    1332:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1334:	00 97       	sbiw	r24, 0x00	; 0
    1336:	71 f0       	breq	.+28     	; 0x1354 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1338:	11 11       	cpse	r17, r1
    133a:	03 c0       	rjmp	.+6      	; 0x1342 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    133c:	99 83       	std	Y+1, r25	; 0x01
    133e:	88 83       	st	Y, r24
    1340:	03 c0       	rjmp	.+6      	; 0x1348 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1342:	4f 96       	adiw	r24, 0x1f	; 31
    1344:	99 83       	std	Y+1, r25	; 0x01
    1346:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1348:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    134a:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    134c:	61 e0       	ldi	r22, 0x01	; 1
    134e:	ce 01       	movw	r24, r28
    1350:	0e 94 49 09 	call	0x1292	; 0x1292 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    1354:	ce 01       	movw	r24, r28
    1356:	df 91       	pop	r29
    1358:	cf 91       	pop	r28
    135a:	1f 91       	pop	r17
    135c:	0f 91       	pop	r16
    135e:	08 95       	ret

00001360 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1360:	af 92       	push	r10
    1362:	bf 92       	push	r11
    1364:	cf 92       	push	r12
    1366:	df 92       	push	r13
    1368:	ff 92       	push	r15
    136a:	0f 93       	push	r16
    136c:	1f 93       	push	r17
    136e:	cf 93       	push	r28
    1370:	df 93       	push	r29
    1372:	00 d0       	rcall	.+0      	; 0x1374 <xQueueGenericSend+0x14>
    1374:	00 d0       	rcall	.+0      	; 0x1376 <xQueueGenericSend+0x16>
    1376:	1f 92       	push	r1
    1378:	cd b7       	in	r28, 0x3d	; 61
    137a:	de b7       	in	r29, 0x3e	; 62
    137c:	8c 01       	movw	r16, r24
    137e:	6b 01       	movw	r12, r22
    1380:	5d 83       	std	Y+5, r21	; 0x05
    1382:	4c 83       	std	Y+4, r20	; 0x04
    1384:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1386:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1388:	58 01       	movw	r10, r16
    138a:	98 e0       	ldi	r25, 0x08	; 8
    138c:	a9 0e       	add	r10, r25
    138e:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1396:	f8 01       	movw	r30, r16
    1398:	22 8d       	ldd	r18, Z+26	; 0x1a
    139a:	93 8d       	ldd	r25, Z+27	; 0x1b
    139c:	29 17       	cp	r18, r25
    139e:	18 f0       	brcs	.+6      	; 0x13a6 <xQueueGenericSend+0x46>
    13a0:	f2 e0       	ldi	r31, 0x02	; 2
    13a2:	ff 12       	cpse	r15, r31
    13a4:	14 c0       	rjmp	.+40     	; 0x13ce <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13a6:	4f 2d       	mov	r20, r15
    13a8:	b6 01       	movw	r22, r12
    13aa:	c8 01       	movw	r24, r16
    13ac:	0e 94 a9 08 	call	0x1152	; 0x1152 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13b0:	f8 01       	movw	r30, r16
    13b2:	91 89       	ldd	r25, Z+17	; 0x11
    13b4:	99 23       	and	r25, r25
    13b6:	21 f0       	breq	.+8      	; 0x13c0 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13b8:	c8 01       	movw	r24, r16
    13ba:	41 96       	adiw	r24, 0x11	; 17
    13bc:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    13c0:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    13c2:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    13c6:	0f 90       	pop	r0
    13c8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13ca:	81 e0       	ldi	r24, 0x01	; 1
    13cc:	50 c0       	rjmp	.+160    	; 0x146e <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    13ce:	2c 81       	ldd	r18, Y+4	; 0x04
    13d0:	3d 81       	ldd	r19, Y+5	; 0x05
    13d2:	23 2b       	or	r18, r19
    13d4:	19 f4       	brne	.+6      	; 0x13dc <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13d6:	0f 90       	pop	r0
    13d8:	0f be       	out	0x3f, r0	; 63
    13da:	48 c0       	rjmp	.+144    	; 0x146c <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    13dc:	81 11       	cpse	r24, r1
    13de:	04 c0       	rjmp	.+8      	; 0x13e8 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    13e0:	ce 01       	movw	r24, r28
    13e2:	01 96       	adiw	r24, 0x01	; 1
    13e4:	0e 94 23 06 	call	0xc46	; 0xc46 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    13e8:	0f 90       	pop	r0
    13ea:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    13ec:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	0f 92       	push	r0
    13f6:	f8 01       	movw	r30, r16
    13f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    13fa:	8f 3f       	cpi	r24, 0xFF	; 255
    13fc:	09 f4       	brne	.+2      	; 0x1400 <xQueueGenericSend+0xa0>
    13fe:	15 8e       	std	Z+29, r1	; 0x1d
    1400:	f8 01       	movw	r30, r16
    1402:	86 8d       	ldd	r24, Z+30	; 0x1e
    1404:	8f 3f       	cpi	r24, 0xFF	; 255
    1406:	09 f4       	brne	.+2      	; 0x140a <xQueueGenericSend+0xaa>
    1408:	16 8e       	std	Z+30, r1	; 0x1e
    140a:	0f 90       	pop	r0
    140c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    140e:	be 01       	movw	r22, r28
    1410:	6c 5f       	subi	r22, 0xFC	; 252
    1412:	7f 4f       	sbci	r23, 0xFF	; 255
    1414:	ce 01       	movw	r24, r28
    1416:	01 96       	adiw	r24, 0x01	; 1
    1418:	0e 94 2e 06 	call	0xc5c	; 0xc5c <xTaskCheckForTimeOut>
    141c:	81 11       	cpse	r24, r1
    141e:	21 c0       	rjmp	.+66     	; 0x1462 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1420:	0f b6       	in	r0, 0x3f	; 63
    1422:	f8 94       	cli
    1424:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1426:	f8 01       	movw	r30, r16
    1428:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    142a:	0f 90       	pop	r0
    142c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    142e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1430:	98 13       	cpse	r25, r24
    1432:	11 c0       	rjmp	.+34     	; 0x1456 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1434:	6c 81       	ldd	r22, Y+4	; 0x04
    1436:	7d 81       	ldd	r23, Y+5	; 0x05
    1438:	c5 01       	movw	r24, r10
    143a:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    143e:	c8 01       	movw	r24, r16
    1440:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1444:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1448:	88 23       	and	r24, r24
    144a:	11 f0       	breq	.+4      	; 0x1450 <xQueueGenericSend+0xf0>
    144c:	81 e0       	ldi	r24, 0x01	; 1
    144e:	a0 cf       	rjmp	.-192    	; 0x1390 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1450:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    1454:	fb cf       	rjmp	.-10     	; 0x144c <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1456:	c8 01       	movw	r24, r16
    1458:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    145c:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1460:	f5 cf       	rjmp	.-22     	; 0x144c <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1462:	c8 01       	movw	r24, r16
    1464:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1468:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    146c:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    146e:	0f 90       	pop	r0
    1470:	0f 90       	pop	r0
    1472:	0f 90       	pop	r0
    1474:	0f 90       	pop	r0
    1476:	0f 90       	pop	r0
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	ff 90       	pop	r15
    1482:	df 90       	pop	r13
    1484:	cf 90       	pop	r12
    1486:	bf 90       	pop	r11
    1488:	af 90       	pop	r10
    148a:	08 95       	ret

0000148c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    148c:	ef 92       	push	r14
    148e:	ff 92       	push	r15
    1490:	1f 93       	push	r17
    1492:	cf 93       	push	r28
    1494:	df 93       	push	r29
    1496:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1498:	9a 8d       	ldd	r25, Y+26	; 0x1a
    149a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    149c:	98 17       	cp	r25, r24
    149e:	10 f0       	brcs	.+4      	; 0x14a4 <xQueueGenericSendFromISR+0x18>
    14a0:	22 30       	cpi	r18, 0x02	; 2
    14a2:	e1 f4       	brne	.+56     	; 0x14dc <xQueueGenericSendFromISR+0x50>
    14a4:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    14a6:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    14a8:	42 2f       	mov	r20, r18
    14aa:	ce 01       	movw	r24, r28
    14ac:	0e 94 a9 08 	call	0x1152	; 0x1152 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14b0:	1f 3f       	cpi	r17, 0xFF	; 255
    14b2:	81 f4       	brne	.+32     	; 0x14d4 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14b4:	89 89       	ldd	r24, Y+17	; 0x11
    14b6:	88 23       	and	r24, r24
    14b8:	79 f0       	breq	.+30     	; 0x14d8 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ba:	ce 01       	movw	r24, r28
    14bc:	41 96       	adiw	r24, 0x11	; 17
    14be:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    14c2:	88 23       	and	r24, r24
    14c4:	49 f0       	breq	.+18     	; 0x14d8 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14c6:	e1 14       	cp	r14, r1
    14c8:	f1 04       	cpc	r15, r1
    14ca:	31 f0       	breq	.+12     	; 0x14d8 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	f7 01       	movw	r30, r14
    14d0:	80 83       	st	Z, r24
    14d2:	05 c0       	rjmp	.+10     	; 0x14de <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    14d4:	1f 5f       	subi	r17, 0xFF	; 255
    14d6:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	01 c0       	rjmp	.+2      	; 0x14de <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14dc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	ff 90       	pop	r15
    14e6:	ef 90       	pop	r14
    14e8:	08 95       	ret

000014ea <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14f0:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    14f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    14f4:	98 17       	cp	r25, r24
    14f6:	c0 f4       	brcc	.+48     	; 0x1528 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    14f8:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    14fa:	9f 5f       	subi	r25, 0xFF	; 255
    14fc:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1500:	79 f4       	brne	.+30     	; 0x1520 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1502:	81 89       	ldd	r24, Z+17	; 0x11
    1504:	88 23       	and	r24, r24
    1506:	71 f0       	breq	.+28     	; 0x1524 <xQueueGiveFromISR+0x3a>
    1508:	eb 01       	movw	r28, r22
    150a:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    150c:	41 96       	adiw	r24, 0x11	; 17
    150e:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    1512:	88 23       	and	r24, r24
    1514:	39 f0       	breq	.+14     	; 0x1524 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1516:	20 97       	sbiw	r28, 0x00	; 0
    1518:	29 f0       	breq	.+10     	; 0x1524 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	88 83       	st	Y, r24
    151e:	05 c0       	rjmp	.+10     	; 0x152a <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1520:	8f 5f       	subi	r24, 0xFF	; 255
    1522:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1524:	81 e0       	ldi	r24, 0x01	; 1
    1526:	01 c0       	rjmp	.+2      	; 0x152a <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1528:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    152a:	df 91       	pop	r29
    152c:	cf 91       	pop	r28
    152e:	08 95       	ret

00001530 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1530:	af 92       	push	r10
    1532:	bf 92       	push	r11
    1534:	cf 92       	push	r12
    1536:	df 92       	push	r13
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	cf 93       	push	r28
    1540:	df 93       	push	r29
    1542:	00 d0       	rcall	.+0      	; 0x1544 <xQueueReceive+0x14>
    1544:	00 d0       	rcall	.+0      	; 0x1546 <xQueueReceive+0x16>
    1546:	1f 92       	push	r1
    1548:	cd b7       	in	r28, 0x3d	; 61
    154a:	de b7       	in	r29, 0x3e	; 62
    154c:	8c 01       	movw	r16, r24
    154e:	6b 01       	movw	r12, r22
    1550:	5d 83       	std	Y+5, r21	; 0x05
    1552:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1554:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1556:	58 01       	movw	r10, r16
    1558:	91 e1       	ldi	r25, 0x11	; 17
    155a:	a9 0e       	add	r10, r25
    155c:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    155e:	0f b6       	in	r0, 0x3f	; 63
    1560:	f8 94       	cli
    1562:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1564:	f8 01       	movw	r30, r16
    1566:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1568:	ff 20       	and	r15, r15
    156a:	a9 f0       	breq	.+42     	; 0x1596 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    156c:	b6 01       	movw	r22, r12
    156e:	c8 01       	movw	r24, r16
    1570:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1574:	fa 94       	dec	r15
    1576:	f8 01       	movw	r30, r16
    1578:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    157a:	80 85       	ldd	r24, Z+8	; 0x08
    157c:	88 23       	and	r24, r24
    157e:	39 f0       	breq	.+14     	; 0x158e <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1580:	c8 01       	movw	r24, r16
    1582:	08 96       	adiw	r24, 0x08	; 8
    1584:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    1588:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    158a:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    158e:	0f 90       	pop	r0
    1590:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	50 c0       	rjmp	.+160    	; 0x1636 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1596:	2c 81       	ldd	r18, Y+4	; 0x04
    1598:	3d 81       	ldd	r19, Y+5	; 0x05
    159a:	23 2b       	or	r18, r19
    159c:	19 f4       	brne	.+6      	; 0x15a4 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	48 c0       	rjmp	.+144    	; 0x1634 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    15a4:	81 11       	cpse	r24, r1
    15a6:	04 c0       	rjmp	.+8      	; 0x15b0 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    15a8:	ce 01       	movw	r24, r28
    15aa:	01 96       	adiw	r24, 0x01	; 1
    15ac:	0e 94 23 06 	call	0xc46	; 0xc46 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15b0:	0f 90       	pop	r0
    15b2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15b4:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	0f 92       	push	r0
    15be:	f8 01       	movw	r30, r16
    15c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    15c2:	8f 3f       	cpi	r24, 0xFF	; 255
    15c4:	09 f4       	brne	.+2      	; 0x15c8 <xQueueReceive+0x98>
    15c6:	15 8e       	std	Z+29, r1	; 0x1d
    15c8:	f8 01       	movw	r30, r16
    15ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    15cc:	8f 3f       	cpi	r24, 0xFF	; 255
    15ce:	09 f4       	brne	.+2      	; 0x15d2 <xQueueReceive+0xa2>
    15d0:	16 8e       	std	Z+30, r1	; 0x1e
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d6:	be 01       	movw	r22, r28
    15d8:	6c 5f       	subi	r22, 0xFC	; 252
    15da:	7f 4f       	sbci	r23, 0xFF	; 255
    15dc:	ce 01       	movw	r24, r28
    15de:	01 96       	adiw	r24, 0x01	; 1
    15e0:	0e 94 2e 06 	call	0xc5c	; 0xc5c <xTaskCheckForTimeOut>
    15e4:	81 11       	cpse	r24, r1
    15e6:	1c c0       	rjmp	.+56     	; 0x1620 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15e8:	c8 01       	movw	r24, r16
    15ea:	0e 94 9e 08 	call	0x113c	; 0x113c <prvIsQueueEmpty>
    15ee:	88 23       	and	r24, r24
    15f0:	89 f0       	breq	.+34     	; 0x1614 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15f2:	6c 81       	ldd	r22, Y+4	; 0x04
    15f4:	7d 81       	ldd	r23, Y+5	; 0x05
    15f6:	c5 01       	movw	r24, r10
    15f8:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15fc:	c8 01       	movw	r24, r16
    15fe:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1602:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1606:	88 23       	and	r24, r24
    1608:	11 f0       	breq	.+4      	; 0x160e <xQueueReceive+0xde>
    160a:	81 e0       	ldi	r24, 0x01	; 1
    160c:	a8 cf       	rjmp	.-176    	; 0x155e <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    160e:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    1612:	fb cf       	rjmp	.-10     	; 0x160a <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1614:	c8 01       	movw	r24, r16
    1616:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    161a:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    161e:	f5 cf       	rjmp	.-22     	; 0x160a <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1620:	c8 01       	movw	r24, r16
    1622:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1626:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    162a:	c8 01       	movw	r24, r16
    162c:	0e 94 9e 08 	call	0x113c	; 0x113c <prvIsQueueEmpty>
    1630:	88 23       	and	r24, r24
    1632:	59 f3       	breq	.-42     	; 0x160a <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1634:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1636:	0f 90       	pop	r0
    1638:	0f 90       	pop	r0
    163a:	0f 90       	pop	r0
    163c:	0f 90       	pop	r0
    163e:	0f 90       	pop	r0
    1640:	df 91       	pop	r29
    1642:	cf 91       	pop	r28
    1644:	1f 91       	pop	r17
    1646:	0f 91       	pop	r16
    1648:	ff 90       	pop	r15
    164a:	df 90       	pop	r13
    164c:	cf 90       	pop	r12
    164e:	bf 90       	pop	r11
    1650:	af 90       	pop	r10
    1652:	08 95       	ret

00001654 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1654:	ef 92       	push	r14
    1656:	ff 92       	push	r15
    1658:	0f 93       	push	r16
    165a:	1f 93       	push	r17
    165c:	cf 93       	push	r28
    165e:	df 93       	push	r29
    1660:	00 d0       	rcall	.+0      	; 0x1662 <xQueueSemaphoreTake+0xe>
    1662:	00 d0       	rcall	.+0      	; 0x1664 <xQueueSemaphoreTake+0x10>
    1664:	1f 92       	push	r1
    1666:	cd b7       	in	r28, 0x3d	; 61
    1668:	de b7       	in	r29, 0x3e	; 62
    166a:	8c 01       	movw	r16, r24
    166c:	7d 83       	std	Y+5, r23	; 0x05
    166e:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1670:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1672:	78 01       	movw	r14, r16
    1674:	81 e1       	ldi	r24, 0x11	; 17
    1676:	e8 0e       	add	r14, r24
    1678:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1680:	f8 01       	movw	r30, r16
    1682:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1684:	88 23       	and	r24, r24
    1686:	81 f0       	breq	.+32     	; 0x16a8 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1688:	81 50       	subi	r24, 0x01	; 1
    168a:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    168c:	80 85       	ldd	r24, Z+8	; 0x08
    168e:	88 23       	and	r24, r24
    1690:	39 f0       	breq	.+14     	; 0x16a0 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1692:	c8 01       	movw	r24, r16
    1694:	08 96       	adiw	r24, 0x08	; 8
    1696:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    169a:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    169c:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	50 c0       	rjmp	.+160    	; 0x1748 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16a8:	2c 81       	ldd	r18, Y+4	; 0x04
    16aa:	3d 81       	ldd	r19, Y+5	; 0x05
    16ac:	23 2b       	or	r18, r19
    16ae:	19 f4       	brne	.+6      	; 0x16b6 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63
    16b4:	48 c0       	rjmp	.+144    	; 0x1746 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    16b6:	91 11       	cpse	r25, r1
    16b8:	04 c0       	rjmp	.+8      	; 0x16c2 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16ba:	ce 01       	movw	r24, r28
    16bc:	01 96       	adiw	r24, 0x01	; 1
    16be:	0e 94 23 06 	call	0xc46	; 0xc46 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16c2:	0f 90       	pop	r0
    16c4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    16c6:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	0f 92       	push	r0
    16d0:	f8 01       	movw	r30, r16
    16d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    16d4:	8f 3f       	cpi	r24, 0xFF	; 255
    16d6:	09 f4       	brne	.+2      	; 0x16da <xQueueSemaphoreTake+0x86>
    16d8:	15 8e       	std	Z+29, r1	; 0x1d
    16da:	f8 01       	movw	r30, r16
    16dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    16de:	8f 3f       	cpi	r24, 0xFF	; 255
    16e0:	09 f4       	brne	.+2      	; 0x16e4 <xQueueSemaphoreTake+0x90>
    16e2:	16 8e       	std	Z+30, r1	; 0x1e
    16e4:	0f 90       	pop	r0
    16e6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16e8:	be 01       	movw	r22, r28
    16ea:	6c 5f       	subi	r22, 0xFC	; 252
    16ec:	7f 4f       	sbci	r23, 0xFF	; 255
    16ee:	ce 01       	movw	r24, r28
    16f0:	01 96       	adiw	r24, 0x01	; 1
    16f2:	0e 94 2e 06 	call	0xc5c	; 0xc5c <xTaskCheckForTimeOut>
    16f6:	81 11       	cpse	r24, r1
    16f8:	1c c0       	rjmp	.+56     	; 0x1732 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16fa:	c8 01       	movw	r24, r16
    16fc:	0e 94 9e 08 	call	0x113c	; 0x113c <prvIsQueueEmpty>
    1700:	88 23       	and	r24, r24
    1702:	89 f0       	breq	.+34     	; 0x1726 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1704:	6c 81       	ldd	r22, Y+4	; 0x04
    1706:	7d 81       	ldd	r23, Y+5	; 0x05
    1708:	c7 01       	movw	r24, r14
    170a:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    170e:	c8 01       	movw	r24, r16
    1710:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1714:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1718:	88 23       	and	r24, r24
    171a:	11 f0       	breq	.+4      	; 0x1720 <xQueueSemaphoreTake+0xcc>
    171c:	91 e0       	ldi	r25, 0x01	; 1
    171e:	ad cf       	rjmp	.-166    	; 0x167a <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1720:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    1724:	fb cf       	rjmp	.-10     	; 0x171c <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1726:	c8 01       	movw	r24, r16
    1728:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    172c:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1730:	f5 cf       	rjmp	.-22     	; 0x171c <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1732:	c8 01       	movw	r24, r16
    1734:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1738:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    173c:	c8 01       	movw	r24, r16
    173e:	0e 94 9e 08 	call	0x113c	; 0x113c <prvIsQueueEmpty>
    1742:	88 23       	and	r24, r24
    1744:	59 f3       	breq	.-42     	; 0x171c <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1746:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1748:	0f 90       	pop	r0
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	0f 90       	pop	r0
    1750:	0f 90       	pop	r0
    1752:	df 91       	pop	r29
    1754:	cf 91       	pop	r28
    1756:	1f 91       	pop	r17
    1758:	0f 91       	pop	r16
    175a:	ff 90       	pop	r15
    175c:	ef 90       	pop	r14
    175e:	08 95       	ret

00001760 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1760:	cf 92       	push	r12
    1762:	df 92       	push	r13
    1764:	ef 92       	push	r14
    1766:	ff 92       	push	r15
    1768:	0f 93       	push	r16
    176a:	1f 93       	push	r17
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	00 d0       	rcall	.+0      	; 0x1772 <xQueuePeek+0x12>
    1772:	00 d0       	rcall	.+0      	; 0x1774 <xQueuePeek+0x14>
    1774:	1f 92       	push	r1
    1776:	cd b7       	in	r28, 0x3d	; 61
    1778:	de b7       	in	r29, 0x3e	; 62
    177a:	8c 01       	movw	r16, r24
    177c:	7b 01       	movw	r14, r22
    177e:	5d 83       	std	Y+5, r21	; 0x05
    1780:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1782:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1784:	68 01       	movw	r12, r16
    1786:	91 e1       	ldi	r25, 0x11	; 17
    1788:	c9 0e       	add	r12, r25
    178a:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1792:	f8 01       	movw	r30, r16
    1794:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1796:	99 23       	and	r25, r25
    1798:	b9 f0       	breq	.+46     	; 0x17c8 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    179a:	c6 80       	ldd	r12, Z+6	; 0x06
    179c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    179e:	b7 01       	movw	r22, r14
    17a0:	c8 01       	movw	r24, r16
    17a2:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    17a6:	f8 01       	movw	r30, r16
    17a8:	d7 82       	std	Z+7, r13	; 0x07
    17aa:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ac:	81 89       	ldd	r24, Z+17	; 0x11
    17ae:	88 23       	and	r24, r24
    17b0:	39 f0       	breq	.+14     	; 0x17c0 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17b2:	c8 01       	movw	r24, r16
    17b4:	41 96       	adiw	r24, 0x11	; 17
    17b6:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    17ba:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    17bc:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    17c0:	0f 90       	pop	r0
    17c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	50 c0       	rjmp	.+160    	; 0x1868 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17c8:	2c 81       	ldd	r18, Y+4	; 0x04
    17ca:	3d 81       	ldd	r19, Y+5	; 0x05
    17cc:	23 2b       	or	r18, r19
    17ce:	19 f4       	brne	.+6      	; 0x17d6 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17d0:	0f 90       	pop	r0
    17d2:	0f be       	out	0x3f, r0	; 63
    17d4:	48 c0       	rjmp	.+144    	; 0x1866 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    17d6:	81 11       	cpse	r24, r1
    17d8:	04 c0       	rjmp	.+8      	; 0x17e2 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    17da:	ce 01       	movw	r24, r28
    17dc:	01 96       	adiw	r24, 0x01	; 1
    17de:	0e 94 23 06 	call	0xc46	; 0xc46 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17e2:	0f 90       	pop	r0
    17e4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17e6:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17ea:	0f b6       	in	r0, 0x3f	; 63
    17ec:	f8 94       	cli
    17ee:	0f 92       	push	r0
    17f0:	f8 01       	movw	r30, r16
    17f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    17f4:	8f 3f       	cpi	r24, 0xFF	; 255
    17f6:	09 f4       	brne	.+2      	; 0x17fa <xQueuePeek+0x9a>
    17f8:	15 8e       	std	Z+29, r1	; 0x1d
    17fa:	f8 01       	movw	r30, r16
    17fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    17fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1800:	09 f4       	brne	.+2      	; 0x1804 <xQueuePeek+0xa4>
    1802:	16 8e       	std	Z+30, r1	; 0x1e
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1808:	be 01       	movw	r22, r28
    180a:	6c 5f       	subi	r22, 0xFC	; 252
    180c:	7f 4f       	sbci	r23, 0xFF	; 255
    180e:	ce 01       	movw	r24, r28
    1810:	01 96       	adiw	r24, 0x01	; 1
    1812:	0e 94 2e 06 	call	0xc5c	; 0xc5c <xTaskCheckForTimeOut>
    1816:	81 11       	cpse	r24, r1
    1818:	1c c0       	rjmp	.+56     	; 0x1852 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    181a:	c8 01       	movw	r24, r16
    181c:	0e 94 9e 08 	call	0x113c	; 0x113c <prvIsQueueEmpty>
    1820:	88 23       	and	r24, r24
    1822:	89 f0       	breq	.+34     	; 0x1846 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1824:	6c 81       	ldd	r22, Y+4	; 0x04
    1826:	7d 81       	ldd	r23, Y+5	; 0x05
    1828:	c6 01       	movw	r24, r12
    182a:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    182e:	c8 01       	movw	r24, r16
    1830:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1834:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1838:	88 23       	and	r24, r24
    183a:	11 f0       	breq	.+4      	; 0x1840 <xQueuePeek+0xe0>
    183c:	81 e0       	ldi	r24, 0x01	; 1
    183e:	a6 cf       	rjmp	.-180    	; 0x178c <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1840:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    1844:	fb cf       	rjmp	.-10     	; 0x183c <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1846:	c8 01       	movw	r24, r16
    1848:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    184c:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
    1850:	f5 cf       	rjmp	.-22     	; 0x183c <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1852:	c8 01       	movw	r24, r16
    1854:	0e 94 0b 09 	call	0x1216	; 0x1216 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1858:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    185c:	c8 01       	movw	r24, r16
    185e:	0e 94 9e 08 	call	0x113c	; 0x113c <prvIsQueueEmpty>
    1862:	88 23       	and	r24, r24
    1864:	59 f3       	breq	.-42     	; 0x183c <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1866:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1868:	0f 90       	pop	r0
    186a:	0f 90       	pop	r0
    186c:	0f 90       	pop	r0
    186e:	0f 90       	pop	r0
    1870:	0f 90       	pop	r0
    1872:	df 91       	pop	r29
    1874:	cf 91       	pop	r28
    1876:	1f 91       	pop	r17
    1878:	0f 91       	pop	r16
    187a:	ff 90       	pop	r15
    187c:	ef 90       	pop	r14
    187e:	df 90       	pop	r13
    1880:	cf 90       	pop	r12
    1882:	08 95       	ret

00001884 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1884:	ef 92       	push	r14
    1886:	ff 92       	push	r15
    1888:	0f 93       	push	r16
    188a:	1f 93       	push	r17
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1890:	fc 01       	movw	r30, r24
    1892:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1894:	00 23       	and	r16, r16
    1896:	e9 f0       	breq	.+58     	; 0x18d2 <xQueueReceiveFromISR+0x4e>
    1898:	7a 01       	movw	r14, r20
    189a:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    189c:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    189e:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    18a2:	01 50       	subi	r16, 0x01	; 1
    18a4:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    18a6:	1f 3f       	cpi	r17, 0xFF	; 255
    18a8:	81 f4       	brne	.+32     	; 0x18ca <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18aa:	88 85       	ldd	r24, Y+8	; 0x08
    18ac:	88 23       	and	r24, r24
    18ae:	79 f0       	breq	.+30     	; 0x18ce <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18b0:	ce 01       	movw	r24, r28
    18b2:	08 96       	adiw	r24, 0x08	; 8
    18b4:	0e 94 a1 05 	call	0xb42	; 0xb42 <xTaskRemoveFromEventList>
    18b8:	88 23       	and	r24, r24
    18ba:	49 f0       	breq	.+18     	; 0x18ce <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    18bc:	e1 14       	cp	r14, r1
    18be:	f1 04       	cpc	r15, r1
    18c0:	31 f0       	breq	.+12     	; 0x18ce <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	f7 01       	movw	r30, r14
    18c6:	80 83       	st	Z, r24
    18c8:	05 c0       	rjmp	.+10     	; 0x18d4 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    18ca:	1f 5f       	subi	r17, 0xFF	; 255
    18cc:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	01 c0       	rjmp	.+2      	; 0x18d4 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    18d2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18d4:	df 91       	pop	r29
    18d6:	cf 91       	pop	r28
    18d8:	1f 91       	pop	r17
    18da:	0f 91       	pop	r16
    18dc:	ff 90       	pop	r15
    18de:	ef 90       	pop	r14
    18e0:	08 95       	ret

000018e2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    18e2:	0f 93       	push	r16
    18e4:	1f 93       	push	r17
    18e6:	cf 93       	push	r28
    18e8:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    18ea:	fc 01       	movw	r30, r24
    18ec:	22 8d       	ldd	r18, Z+26	; 0x1a
    18ee:	22 23       	and	r18, r18
    18f0:	49 f0       	breq	.+18     	; 0x1904 <xQueuePeekFromISR+0x22>
    18f2:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    18f4:	06 81       	ldd	r16, Z+6	; 0x06
    18f6:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    18f8:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18fc:	1f 83       	std	Y+7, r17	; 0x07
    18fe:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	01 c0       	rjmp	.+2      	; 0x1906 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1904:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1906:	df 91       	pop	r29
    1908:	cf 91       	pop	r28
    190a:	1f 91       	pop	r17
    190c:	0f 91       	pop	r16
    190e:	08 95       	ret

00001910 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1916:	fc 01       	movw	r30, r24
    1918:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    191a:	0f 90       	pop	r0
    191c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    191e:	08 95       	ret

00001920 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1920:	0f b6       	in	r0, 0x3f	; 63
    1922:	f8 94       	cli
    1924:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1926:	fc 01       	movw	r30, r24
    1928:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    192a:	0f 90       	pop	r0
    192c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    192e:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1930:	82 1b       	sub	r24, r18
    1932:	08 95       	ret

00001934 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1934:	fc 01       	movw	r30, r24
    1936:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1938:	08 95       	ret

0000193a <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    193a:	0c 94 11 10 	jmp	0x2022	; 0x2022 <vPortFree>

0000193e <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    193e:	fc 01       	movw	r30, r24
    1940:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	91 11       	cpse	r25, r1
    1946:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1948:	08 95       	ret

0000194a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    194a:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    194c:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    194e:	81 e0       	ldi	r24, 0x01	; 1
    1950:	23 8d       	ldd	r18, Z+27	; 0x1b
    1952:	29 13       	cpse	r18, r25
    1954:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1956:	08 95       	ret

00001958 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1958:	cf 93       	push	r28
    195a:	df 93       	push	r29
    195c:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    195e:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1966:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1968:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    196a:	0f 90       	pop	r0
    196c:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    196e:	89 13       	cpse	r24, r25
    1970:	0f c0       	rjmp	.+30     	; 0x1990 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1972:	41 15       	cp	r20, r1
    1974:	51 05       	cpc	r21, r1
    1976:	49 f0       	breq	.+18     	; 0x198a <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1978:	be 01       	movw	r22, r28
    197a:	68 5f       	subi	r22, 0xF8	; 248
    197c:	7f 4f       	sbci	r23, 0xFF	; 255
    197e:	ca 01       	movw	r24, r20
    1980:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1984:	78 94       	sei
					return errQUEUE_BLOCKED;
    1986:	8c ef       	ldi	r24, 0xFC	; 252
    1988:	1b c0       	rjmp	.+54     	; 0x19c0 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    198a:	78 94       	sei
					return errQUEUE_FULL;
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	18 c0       	rjmp	.+48     	; 0x19c0 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1990:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1992:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1994:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1996:	89 17       	cp	r24, r25
    1998:	88 f4       	brcc	.+34     	; 0x19bc <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    199a:	40 e0       	ldi	r20, 0x00	; 0
    199c:	ce 01       	movw	r24, r28
    199e:	0e 94 a9 08 	call	0x1152	; 0x1152 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19a2:	89 89       	ldd	r24, Y+17	; 0x11
    19a4:	81 11       	cpse	r24, r1
    19a6:	02 c0       	rjmp	.+4      	; 0x19ac <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	09 c0       	rjmp	.+18     	; 0x19be <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19ac:	ce 01       	movw	r24, r28
    19ae:	41 96       	adiw	r24, 0x11	; 17
    19b0:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <xCoRoutineRemoveFromEventList>
    19b4:	88 23       	and	r24, r24
    19b6:	c1 f3       	breq	.-16     	; 0x19a8 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    19b8:	8b ef       	ldi	r24, 0xFB	; 251
    19ba:	01 c0       	rjmp	.+2      	; 0x19be <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    19bc:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    19be:	78 94       	sei

		return xReturn;
	}
    19c0:	df 91       	pop	r29
    19c2:	cf 91       	pop	r28
    19c4:	08 95       	ret

000019c6 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    19c6:	cf 93       	push	r28
    19c8:	df 93       	push	r29
    19ca:	ec 01       	movw	r28, r24
    19cc:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    19ce:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19d2:	81 11       	cpse	r24, r1
    19d4:	0f c0       	rjmp	.+30     	; 0x19f4 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    19d6:	41 15       	cp	r20, r1
    19d8:	51 05       	cpc	r21, r1
    19da:	49 f0       	breq	.+18     	; 0x19ee <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    19dc:	be 01       	movw	r22, r28
    19de:	6f 5e       	subi	r22, 0xEF	; 239
    19e0:	7f 4f       	sbci	r23, 0xFF	; 255
    19e2:	ca 01       	movw	r24, r20
    19e4:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    19e8:	78 94       	sei
					return errQUEUE_BLOCKED;
    19ea:	8c ef       	ldi	r24, 0xFC	; 252
    19ec:	30 c0       	rjmp	.+96     	; 0x1a4e <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    19ee:	78 94       	sei
					return errQUEUE_FULL;
    19f0:	80 e0       	ldi	r24, 0x00	; 0
    19f2:	2d c0       	rjmp	.+90     	; 0x1a4e <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    19f4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    19f6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19fa:	88 23       	and	r24, r24
    19fc:	31 f1       	breq	.+76     	; 0x1a4a <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    19fe:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a00:	50 e0       	ldi	r21, 0x00	; 0
    1a02:	2e 81       	ldd	r18, Y+6	; 0x06
    1a04:	3f 81       	ldd	r19, Y+7	; 0x07
    1a06:	24 0f       	add	r18, r20
    1a08:	35 1f       	adc	r19, r21
    1a0a:	3f 83       	std	Y+7, r19	; 0x07
    1a0c:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1a0e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a10:	9d 81       	ldd	r25, Y+5	; 0x05
    1a12:	28 17       	cp	r18, r24
    1a14:	39 07       	cpc	r19, r25
    1a16:	20 f0       	brcs	.+8      	; 0x1a20 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1a18:	88 81       	ld	r24, Y
    1a1a:	99 81       	ldd	r25, Y+1	; 0x01
    1a1c:	9f 83       	std	Y+7, r25	; 0x07
    1a1e:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1a20:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a22:	91 50       	subi	r25, 0x01	; 1
    1a24:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a26:	6e 81       	ldd	r22, Y+6	; 0x06
    1a28:	7f 81       	ldd	r23, Y+7	; 0x07
    1a2a:	cf 01       	movw	r24, r30
    1a2c:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a30:	88 85       	ldd	r24, Y+8	; 0x08
    1a32:	81 11       	cpse	r24, r1
    1a34:	02 c0       	rjmp	.+4      	; 0x1a3a <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	09 c0       	rjmp	.+18     	; 0x1a4c <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a3a:	ce 01       	movw	r24, r28
    1a3c:	08 96       	adiw	r24, 0x08	; 8
    1a3e:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <xCoRoutineRemoveFromEventList>
    1a42:	88 23       	and	r24, r24
    1a44:	c1 f3       	breq	.-16     	; 0x1a36 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1a46:	8b ef       	ldi	r24, 0xFB	; 251
    1a48:	01 c0       	rjmp	.+2      	; 0x1a4c <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1a4a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a4c:	78 94       	sei

		return xReturn;
	}
    1a4e:	df 91       	pop	r29
    1a50:	cf 91       	pop	r28
    1a52:	08 95       	ret

00001a54 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	8c 01       	movw	r16, r24
    1a5c:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a5e:	fc 01       	movw	r30, r24
    1a60:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a62:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a64:	98 17       	cp	r25, r24
    1a66:	10 f0       	brcs	.+4      	; 0x1a6c <xQueueCRSendFromISR+0x18>
    1a68:	4c 2f       	mov	r20, r28
    1a6a:	12 c0       	rjmp	.+36     	; 0x1a90 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a6c:	40 e0       	ldi	r20, 0x00	; 0
    1a6e:	c8 01       	movw	r24, r16
    1a70:	0e 94 a9 08 	call	0x1152	; 0x1152 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1a74:	c1 11       	cpse	r28, r1
    1a76:	f8 cf       	rjmp	.-16     	; 0x1a68 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a78:	f8 01       	movw	r30, r16
    1a7a:	81 89       	ldd	r24, Z+17	; 0x11
    1a7c:	88 23       	and	r24, r24
    1a7e:	39 f0       	breq	.+14     	; 0x1a8e <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a80:	c8 01       	movw	r24, r16
    1a82:	41 96       	adiw	r24, 0x11	; 17
    1a84:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1a88:	41 e0       	ldi	r20, 0x01	; 1
    1a8a:	81 11       	cpse	r24, r1
    1a8c:	01 c0       	rjmp	.+2      	; 0x1a90 <xQueueCRSendFromISR+0x3c>
    1a8e:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1a90:	84 2f       	mov	r24, r20
    1a92:	cf 91       	pop	r28
    1a94:	1f 91       	pop	r17
    1a96:	0f 91       	pop	r16
    1a98:	08 95       	ret

00001a9a <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1a9a:	0f 93       	push	r16
    1a9c:	1f 93       	push	r17
    1a9e:	cf 93       	push	r28
    1aa0:	df 93       	push	r29
    1aa2:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aa4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aa6:	88 23       	and	r24, r24
    1aa8:	79 f1       	breq	.+94     	; 0x1b08 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1aaa:	24 8d       	ldd	r18, Z+28	; 0x1c
    1aac:	30 e0       	ldi	r19, 0x00	; 0
    1aae:	a6 81       	ldd	r26, Z+6	; 0x06
    1ab0:	b7 81       	ldd	r27, Z+7	; 0x07
    1ab2:	a2 0f       	add	r26, r18
    1ab4:	b3 1f       	adc	r27, r19
    1ab6:	b7 83       	std	Z+7, r27	; 0x07
    1ab8:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1aba:	84 81       	ldd	r24, Z+4	; 0x04
    1abc:	95 81       	ldd	r25, Z+5	; 0x05
    1abe:	a8 17       	cp	r26, r24
    1ac0:	b9 07       	cpc	r27, r25
    1ac2:	20 f0       	brcs	.+8      	; 0x1acc <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1ac4:	80 81       	ld	r24, Z
    1ac6:	91 81       	ldd	r25, Z+1	; 0x01
    1ac8:	97 83       	std	Z+7, r25	; 0x07
    1aca:	86 83       	std	Z+6, r24	; 0x06
    1acc:	8a 01       	movw	r16, r20
    1ace:	cb 01       	movw	r24, r22
    1ad0:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1ad2:	42 8d       	ldd	r20, Z+26	; 0x1a
    1ad4:	41 50       	subi	r20, 0x01	; 1
    1ad6:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1ad8:	66 81       	ldd	r22, Z+6	; 0x06
    1ada:	77 81       	ldd	r23, Z+7	; 0x07
    1adc:	a9 01       	movw	r20, r18
    1ade:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1ae2:	f8 01       	movw	r30, r16
    1ae4:	80 81       	ld	r24, Z
    1ae6:	88 23       	and	r24, r24
    1ae8:	11 f0       	breq	.+4      	; 0x1aee <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1aea:	81 e0       	ldi	r24, 0x01	; 1
    1aec:	0e c0       	rjmp	.+28     	; 0x1b0a <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1aee:	88 85       	ldd	r24, Y+8	; 0x08
    1af0:	88 23       	and	r24, r24
    1af2:	d9 f3       	breq	.-10     	; 0x1aea <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1af4:	ce 01       	movw	r24, r28
    1af6:	08 96       	adiw	r24, 0x08	; 8
    1af8:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <xCoRoutineRemoveFromEventList>
    1afc:	88 23       	and	r24, r24
    1afe:	a9 f3       	breq	.-22     	; 0x1aea <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1b00:	81 e0       	ldi	r24, 0x01	; 1
    1b02:	f8 01       	movw	r30, r16
    1b04:	80 83       	st	Z, r24
    1b06:	01 c0       	rjmp	.+2      	; 0x1b0a <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b08:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1b0a:	df 91       	pop	r29
    1b0c:	cf 91       	pop	r28
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	08 95       	ret

00001b14 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b14:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b16:	03 96       	adiw	r24, 0x03	; 3
    1b18:	92 83       	std	Z+2, r25	; 0x02
    1b1a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b1c:	2f ef       	ldi	r18, 0xFF	; 255
    1b1e:	3f ef       	ldi	r19, 0xFF	; 255
    1b20:	34 83       	std	Z+4, r19	; 0x04
    1b22:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b24:	96 83       	std	Z+6, r25	; 0x06
    1b26:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b28:	90 87       	std	Z+8, r25	; 0x08
    1b2a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b2c:	10 82       	st	Z, r1
    1b2e:	08 95       	ret

00001b30 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1b30:	fc 01       	movw	r30, r24
    1b32:	11 86       	std	Z+9, r1	; 0x09
    1b34:	10 86       	std	Z+8, r1	; 0x08
    1b36:	08 95       	ret

00001b38 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b38:	cf 93       	push	r28
    1b3a:	df 93       	push	r29
    1b3c:	9c 01       	movw	r18, r24
    1b3e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1b40:	dc 01       	movw	r26, r24
    1b42:	11 96       	adiw	r26, 0x01	; 1
    1b44:	cd 91       	ld	r28, X+
    1b46:	dc 91       	ld	r29, X
    1b48:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1b4a:	d3 83       	std	Z+3, r29	; 0x03
    1b4c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b50:	9d 81       	ldd	r25, Y+5	; 0x05
    1b52:	95 83       	std	Z+5, r25	; 0x05
    1b54:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b56:	8c 81       	ldd	r24, Y+4	; 0x04
    1b58:	9d 81       	ldd	r25, Y+5	; 0x05
    1b5a:	dc 01       	movw	r26, r24
    1b5c:	13 96       	adiw	r26, 0x03	; 3
    1b5e:	7c 93       	st	X, r23
    1b60:	6e 93       	st	-X, r22
    1b62:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1b64:	7d 83       	std	Y+5, r23	; 0x05
    1b66:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1b68:	31 87       	std	Z+9, r19	; 0x09
    1b6a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1b6c:	f9 01       	movw	r30, r18
    1b6e:	80 81       	ld	r24, Z
    1b70:	8f 5f       	subi	r24, 0xFF	; 255
    1b72:	80 83       	st	Z, r24
}
    1b74:	df 91       	pop	r29
    1b76:	cf 91       	pop	r28
    1b78:	08 95       	ret

00001b7a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b7a:	0f 93       	push	r16
    1b7c:	1f 93       	push	r17
    1b7e:	cf 93       	push	r28
    1b80:	df 93       	push	r29
    1b82:	8c 01       	movw	r16, r24
    1b84:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1b86:	80 81       	ld	r24, Z
    1b88:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1b8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b8c:	2f ef       	ldi	r18, 0xFF	; 255
    1b8e:	92 07       	cpc	r25, r18
    1b90:	21 f4       	brne	.+8      	; 0x1b9a <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1b92:	e8 01       	movw	r28, r16
    1b94:	af 81       	ldd	r26, Y+7	; 0x07
    1b96:	b8 85       	ldd	r27, Y+8	; 0x08
    1b98:	0e c0       	rjmp	.+28     	; 0x1bb6 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1b9a:	d8 01       	movw	r26, r16
    1b9c:	13 96       	adiw	r26, 0x03	; 3
    1b9e:	12 96       	adiw	r26, 0x02	; 2
    1ba0:	2d 91       	ld	r18, X+
    1ba2:	3c 91       	ld	r19, X
    1ba4:	13 97       	sbiw	r26, 0x03	; 3
    1ba6:	e9 01       	movw	r28, r18
    1ba8:	48 81       	ld	r20, Y
    1baa:	59 81       	ldd	r21, Y+1	; 0x01
    1bac:	84 17       	cp	r24, r20
    1bae:	95 07       	cpc	r25, r21
    1bb0:	10 f0       	brcs	.+4      	; 0x1bb6 <vListInsert+0x3c>
    1bb2:	d9 01       	movw	r26, r18
    1bb4:	f4 cf       	rjmp	.-24     	; 0x1b9e <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1bb6:	12 96       	adiw	r26, 0x02	; 2
    1bb8:	8d 91       	ld	r24, X+
    1bba:	9c 91       	ld	r25, X
    1bbc:	13 97       	sbiw	r26, 0x03	; 3
    1bbe:	93 83       	std	Z+3, r25	; 0x03
    1bc0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1bc2:	ec 01       	movw	r28, r24
    1bc4:	fd 83       	std	Y+5, r31	; 0x05
    1bc6:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1bc8:	b5 83       	std	Z+5, r27	; 0x05
    1bca:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1bcc:	13 96       	adiw	r26, 0x03	; 3
    1bce:	fc 93       	st	X, r31
    1bd0:	ee 93       	st	-X, r30
    1bd2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1bd4:	11 87       	std	Z+9, r17	; 0x09
    1bd6:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1bd8:	f8 01       	movw	r30, r16
    1bda:	80 81       	ld	r24, Z
    1bdc:	8f 5f       	subi	r24, 0xFF	; 255
    1bde:	80 83       	st	Z, r24
}
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	1f 91       	pop	r17
    1be6:	0f 91       	pop	r16
    1be8:	08 95       	ret

00001bea <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1bea:	cf 93       	push	r28
    1bec:	df 93       	push	r29
    1bee:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1bf0:	a0 85       	ldd	r26, Z+8	; 0x08
    1bf2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1bf4:	82 81       	ldd	r24, Z+2	; 0x02
    1bf6:	93 81       	ldd	r25, Z+3	; 0x03
    1bf8:	24 81       	ldd	r18, Z+4	; 0x04
    1bfa:	35 81       	ldd	r19, Z+5	; 0x05
    1bfc:	ec 01       	movw	r28, r24
    1bfe:	3d 83       	std	Y+5, r19	; 0x05
    1c00:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c02:	c4 81       	ldd	r28, Z+4	; 0x04
    1c04:	d5 81       	ldd	r29, Z+5	; 0x05
    1c06:	9b 83       	std	Y+3, r25	; 0x03
    1c08:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c0a:	11 96       	adiw	r26, 0x01	; 1
    1c0c:	8d 91       	ld	r24, X+
    1c0e:	9c 91       	ld	r25, X
    1c10:	12 97       	sbiw	r26, 0x02	; 2
    1c12:	e8 17       	cp	r30, r24
    1c14:	f9 07       	cpc	r31, r25
    1c16:	21 f4       	brne	.+8      	; 0x1c20 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c18:	12 96       	adiw	r26, 0x02	; 2
    1c1a:	dc 93       	st	X, r29
    1c1c:	ce 93       	st	-X, r28
    1c1e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1c20:	11 86       	std	Z+9, r1	; 0x09
    1c22:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c24:	8c 91       	ld	r24, X
    1c26:	81 50       	subi	r24, 0x01	; 1
    1c28:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1c2a:	8c 91       	ld	r24, X
}
    1c2c:	df 91       	pop	r29
    1c2e:	cf 91       	pop	r28
    1c30:	08 95       	ret

00001c32 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1c32:	cf 92       	push	r12
    1c34:	df 92       	push	r13
    1c36:	ef 92       	push	r14
    1c38:	ff 92       	push	r15
    1c3a:	1f 93       	push	r17
    1c3c:	cf 93       	push	r28
    1c3e:	df 93       	push	r29
    1c40:	6c 01       	movw	r12, r24
    1c42:	16 2f       	mov	r17, r22
    1c44:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1c46:	8a e1       	ldi	r24, 0x1A	; 26
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <pvPortMalloc>
    1c4e:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1c50:	89 2b       	or	r24, r25
    1c52:	09 f4       	brne	.+2      	; 0x1c56 <xCoRoutineCreate+0x24>
    1c54:	57 c0       	rjmp	.+174    	; 0x1d04 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1c56:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1c5a:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1c5e:	89 2b       	or	r24, r25
    1c60:	21 f5       	brne	.+72     	; 0x1caa <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1c62:	d0 93 87 01 	sts	0x0187, r29	; 0x800187 <pxCurrentCoRoutine+0x1>
    1c66:	c0 93 86 01 	sts	0x0186, r28	; 0x800186 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1c6a:	8e ea       	ldi	r24, 0xAE	; 174
    1c6c:	91 e0       	ldi	r25, 0x01	; 1
    1c6e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
    1c72:	87 eb       	ldi	r24, 0xB7	; 183
    1c74:	91 e0       	ldi	r25, 0x01	; 1
    1c76:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1c7a:	85 ea       	ldi	r24, 0xA5	; 165
    1c7c:	91 e0       	ldi	r25, 0x01	; 1
    1c7e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1c82:	8c e9       	ldi	r24, 0x9C	; 156
    1c84:	91 e0       	ldi	r25, 0x01	; 1
    1c86:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1c8a:	8f e8       	ldi	r24, 0x8F	; 143
    1c8c:	91 e0       	ldi	r25, 0x01	; 1
    1c8e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1c92:	85 ea       	ldi	r24, 0xA5	; 165
    1c94:	91 e0       	ldi	r25, 0x01	; 1
    1c96:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1c9a:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1c9e:	8c e9       	ldi	r24, 0x9C	; 156
    1ca0:	91 e0       	ldi	r25, 0x01	; 1
    1ca2:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1ca6:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1caa:	11 11       	cpse	r17, r1
    1cac:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1cae:	19 8e       	std	Y+25, r1	; 0x19
    1cb0:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1cb2:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1cb4:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1cb6:	fe 01       	movw	r30, r28
    1cb8:	c1 92       	st	Z+, r12
    1cba:	d1 92       	st	Z+, r13
    1cbc:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1cbe:	cf 01       	movw	r24, r30
    1cc0:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1cc4:	ce 01       	movw	r24, r28
    1cc6:	0c 96       	adiw	r24, 0x0c	; 12
    1cc8:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1ccc:	d9 87       	std	Y+9, r29	; 0x09
    1cce:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1cd0:	db 8b       	std	Y+19, r29	; 0x13
    1cd2:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1cd4:	82 e0       	ldi	r24, 0x02	; 2
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	81 1b       	sub	r24, r17
    1cda:	91 09       	sbc	r25, r1
    1cdc:	9d 87       	std	Y+13, r25	; 0x0d
    1cde:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1ce0:	8e 89       	ldd	r24, Y+22	; 0x16
    1ce2:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1ce6:	98 17       	cp	r25, r24
    1ce8:	10 f4       	brcc	.+4      	; 0x1cee <xCoRoutineCreate+0xbc>
    1cea:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1cee:	f9 e0       	ldi	r31, 0x09	; 9
    1cf0:	8f 9f       	mul	r24, r31
    1cf2:	c0 01       	movw	r24, r0
    1cf4:	11 24       	eor	r1, r1
    1cf6:	b7 01       	movw	r22, r14
    1cf8:	82 55       	subi	r24, 0x52	; 82
    1cfa:	9e 4f       	sbci	r25, 0xFE	; 254
    1cfc:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

		xReturn = pdPASS;
    1d00:	81 e0       	ldi	r24, 0x01	; 1
    1d02:	01 c0       	rjmp	.+2      	; 0x1d06 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d04:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1d06:	df 91       	pop	r29
    1d08:	cf 91       	pop	r28
    1d0a:	1f 91       	pop	r17
    1d0c:	ff 90       	pop	r15
    1d0e:	ef 90       	pop	r14
    1d10:	df 90       	pop	r13
    1d12:	cf 90       	pop	r12
    1d14:	08 95       	ret

00001d16 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1d16:	0f 93       	push	r16
    1d18:	1f 93       	push	r17
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1d20:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1d24:	d0 91 8d 01 	lds	r29, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1d28:	c8 0f       	add	r28, r24
    1d2a:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1d2c:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1d30:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1d34:	02 96       	adiw	r24, 0x02	; 2
    1d36:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1d3a:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1d3e:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1d42:	d3 83       	std	Z+3, r29	; 0x03
    1d44:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1d46:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1d4a:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1d4e:	bf 01       	movw	r22, r30
    1d50:	6e 5f       	subi	r22, 0xFE	; 254
    1d52:	7f 4f       	sbci	r23, 0xFF	; 255
    1d54:	c8 17       	cp	r28, r24
    1d56:	d9 07       	cpc	r29, r25
    1d58:	28 f4       	brcc	.+10     	; 0x1d64 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1d5a:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1d5e:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1d62:	04 c0       	rjmp	.+8      	; 0x1d6c <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1d64:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1d68:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1d6c:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInsert>
	}

	if( pxEventList )
    1d70:	01 15       	cp	r16, r1
    1d72:	11 05       	cpc	r17, r1
    1d74:	69 f0       	breq	.+26     	; 0x1d90 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1d76:	60 91 86 01 	lds	r22, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1d7a:	70 91 87 01 	lds	r23, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1d7e:	64 5f       	subi	r22, 0xF4	; 244
    1d80:	7f 4f       	sbci	r23, 0xFF	; 255
    1d82:	c8 01       	movw	r24, r16
	}
}
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	1f 91       	pop	r17
    1d8a:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1d8c:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <vListInsert>
	}
}
    1d90:	df 91       	pop	r29
    1d92:	cf 91       	pop	r28
    1d94:	1f 91       	pop	r17
    1d96:	0f 91       	pop	r16
    1d98:	08 95       	ret

00001d9a <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1d9a:	ff 92       	push	r15
    1d9c:	0f 93       	push	r16
    1d9e:	1f 93       	push	r17
    1da0:	cf 93       	push	r28
    1da2:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1da4:	99 e0       	ldi	r25, 0x09	; 9
    1da6:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1da8:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <xPendingReadyCoRoutineList>
    1dac:	88 23       	and	r24, r24
    1dae:	11 f1       	breq	.+68     	; 0x1df4 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1db0:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1db2:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <xPendingReadyCoRoutineList+0x5>
    1db6:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <xPendingReadyCoRoutineList+0x6>
    1dba:	c6 81       	ldd	r28, Z+6	; 0x06
    1dbc:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1dbe:	ce 01       	movw	r24, r28
    1dc0:	0c 96       	adiw	r24, 0x0c	; 12
    1dc2:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1dc6:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1dc8:	8e 01       	movw	r16, r28
    1dca:	0e 5f       	subi	r16, 0xFE	; 254
    1dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    1dce:	c8 01       	movw	r24, r16
    1dd0:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1dd4:	8e 89       	ldd	r24, Y+22	; 0x16
    1dd6:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1dda:	98 17       	cp	r25, r24
    1ddc:	10 f4       	brcc	.+4      	; 0x1de2 <vCoRoutineSchedule+0x48>
    1dde:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1de2:	f8 9e       	mul	r15, r24
    1de4:	c0 01       	movw	r24, r0
    1de6:	11 24       	eor	r1, r1
    1de8:	b8 01       	movw	r22, r16
    1dea:	82 55       	subi	r24, 0x52	; 82
    1dec:	9e 4f       	sbci	r25, 0xFE	; 254
    1dee:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
    1df2:	da cf       	rjmp	.-76     	; 0x1da8 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1df4:	0e 94 5d 03 	call	0x6ba	; 0x6ba <xTaskGetTickCount>
    1df8:	20 91 8a 01 	lds	r18, 0x018A	; 0x80018a <xLastTickCount>
    1dfc:	30 91 8b 01 	lds	r19, 0x018B	; 0x80018b <xLastTickCount+0x1>
    1e00:	82 1b       	sub	r24, r18
    1e02:	93 0b       	sbc	r25, r19
    1e04:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <xPassedTicks+0x1>
    1e08:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1e0c:	89 e0       	ldi	r24, 0x09	; 9
    1e0e:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e10:	20 91 88 01 	lds	r18, 0x0188	; 0x800188 <xPassedTicks>
    1e14:	30 91 89 01 	lds	r19, 0x0189	; 0x800189 <xPassedTicks+0x1>
    1e18:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1e1c:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1e20:	21 15       	cp	r18, r1
    1e22:	31 05       	cpc	r19, r1
    1e24:	09 f4       	brne	.+2      	; 0x1e28 <vCoRoutineSchedule+0x8e>
    1e26:	54 c0       	rjmp	.+168    	; 0x1ed0 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1e28:	01 96       	adiw	r24, 0x01	; 1
    1e2a:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <xCoRoutineTickCount+0x1>
    1e2e:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <xCoRoutineTickCount>
		xPassedTicks--;
    1e32:	21 50       	subi	r18, 0x01	; 1
    1e34:	31 09       	sbc	r19, r1
    1e36:	30 93 89 01 	sts	0x0189, r19	; 0x800189 <xPassedTicks+0x1>
    1e3a:	20 93 88 01 	sts	0x0188, r18	; 0x800188 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1e3e:	89 2b       	or	r24, r25
    1e40:	09 f0       	breq	.+2      	; 0x1e44 <vCoRoutineSchedule+0xaa>
    1e42:	3e c0       	rjmp	.+124    	; 0x1ec0 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1e44:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1e48:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1e4c:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1e50:	30 91 99 01 	lds	r19, 0x0199	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1e54:	30 93 9b 01 	sts	0x019B, r19	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1e58:	20 93 9a 01 	sts	0x019A, r18	; 0x80019a <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1e5c:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1e60:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1e64:	2d c0       	rjmp	.+90     	; 0x1ec0 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1e66:	05 80       	ldd	r0, Z+5	; 0x05
    1e68:	f6 81       	ldd	r31, Z+6	; 0x06
    1e6a:	e0 2d       	mov	r30, r0
    1e6c:	c6 81       	ldd	r28, Z+6	; 0x06
    1e6e:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1e70:	2a 81       	ldd	r18, Y+2	; 0x02
    1e72:	3b 81       	ldd	r19, Y+3	; 0x03
    1e74:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1e78:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1e7c:	82 17       	cp	r24, r18
    1e7e:	93 07       	cpc	r25, r19
    1e80:	38 f2       	brcs	.-114    	; 0x1e10 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1e82:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1e84:	8e 01       	movw	r16, r28
    1e86:	0e 5f       	subi	r16, 0xFE	; 254
    1e88:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8a:	c8 01       	movw	r24, r16
    1e8c:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1e90:	8c 89       	ldd	r24, Y+20	; 0x14
    1e92:	9d 89       	ldd	r25, Y+21	; 0x15
    1e94:	89 2b       	or	r24, r25
    1e96:	21 f0       	breq	.+8      	; 0x1ea0 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1e98:	ce 01       	movw	r24, r28
    1e9a:	0c 96       	adiw	r24, 0x0c	; 12
    1e9c:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1ea0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1ea2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ea4:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1ea8:	98 17       	cp	r25, r24
    1eaa:	10 f4       	brcc	.+4      	; 0x1eb0 <vCoRoutineSchedule+0x116>
    1eac:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1eb0:	f8 9e       	mul	r15, r24
    1eb2:	c0 01       	movw	r24, r0
    1eb4:	11 24       	eor	r1, r1
    1eb6:	b8 01       	movw	r22, r16
    1eb8:	82 55       	subi	r24, 0x52	; 82
    1eba:	9e 4f       	sbci	r25, 0xFE	; 254
    1ebc:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1ec0:	e0 91 9a 01 	lds	r30, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1ec4:	f0 91 9b 01 	lds	r31, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1ec8:	80 81       	ld	r24, Z
    1eca:	81 11       	cpse	r24, r1
    1ecc:	cc cf       	rjmp	.-104    	; 0x1e66 <vCoRoutineSchedule+0xcc>
    1ece:	a0 cf       	rjmp	.-192    	; 0x1e10 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1ed0:	90 93 8b 01 	sts	0x018B, r25	; 0x80018b <xLastTickCount+0x1>
    1ed4:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <xLastTickCount>
    1ed8:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1edc:	69 e0       	ldi	r22, 0x09	; 9
    1ede:	48 2f       	mov	r20, r24
    1ee0:	50 e0       	ldi	r21, 0x00	; 0
    1ee2:	64 9f       	mul	r22, r20
    1ee4:	90 01       	movw	r18, r0
    1ee6:	65 9f       	mul	r22, r21
    1ee8:	30 0d       	add	r19, r0
    1eea:	11 24       	eor	r1, r1
    1eec:	f9 01       	movw	r30, r18
    1eee:	e2 55       	subi	r30, 0x52	; 82
    1ef0:	fe 4f       	sbci	r31, 0xFE	; 254
    1ef2:	90 81       	ld	r25, Z
    1ef4:	91 11       	cpse	r25, r1
    1ef6:	0c c0       	rjmp	.+24     	; 0x1f10 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1ef8:	81 11       	cpse	r24, r1
    1efa:	08 c0       	rjmp	.+16     	; 0x1f0c <vCoRoutineSchedule+0x172>
    1efc:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1f00:	df 91       	pop	r29
    1f02:	cf 91       	pop	r28
    1f04:	1f 91       	pop	r17
    1f06:	0f 91       	pop	r16
    1f08:	ff 90       	pop	r15
    1f0a:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1f0c:	81 50       	subi	r24, 0x01	; 1
    1f0e:	e7 cf       	rjmp	.-50     	; 0x1ede <vCoRoutineSchedule+0x144>
    1f10:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f14:	a1 81       	ldd	r26, Z+1	; 0x01
    1f16:	b2 81       	ldd	r27, Z+2	; 0x02
    1f18:	12 96       	adiw	r26, 0x02	; 2
    1f1a:	0d 90       	ld	r0, X+
    1f1c:	bc 91       	ld	r27, X
    1f1e:	a0 2d       	mov	r26, r0
    1f20:	b2 83       	std	Z+2, r27	; 0x02
    1f22:	a1 83       	std	Z+1, r26	; 0x01
    1f24:	2f 54       	subi	r18, 0x4F	; 79
    1f26:	3e 4f       	sbci	r19, 0xFE	; 254
    1f28:	a2 17       	cp	r26, r18
    1f2a:	b3 07       	cpc	r27, r19
    1f2c:	31 f4       	brne	.+12     	; 0x1f3a <vCoRoutineSchedule+0x1a0>
    1f2e:	12 96       	adiw	r26, 0x02	; 2
    1f30:	8d 91       	ld	r24, X+
    1f32:	9c 91       	ld	r25, X
    1f34:	13 97       	sbiw	r26, 0x03	; 3
    1f36:	92 83       	std	Z+2, r25	; 0x02
    1f38:	81 83       	std	Z+1, r24	; 0x01
    1f3a:	89 e0       	ldi	r24, 0x09	; 9
    1f3c:	84 9f       	mul	r24, r20
    1f3e:	f0 01       	movw	r30, r0
    1f40:	85 9f       	mul	r24, r21
    1f42:	f0 0d       	add	r31, r0
    1f44:	11 24       	eor	r1, r1
    1f46:	e2 55       	subi	r30, 0x52	; 82
    1f48:	fe 4f       	sbci	r31, 0xFE	; 254
    1f4a:	01 80       	ldd	r0, Z+1	; 0x01
    1f4c:	f2 81       	ldd	r31, Z+2	; 0x02
    1f4e:	e0 2d       	mov	r30, r0
    1f50:	86 81       	ldd	r24, Z+6	; 0x06
    1f52:	97 81       	ldd	r25, Z+7	; 0x07
    1f54:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <pxCurrentCoRoutine+0x1>
    1f58:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1f5c:	dc 01       	movw	r26, r24
    1f5e:	ed 91       	ld	r30, X+
    1f60:	fc 91       	ld	r31, X
    1f62:	11 97       	sbiw	r26, 0x01	; 1
    1f64:	57 96       	adiw	r26, 0x17	; 23
    1f66:	6c 91       	ld	r22, X

	return;
}
    1f68:	df 91       	pop	r29
    1f6a:	cf 91       	pop	r28
    1f6c:	1f 91       	pop	r17
    1f6e:	0f 91       	pop	r16
    1f70:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1f72:	09 94       	ijmp

00001f74 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1f74:	0f 93       	push	r16
    1f76:	1f 93       	push	r17
    1f78:	cf 93       	push	r28
    1f7a:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1f7c:	dc 01       	movw	r26, r24
    1f7e:	15 96       	adiw	r26, 0x05	; 5
    1f80:	ed 91       	ld	r30, X+
    1f82:	fc 91       	ld	r31, X
    1f84:	16 97       	sbiw	r26, 0x06	; 6
    1f86:	c6 81       	ldd	r28, Z+6	; 0x06
    1f88:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f8a:	8e 01       	movw	r16, r28
    1f8c:	04 5f       	subi	r16, 0xF4	; 244
    1f8e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f90:	c8 01       	movw	r24, r16
    1f92:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1f96:	b8 01       	movw	r22, r16
    1f98:	8f e8       	ldi	r24, 0x8F	; 143
    1f9a:	91 e0       	ldi	r25, 0x01	; 1
    1f9c:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1fa0:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1fa4:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1fa8:	81 e0       	ldi	r24, 0x01	; 1
    1faa:	2e 89       	ldd	r18, Y+22	; 0x16
    1fac:	96 89       	ldd	r25, Z+22	; 0x16
    1fae:	29 17       	cp	r18, r25
    1fb0:	08 f4       	brcc	.+2      	; 0x1fb4 <xCoRoutineRemoveFromEventList+0x40>
    1fb2:	80 e0       	ldi	r24, 0x00	; 0
}
    1fb4:	df 91       	pop	r29
    1fb6:	cf 91       	pop	r28
    1fb8:	1f 91       	pop	r17
    1fba:	0f 91       	pop	r16
    1fbc:	08 95       	ret

00001fbe <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1fbe:	cf 93       	push	r28
    1fc0:	df 93       	push	r29
    1fc2:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1fc4:	0e 94 57 03 	call	0x6ae	; 0x6ae <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1fc8:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <pucAlignedHeap.2081>
    1fcc:	90 91 c1 01 	lds	r25, 0x01C1	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    1fd0:	89 2b       	or	r24, r25
    1fd2:	31 f4       	brne	.+12     	; 0x1fe0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1fd4:	85 ec       	ldi	r24, 0xC5	; 197
    1fd6:	91 e0       	ldi	r25, 0x01	; 1
    1fd8:	90 93 c1 01 	sts	0x01C1, r25	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    1fdc:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1fe0:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <xNextFreeByte>
    1fe4:	30 91 c3 01 	lds	r19, 0x01C3	; 0x8001c3 <xNextFreeByte+0x1>
    1fe8:	c9 01       	movw	r24, r18
    1fea:	8c 0f       	add	r24, r28
    1fec:	9d 1f       	adc	r25, r29
    1fee:	8b 3d       	cpi	r24, 0xDB	; 219
    1ff0:	45 e0       	ldi	r20, 0x05	; 5
    1ff2:	94 07       	cpc	r25, r20
    1ff4:	70 f4       	brcc	.+28     	; 0x2012 <pvPortMalloc+0x54>
    1ff6:	28 17       	cp	r18, r24
    1ff8:	39 07       	cpc	r19, r25
    1ffa:	58 f4       	brcc	.+22     	; 0x2012 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1ffc:	c0 91 c0 01 	lds	r28, 0x01C0	; 0x8001c0 <pucAlignedHeap.2081>
    2000:	d0 91 c1 01 	lds	r29, 0x01C1	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    2004:	c2 0f       	add	r28, r18
    2006:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2008:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <xNextFreeByte+0x1>
    200c:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <xNextFreeByte>
    2010:	02 c0       	rjmp	.+4      	; 0x2016 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2012:	c0 e0       	ldi	r28, 0x00	; 0
    2014:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2016:	0e 94 23 04 	call	0x846	; 0x846 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    201a:	ce 01       	movw	r24, r28
    201c:	df 91       	pop	r29
    201e:	cf 91       	pop	r28
    2020:	08 95       	ret

00002022 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2022:	08 95       	ret

00002024 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2024:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <xNextFreeByte+0x1>
    2028:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <xNextFreeByte>
    202c:	08 95       	ret

0000202e <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    202e:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <xNextFreeByte>
    2032:	30 91 c3 01 	lds	r19, 0x01C3	; 0x8001c3 <xNextFreeByte+0x1>
}
    2036:	8b ed       	ldi	r24, 0xDB	; 219
    2038:	95 e0       	ldi	r25, 0x05	; 5
    203a:	82 1b       	sub	r24, r18
    203c:	93 0b       	sbc	r25, r19
    203e:	08 95       	ret

00002040 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2040:	31 e1       	ldi	r19, 0x11	; 17
    2042:	fc 01       	movw	r30, r24
    2044:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2046:	31 97       	sbiw	r30, 0x01	; 1
    2048:	22 e2       	ldi	r18, 0x22	; 34
    204a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    204c:	31 97       	sbiw	r30, 0x01	; 1
    204e:	a3 e3       	ldi	r26, 0x33	; 51
    2050:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2052:	31 97       	sbiw	r30, 0x01	; 1
    2054:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2056:	31 97       	sbiw	r30, 0x01	; 1
    2058:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    205a:	31 97       	sbiw	r30, 0x01	; 1
    205c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    205e:	31 97       	sbiw	r30, 0x01	; 1
    2060:	60 e8       	ldi	r22, 0x80	; 128
    2062:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2064:	31 97       	sbiw	r30, 0x01	; 1
    2066:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2068:	31 97       	sbiw	r30, 0x01	; 1
    206a:	62 e0       	ldi	r22, 0x02	; 2
    206c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    206e:	31 97       	sbiw	r30, 0x01	; 1
    2070:	63 e0       	ldi	r22, 0x03	; 3
    2072:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2074:	31 97       	sbiw	r30, 0x01	; 1
    2076:	64 e0       	ldi	r22, 0x04	; 4
    2078:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    207a:	31 97       	sbiw	r30, 0x01	; 1
    207c:	65 e0       	ldi	r22, 0x05	; 5
    207e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2080:	31 97       	sbiw	r30, 0x01	; 1
    2082:	66 e0       	ldi	r22, 0x06	; 6
    2084:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2086:	31 97       	sbiw	r30, 0x01	; 1
    2088:	67 e0       	ldi	r22, 0x07	; 7
    208a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    208c:	31 97       	sbiw	r30, 0x01	; 1
    208e:	68 e0       	ldi	r22, 0x08	; 8
    2090:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2092:	31 97       	sbiw	r30, 0x01	; 1
    2094:	69 e0       	ldi	r22, 0x09	; 9
    2096:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2098:	31 97       	sbiw	r30, 0x01	; 1
    209a:	60 e1       	ldi	r22, 0x10	; 16
    209c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    209e:	31 97       	sbiw	r30, 0x01	; 1
    20a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    20a2:	31 97       	sbiw	r30, 0x01	; 1
    20a4:	32 e1       	ldi	r19, 0x12	; 18
    20a6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    20a8:	31 97       	sbiw	r30, 0x01	; 1
    20aa:	33 e1       	ldi	r19, 0x13	; 19
    20ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    20ae:	31 97       	sbiw	r30, 0x01	; 1
    20b0:	34 e1       	ldi	r19, 0x14	; 20
    20b2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    20b4:	31 97       	sbiw	r30, 0x01	; 1
    20b6:	35 e1       	ldi	r19, 0x15	; 21
    20b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    20ba:	31 97       	sbiw	r30, 0x01	; 1
    20bc:	36 e1       	ldi	r19, 0x16	; 22
    20be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    20c0:	31 97       	sbiw	r30, 0x01	; 1
    20c2:	37 e1       	ldi	r19, 0x17	; 23
    20c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    20c6:	31 97       	sbiw	r30, 0x01	; 1
    20c8:	38 e1       	ldi	r19, 0x18	; 24
    20ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    20cc:	31 97       	sbiw	r30, 0x01	; 1
    20ce:	39 e1       	ldi	r19, 0x19	; 25
    20d0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    20d2:	31 97       	sbiw	r30, 0x01	; 1
    20d4:	30 e2       	ldi	r19, 0x20	; 32
    20d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    20d8:	31 97       	sbiw	r30, 0x01	; 1
    20da:	31 e2       	ldi	r19, 0x21	; 33
    20dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    20de:	31 97       	sbiw	r30, 0x01	; 1
    20e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    20e2:	31 97       	sbiw	r30, 0x01	; 1
    20e4:	23 e2       	ldi	r18, 0x23	; 35
    20e6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20e8:	31 97       	sbiw	r30, 0x01	; 1
    20ea:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20ec:	31 97       	sbiw	r30, 0x01	; 1
    20ee:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    20f0:	31 97       	sbiw	r30, 0x01	; 1
    20f2:	26 e2       	ldi	r18, 0x26	; 38
    20f4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	27 e2       	ldi	r18, 0x27	; 39
    20fa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	28 e2       	ldi	r18, 0x28	; 40
    2100:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	29 e2       	ldi	r18, 0x29	; 41
    2106:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	20 e3       	ldi	r18, 0x30	; 48
    210c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	21 e3       	ldi	r18, 0x31	; 49
    2112:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2114:	86 97       	sbiw	r24, 0x26	; 38
    2116:	08 95       	ret

00002118 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2118:	89 ef       	ldi	r24, 0xF9	; 249
    211a:	90 e0       	ldi	r25, 0x00	; 0
    211c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    2120:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    2124:	e0 e8       	ldi	r30, 0x80	; 128
    2126:	f0 e0       	ldi	r31, 0x00	; 0
    2128:	80 81       	ld	r24, Z
    212a:	8c 7f       	andi	r24, 0xFC	; 252
    212c:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    212e:	8b e0       	ldi	r24, 0x0B	; 11
    2130:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2134:	ef e6       	ldi	r30, 0x6F	; 111
    2136:	f0 e0       	ldi	r31, 0x00	; 0
    2138:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    213a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    213c:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    213e:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2142:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2146:	cd 91       	ld	r28, X+
    2148:	cd bf       	out	0x3d, r28	; 61
    214a:	dd 91       	ld	r29, X+
    214c:	de bf       	out	0x3e, r29	; 62
    214e:	ff 91       	pop	r31
    2150:	ef 91       	pop	r30
    2152:	df 91       	pop	r29
    2154:	cf 91       	pop	r28
    2156:	bf 91       	pop	r27
    2158:	af 91       	pop	r26
    215a:	9f 91       	pop	r25
    215c:	8f 91       	pop	r24
    215e:	7f 91       	pop	r23
    2160:	6f 91       	pop	r22
    2162:	5f 91       	pop	r21
    2164:	4f 91       	pop	r20
    2166:	3f 91       	pop	r19
    2168:	2f 91       	pop	r18
    216a:	1f 91       	pop	r17
    216c:	0f 91       	pop	r16
    216e:	ff 90       	pop	r15
    2170:	ef 90       	pop	r14
    2172:	df 90       	pop	r13
    2174:	cf 90       	pop	r12
    2176:	bf 90       	pop	r11
    2178:	af 90       	pop	r10
    217a:	9f 90       	pop	r9
    217c:	8f 90       	pop	r8
    217e:	7f 90       	pop	r7
    2180:	6f 90       	pop	r6
    2182:	5f 90       	pop	r5
    2184:	4f 90       	pop	r4
    2186:	3f 90       	pop	r3
    2188:	2f 90       	pop	r2
    218a:	1f 90       	pop	r1
    218c:	0f 90       	pop	r0
    218e:	0f be       	out	0x3f, r0	; 63
    2190:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2192:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2194:	81 e0       	ldi	r24, 0x01	; 1
    2196:	08 95       	ret

00002198 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2198:	08 95       	ret

0000219a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    219a:	0f 92       	push	r0
    219c:	0f b6       	in	r0, 0x3f	; 63
    219e:	f8 94       	cli
    21a0:	0f 92       	push	r0
    21a2:	1f 92       	push	r1
    21a4:	11 24       	eor	r1, r1
    21a6:	2f 92       	push	r2
    21a8:	3f 92       	push	r3
    21aa:	4f 92       	push	r4
    21ac:	5f 92       	push	r5
    21ae:	6f 92       	push	r6
    21b0:	7f 92       	push	r7
    21b2:	8f 92       	push	r8
    21b4:	9f 92       	push	r9
    21b6:	af 92       	push	r10
    21b8:	bf 92       	push	r11
    21ba:	cf 92       	push	r12
    21bc:	df 92       	push	r13
    21be:	ef 92       	push	r14
    21c0:	ff 92       	push	r15
    21c2:	0f 93       	push	r16
    21c4:	1f 93       	push	r17
    21c6:	2f 93       	push	r18
    21c8:	3f 93       	push	r19
    21ca:	4f 93       	push	r20
    21cc:	5f 93       	push	r21
    21ce:	6f 93       	push	r22
    21d0:	7f 93       	push	r23
    21d2:	8f 93       	push	r24
    21d4:	9f 93       	push	r25
    21d6:	af 93       	push	r26
    21d8:	bf 93       	push	r27
    21da:	cf 93       	push	r28
    21dc:	df 93       	push	r29
    21de:	ef 93       	push	r30
    21e0:	ff 93       	push	r31
    21e2:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    21e6:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    21ea:	0d b6       	in	r0, 0x3d	; 61
    21ec:	0d 92       	st	X+, r0
    21ee:	0e b6       	in	r0, 0x3e	; 62
    21f0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    21f2:	0e 94 df 04 	call	0x9be	; 0x9be <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    21f6:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    21fa:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    21fe:	cd 91       	ld	r28, X+
    2200:	cd bf       	out	0x3d, r28	; 61
    2202:	dd 91       	ld	r29, X+
    2204:	de bf       	out	0x3e, r29	; 62
    2206:	ff 91       	pop	r31
    2208:	ef 91       	pop	r30
    220a:	df 91       	pop	r29
    220c:	cf 91       	pop	r28
    220e:	bf 91       	pop	r27
    2210:	af 91       	pop	r26
    2212:	9f 91       	pop	r25
    2214:	8f 91       	pop	r24
    2216:	7f 91       	pop	r23
    2218:	6f 91       	pop	r22
    221a:	5f 91       	pop	r21
    221c:	4f 91       	pop	r20
    221e:	3f 91       	pop	r19
    2220:	2f 91       	pop	r18
    2222:	1f 91       	pop	r17
    2224:	0f 91       	pop	r16
    2226:	ff 90       	pop	r15
    2228:	ef 90       	pop	r14
    222a:	df 90       	pop	r13
    222c:	cf 90       	pop	r12
    222e:	bf 90       	pop	r11
    2230:	af 90       	pop	r10
    2232:	9f 90       	pop	r9
    2234:	8f 90       	pop	r8
    2236:	7f 90       	pop	r7
    2238:	6f 90       	pop	r6
    223a:	5f 90       	pop	r5
    223c:	4f 90       	pop	r4
    223e:	3f 90       	pop	r3
    2240:	2f 90       	pop	r2
    2242:	1f 90       	pop	r1
    2244:	0f 90       	pop	r0
    2246:	0f be       	out	0x3f, r0	; 63
    2248:	0f 90       	pop	r0

	asm volatile ( "ret" );
    224a:	08 95       	ret

0000224c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    224c:	0f 92       	push	r0
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	0f 92       	push	r0
    2254:	1f 92       	push	r1
    2256:	11 24       	eor	r1, r1
    2258:	2f 92       	push	r2
    225a:	3f 92       	push	r3
    225c:	4f 92       	push	r4
    225e:	5f 92       	push	r5
    2260:	6f 92       	push	r6
    2262:	7f 92       	push	r7
    2264:	8f 92       	push	r8
    2266:	9f 92       	push	r9
    2268:	af 92       	push	r10
    226a:	bf 92       	push	r11
    226c:	cf 92       	push	r12
    226e:	df 92       	push	r13
    2270:	ef 92       	push	r14
    2272:	ff 92       	push	r15
    2274:	0f 93       	push	r16
    2276:	1f 93       	push	r17
    2278:	2f 93       	push	r18
    227a:	3f 93       	push	r19
    227c:	4f 93       	push	r20
    227e:	5f 93       	push	r21
    2280:	6f 93       	push	r22
    2282:	7f 93       	push	r23
    2284:	8f 93       	push	r24
    2286:	9f 93       	push	r25
    2288:	af 93       	push	r26
    228a:	bf 93       	push	r27
    228c:	cf 93       	push	r28
    228e:	df 93       	push	r29
    2290:	ef 93       	push	r30
    2292:	ff 93       	push	r31
    2294:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2298:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    229c:	0d b6       	in	r0, 0x3d	; 61
    229e:	0d 92       	st	X+, r0
    22a0:	0e b6       	in	r0, 0x3e	; 62
    22a2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    22a4:	0e 94 77 03 	call	0x6ee	; 0x6ee <xTaskIncrementTick>
    22a8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    22aa:	0e 94 df 04 	call	0x9be	; 0x9be <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    22ae:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    22b2:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    22b6:	cd 91       	ld	r28, X+
    22b8:	cd bf       	out	0x3d, r28	; 61
    22ba:	dd 91       	ld	r29, X+
    22bc:	de bf       	out	0x3e, r29	; 62
    22be:	ff 91       	pop	r31
    22c0:	ef 91       	pop	r30
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	bf 91       	pop	r27
    22c8:	af 91       	pop	r26
    22ca:	9f 91       	pop	r25
    22cc:	8f 91       	pop	r24
    22ce:	7f 91       	pop	r23
    22d0:	6f 91       	pop	r22
    22d2:	5f 91       	pop	r21
    22d4:	4f 91       	pop	r20
    22d6:	3f 91       	pop	r19
    22d8:	2f 91       	pop	r18
    22da:	1f 91       	pop	r17
    22dc:	0f 91       	pop	r16
    22de:	ff 90       	pop	r15
    22e0:	ef 90       	pop	r14
    22e2:	df 90       	pop	r13
    22e4:	cf 90       	pop	r12
    22e6:	bf 90       	pop	r11
    22e8:	af 90       	pop	r10
    22ea:	9f 90       	pop	r9
    22ec:	8f 90       	pop	r8
    22ee:	7f 90       	pop	r7
    22f0:	6f 90       	pop	r6
    22f2:	5f 90       	pop	r5
    22f4:	4f 90       	pop	r4
    22f6:	3f 90       	pop	r3
    22f8:	2f 90       	pop	r2
    22fa:	1f 90       	pop	r1
    22fc:	0f 90       	pop	r0
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2302:	08 95       	ret

00002304 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2304:	0e 94 26 11 	call	0x224c	; 0x224c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2308:	18 95       	reti

0000230a <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
}

int uart_transmit(char c, FILE *stream) {
    230a:	cf 93       	push	r28
    230c:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
    230e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    2312:	85 fd       	sbrc	r24, 5
    2314:	03 c0       	rjmp	.+6      	; 0x231c <uart_transmit+0x12>
    2316:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    231a:	f9 cf       	rjmp	.-14     	; 0x230e <uart_transmit+0x4>
  UDR0 = c;
    231c:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  return 0;
}
    2320:	80 e0       	ldi	r24, 0x00	; 0
    2322:	90 e0       	ldi	r25, 0x00	; 0
    2324:	cf 91       	pop	r28
    2326:	08 95       	ret

00002328 <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
    2328:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    232c:	87 fd       	sbrc	r24, 7
    232e:	03 c0       	rjmp	.+6      	; 0x2336 <uart_receive+0xe>
    2330:	0e 94 cd 10 	call	0x219a	; 0x219a <vPortYield>
    2334:	f9 cf       	rjmp	.-14     	; 0x2328 <uart_receive>
  return UDR0;
    2336:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
    233a:	90 e0       	ldi	r25, 0x00	; 0
    233c:	08 95       	ret

0000233e <uart_init>:
    233e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    2342:	87 e6       	ldi	r24, 0x67	; 103
    2344:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    2348:	e0 ec       	ldi	r30, 0xC0	; 192
    234a:	f0 e0       	ldi	r31, 0x00	; 0
    234c:	80 81       	ld	r24, Z
    234e:	8d 7f       	andi	r24, 0xFD	; 253
    2350:	80 83       	st	Z, r24
    2352:	86 e0       	ldi	r24, 0x06	; 6
    2354:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    2358:	88 e1       	ldi	r24, 0x18	; 24
    235a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    235e:	08 95       	ret

00002360 <main>:
 *
 * \return
 ******************************************************************************/
bool tab[102];
int main(void)
{
    2360:	ef 92       	push	r14
    2362:	ff 92       	push	r15
    2364:	0f 93       	push	r16
    2366:	cf 93       	push	r28
    2368:	df 93       	push	r29
    236a:	00 d0       	rcall	.+0      	; 0x236c <main+0xc>
    236c:	00 d0       	rcall	.+0      	; 0x236e <main+0xe>
    236e:	cd b7       	in	r28, 0x3d	; 61
    2370:	de b7       	in	r29, 0x3e	; 62
    // Create task.
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    xTaskCreate
    2372:	ce 01       	movw	r24, r28
    2374:	03 96       	adiw	r24, 0x03	; 3
    2376:	7c 01       	movw	r14, r24
    2378:	02 e0       	ldi	r16, 0x02	; 2
    237a:	20 e0       	ldi	r18, 0x00	; 0
    237c:	30 e0       	ldi	r19, 0x00	; 0
    237e:	45 e5       	ldi	r20, 0x55	; 85
    2380:	50 e0       	ldi	r21, 0x00	; 0
    2382:	6e e0       	ldi	r22, 0x0E	; 14
    2384:	71 e0       	ldi	r23, 0x01	; 1
    2386:	8d e7       	ldi	r24, 0x7D	; 125
    2388:	90 e0       	ldi	r25, 0x00	; 0
    238a:	0e 94 43 01 	call	0x286	; 0x286 <xTaskCreate>
         NULL,
         mainLED_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    238e:	ce 01       	movw	r24, r28
    2390:	01 96       	adiw	r24, 0x01	; 1
    2392:	7c 01       	movw	r14, r24
    2394:	01 e0       	ldi	r16, 0x01	; 1
    2396:	20 e0       	ldi	r18, 0x00	; 0
    2398:	30 e0       	ldi	r19, 0x00	; 0
    239a:	45 e5       	ldi	r20, 0x55	; 85
    239c:	50 e0       	ldi	r21, 0x00	; 0
    239e:	64 e1       	ldi	r22, 0x14	; 20
    23a0:	71 e0       	ldi	r23, 0x01	; 1
    23a2:	83 e5       	ldi	r24, 0x53	; 83
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	0e 94 43 01 	call	0x286	; 0x286 <xTaskCreate>
         mainSERIAL_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    23aa:	0e 94 28 03 	call	0x650	; 0x650 <vTaskStartScheduler>

    return 0;
}
    23ae:	80 e0       	ldi	r24, 0x00	; 0
    23b0:	90 e0       	ldi	r25, 0x00	; 0
    23b2:	0f 90       	pop	r0
    23b4:	0f 90       	pop	r0
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	0f 91       	pop	r16
    23c0:	ff 90       	pop	r15
    23c2:	ef 90       	pop	r14
    23c4:	08 95       	ret

000023c6 <__divmodhi4>:
    23c6:	97 fb       	bst	r25, 7
    23c8:	07 2e       	mov	r0, r23
    23ca:	16 f4       	brtc	.+4      	; 0x23d0 <__divmodhi4+0xa>
    23cc:	00 94       	com	r0
    23ce:	07 d0       	rcall	.+14     	; 0x23de <__divmodhi4_neg1>
    23d0:	77 fd       	sbrc	r23, 7
    23d2:	09 d0       	rcall	.+18     	; 0x23e6 <__divmodhi4_neg2>
    23d4:	0e 94 f7 11 	call	0x23ee	; 0x23ee <__udivmodhi4>
    23d8:	07 fc       	sbrc	r0, 7
    23da:	05 d0       	rcall	.+10     	; 0x23e6 <__divmodhi4_neg2>
    23dc:	3e f4       	brtc	.+14     	; 0x23ec <__divmodhi4_exit>

000023de <__divmodhi4_neg1>:
    23de:	90 95       	com	r25
    23e0:	81 95       	neg	r24
    23e2:	9f 4f       	sbci	r25, 0xFF	; 255
    23e4:	08 95       	ret

000023e6 <__divmodhi4_neg2>:
    23e6:	70 95       	com	r23
    23e8:	61 95       	neg	r22
    23ea:	7f 4f       	sbci	r23, 0xFF	; 255

000023ec <__divmodhi4_exit>:
    23ec:	08 95       	ret

000023ee <__udivmodhi4>:
    23ee:	aa 1b       	sub	r26, r26
    23f0:	bb 1b       	sub	r27, r27
    23f2:	51 e1       	ldi	r21, 0x11	; 17
    23f4:	07 c0       	rjmp	.+14     	; 0x2404 <__udivmodhi4_ep>

000023f6 <__udivmodhi4_loop>:
    23f6:	aa 1f       	adc	r26, r26
    23f8:	bb 1f       	adc	r27, r27
    23fa:	a6 17       	cp	r26, r22
    23fc:	b7 07       	cpc	r27, r23
    23fe:	10 f0       	brcs	.+4      	; 0x2404 <__udivmodhi4_ep>
    2400:	a6 1b       	sub	r26, r22
    2402:	b7 0b       	sbc	r27, r23

00002404 <__udivmodhi4_ep>:
    2404:	88 1f       	adc	r24, r24
    2406:	99 1f       	adc	r25, r25
    2408:	5a 95       	dec	r21
    240a:	a9 f7       	brne	.-22     	; 0x23f6 <__udivmodhi4_loop>
    240c:	80 95       	com	r24
    240e:	90 95       	com	r25
    2410:	bc 01       	movw	r22, r24
    2412:	cd 01       	movw	r24, r26
    2414:	08 95       	ret

00002416 <memcpy>:
    2416:	fb 01       	movw	r30, r22
    2418:	dc 01       	movw	r26, r24
    241a:	02 c0       	rjmp	.+4      	; 0x2420 <memcpy+0xa>
    241c:	01 90       	ld	r0, Z+
    241e:	0d 92       	st	X+, r0
    2420:	41 50       	subi	r20, 0x01	; 1
    2422:	50 40       	sbci	r21, 0x00	; 0
    2424:	d8 f7       	brcc	.-10     	; 0x241c <memcpy+0x6>
    2426:	08 95       	ret

00002428 <_exit>:
    2428:	f8 94       	cli

0000242a <__stop_program>:
    242a:	ff cf       	rjmp	.-2      	; 0x242a <__stop_program>
