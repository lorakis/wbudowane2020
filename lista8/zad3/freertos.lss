
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00002b24  00002bb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b24  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068a  00800126  00800126  00002bde  2**0
                  ALLOC
  3 .stab         000076e0  00000000  00000000  00002be0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004398  00000000  00000000  0000a2c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e658  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e66c  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e6ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000eca0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f242  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f25c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 cc 11 	jmp	0x2398	; 0x2398 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 bb 00 	jmp	0x176	; 0x176 <__vector_18>
      4c:	0c 94 87 00 	jmp	0x10e	; 0x10e <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e4 e2       	ldi	r30, 0x24	; 36
      7c:	fb e2       	ldi	r31, 0x2B	; 43
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a6 32       	cpi	r26, 0x26	; 38
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a6 e2       	ldi	r26, 0x26	; 38
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a0 3b       	cpi	r26, 0xB0	; 176
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 26 12 	call	0x244c	; 0x244c <main>
      9e:	0c 94 90 15 	jmp	0x2b20	; 0x2b20 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
    uart_init();
      a6:	0e 94 15 12 	call	0x242a	; 0x242a <uart_init>
    stdin = stdout = stderr = &uart_file;
      aa:	80 e0       	ldi	r24, 0x00	; 0
      ac:	91 e0       	ldi	r25, 0x01	; 1
      ae:	90 93 af 07 	sts	0x07AF, r25	; 0x8007af <__iob+0x5>
      b2:	80 93 ae 07 	sts	0x07AE, r24	; 0x8007ae <__iob+0x4>
      b6:	90 93 ad 07 	sts	0x07AD, r25	; 0x8007ad <__iob+0x3>
      ba:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <__iob+0x2>
      be:	90 93 ab 07 	sts	0x07AB, r25	; 0x8007ab <__iob+0x1>
      c2:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <__iob>
    char input;

    for ( ;; )
    {
        input = getchar();
        printf("%c\r\n", input);
      c6:	ce e0       	ldi	r28, 0x0E	; 14
      c8:	d1 e0       	ldi	r29, 0x01	; 1

    char input;

    for ( ;; )
    {
        input = getchar();
      ca:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <__iob>
      ce:	90 91 ab 07 	lds	r25, 0x07AB	; 0x8007ab <__iob+0x1>
      d2:	0e 94 74 12 	call	0x24e8	; 0x24e8 <fgetc>
        printf("%c\r\n", input);
      d6:	28 2f       	mov	r18, r24
      d8:	08 2e       	mov	r0, r24
      da:	00 0c       	add	r0, r0
      dc:	33 0b       	sbc	r19, r19
      de:	3f 93       	push	r19
      e0:	8f 93       	push	r24
      e2:	df 93       	push	r29
      e4:	cf 93       	push	r28
      e6:	0e 94 b2 12 	call	0x2564	; 0x2564 <printf>
      ea:	0f 90       	pop	r0
      ec:	0f 90       	pop	r0
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	eb cf       	rjmp	.-42     	; 0xca <vSerial+0x24>

000000f4 <vBlinkLed>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
    DDRB |= _BV(PB5);
      f4:	25 9a       	sbi	0x04, 5	; 4

    for ( ;; )
    {
        LED_PORT &= ~_BV(LED);
      f6:	2d 98       	cbi	0x05, 5	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
      f8:	84 ef       	ldi	r24, 0xF4	; 244
      fa:	91 e0       	ldi	r25, 0x01	; 1
      fc:	0e 94 14 05 	call	0xa28	; 0xa28 <vTaskDelay>
        LED_PORT |= _BV(LED);
     100:	2d 9a       	sbi	0x05, 5	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
     102:	84 ef       	ldi	r24, 0xF4	; 244
     104:	91 e0       	ldi	r25, 0x01	; 1
     106:	0e 94 14 05 	call	0xa28	; 0xa28 <vTaskDelay>
     10a:	f5 cf       	rjmp	.-22     	; 0xf6 <vBlinkLed+0x2>

0000010c <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     10c:	08 95       	ret

0000010e <__vector_19>:
        printf("%c\r\n", input);
    }
}

ISR(USART_UDRE_vect)
{
     10e:	1f 92       	push	r1
     110:	0f 92       	push	r0
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	0f 92       	push	r0
     116:	11 24       	eor	r1, r1
     118:	2f 93       	push	r18
     11a:	3f 93       	push	r19
     11c:	4f 93       	push	r20
     11e:	5f 93       	push	r21
     120:	6f 93       	push	r22
     122:	7f 93       	push	r23
     124:	8f 93       	push	r24
     126:	9f 93       	push	r25
     128:	af 93       	push	r26
     12a:	bf 93       	push	r27
     12c:	ef 93       	push	r30
     12e:	ff 93       	push	r31
  if(xQueueIsQueueEmptyFromISR(out) == pdFALSE)
     130:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <out>
     134:	90 91 a9 07 	lds	r25, 0x07A9	; 0x8007a9 <out+0x1>
     138:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <xQueueIsQueueEmptyFromISR>
     13c:	81 11       	cpse	r24, r1
     13e:	0a c0       	rjmp	.+20     	; 0x154 <__vector_19+0x46>
    xQueueReceiveFromISR(out, (void*)&UDR0, NULL);
     140:	40 e0       	ldi	r20, 0x00	; 0
     142:	50 e0       	ldi	r21, 0x00	; 0
     144:	66 ec       	ldi	r22, 0xC6	; 198
     146:	70 e0       	ldi	r23, 0x00	; 0
     148:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <out>
     14c:	90 91 a9 07 	lds	r25, 0x07A9	; 0x8007a9 <out+0x1>
     150:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xQueueReceiveFromISR>
}
     154:	ff 91       	pop	r31
     156:	ef 91       	pop	r30
     158:	bf 91       	pop	r27
     15a:	af 91       	pop	r26
     15c:	9f 91       	pop	r25
     15e:	8f 91       	pop	r24
     160:	7f 91       	pop	r23
     162:	6f 91       	pop	r22
     164:	5f 91       	pop	r21
     166:	4f 91       	pop	r20
     168:	3f 91       	pop	r19
     16a:	2f 91       	pop	r18
     16c:	0f 90       	pop	r0
     16e:	0f be       	out	0x3f, r0	; 63
     170:	0f 90       	pop	r0
     172:	1f 90       	pop	r1
     174:	18 95       	reti

00000176 <__vector_18>:

ISR(USART_RX_vect)
{
     176:	1f 92       	push	r1
     178:	0f 92       	push	r0
     17a:	0f b6       	in	r0, 0x3f	; 63
     17c:	0f 92       	push	r0
     17e:	11 24       	eor	r1, r1
     180:	2f 93       	push	r18
     182:	3f 93       	push	r19
     184:	4f 93       	push	r20
     186:	5f 93       	push	r21
     188:	6f 93       	push	r22
     18a:	7f 93       	push	r23
     18c:	8f 93       	push	r24
     18e:	9f 93       	push	r25
     190:	af 93       	push	r26
     192:	bf 93       	push	r27
     194:	ef 93       	push	r30
     196:	ff 93       	push	r31
  xQueueSendFromISR(in, (void*)&UDR0, NULL);
     198:	20 e0       	ldi	r18, 0x00	; 0
     19a:	40 e0       	ldi	r20, 0x00	; 0
     19c:	50 e0       	ldi	r21, 0x00	; 0
     19e:	66 ec       	ldi	r22, 0xC6	; 198
     1a0:	70 e0       	ldi	r23, 0x00	; 0
     1a2:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <in>
     1a6:	90 91 a7 07 	lds	r25, 0x07A7	; 0x8007a7 <in+0x1>
     1aa:	0e 94 90 0a 	call	0x1520	; 0x1520 <xQueueGenericSendFromISR>
}
     1ae:	ff 91       	pop	r31
     1b0:	ef 91       	pop	r30
     1b2:	bf 91       	pop	r27
     1b4:	af 91       	pop	r26
     1b6:	9f 91       	pop	r25
     1b8:	8f 91       	pop	r24
     1ba:	7f 91       	pop	r23
     1bc:	6f 91       	pop	r22
     1be:	5f 91       	pop	r21
     1c0:	4f 91       	pop	r20
     1c2:	3f 91       	pop	r19
     1c4:	2f 91       	pop	r18
     1c6:	0f 90       	pop	r0
     1c8:	0f be       	out	0x3f, r0	; 63
     1ca:	0f 90       	pop	r0
     1cc:	1f 90       	pop	r1
     1ce:	18 95       	reti

000001d0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1d0:	e0 91 54 01 	lds	r30, 0x0154	; 0x800154 <pxDelayedTaskList>
     1d4:	f0 91 55 01 	lds	r31, 0x0155	; 0x800155 <pxDelayedTaskList+0x1>
     1d8:	80 81       	ld	r24, Z
     1da:	81 11       	cpse	r24, r1
     1dc:	03 c0       	rjmp	.+6      	; 0x1e4 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1de:	8f ef       	ldi	r24, 0xFF	; 255
     1e0:	9f ef       	ldi	r25, 0xFF	; 255
     1e2:	0c c0       	rjmp	.+24     	; 0x1fc <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     1e4:	e0 91 54 01 	lds	r30, 0x0154	; 0x800154 <pxDelayedTaskList>
     1e8:	f0 91 55 01 	lds	r31, 0x0155	; 0x800155 <pxDelayedTaskList+0x1>
     1ec:	05 80       	ldd	r0, Z+5	; 0x05
     1ee:	f6 81       	ldd	r31, Z+6	; 0x06
     1f0:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     1f2:	06 80       	ldd	r0, Z+6	; 0x06
     1f4:	f7 81       	ldd	r31, Z+7	; 0x07
     1f6:	e0 2d       	mov	r30, r0
     1f8:	82 81       	ldd	r24, Z+2	; 0x02
     1fa:	93 81       	ldd	r25, Z+3	; 0x03
     1fc:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
     200:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
     204:	08 95       	ret

00000206 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     206:	ff 92       	push	r15
     208:	0f 93       	push	r16
     20a:	1f 93       	push	r17
     20c:	cf 93       	push	r28
     20e:	df 93       	push	r29
     210:	ec 01       	movw	r28, r24
     212:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     214:	00 91 33 01 	lds	r16, 0x0133	; 0x800133 <xTickCount>
     218:	10 91 34 01 	lds	r17, 0x0134	; 0x800134 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     21c:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     220:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
     224:	02 96       	adiw	r24, 0x02	; 2
     226:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     22a:	cf 3f       	cpi	r28, 0xFF	; 255
     22c:	8f ef       	ldi	r24, 0xFF	; 255
     22e:	d8 07       	cpc	r29, r24
     230:	89 f4       	brne	.+34     	; 0x254 <prvAddCurrentTaskToDelayedList+0x4e>
     232:	ff 20       	and	r15, r15
     234:	79 f0       	breq	.+30     	; 0x254 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     236:	60 91 26 01 	lds	r22, 0x0126	; 0x800126 <__data_end>
     23a:	70 91 27 01 	lds	r23, 0x0127	; 0x800127 <__data_end+0x1>
     23e:	6e 5f       	subi	r22, 0xFE	; 254
     240:	7f 4f       	sbci	r23, 0xFF	; 255
     242:	86 e3       	ldi	r24, 0x36	; 54
     244:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     246:	df 91       	pop	r29
     248:	cf 91       	pop	r28
     24a:	1f 91       	pop	r17
     24c:	0f 91       	pop	r16
     24e:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     250:	0c 94 e6 0d 	jmp	0x1bcc	; 0x1bcc <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     254:	c0 0f       	add	r28, r16
     256:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     258:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     25c:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     260:	d3 83       	std	Z+3, r29	; 0x03
     262:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     264:	60 91 26 01 	lds	r22, 0x0126	; 0x800126 <__data_end>
     268:	70 91 27 01 	lds	r23, 0x0127	; 0x800127 <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     26c:	c0 17       	cp	r28, r16
     26e:	d1 07       	cpc	r29, r17
     270:	68 f4       	brcc	.+26     	; 0x28c <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     272:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <pxOverflowDelayedTaskList>
     276:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <pxOverflowDelayedTaskList+0x1>
     27a:	6e 5f       	subi	r22, 0xFE	; 254
     27c:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     27e:	df 91       	pop	r29
     280:	cf 91       	pop	r28
     282:	1f 91       	pop	r17
     284:	0f 91       	pop	r16
     286:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     288:	0c 94 07 0e 	jmp	0x1c0e	; 0x1c0e <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     28c:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <pxDelayedTaskList>
     290:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <pxDelayedTaskList+0x1>
     294:	6e 5f       	subi	r22, 0xFE	; 254
     296:	7f 4f       	sbci	r23, 0xFF	; 255
     298:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     29c:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xNextTaskUnblockTime>
     2a0:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <xNextTaskUnblockTime+0x1>
     2a4:	c8 17       	cp	r28, r24
     2a6:	d9 07       	cpc	r29, r25
     2a8:	20 f4       	brcc	.+8      	; 0x2b2 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     2aa:	d0 93 2c 01 	sts	0x012C, r29	; 0x80012c <xNextTaskUnblockTime+0x1>
     2ae:	c0 93 2b 01 	sts	0x012B, r28	; 0x80012b <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2b2:	df 91       	pop	r29
     2b4:	cf 91       	pop	r28
     2b6:	1f 91       	pop	r17
     2b8:	0f 91       	pop	r16
     2ba:	ff 90       	pop	r15
     2bc:	08 95       	ret

000002be <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     2be:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxDeletedTasksWaitingCleanUp>
     2c2:	88 23       	and	r24, r24
     2c4:	09 f1       	breq	.+66     	; 0x308 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     2c6:	0f b6       	in	r0, 0x3f	; 63
     2c8:	f8 94       	cli
     2ca:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2cc:	e0 91 45 01 	lds	r30, 0x0145	; 0x800145 <xTasksWaitingTermination+0x5>
     2d0:	f0 91 46 01 	lds	r31, 0x0146	; 0x800146 <xTasksWaitingTermination+0x6>
     2d4:	c6 81       	ldd	r28, Z+6	; 0x06
     2d6:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     2d8:	ce 01       	movw	r24, r28
     2da:	02 96       	adiw	r24, 0x02	; 2
     2dc:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
				--uxCurrentNumberOfTasks;
     2e0:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
     2e4:	81 50       	subi	r24, 0x01	; 1
     2e6:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     2ea:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxDeletedTasksWaitingCleanUp>
     2ee:	81 50       	subi	r24, 0x01	; 1
     2f0:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     2f4:	0f 90       	pop	r0
     2f6:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     2f8:	8f 89       	ldd	r24, Y+23	; 0x17
     2fa:	98 8d       	ldd	r25, Y+24	; 0x18
     2fc:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <vPortFree>
			vPortFree( pxTCB );
     300:	ce 01       	movw	r24, r28
     302:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <vPortFree>
     306:	db cf       	rjmp	.-74     	; 0x2be <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     308:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <pxReadyTasksLists>
     30c:	82 30       	cpi	r24, 0x02	; 2
     30e:	10 f0       	brcs	.+4      	; 0x314 <prvIdleTask+0x56>
			{
				taskYIELD();
     310:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     314:	0e 94 86 00 	call	0x10c	; 0x10c <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     318:	d2 cf       	rjmp	.-92     	; 0x2be <prvIdleTask>

0000031a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     31a:	3f 92       	push	r3
     31c:	4f 92       	push	r4
     31e:	5f 92       	push	r5
     320:	6f 92       	push	r6
     322:	7f 92       	push	r7
     324:	8f 92       	push	r8
     326:	9f 92       	push	r9
     328:	af 92       	push	r10
     32a:	bf 92       	push	r11
     32c:	cf 92       	push	r12
     32e:	df 92       	push	r13
     330:	ef 92       	push	r14
     332:	ff 92       	push	r15
     334:	0f 93       	push	r16
     336:	1f 93       	push	r17
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
     33c:	4c 01       	movw	r8, r24
     33e:	16 2f       	mov	r17, r22
     340:	37 2e       	mov	r3, r23
     342:	6a 01       	movw	r12, r20
     344:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     346:	ca 01       	movw	r24, r20
     348:	0e 94 29 10 	call	0x2052	; 0x2052 <pvPortMalloc>
     34c:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     34e:	89 2b       	or	r24, r25
     350:	09 f4       	brne	.+2      	; 0x354 <xTaskCreate+0x3a>
     352:	d1 c0       	rjmp	.+418    	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     354:	86 e2       	ldi	r24, 0x26	; 38
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	0e 94 29 10 	call	0x2052	; 0x2052 <pvPortMalloc>
     35c:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     35e:	89 2b       	or	r24, r25
     360:	79 f0       	breq	.+30     	; 0x380 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     362:	58 8e       	std	Y+24, r5	; 0x18
     364:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     366:	c6 01       	movw	r24, r12
     368:	01 97       	sbiw	r24, 0x01	; 1
     36a:	32 01       	movw	r6, r4
     36c:	68 0e       	add	r6, r24
     36e:	79 1e       	adc	r7, r25
     370:	be 01       	movw	r22, r28
     372:	67 5e       	subi	r22, 0xE7	; 231
     374:	7f 4f       	sbci	r23, 0xFF	; 255
     376:	e1 2f       	mov	r30, r17
     378:	f3 2d       	mov	r31, r3
     37a:	cf 01       	movw	r24, r30
     37c:	08 96       	adiw	r24, 0x08	; 8
     37e:	07 c0       	rjmp	.+14     	; 0x38e <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     380:	c2 01       	movw	r24, r4
     382:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <vPortFree>
     386:	b7 c0       	rjmp	.+366    	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     388:	e8 17       	cp	r30, r24
     38a:	f9 07       	cpc	r31, r25
     38c:	49 f0       	breq	.+18     	; 0x3a0 <xTaskCreate+0x86>
     38e:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     390:	41 91       	ld	r20, Z+
     392:	db 01       	movw	r26, r22
     394:	4d 93       	st	X+, r20
     396:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     398:	d9 01       	movw	r26, r18
     39a:	2c 91       	ld	r18, X
     39c:	21 11       	cpse	r18, r1
     39e:	f4 cf       	rjmp	.-24     	; 0x388 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     3a0:	18 a2       	std	Y+32, r1	; 0x20
     3a2:	04 30       	cpi	r16, 0x04	; 4
     3a4:	08 f0       	brcs	.+2      	; 0x3a8 <xTaskCreate+0x8e>
     3a6:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     3a8:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     3aa:	6e 01       	movw	r12, r28
     3ac:	b2 e0       	ldi	r27, 0x02	; 2
     3ae:	cb 0e       	add	r12, r27
     3b0:	d1 1c       	adc	r13, r1
     3b2:	c6 01       	movw	r24, r12
     3b4:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     3b8:	ce 01       	movw	r24, r28
     3ba:	0c 96       	adiw	r24, 0x0c	; 12
     3bc:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     3c0:	d9 87       	std	Y+9, r29	; 0x09
     3c2:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     3c4:	84 e0       	ldi	r24, 0x04	; 4
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	80 1b       	sub	r24, r16
     3ca:	91 09       	sbc	r25, r1
     3cc:	9d 87       	std	Y+13, r25	; 0x0d
     3ce:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     3d0:	db 8b       	std	Y+19, r29	; 0x13
     3d2:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     3d4:	19 a2       	std	Y+33, r1	; 0x21
     3d6:	1a a2       	std	Y+34, r1	; 0x22
     3d8:	1b a2       	std	Y+35, r1	; 0x23
     3da:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     3dc:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     3de:	a5 01       	movw	r20, r10
     3e0:	b4 01       	movw	r22, r8
     3e2:	c3 01       	movw	r24, r6
     3e4:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <pxPortInitialiseStack>
     3e8:	99 83       	std	Y+1, r25	; 0x01
     3ea:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     3ec:	e1 14       	cp	r14, r1
     3ee:	f1 04       	cpc	r15, r1
     3f0:	19 f0       	breq	.+6      	; 0x3f8 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     3f2:	f7 01       	movw	r30, r14
     3f4:	d1 83       	std	Z+1, r29	; 0x01
     3f6:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     3f8:	0f b6       	in	r0, 0x3f	; 63
     3fa:	f8 94       	cli
     3fc:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     3fe:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
     402:	8f 5f       	subi	r24, 0xFF	; 255
     404:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     408:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     40c:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
     410:	89 2b       	or	r24, r25
     412:	d1 f5       	brne	.+116    	; 0x488 <__LOCK_REGION_LENGTH__+0x88>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     414:	d0 93 27 01 	sts	0x0127, r29	; 0x800127 <__data_end+0x1>
     418:	c0 93 26 01 	sts	0x0126, r28	; 0x800126 <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     41c:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	09 f0       	breq	.+2      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     424:	41 c0       	rjmp	.+130    	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     426:	88 e6       	ldi	r24, 0x68	; 104
     428:	91 e0       	ldi	r25, 0x01	; 1
     42a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
     42e:	81 e7       	ldi	r24, 0x71	; 113
     430:	91 e0       	ldi	r25, 0x01	; 1
     432:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
     436:	8a e7       	ldi	r24, 0x7A	; 122
     438:	91 e0       	ldi	r25, 0x01	; 1
     43a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
     43e:	83 e8       	ldi	r24, 0x83	; 131
     440:	91 e0       	ldi	r25, 0x01	; 1
     442:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     446:	8f e5       	ldi	r24, 0x5F	; 95
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     44e:	86 e5       	ldi	r24, 0x56	; 86
     450:	91 e0       	ldi	r25, 0x01	; 1
     452:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     456:	89 e4       	ldi	r24, 0x49	; 73
     458:	91 e0       	ldi	r25, 0x01	; 1
     45a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     45e:	80 e4       	ldi	r24, 0x40	; 64
     460:	91 e0       	ldi	r25, 0x01	; 1
     462:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     466:	86 e3       	ldi	r24, 0x36	; 54
     468:	91 e0       	ldi	r25, 0x01	; 1
     46a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     46e:	8f e5       	ldi	r24, 0x5F	; 95
     470:	91 e0       	ldi	r25, 0x01	; 1
     472:	90 93 55 01 	sts	0x0155, r25	; 0x800155 <pxDelayedTaskList+0x1>
     476:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     47a:	86 e5       	ldi	r24, 0x56	; 86
     47c:	91 e0       	ldi	r25, 0x01	; 1
     47e:	90 93 53 01 	sts	0x0153, r25	; 0x800153 <pxOverflowDelayedTaskList+0x1>
     482:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <pxOverflowDelayedTaskList>
     486:	10 c0       	rjmp	.+32     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     488:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <xSchedulerRunning>
     48c:	81 11       	cpse	r24, r1
     48e:	0c c0       	rjmp	.+24     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     490:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     494:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     498:	96 89       	ldd	r25, Z+22	; 0x16
     49a:	8e 89       	ldd	r24, Y+22	; 0x16
     49c:	89 17       	cp	r24, r25
     49e:	20 f0       	brcs	.+8      	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
				{
					pxCurrentTCB = pxNewTCB;
     4a0:	d0 93 27 01 	sts	0x0127, r29	; 0x800127 <__data_end+0x1>
     4a4:	c0 93 26 01 	sts	0x0126, r28	; 0x800126 <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     4a8:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <uxTaskNumber>
     4ac:	8f 5f       	subi	r24, 0xFF	; 255
     4ae:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     4b2:	8e 89       	ldd	r24, Y+22	; 0x16
     4b4:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     4b8:	98 17       	cp	r25, r24
     4ba:	10 f4       	brcc	.+4      	; 0x4c0 <__LOCK_REGION_LENGTH__+0xc0>
     4bc:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     4c0:	f9 e0       	ldi	r31, 0x09	; 9
     4c2:	8f 9f       	mul	r24, r31
     4c4:	c0 01       	movw	r24, r0
     4c6:	11 24       	eor	r1, r1
     4c8:	b6 01       	movw	r22, r12
     4ca:	88 59       	subi	r24, 0x98	; 152
     4cc:	9e 4f       	sbci	r25, 0xFE	; 254
     4ce:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     4d2:	0f 90       	pop	r0
     4d4:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     4d6:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <xSchedulerRunning>
     4da:	88 23       	and	r24, r24
     4dc:	51 f0       	breq	.+20     	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     4de:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     4e2:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     4e6:	96 89       	ldd	r25, Z+22	; 0x16
     4e8:	8e 89       	ldd	r24, Y+22	; 0x16
     4ea:	98 17       	cp	r25, r24
     4ec:	10 f4       	brcc	.+4      	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
		{
			taskYIELD_IF_USING_PREEMPTION();
     4ee:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	01 c0       	rjmp	.+2      	; 0x4f8 <__LOCK_REGION_LENGTH__+0xf8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     4f6:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     4f8:	df 91       	pop	r29
     4fa:	cf 91       	pop	r28
     4fc:	1f 91       	pop	r17
     4fe:	0f 91       	pop	r16
     500:	ff 90       	pop	r15
     502:	ef 90       	pop	r14
     504:	df 90       	pop	r13
     506:	cf 90       	pop	r12
     508:	bf 90       	pop	r11
     50a:	af 90       	pop	r10
     50c:	9f 90       	pop	r9
     50e:	8f 90       	pop	r8
     510:	7f 90       	pop	r7
     512:	6f 90       	pop	r6
     514:	5f 90       	pop	r5
     516:	4f 90       	pop	r4
     518:	3f 90       	pop	r3
     51a:	08 95       	ret

0000051c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     51c:	0f 93       	push	r16
     51e:	1f 93       	push	r17
     520:	cf 93       	push	r28
     522:	df 93       	push	r29
     524:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     526:	0f b6       	in	r0, 0x3f	; 63
     528:	f8 94       	cli
     52a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     52c:	89 2b       	or	r24, r25
     52e:	21 f4       	brne	.+8      	; 0x538 <vTaskDelete+0x1c>
     530:	c0 91 26 01 	lds	r28, 0x0126	; 0x800126 <__data_end>
     534:	d0 91 27 01 	lds	r29, 0x0127	; 0x800127 <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     538:	8e 01       	movw	r16, r28
     53a:	0e 5f       	subi	r16, 0xFE	; 254
     53c:	1f 4f       	sbci	r17, 0xFF	; 255
     53e:	c8 01       	movw	r24, r16
     540:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     544:	8c 89       	ldd	r24, Y+20	; 0x14
     546:	9d 89       	ldd	r25, Y+21	; 0x15
     548:	89 2b       	or	r24, r25
     54a:	21 f0       	breq	.+8      	; 0x554 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     54c:	ce 01       	movw	r24, r28
     54e:	0c 96       	adiw	r24, 0x0c	; 12
     550:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     554:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <uxTaskNumber>
     558:	8f 5f       	subi	r24, 0xFF	; 255
     55a:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     55e:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     562:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
     566:	c8 17       	cp	r28, r24
     568:	d9 07       	cpc	r29, r25
     56a:	59 f4       	brne	.+22     	; 0x582 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     56c:	b8 01       	movw	r22, r16
     56e:	80 e4       	ldi	r24, 0x40	; 64
     570:	91 e0       	ldi	r25, 0x01	; 1
     572:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     576:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxDeletedTasksWaitingCleanUp>
     57a:	8f 5f       	subi	r24, 0xFF	; 255
     57c:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <uxDeletedTasksWaitingCleanUp>
     580:	0e c0       	rjmp	.+28     	; 0x59e <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     582:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
     586:	81 50       	subi	r24, 0x01	; 1
     588:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     58c:	8f 89       	ldd	r24, Y+23	; 0x17
     58e:	98 8d       	ldd	r25, Y+24	; 0x18
     590:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <vPortFree>
			vPortFree( pxTCB );
     594:	ce 01       	movw	r24, r28
     596:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     59a:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     59e:	0f 90       	pop	r0
     5a0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     5a2:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <xSchedulerRunning>
     5a6:	88 23       	and	r24, r24
     5a8:	49 f0       	breq	.+18     	; 0x5bc <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     5aa:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     5ae:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
     5b2:	c8 17       	cp	r28, r24
     5b4:	d9 07       	cpc	r29, r25
     5b6:	11 f4       	brne	.+4      	; 0x5bc <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     5b8:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     5bc:	df 91       	pop	r29
     5be:	cf 91       	pop	r28
     5c0:	1f 91       	pop	r17
     5c2:	0f 91       	pop	r16
     5c4:	08 95       	ret

000005c6 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     5c6:	0f 93       	push	r16
     5c8:	1f 93       	push	r17
     5ca:	cf 93       	push	r28
     5cc:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     5ce:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__data_end>
     5d2:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__data_end+0x1>
     5d6:	82 17       	cp	r24, r18
     5d8:	93 07       	cpc	r25, r19
     5da:	b9 f1       	breq	.+110    	; 0x64a <vTaskResume+0x84>
     5dc:	00 97       	sbiw	r24, 0x00	; 0
     5de:	a9 f1       	breq	.+106    	; 0x64a <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     5e0:	0f b6       	in	r0, 0x3f	; 63
     5e2:	f8 94       	cli
     5e4:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     5e6:	fc 01       	movw	r30, r24
     5e8:	22 85       	ldd	r18, Z+10	; 0x0a
     5ea:	33 85       	ldd	r19, Z+11	; 0x0b
     5ec:	26 53       	subi	r18, 0x36	; 54
     5ee:	31 40       	sbci	r19, 0x01	; 1
     5f0:	51 f5       	brne	.+84     	; 0x646 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     5f2:	fc 01       	movw	r30, r24
     5f4:	24 89       	ldd	r18, Z+20	; 0x14
     5f6:	35 89       	ldd	r19, Z+21	; 0x15
     5f8:	f1 e0       	ldi	r31, 0x01	; 1
     5fa:	29 34       	cpi	r18, 0x49	; 73
     5fc:	3f 07       	cpc	r19, r31
     5fe:	19 f1       	breq	.+70     	; 0x646 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     600:	23 2b       	or	r18, r19
     602:	09 f5       	brne	.+66     	; 0x646 <vTaskResume+0x80>
     604:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     606:	8c 01       	movw	r16, r24
     608:	0e 5f       	subi	r16, 0xFE	; 254
     60a:	1f 4f       	sbci	r17, 0xFF	; 255
     60c:	c8 01       	movw	r24, r16
     60e:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     612:	8e 89       	ldd	r24, Y+22	; 0x16
     614:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     618:	98 17       	cp	r25, r24
     61a:	10 f4       	brcc	.+4      	; 0x620 <vTaskResume+0x5a>
     61c:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     620:	29 e0       	ldi	r18, 0x09	; 9
     622:	82 9f       	mul	r24, r18
     624:	c0 01       	movw	r24, r0
     626:	11 24       	eor	r1, r1
     628:	b8 01       	movw	r22, r16
     62a:	88 59       	subi	r24, 0x98	; 152
     62c:	9e 4f       	sbci	r25, 0xFE	; 254
     62e:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     632:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     636:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     63a:	9e 89       	ldd	r25, Y+22	; 0x16
     63c:	86 89       	ldd	r24, Z+22	; 0x16
     63e:	98 17       	cp	r25, r24
     640:	10 f0       	brcs	.+4      	; 0x646 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     642:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     646:	0f 90       	pop	r0
     648:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	1f 91       	pop	r17
     650:	0f 91       	pop	r16
     652:	08 95       	ret

00000654 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     654:	ef 92       	push	r14
     656:	ff 92       	push	r15
     658:	1f 93       	push	r17
     65a:	cf 93       	push	r28
     65c:	df 93       	push	r29
     65e:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     660:	8a 85       	ldd	r24, Y+10	; 0x0a
     662:	9b 85       	ldd	r25, Y+11	; 0x0b
     664:	86 53       	subi	r24, 0x36	; 54
     666:	91 40       	sbci	r25, 0x01	; 1
     668:	99 f4       	brne	.+38     	; 0x690 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     66a:	8c 89       	ldd	r24, Y+20	; 0x14
     66c:	9d 89       	ldd	r25, Y+21	; 0x15
     66e:	21 e0       	ldi	r18, 0x01	; 1
     670:	89 34       	cpi	r24, 0x49	; 73
     672:	92 07       	cpc	r25, r18
     674:	69 f0       	breq	.+26     	; 0x690 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     676:	89 2b       	or	r24, r25
     678:	59 f4       	brne	.+22     	; 0x690 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     67a:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     67e:	88 23       	and	r24, r24
     680:	49 f0       	breq	.+18     	; 0x694 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     682:	be 01       	movw	r22, r28
     684:	64 5f       	subi	r22, 0xF4	; 244
     686:	7f 4f       	sbci	r23, 0xFF	; 255
     688:	89 e4       	ldi	r24, 0x49	; 73
     68a:	91 e0       	ldi	r25, 0x01	; 1
     68c:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     690:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     692:	21 c0       	rjmp	.+66     	; 0x6d6 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     694:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     698:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     69c:	11 e0       	ldi	r17, 0x01	; 1
     69e:	9e 89       	ldd	r25, Y+22	; 0x16
     6a0:	86 89       	ldd	r24, Z+22	; 0x16
     6a2:	98 17       	cp	r25, r24
     6a4:	08 f4       	brcc	.+2      	; 0x6a8 <xTaskResumeFromISR+0x54>
     6a6:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     6a8:	7e 01       	movw	r14, r28
     6aa:	82 e0       	ldi	r24, 0x02	; 2
     6ac:	e8 0e       	add	r14, r24
     6ae:	f1 1c       	adc	r15, r1
     6b0:	c7 01       	movw	r24, r14
     6b2:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6b6:	8e 89       	ldd	r24, Y+22	; 0x16
     6b8:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     6bc:	98 17       	cp	r25, r24
     6be:	10 f4       	brcc	.+4      	; 0x6c4 <xTaskResumeFromISR+0x70>
     6c0:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     6c4:	29 e0       	ldi	r18, 0x09	; 9
     6c6:	82 9f       	mul	r24, r18
     6c8:	c0 01       	movw	r24, r0
     6ca:	11 24       	eor	r1, r1
     6cc:	b7 01       	movw	r22, r14
     6ce:	88 59       	subi	r24, 0x98	; 152
     6d0:	9e 4f       	sbci	r25, 0xFE	; 254
     6d2:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     6d6:	81 2f       	mov	r24, r17
     6d8:	df 91       	pop	r29
     6da:	cf 91       	pop	r28
     6dc:	1f 91       	pop	r17
     6de:	ff 90       	pop	r15
     6e0:	ef 90       	pop	r14
     6e2:	08 95       	ret

000006e4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     6e4:	ef 92       	push	r14
     6e6:	ff 92       	push	r15
     6e8:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     6ea:	89 e2       	ldi	r24, 0x29	; 41
     6ec:	e8 2e       	mov	r14, r24
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	f8 2e       	mov	r15, r24
     6f2:	00 e0       	ldi	r16, 0x00	; 0
     6f4:	20 e0       	ldi	r18, 0x00	; 0
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	45 e5       	ldi	r20, 0x55	; 85
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	60 e2       	ldi	r22, 0x20	; 32
     6fe:	71 e0       	ldi	r23, 0x01	; 1
     700:	8f e5       	ldi	r24, 0x5F	; 95
     702:	91 e0       	ldi	r25, 0x01	; 1
     704:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     708:	81 30       	cpi	r24, 0x01	; 1
     70a:	91 f4       	brne	.+36     	; 0x730 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     70c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     70e:	2f ef       	ldi	r18, 0xFF	; 255
     710:	3f ef       	ldi	r19, 0xFF	; 255
     712:	30 93 2c 01 	sts	0x012C, r19	; 0x80012c <xNextTaskUnblockTime+0x1>
     716:	20 93 2b 01 	sts	0x012B, r18	; 0x80012b <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     71a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     71e:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <xTickCount+0x1>
     722:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     726:	0f 91       	pop	r16
     728:	ff 90       	pop	r15
     72a:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     72c:	0c 94 d6 10 	jmp	0x21ac	; 0x21ac <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     730:	0f 91       	pop	r16
     732:	ff 90       	pop	r15
     734:	ef 90       	pop	r14
     736:	08 95       	ret

00000738 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     738:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     73a:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <xSchedulerRunning>
	vPortEndScheduler();
     73e:	0c 94 16 11 	jmp	0x222c	; 0x222c <vPortEndScheduler>

00000742 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     742:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     746:	8f 5f       	subi	r24, 0xFF	; 255
     748:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxSchedulerSuspended>
     74c:	08 95       	ret

0000074e <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	f8 94       	cli
     752:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     754:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xTickCount>
     758:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     75c:	0f 90       	pop	r0
     75e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     760:	08 95       	ret

00000762 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     762:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xTickCount>
     766:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     76a:	08 95       	ret

0000076c <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     76c:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
}
     770:	08 95       	ret

00000772 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     772:	00 97       	sbiw	r24, 0x00	; 0
     774:	21 f4       	brne	.+8      	; 0x77e <pcTaskGetName+0xc>
     776:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     77a:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     77e:	49 96       	adiw	r24, 0x19	; 25
     780:	08 95       	ret

00000782 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     782:	cf 92       	push	r12
     784:	df 92       	push	r13
     786:	ef 92       	push	r14
     788:	ff 92       	push	r15
     78a:	0f 93       	push	r16
     78c:	1f 93       	push	r17
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     792:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     796:	81 11       	cpse	r24, r1
     798:	8c c0       	rjmp	.+280    	; 0x8b2 <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     79a:	00 91 33 01 	lds	r16, 0x0133	; 0x800133 <xTickCount>
     79e:	10 91 34 01 	lds	r17, 0x0134	; 0x800134 <xTickCount+0x1>
     7a2:	0f 5f       	subi	r16, 0xFF	; 255
     7a4:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     7a6:	10 93 34 01 	sts	0x0134, r17	; 0x800134 <xTickCount+0x1>
     7aa:	00 93 33 01 	sts	0x0133, r16	; 0x800133 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     7ae:	01 15       	cp	r16, r1
     7b0:	11 05       	cpc	r17, r1
     7b2:	b9 f4       	brne	.+46     	; 0x7e2 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     7b4:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <pxDelayedTaskList>
     7b8:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <pxDelayedTaskList+0x1>
     7bc:	20 91 52 01 	lds	r18, 0x0152	; 0x800152 <pxOverflowDelayedTaskList>
     7c0:	30 91 53 01 	lds	r19, 0x0153	; 0x800153 <pxOverflowDelayedTaskList+0x1>
     7c4:	30 93 55 01 	sts	0x0155, r19	; 0x800155 <pxDelayedTaskList+0x1>
     7c8:	20 93 54 01 	sts	0x0154, r18	; 0x800154 <pxDelayedTaskList>
     7cc:	90 93 53 01 	sts	0x0153, r25	; 0x800153 <pxOverflowDelayedTaskList+0x1>
     7d0:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <pxOverflowDelayedTaskList>
     7d4:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xNumOfOverflows>
     7d8:	8f 5f       	subi	r24, 0xFF	; 255
     7da:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xNumOfOverflows>
     7de:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     7e2:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xNextTaskUnblockTime>
     7e6:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <xNextTaskUnblockTime+0x1>
     7ea:	c0 e0       	ldi	r28, 0x00	; 0
     7ec:	08 17       	cp	r16, r24
     7ee:	19 07       	cpc	r17, r25
     7f0:	08 f4       	brcc	.+2      	; 0x7f4 <xTaskIncrementTick+0x72>
     7f2:	4f c0       	rjmp	.+158    	; 0x892 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     7f4:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     7f6:	e0 91 54 01 	lds	r30, 0x0154	; 0x800154 <pxDelayedTaskList>
     7fa:	f0 91 55 01 	lds	r31, 0x0155	; 0x800155 <pxDelayedTaskList+0x1>
     7fe:	80 81       	ld	r24, Z
     800:	81 11       	cpse	r24, r1
     802:	03 c0       	rjmp	.+6      	; 0x80a <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     804:	8f ef       	ldi	r24, 0xFF	; 255
     806:	9f ef       	ldi	r25, 0xFF	; 255
     808:	11 c0       	rjmp	.+34     	; 0x82c <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     80a:	e0 91 54 01 	lds	r30, 0x0154	; 0x800154 <pxDelayedTaskList>
     80e:	f0 91 55 01 	lds	r31, 0x0155	; 0x800155 <pxDelayedTaskList+0x1>
     812:	05 80       	ldd	r0, Z+5	; 0x05
     814:	f6 81       	ldd	r31, Z+6	; 0x06
     816:	e0 2d       	mov	r30, r0
     818:	e6 80       	ldd	r14, Z+6	; 0x06
     81a:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     81c:	d7 01       	movw	r26, r14
     81e:	12 96       	adiw	r26, 0x02	; 2
     820:	8d 91       	ld	r24, X+
     822:	9c 91       	ld	r25, X
     824:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     826:	08 17       	cp	r16, r24
     828:	19 07       	cpc	r17, r25
     82a:	28 f4       	brcc	.+10     	; 0x836 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     82c:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
     830:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     834:	2e c0       	rjmp	.+92     	; 0x892 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     836:	67 01       	movw	r12, r14
     838:	b2 e0       	ldi	r27, 0x02	; 2
     83a:	cb 0e       	add	r12, r27
     83c:	d1 1c       	adc	r13, r1
     83e:	c6 01       	movw	r24, r12
     840:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     844:	f7 01       	movw	r30, r14
     846:	84 89       	ldd	r24, Z+20	; 0x14
     848:	95 89       	ldd	r25, Z+21	; 0x15
     84a:	89 2b       	or	r24, r25
     84c:	21 f0       	breq	.+8      	; 0x856 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     84e:	c7 01       	movw	r24, r14
     850:	0c 96       	adiw	r24, 0x0c	; 12
     852:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     856:	d7 01       	movw	r26, r14
     858:	56 96       	adiw	r26, 0x16	; 22
     85a:	8c 91       	ld	r24, X
     85c:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     860:	98 17       	cp	r25, r24
     862:	10 f4       	brcc	.+4      	; 0x868 <xTaskIncrementTick+0xe6>
     864:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     868:	d8 9f       	mul	r29, r24
     86a:	c0 01       	movw	r24, r0
     86c:	11 24       	eor	r1, r1
     86e:	b6 01       	movw	r22, r12
     870:	88 59       	subi	r24, 0x98	; 152
     872:	9e 4f       	sbci	r25, 0xFE	; 254
     874:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     878:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     87c:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     880:	d7 01       	movw	r26, r14
     882:	56 96       	adiw	r26, 0x16	; 22
     884:	9c 91       	ld	r25, X
     886:	86 89       	ldd	r24, Z+22	; 0x16
     888:	98 17       	cp	r25, r24
     88a:	08 f4       	brcc	.+2      	; 0x88e <xTaskIncrementTick+0x10c>
     88c:	b4 cf       	rjmp	.-152    	; 0x7f6 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     88e:	c1 e0       	ldi	r28, 0x01	; 1
     890:	b2 cf       	rjmp	.-156    	; 0x7f6 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     892:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     896:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     89a:	e6 89       	ldd	r30, Z+22	; 0x16
     89c:	b9 e0       	ldi	r27, 0x09	; 9
     89e:	eb 9f       	mul	r30, r27
     8a0:	f0 01       	movw	r30, r0
     8a2:	11 24       	eor	r1, r1
     8a4:	e8 59       	subi	r30, 0x98	; 152
     8a6:	fe 4f       	sbci	r31, 0xFE	; 254
     8a8:	80 81       	ld	r24, Z
     8aa:	82 30       	cpi	r24, 0x02	; 2
     8ac:	40 f0       	brcs	.+16     	; 0x8be <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     8ae:	c1 e0       	ldi	r28, 0x01	; 1
     8b0:	06 c0       	rjmp	.+12     	; 0x8be <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     8b2:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxPendedTicks>
     8b6:	8f 5f       	subi	r24, 0xFF	; 255
     8b8:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     8bc:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     8be:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xYieldPending>
     8c2:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     8c4:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     8c6:	8c 2f       	mov	r24, r28
     8c8:	df 91       	pop	r29
     8ca:	cf 91       	pop	r28
     8cc:	1f 91       	pop	r17
     8ce:	0f 91       	pop	r16
     8d0:	ff 90       	pop	r15
     8d2:	ef 90       	pop	r14
     8d4:	df 90       	pop	r13
     8d6:	cf 90       	pop	r12
     8d8:	08 95       	ret

000008da <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     8da:	ef 92       	push	r14
     8dc:	ff 92       	push	r15
     8de:	0f 93       	push	r16
     8e0:	1f 93       	push	r17
     8e2:	cf 93       	push	r28
     8e4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     8e6:	0f b6       	in	r0, 0x3f	; 63
     8e8:	f8 94       	cli
     8ea:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     8ec:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     8f0:	81 50       	subi	r24, 0x01	; 1
     8f2:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8f6:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     8fa:	88 23       	and	r24, r24
     8fc:	11 f0       	breq	.+4      	; 0x902 <__stack+0x3>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	52 c0       	rjmp	.+164    	; 0x9a6 <__stack+0xa7>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     902:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
     906:	88 23       	and	r24, r24
     908:	d1 f3       	breq	.-12     	; 0x8fe <xTaskResumeAll+0x24>
     90a:	c0 e0       	ldi	r28, 0x00	; 0
     90c:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     90e:	89 e0       	ldi	r24, 0x09	; 9
     910:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     912:	ee 24       	eor	r14, r14
     914:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     916:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xPendingReadyList>
     91a:	88 23       	and	r24, r24
     91c:	51 f1       	breq	.+84     	; 0x972 <__stack+0x73>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     91e:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <xPendingReadyList+0x5>
     922:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <xPendingReadyList+0x6>
     926:	c6 81       	ldd	r28, Z+6	; 0x06
     928:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     92a:	ce 01       	movw	r24, r28
     92c:	0c 96       	adiw	r24, 0x0c	; 12
     92e:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     932:	8e 01       	movw	r16, r28
     934:	0e 5f       	subi	r16, 0xFE	; 254
     936:	1f 4f       	sbci	r17, 0xFF	; 255
     938:	c8 01       	movw	r24, r16
     93a:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     93e:	8e 89       	ldd	r24, Y+22	; 0x16
     940:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     944:	98 17       	cp	r25, r24
     946:	10 f4       	brcc	.+4      	; 0x94c <__stack+0x4d>
     948:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     94c:	f8 9e       	mul	r15, r24
     94e:	c0 01       	movw	r24, r0
     950:	11 24       	eor	r1, r1
     952:	b8 01       	movw	r22, r16
     954:	88 59       	subi	r24, 0x98	; 152
     956:	9e 4f       	sbci	r25, 0xFE	; 254
     958:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     95c:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     960:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     964:	9e 89       	ldd	r25, Y+22	; 0x16
     966:	86 89       	ldd	r24, Z+22	; 0x16
     968:	98 17       	cp	r25, r24
     96a:	a8 f2       	brcs	.-86     	; 0x916 <__stack+0x17>
					{
						xYieldPending = pdTRUE;
     96c:	e0 92 2f 01 	sts	0x012F, r14	; 0x80012f <xYieldPending>
     970:	d2 cf       	rjmp	.-92     	; 0x916 <__stack+0x17>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     972:	cd 2b       	or	r28, r29
     974:	11 f0       	breq	.+4      	; 0x97a <__stack+0x7b>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     976:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     97a:	c0 91 30 01 	lds	r28, 0x0130	; 0x800130 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     97e:	cc 23       	and	r28, r28
     980:	51 f0       	breq	.+20     	; 0x996 <__stack+0x97>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     982:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     984:	0e 94 c1 03 	call	0x782	; 0x782 <xTaskIncrementTick>
     988:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     98a:	d0 93 2f 01 	sts	0x012F, r29	; 0x80012f <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     98e:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     990:	c9 f7       	brne	.-14     	; 0x984 <__stack+0x85>

						uxPendedTicks = 0;
     992:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     996:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xYieldPending>
     99a:	88 23       	and	r24, r24
     99c:	09 f4       	brne	.+2      	; 0x9a0 <__stack+0xa1>
     99e:	af cf       	rjmp	.-162    	; 0x8fe <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     9a0:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     9a4:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     9a6:	0f 90       	pop	r0
     9a8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     9aa:	df 91       	pop	r29
     9ac:	cf 91       	pop	r28
     9ae:	1f 91       	pop	r17
     9b0:	0f 91       	pop	r16
     9b2:	ff 90       	pop	r15
     9b4:	ef 90       	pop	r14
     9b6:	08 95       	ret

000009b8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     9b8:	0f 93       	push	r16
     9ba:	1f 93       	push	r17
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	8c 01       	movw	r16, r24
     9c2:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     9c4:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     9c8:	40 91 33 01 	lds	r20, 0x0133	; 0x800133 <xTickCount>
     9cc:	50 91 34 01 	lds	r21, 0x0134	; 0x800134 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     9d0:	f8 01       	movw	r30, r16
     9d2:	20 81       	ld	r18, Z
     9d4:	31 81       	ldd	r19, Z+1	; 0x01
     9d6:	c9 01       	movw	r24, r18
     9d8:	8c 0f       	add	r24, r28
     9da:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     9dc:	42 17       	cp	r20, r18
     9de:	53 07       	cpc	r21, r19
     9e0:	20 f4       	brcc	.+8      	; 0x9ea <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     9e2:	82 17       	cp	r24, r18
     9e4:	93 07       	cpc	r25, r19
     9e6:	40 f4       	brcc	.+16     	; 0x9f8 <vTaskDelayUntil+0x40>
     9e8:	03 c0       	rjmp	.+6      	; 0x9f0 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     9ea:	82 17       	cp	r24, r18
     9ec:	93 07       	cpc	r25, r19
     9ee:	30 f0       	brcs	.+12     	; 0x9fc <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     9f0:	21 e0       	ldi	r18, 0x01	; 1
     9f2:	48 17       	cp	r20, r24
     9f4:	59 07       	cpc	r21, r25
     9f6:	18 f0       	brcs	.+6      	; 0x9fe <vTaskDelayUntil+0x46>
     9f8:	20 e0       	ldi	r18, 0x00	; 0
     9fa:	01 c0       	rjmp	.+2      	; 0x9fe <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     9fc:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     9fe:	f8 01       	movw	r30, r16
     a00:	91 83       	std	Z+1, r25	; 0x01
     a02:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     a04:	22 23       	and	r18, r18
     a06:	29 f0       	breq	.+10     	; 0xa12 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     a08:	60 e0       	ldi	r22, 0x00	; 0
     a0a:	84 1b       	sub	r24, r20
     a0c:	95 0b       	sbc	r25, r21
     a0e:	0e 94 03 01 	call	0x206	; 0x206 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a12:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a16:	81 11       	cpse	r24, r1
     a18:	02 c0       	rjmp	.+4      	; 0xa1e <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a1a:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a1e:	df 91       	pop	r29
     a20:	cf 91       	pop	r28
     a22:	1f 91       	pop	r17
     a24:	0f 91       	pop	r16
     a26:	08 95       	ret

00000a28 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     a2e:	89 2b       	or	r24, r25
     a30:	19 f4       	brne	.+6      	; 0xa38 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     a32:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
     a36:	0a c0       	rjmp	.+20     	; 0xa4c <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     a38:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     a3c:	60 e0       	ldi	r22, 0x00	; 0
     a3e:	ce 01       	movw	r24, r28
     a40:	0e 94 03 01 	call	0x206	; 0x206 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a44:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a48:	88 23       	and	r24, r24
     a4a:	99 f3       	breq	.-26     	; 0xa32 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	08 95       	ret

00000a52 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a52:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     a56:	88 23       	and	r24, r24
     a58:	21 f0       	breq	.+8      	; 0xa62 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
     a60:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a62:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a66:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <uxTopReadyPriority>
     a6a:	69 e0       	ldi	r22, 0x09	; 9
     a6c:	48 2f       	mov	r20, r24
     a6e:	50 e0       	ldi	r21, 0x00	; 0
     a70:	64 9f       	mul	r22, r20
     a72:	90 01       	movw	r18, r0
     a74:	65 9f       	mul	r22, r21
     a76:	30 0d       	add	r19, r0
     a78:	11 24       	eor	r1, r1
     a7a:	f9 01       	movw	r30, r18
     a7c:	e8 59       	subi	r30, 0x98	; 152
     a7e:	fe 4f       	sbci	r31, 0xFE	; 254
     a80:	90 81       	ld	r25, Z
     a82:	91 11       	cpse	r25, r1
     a84:	02 c0       	rjmp	.+4      	; 0xa8a <vTaskSwitchContext+0x38>
     a86:	81 50       	subi	r24, 0x01	; 1
     a88:	f1 cf       	rjmp	.-30     	; 0xa6c <vTaskSwitchContext+0x1a>
     a8a:	a1 81       	ldd	r26, Z+1	; 0x01
     a8c:	b2 81       	ldd	r27, Z+2	; 0x02
     a8e:	12 96       	adiw	r26, 0x02	; 2
     a90:	0d 90       	ld	r0, X+
     a92:	bc 91       	ld	r27, X
     a94:	a0 2d       	mov	r26, r0
     a96:	b2 83       	std	Z+2, r27	; 0x02
     a98:	a1 83       	std	Z+1, r26	; 0x01
     a9a:	25 59       	subi	r18, 0x95	; 149
     a9c:	3e 4f       	sbci	r19, 0xFE	; 254
     a9e:	a2 17       	cp	r26, r18
     aa0:	b3 07       	cpc	r27, r19
     aa2:	31 f4       	brne	.+12     	; 0xab0 <vTaskSwitchContext+0x5e>
     aa4:	12 96       	adiw	r26, 0x02	; 2
     aa6:	2d 91       	ld	r18, X+
     aa8:	3c 91       	ld	r19, X
     aaa:	13 97       	sbiw	r26, 0x03	; 3
     aac:	32 83       	std	Z+2, r19	; 0x02
     aae:	21 83       	std	Z+1, r18	; 0x01
     ab0:	99 e0       	ldi	r25, 0x09	; 9
     ab2:	94 9f       	mul	r25, r20
     ab4:	f0 01       	movw	r30, r0
     ab6:	95 9f       	mul	r25, r21
     ab8:	f0 0d       	add	r31, r0
     aba:	11 24       	eor	r1, r1
     abc:	e8 59       	subi	r30, 0x98	; 152
     abe:	fe 4f       	sbci	r31, 0xFE	; 254
     ac0:	01 80       	ldd	r0, Z+1	; 0x01
     ac2:	f2 81       	ldd	r31, Z+2	; 0x02
     ac4:	e0 2d       	mov	r30, r0
     ac6:	26 81       	ldd	r18, Z+6	; 0x06
     ac8:	37 81       	ldd	r19, Z+7	; 0x07
     aca:	30 93 27 01 	sts	0x0127, r19	; 0x800127 <__data_end+0x1>
     ace:	20 93 26 01 	sts	0x0126, r18	; 0x800126 <__data_end>
     ad2:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     ad6:	08 95       	ret

00000ad8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     ad8:	0f 93       	push	r16
     ada:	1f 93       	push	r17
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29
     ae0:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     ae2:	0f b6       	in	r0, 0x3f	; 63
     ae4:	f8 94       	cli
     ae6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     ae8:	89 2b       	or	r24, r25
     aea:	21 f4       	brne	.+8      	; 0xaf4 <vTaskSuspend+0x1c>
     aec:	c0 91 26 01 	lds	r28, 0x0126	; 0x800126 <__data_end>
     af0:	d0 91 27 01 	lds	r29, 0x0127	; 0x800127 <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     af4:	8e 01       	movw	r16, r28
     af6:	0e 5f       	subi	r16, 0xFE	; 254
     af8:	1f 4f       	sbci	r17, 0xFF	; 255
     afa:	c8 01       	movw	r24, r16
     afc:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b00:	8c 89       	ldd	r24, Y+20	; 0x14
     b02:	9d 89       	ldd	r25, Y+21	; 0x15
     b04:	89 2b       	or	r24, r25
     b06:	21 f0       	breq	.+8      	; 0xb10 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b08:	ce 01       	movw	r24, r28
     b0a:	0c 96       	adiw	r24, 0x0c	; 12
     b0c:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     b10:	b8 01       	movw	r22, r16
     b12:	86 e3       	ldi	r24, 0x36	; 54
     b14:	91 e0       	ldi	r25, 0x01	; 1
     b16:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b1a:	8d a1       	ldd	r24, Y+37	; 0x25
     b1c:	81 30       	cpi	r24, 0x01	; 1
     b1e:	09 f4       	brne	.+2      	; 0xb22 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b20:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b22:	0f 90       	pop	r0
     b24:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b26:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <xSchedulerRunning>
     b2a:	88 23       	and	r24, r24
     b2c:	39 f0       	breq	.+14     	; 0xb3c <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     b2e:	0f b6       	in	r0, 0x3f	; 63
     b30:	f8 94       	cli
     b32:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     b34:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     b38:	0f 90       	pop	r0
     b3a:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     b3c:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     b40:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
     b44:	c8 17       	cp	r28, r24
     b46:	d9 07       	cpc	r29, r25
     b48:	c1 f4       	brne	.+48     	; 0xb7a <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b4a:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <xSchedulerRunning>
     b4e:	88 23       	and	r24, r24
     b50:	19 f0       	breq	.+6      	; 0xb58 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b52:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
     b56:	11 c0       	rjmp	.+34     	; 0xb7a <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b58:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <xSuspendedTaskList>
     b5c:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxCurrentNumberOfTasks>
     b60:	98 13       	cpse	r25, r24
     b62:	05 c0       	rjmp	.+10     	; 0xb6e <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b64:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <__data_end+0x1>
     b68:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <__data_end>
     b6c:	06 c0       	rjmp	.+12     	; 0xb7a <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	1f 91       	pop	r17
     b74:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b76:	0c 94 29 05 	jmp	0xa52	; 0xa52 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	1f 91       	pop	r17
     b80:	0f 91       	pop	r16
     b82:	08 95       	ret

00000b84 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b8a:	60 91 26 01 	lds	r22, 0x0126	; 0x800126 <__data_end>
     b8e:	70 91 27 01 	lds	r23, 0x0127	; 0x800127 <__data_end+0x1>
     b92:	64 5f       	subi	r22, 0xF4	; 244
     b94:	7f 4f       	sbci	r23, 0xFF	; 255
     b96:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b9a:	61 e0       	ldi	r22, 0x01	; 1
     b9c:	ce 01       	movw	r24, r28
}
     b9e:	df 91       	pop	r29
     ba0:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ba2:	0c 94 03 01 	jmp	0x206	; 0x206 <prvAddCurrentTaskToDelayedList>

00000ba6 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     bac:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     bb0:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     bb4:	70 68       	ori	r23, 0x80	; 128
     bb6:	75 87       	std	Z+13, r23	; 0x0d
     bb8:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     bba:	60 91 26 01 	lds	r22, 0x0126	; 0x800126 <__data_end>
     bbe:	70 91 27 01 	lds	r23, 0x0127	; 0x800127 <__data_end+0x1>
     bc2:	64 5f       	subi	r22, 0xF4	; 244
     bc4:	7f 4f       	sbci	r23, 0xFF	; 255
     bc6:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bca:	61 e0       	ldi	r22, 0x01	; 1
     bcc:	ce 01       	movw	r24, r28
}
     bce:	df 91       	pop	r29
     bd0:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bd2:	0c 94 03 01 	jmp	0x206	; 0x206 <prvAddCurrentTaskToDelayedList>

00000bd6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     bd6:	0f 93       	push	r16
     bd8:	1f 93       	push	r17
     bda:	cf 93       	push	r28
     bdc:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     bde:	dc 01       	movw	r26, r24
     be0:	15 96       	adiw	r26, 0x05	; 5
     be2:	ed 91       	ld	r30, X+
     be4:	fc 91       	ld	r31, X
     be6:	16 97       	sbiw	r26, 0x06	; 6
     be8:	c6 81       	ldd	r28, Z+6	; 0x06
     bea:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     bec:	8e 01       	movw	r16, r28
     bee:	04 5f       	subi	r16, 0xF4	; 244
     bf0:	1f 4f       	sbci	r17, 0xFF	; 255
     bf2:	c8 01       	movw	r24, r16
     bf4:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     bf8:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
     bfc:	81 11       	cpse	r24, r1
     bfe:	14 c0       	rjmp	.+40     	; 0xc28 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c00:	0a 50       	subi	r16, 0x0A	; 10
     c02:	11 09       	sbc	r17, r1
     c04:	c8 01       	movw	r24, r16
     c06:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c0a:	8e 89       	ldd	r24, Y+22	; 0x16
     c0c:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     c10:	98 17       	cp	r25, r24
     c12:	10 f4       	brcc	.+4      	; 0xc18 <xTaskRemoveFromEventList+0x42>
     c14:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     c18:	b9 e0       	ldi	r27, 0x09	; 9
     c1a:	8b 9f       	mul	r24, r27
     c1c:	c0 01       	movw	r24, r0
     c1e:	11 24       	eor	r1, r1
     c20:	b8 01       	movw	r22, r16
     c22:	88 59       	subi	r24, 0x98	; 152
     c24:	9e 4f       	sbci	r25, 0xFE	; 254
     c26:	03 c0       	rjmp	.+6      	; 0xc2e <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c28:	b8 01       	movw	r22, r16
     c2a:	89 e4       	ldi	r24, 0x49	; 73
     c2c:	91 e0       	ldi	r25, 0x01	; 1
     c2e:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c32:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     c36:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     c3a:	9e 89       	ldd	r25, Y+22	; 0x16
     c3c:	86 89       	ldd	r24, Z+22	; 0x16
     c3e:	89 17       	cp	r24, r25
     c40:	20 f4       	brcc	.+8      	; 0xc4a <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c42:	81 e0       	ldi	r24, 0x01	; 1
     c44:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
     c48:	01 c0       	rjmp	.+2      	; 0xc4c <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c4a:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c4c:	df 91       	pop	r29
     c4e:	cf 91       	pop	r28
     c50:	1f 91       	pop	r17
     c52:	0f 91       	pop	r16
     c54:	08 95       	ret

00000c56 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c56:	0f 93       	push	r16
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c5e:	70 68       	ori	r23, 0x80	; 128
     c60:	fc 01       	movw	r30, r24
     c62:	71 83       	std	Z+1, r23	; 0x01
     c64:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c66:	c6 81       	ldd	r28, Z+6	; 0x06
     c68:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c6a:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c6e:	8e 01       	movw	r16, r28
     c70:	0e 5f       	subi	r16, 0xFE	; 254
     c72:	1f 4f       	sbci	r17, 0xFF	; 255
     c74:	c8 01       	movw	r24, r16
     c76:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c7a:	8e 89       	ldd	r24, Y+22	; 0x16
     c7c:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     c80:	98 17       	cp	r25, r24
     c82:	10 f4       	brcc	.+4      	; 0xc88 <vTaskRemoveFromUnorderedEventList+0x32>
     c84:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     c88:	f9 e0       	ldi	r31, 0x09	; 9
     c8a:	8f 9f       	mul	r24, r31
     c8c:	c0 01       	movw	r24, r0
     c8e:	11 24       	eor	r1, r1
     c90:	b8 01       	movw	r22, r16
     c92:	88 59       	subi	r24, 0x98	; 152
     c94:	9e 4f       	sbci	r25, 0xFE	; 254
     c96:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c9a:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     c9e:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     ca2:	9e 89       	ldd	r25, Y+22	; 0x16
     ca4:	86 89       	ldd	r24, Z+22	; 0x16
     ca6:	89 17       	cp	r24, r25
     ca8:	18 f4       	brcc	.+6      	; 0xcb0 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     caa:	81 e0       	ldi	r24, 0x01	; 1
     cac:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
	}
}
     cb0:	df 91       	pop	r29
     cb2:	cf 91       	pop	r28
     cb4:	1f 91       	pop	r17
     cb6:	0f 91       	pop	r16
     cb8:	08 95       	ret

00000cba <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     cba:	0f b6       	in	r0, 0x3f	; 63
     cbc:	f8 94       	cli
     cbe:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     cc0:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <xNumOfOverflows>
     cc4:	fc 01       	movw	r30, r24
     cc6:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     cc8:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <xTickCount>
     ccc:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <xTickCount+0x1>
     cd0:	32 83       	std	Z+2, r19	; 0x02
     cd2:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     cd4:	0f 90       	pop	r0
     cd6:	0f be       	out	0x3f, r0	; 63
     cd8:	08 95       	ret

00000cda <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     cda:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <xNumOfOverflows>
     cde:	fc 01       	movw	r30, r24
     ce0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     ce2:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <xTickCount>
     ce6:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <xTickCount+0x1>
     cea:	32 83       	std	Z+2, r19	; 0x02
     cec:	21 83       	std	Z+1, r18	; 0x01
     cee:	08 95       	ret

00000cf0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     cfa:	40 91 33 01 	lds	r20, 0x0133	; 0x800133 <xTickCount>
     cfe:	50 91 34 01 	lds	r21, 0x0134	; 0x800134 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     d02:	db 01       	movw	r26, r22
     d04:	2d 91       	ld	r18, X+
     d06:	3c 91       	ld	r19, X
     d08:	2f 3f       	cpi	r18, 0xFF	; 255
     d0a:	bf ef       	ldi	r27, 0xFF	; 255
     d0c:	3b 07       	cpc	r19, r27
     d0e:	d9 f0       	breq	.+54     	; 0xd46 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d10:	ec 01       	movw	r28, r24
     d12:	e9 81       	ldd	r30, Y+1	; 0x01
     d14:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d16:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <xNumOfOverflows>
     d1a:	b8 81       	ld	r27, Y
     d1c:	ba 17       	cp	r27, r26
     d1e:	19 f0       	breq	.+6      	; 0xd26 <xTaskCheckForTimeOut+0x36>
     d20:	4e 17       	cp	r20, r30
     d22:	5f 07       	cpc	r21, r31
     d24:	90 f4       	brcc	.+36     	; 0xd4a <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d26:	4e 1b       	sub	r20, r30
     d28:	5f 0b       	sbc	r21, r31
     d2a:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     d2c:	42 17       	cp	r20, r18
     d2e:	53 07       	cpc	r21, r19
     d30:	38 f4       	brcc	.+14     	; 0xd40 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     d32:	24 1b       	sub	r18, r20
     d34:	35 0b       	sbc	r19, r21
     d36:	31 83       	std	Z+1, r19	; 0x01
     d38:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     d3a:	0e 94 6d 06 	call	0xcda	; 0xcda <vTaskInternalSetTimeOutState>
     d3e:	03 c0       	rjmp	.+6      	; 0xd46 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     d40:	11 82       	std	Z+1, r1	; 0x01
     d42:	10 82       	st	Z, r1
     d44:	02 c0       	rjmp	.+4      	; 0xd4a <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	01 c0       	rjmp	.+2      	; 0xd4c <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d4a:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	08 95       	ret

00000d56 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
     d5c:	08 95       	ret

00000d5e <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d5e:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     d62:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     d66:	84 85       	ldd	r24, Z+12	; 0x0c
     d68:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d6a:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     d6e:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     d72:	a0 91 26 01 	lds	r26, 0x0126	; 0x800126 <__data_end>
     d76:	b0 91 27 01 	lds	r27, 0x0127	; 0x800127 <__data_end+0x1>
     d7a:	56 96       	adiw	r26, 0x16	; 22
     d7c:	4c 91       	ld	r20, X
     d7e:	24 e0       	ldi	r18, 0x04	; 4
     d80:	30 e0       	ldi	r19, 0x00	; 0
     d82:	24 1b       	sub	r18, r20
     d84:	31 09       	sbc	r19, r1
     d86:	35 87       	std	Z+13, r19	; 0x0d
     d88:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     d8a:	08 95       	ret

00000d8c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     d8c:	0f 93       	push	r16
     d8e:	1f 93       	push	r17
     d90:	18 2f       	mov	r17, r24
     d92:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     d94:	0f b6       	in	r0, 0x3f	; 63
     d96:	f8 94       	cli
     d98:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     d9a:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     d9e:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     da2:	41 a1       	ldd	r20, Z+33	; 0x21
     da4:	52 a1       	ldd	r21, Z+34	; 0x22
     da6:	63 a1       	ldd	r22, Z+35	; 0x23
     da8:	74 a1       	ldd	r23, Z+36	; 0x24
     daa:	45 2b       	or	r20, r21
     dac:	46 2b       	or	r20, r22
     dae:	47 2b       	or	r20, r23
     db0:	69 f4       	brne	.+26     	; 0xdcc <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     db2:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     db6:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     dba:	21 e0       	ldi	r18, 0x01	; 1
     dbc:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     dbe:	00 97       	sbiw	r24, 0x00	; 0
     dc0:	29 f0       	breq	.+10     	; 0xdcc <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     dc2:	61 e0       	ldi	r22, 0x01	; 1
     dc4:	0e 94 03 01 	call	0x206	; 0x206 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     dc8:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     dcc:	0f 90       	pop	r0
     dce:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     dd6:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     dda:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     dde:	61 a1       	ldd	r22, Z+33	; 0x21
     de0:	72 a1       	ldd	r23, Z+34	; 0x22
     de2:	83 a1       	ldd	r24, Z+35	; 0x23
     de4:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     de6:	61 15       	cp	r22, r1
     de8:	71 05       	cpc	r23, r1
     dea:	81 05       	cpc	r24, r1
     dec:	91 05       	cpc	r25, r1
     dee:	a9 f0       	breq	.+42     	; 0xe1a <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     df0:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     df4:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     df8:	11 23       	and	r17, r17
     dfa:	29 f0       	breq	.+10     	; 0xe06 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     dfc:	11 a2       	std	Z+33, r1	; 0x21
     dfe:	12 a2       	std	Z+34, r1	; 0x22
     e00:	13 a2       	std	Z+35, r1	; 0x23
     e02:	14 a2       	std	Z+36, r1	; 0x24
     e04:	0a c0       	rjmp	.+20     	; 0xe1a <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     e06:	8b 01       	movw	r16, r22
     e08:	9c 01       	movw	r18, r24
     e0a:	01 50       	subi	r16, 0x01	; 1
     e0c:	11 09       	sbc	r17, r1
     e0e:	21 09       	sbc	r18, r1
     e10:	31 09       	sbc	r19, r1
     e12:	01 a3       	std	Z+33, r16	; 0x21
     e14:	12 a3       	std	Z+34, r17	; 0x22
     e16:	23 a3       	std	Z+35, r18	; 0x23
     e18:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e1a:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     e1e:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     e22:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     e24:	0f 90       	pop	r0
     e26:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     e28:	1f 91       	pop	r17
     e2a:	0f 91       	pop	r16
     e2c:	08 95       	ret

00000e2e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     e2e:	4f 92       	push	r4
     e30:	5f 92       	push	r5
     e32:	6f 92       	push	r6
     e34:	7f 92       	push	r7
     e36:	8f 92       	push	r8
     e38:	9f 92       	push	r9
     e3a:	af 92       	push	r10
     e3c:	bf 92       	push	r11
     e3e:	ef 92       	push	r14
     e40:	ff 92       	push	r15
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	49 01       	movw	r8, r18
     e48:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e50:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     e54:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     e58:	25 a1       	ldd	r18, Z+37	; 0x25
     e5a:	22 30       	cpi	r18, 0x02	; 2
     e5c:	39 f1       	breq	.+78     	; 0xeac <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e5e:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     e62:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     e66:	21 a1       	ldd	r18, Z+33	; 0x21
     e68:	32 a1       	ldd	r19, Z+34	; 0x22
     e6a:	43 a1       	ldd	r20, Z+35	; 0x23
     e6c:	54 a1       	ldd	r21, Z+36	; 0x24
     e6e:	2b 01       	movw	r4, r22
     e70:	3c 01       	movw	r6, r24
     e72:	40 94       	com	r4
     e74:	50 94       	com	r5
     e76:	60 94       	com	r6
     e78:	70 94       	com	r7
     e7a:	d3 01       	movw	r26, r6
     e7c:	c2 01       	movw	r24, r4
     e7e:	82 23       	and	r24, r18
     e80:	93 23       	and	r25, r19
     e82:	a4 23       	and	r26, r20
     e84:	b5 23       	and	r27, r21
     e86:	81 a3       	std	Z+33, r24	; 0x21
     e88:	92 a3       	std	Z+34, r25	; 0x22
     e8a:	a3 a3       	std	Z+35, r26	; 0x23
     e8c:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e8e:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     e92:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e9a:	e1 14       	cp	r14, r1
     e9c:	f1 04       	cpc	r15, r1
     e9e:	31 f0       	breq	.+12     	; 0xeac <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ea0:	61 e0       	ldi	r22, 0x01	; 1
     ea2:	c7 01       	movw	r24, r14
     ea4:	0e 94 03 01 	call	0x206	; 0x206 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     ea8:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     eac:	0f 90       	pop	r0
     eae:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     eb6:	01 15       	cp	r16, r1
     eb8:	11 05       	cpc	r17, r1
     eba:	69 f0       	breq	.+26     	; 0xed6 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     ebc:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     ec0:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     ec4:	81 a1       	ldd	r24, Z+33	; 0x21
     ec6:	92 a1       	ldd	r25, Z+34	; 0x22
     ec8:	a3 a1       	ldd	r26, Z+35	; 0x23
     eca:	b4 a1       	ldd	r27, Z+36	; 0x24
     ecc:	f8 01       	movw	r30, r16
     ece:	80 83       	st	Z, r24
     ed0:	91 83       	std	Z+1, r25	; 0x01
     ed2:	a2 83       	std	Z+2, r26	; 0x02
     ed4:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     ed6:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     eda:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     ede:	85 a1       	ldd	r24, Z+37	; 0x25
     ee0:	82 30       	cpi	r24, 0x02	; 2
     ee2:	c1 f4       	brne	.+48     	; 0xf14 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     ee4:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     ee8:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     eec:	41 a1       	ldd	r20, Z+33	; 0x21
     eee:	52 a1       	ldd	r21, Z+34	; 0x22
     ef0:	63 a1       	ldd	r22, Z+35	; 0x23
     ef2:	74 a1       	ldd	r23, Z+36	; 0x24
     ef4:	d5 01       	movw	r26, r10
     ef6:	c4 01       	movw	r24, r8
     ef8:	80 95       	com	r24
     efa:	90 95       	com	r25
     efc:	a0 95       	com	r26
     efe:	b0 95       	com	r27
     f00:	84 23       	and	r24, r20
     f02:	95 23       	and	r25, r21
     f04:	a6 23       	and	r26, r22
     f06:	b7 23       	and	r27, r23
     f08:	81 a3       	std	Z+33, r24	; 0x21
     f0a:	92 a3       	std	Z+34, r25	; 0x22
     f0c:	a3 a3       	std	Z+35, r26	; 0x23
     f0e:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	01 c0       	rjmp	.+2      	; 0xf16 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     f14:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     f16:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     f1a:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     f1e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f20:	0f 90       	pop	r0
     f22:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f24:	1f 91       	pop	r17
     f26:	0f 91       	pop	r16
     f28:	ff 90       	pop	r15
     f2a:	ef 90       	pop	r14
     f2c:	bf 90       	pop	r11
     f2e:	af 90       	pop	r10
     f30:	9f 90       	pop	r9
     f32:	8f 90       	pop	r8
     f34:	7f 90       	pop	r7
     f36:	6f 90       	pop	r6
     f38:	5f 90       	pop	r5
     f3a:	4f 90       	pop	r4
     f3c:	08 95       	ret

00000f3e <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     f3e:	0f 93       	push	r16
     f40:	1f 93       	push	r17
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     f48:	0f b6       	in	r0, 0x3f	; 63
     f4a:	f8 94       	cli
     f4c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     f4e:	01 15       	cp	r16, r1
     f50:	11 05       	cpc	r17, r1
     f52:	49 f0       	breq	.+18     	; 0xf66 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f54:	81 a1       	ldd	r24, Z+33	; 0x21
     f56:	92 a1       	ldd	r25, Z+34	; 0x22
     f58:	a3 a1       	ldd	r26, Z+35	; 0x23
     f5a:	b4 a1       	ldd	r27, Z+36	; 0x24
     f5c:	e8 01       	movw	r28, r16
     f5e:	88 83       	st	Y, r24
     f60:	99 83       	std	Y+1, r25	; 0x01
     f62:	aa 83       	std	Y+2, r26	; 0x02
     f64:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f66:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f68:	82 e0       	ldi	r24, 0x02	; 2
     f6a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f6c:	22 30       	cpi	r18, 0x02	; 2
     f6e:	89 f0       	breq	.+34     	; 0xf92 <xTaskGenericNotify+0x54>
     f70:	58 f4       	brcc	.+22     	; 0xf88 <xTaskGenericNotify+0x4a>
     f72:	21 30       	cpi	r18, 0x01	; 1
     f74:	01 f5       	brne	.+64     	; 0xfb6 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f76:	81 a1       	ldd	r24, Z+33	; 0x21
     f78:	92 a1       	ldd	r25, Z+34	; 0x22
     f7a:	a3 a1       	ldd	r26, Z+35	; 0x23
     f7c:	b4 a1       	ldd	r27, Z+36	; 0x24
     f7e:	48 2b       	or	r20, r24
     f80:	59 2b       	or	r21, r25
     f82:	6a 2b       	or	r22, r26
     f84:	7b 2b       	or	r23, r27
     f86:	13 c0       	rjmp	.+38     	; 0xfae <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     f88:	23 30       	cpi	r18, 0x03	; 3
     f8a:	89 f0       	breq	.+34     	; 0xfae <xTaskGenericNotify+0x70>
     f8c:	24 30       	cpi	r18, 0x04	; 4
     f8e:	69 f0       	breq	.+26     	; 0xfaa <xTaskGenericNotify+0x6c>
     f90:	12 c0       	rjmp	.+36     	; 0xfb6 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     f92:	81 a1       	ldd	r24, Z+33	; 0x21
     f94:	92 a1       	ldd	r25, Z+34	; 0x22
     f96:	a3 a1       	ldd	r26, Z+35	; 0x23
     f98:	b4 a1       	ldd	r27, Z+36	; 0x24
     f9a:	01 96       	adiw	r24, 0x01	; 1
     f9c:	a1 1d       	adc	r26, r1
     f9e:	b1 1d       	adc	r27, r1
     fa0:	81 a3       	std	Z+33, r24	; 0x21
     fa2:	92 a3       	std	Z+34, r25	; 0x22
     fa4:	a3 a3       	std	Z+35, r26	; 0x23
     fa6:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     fa8:	06 c0       	rjmp	.+12     	; 0xfb6 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     faa:	32 30       	cpi	r19, 0x02	; 2
     fac:	49 f1       	breq	.+82     	; 0x1000 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     fae:	41 a3       	std	Z+33, r20	; 0x21
     fb0:	52 a3       	std	Z+34, r21	; 0x22
     fb2:	63 a3       	std	Z+35, r22	; 0x23
     fb4:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     fb6:	31 30       	cpi	r19, 0x01	; 1
     fb8:	09 f5       	brne	.+66     	; 0xffc <xTaskGenericNotify+0xbe>
     fba:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     fbc:	8f 01       	movw	r16, r30
     fbe:	0e 5f       	subi	r16, 0xFE	; 254
     fc0:	1f 4f       	sbci	r17, 0xFF	; 255
     fc2:	c8 01       	movw	r24, r16
     fc4:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     fc8:	8e 89       	ldd	r24, Y+22	; 0x16
     fca:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
     fce:	98 17       	cp	r25, r24
     fd0:	10 f4       	brcc	.+4      	; 0xfd6 <xTaskGenericNotify+0x98>
     fd2:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
     fd6:	29 e0       	ldi	r18, 0x09	; 9
     fd8:	82 9f       	mul	r24, r18
     fda:	c0 01       	movw	r24, r0
     fdc:	11 24       	eor	r1, r1
     fde:	b8 01       	movw	r22, r16
     fe0:	88 59       	subi	r24, 0x98	; 152
     fe2:	9e 4f       	sbci	r25, 0xFE	; 254
     fe4:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     fe8:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     fec:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
     ff0:	9e 89       	ldd	r25, Y+22	; 0x16
     ff2:	86 89       	ldd	r24, Z+22	; 0x16
     ff4:	89 17       	cp	r24, r25
     ff6:	10 f4       	brcc	.+4      	; 0xffc <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     ff8:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	01 c0       	rjmp	.+2      	; 0x1002 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1000:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	1f 91       	pop	r17
    100c:	0f 91       	pop	r16
    100e:	08 95       	ret

00001010 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1010:	ef 92       	push	r14
    1012:	ff 92       	push	r15
    1014:	0f 93       	push	r16
    1016:	1f 93       	push	r17
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    101e:	01 15       	cp	r16, r1
    1020:	11 05       	cpc	r17, r1
    1022:	49 f0       	breq	.+18     	; 0x1036 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1024:	81 a1       	ldd	r24, Z+33	; 0x21
    1026:	92 a1       	ldd	r25, Z+34	; 0x22
    1028:	a3 a1       	ldd	r26, Z+35	; 0x23
    102a:	b4 a1       	ldd	r27, Z+36	; 0x24
    102c:	e8 01       	movw	r28, r16
    102e:	88 83       	st	Y, r24
    1030:	99 83       	std	Y+1, r25	; 0x01
    1032:	aa 83       	std	Y+2, r26	; 0x02
    1034:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1036:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1038:	82 e0       	ldi	r24, 0x02	; 2
    103a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    103c:	22 30       	cpi	r18, 0x02	; 2
    103e:	89 f0       	breq	.+34     	; 0x1062 <xTaskGenericNotifyFromISR+0x52>
    1040:	58 f4       	brcc	.+22     	; 0x1058 <xTaskGenericNotifyFromISR+0x48>
    1042:	21 30       	cpi	r18, 0x01	; 1
    1044:	01 f5       	brne	.+64     	; 0x1086 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1046:	81 a1       	ldd	r24, Z+33	; 0x21
    1048:	92 a1       	ldd	r25, Z+34	; 0x22
    104a:	a3 a1       	ldd	r26, Z+35	; 0x23
    104c:	b4 a1       	ldd	r27, Z+36	; 0x24
    104e:	48 2b       	or	r20, r24
    1050:	59 2b       	or	r21, r25
    1052:	6a 2b       	or	r22, r26
    1054:	7b 2b       	or	r23, r27
    1056:	13 c0       	rjmp	.+38     	; 0x107e <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1058:	23 30       	cpi	r18, 0x03	; 3
    105a:	89 f0       	breq	.+34     	; 0x107e <xTaskGenericNotifyFromISR+0x6e>
    105c:	24 30       	cpi	r18, 0x04	; 4
    105e:	69 f0       	breq	.+26     	; 0x107a <xTaskGenericNotifyFromISR+0x6a>
    1060:	12 c0       	rjmp	.+36     	; 0x1086 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1062:	81 a1       	ldd	r24, Z+33	; 0x21
    1064:	92 a1       	ldd	r25, Z+34	; 0x22
    1066:	a3 a1       	ldd	r26, Z+35	; 0x23
    1068:	b4 a1       	ldd	r27, Z+36	; 0x24
    106a:	01 96       	adiw	r24, 0x01	; 1
    106c:	a1 1d       	adc	r26, r1
    106e:	b1 1d       	adc	r27, r1
    1070:	81 a3       	std	Z+33, r24	; 0x21
    1072:	92 a3       	std	Z+34, r25	; 0x22
    1074:	a3 a3       	std	Z+35, r26	; 0x23
    1076:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1078:	06 c0       	rjmp	.+12     	; 0x1086 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    107a:	32 30       	cpi	r19, 0x02	; 2
    107c:	d9 f1       	breq	.+118    	; 0x10f4 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    107e:	41 a3       	std	Z+33, r20	; 0x21
    1080:	52 a3       	std	Z+34, r21	; 0x22
    1082:	63 a3       	std	Z+35, r22	; 0x23
    1084:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1086:	31 30       	cpi	r19, 0x01	; 1
    1088:	11 f0       	breq	.+4      	; 0x108e <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	34 c0       	rjmp	.+104    	; 0x10f6 <xTaskGenericNotifyFromISR+0xe6>
    108e:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1090:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    1094:	81 11       	cpse	r24, r1
    1096:	15 c0       	rjmp	.+42     	; 0x10c2 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1098:	8f 01       	movw	r16, r30
    109a:	0e 5f       	subi	r16, 0xFE	; 254
    109c:	1f 4f       	sbci	r17, 0xFF	; 255
    109e:	c8 01       	movw	r24, r16
    10a0:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    10a4:	8e 89       	ldd	r24, Y+22	; 0x16
    10a6:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
    10aa:	98 17       	cp	r25, r24
    10ac:	10 f4       	brcc	.+4      	; 0x10b2 <xTaskGenericNotifyFromISR+0xa2>
    10ae:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
    10b2:	e9 e0       	ldi	r30, 0x09	; 9
    10b4:	8e 9f       	mul	r24, r30
    10b6:	c0 01       	movw	r24, r0
    10b8:	11 24       	eor	r1, r1
    10ba:	b8 01       	movw	r22, r16
    10bc:	88 59       	subi	r24, 0x98	; 152
    10be:	9e 4f       	sbci	r25, 0xFE	; 254
    10c0:	05 c0       	rjmp	.+10     	; 0x10cc <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    10c2:	bf 01       	movw	r22, r30
    10c4:	64 5f       	subi	r22, 0xF4	; 244
    10c6:	7f 4f       	sbci	r23, 0xFF	; 255
    10c8:	89 e4       	ldi	r24, 0x49	; 73
    10ca:	91 e0       	ldi	r25, 0x01	; 1
    10cc:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10d0:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
    10d4:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
    10d8:	9e 89       	ldd	r25, Y+22	; 0x16
    10da:	86 89       	ldd	r24, Z+22	; 0x16
    10dc:	89 17       	cp	r24, r25
    10de:	a8 f6       	brcc	.-86     	; 0x108a <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    10e0:	e1 14       	cp	r14, r1
    10e2:	f1 04       	cpc	r15, r1
    10e4:	19 f0       	breq	.+6      	; 0x10ec <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	e7 01       	movw	r28, r14
    10ea:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
    10f2:	01 c0       	rjmp	.+2      	; 0x10f6 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10f4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    10f6:	df 91       	pop	r29
    10f8:	cf 91       	pop	r28
    10fa:	1f 91       	pop	r17
    10fc:	0f 91       	pop	r16
    10fe:	ff 90       	pop	r15
    1100:	ef 90       	pop	r14
    1102:	08 95       	ret

00001104 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1104:	ef 92       	push	r14
    1106:	ff 92       	push	r15
    1108:	0f 93       	push	r16
    110a:	1f 93       	push	r17
    110c:	cf 93       	push	r28
    110e:	df 93       	push	r29
    1110:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1112:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1114:	82 e0       	ldi	r24, 0x02	; 2
    1116:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1118:	81 a1       	ldd	r24, Z+33	; 0x21
    111a:	92 a1       	ldd	r25, Z+34	; 0x22
    111c:	a3 a1       	ldd	r26, Z+35	; 0x23
    111e:	b4 a1       	ldd	r27, Z+36	; 0x24
    1120:	01 96       	adiw	r24, 0x01	; 1
    1122:	a1 1d       	adc	r26, r1
    1124:	b1 1d       	adc	r27, r1
    1126:	81 a3       	std	Z+33, r24	; 0x21
    1128:	92 a3       	std	Z+34, r25	; 0x22
    112a:	a3 a3       	std	Z+35, r26	; 0x23
    112c:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    112e:	21 30       	cpi	r18, 0x01	; 1
    1130:	a1 f5       	brne	.+104    	; 0x119a <vTaskNotifyGiveFromISR+0x96>
    1132:	8b 01       	movw	r16, r22
    1134:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1136:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    113a:	81 11       	cpse	r24, r1
    113c:	16 c0       	rjmp	.+44     	; 0x116a <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    113e:	7f 01       	movw	r14, r30
    1140:	22 e0       	ldi	r18, 0x02	; 2
    1142:	e2 0e       	add	r14, r18
    1144:	f1 1c       	adc	r15, r1
    1146:	c7 01       	movw	r24, r14
    1148:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    114c:	8e 89       	ldd	r24, Y+22	; 0x16
    114e:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <uxTopReadyPriority>
    1152:	98 17       	cp	r25, r24
    1154:	10 f4       	brcc	.+4      	; 0x115a <vTaskNotifyGiveFromISR+0x56>
    1156:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <uxTopReadyPriority>
    115a:	e9 e0       	ldi	r30, 0x09	; 9
    115c:	8e 9f       	mul	r24, r30
    115e:	c0 01       	movw	r24, r0
    1160:	11 24       	eor	r1, r1
    1162:	b7 01       	movw	r22, r14
    1164:	88 59       	subi	r24, 0x98	; 152
    1166:	9e 4f       	sbci	r25, 0xFE	; 254
    1168:	05 c0       	rjmp	.+10     	; 0x1174 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    116a:	bf 01       	movw	r22, r30
    116c:	64 5f       	subi	r22, 0xF4	; 244
    116e:	7f 4f       	sbci	r23, 0xFF	; 255
    1170:	89 e4       	ldi	r24, 0x49	; 73
    1172:	91 e0       	ldi	r25, 0x01	; 1
    1174:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1178:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
    117c:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
    1180:	9e 89       	ldd	r25, Y+22	; 0x16
    1182:	86 89       	ldd	r24, Z+22	; 0x16
    1184:	89 17       	cp	r24, r25
    1186:	48 f4       	brcc	.+18     	; 0x119a <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1188:	01 15       	cp	r16, r1
    118a:	11 05       	cpc	r17, r1
    118c:	19 f0       	breq	.+6      	; 0x1194 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    118e:	81 e0       	ldi	r24, 0x01	; 1
    1190:	f8 01       	movw	r30, r16
    1192:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	1f 91       	pop	r17
    11a0:	0f 91       	pop	r16
    11a2:	ff 90       	pop	r15
    11a4:	ef 90       	pop	r14
    11a6:	08 95       	ret

000011a8 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    11a8:	00 97       	sbiw	r24, 0x00	; 0
    11aa:	21 f4       	brne	.+8      	; 0x11b4 <xTaskNotifyStateClear+0xc>
    11ac:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
    11b0:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>

		taskENTER_CRITICAL();
    11b4:	0f b6       	in	r0, 0x3f	; 63
    11b6:	f8 94       	cli
    11b8:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    11ba:	fc 01       	movw	r30, r24
    11bc:	25 a1       	ldd	r18, Z+37	; 0x25
    11be:	22 30       	cpi	r18, 0x02	; 2
    11c0:	19 f4       	brne	.+6      	; 0x11c8 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11c2:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    11c4:	81 e0       	ldi	r24, 0x01	; 1
    11c6:	01 c0       	rjmp	.+2      	; 0x11ca <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    11c8:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    11ca:	0f 90       	pop	r0
    11cc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11ce:	08 95       	ret

000011d0 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11d0:	0f b6       	in	r0, 0x3f	; 63
    11d2:	f8 94       	cli
    11d4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    11d6:	fc 01       	movw	r30, r24
    11d8:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    11da:	0f 90       	pop	r0
    11dc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	91 11       	cpse	r25, r1
    11e2:	80 e0       	ldi	r24, 0x00	; 0
}
    11e4:	08 95       	ret

000011e6 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    11e6:	0f 93       	push	r16
    11e8:	1f 93       	push	r17
    11ea:	cf 93       	push	r28
    11ec:	df 93       	push	r29
    11ee:	ec 01       	movw	r28, r24
    11f0:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11f2:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    11f4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11f6:	44 23       	and	r20, r20
    11f8:	b1 f1       	breq	.+108    	; 0x1266 <prvCopyDataToQueue+0x80>
    11fa:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    11fc:	01 11       	cpse	r16, r1
    11fe:	15 c0       	rjmp	.+42     	; 0x122a <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1200:	8a 81       	ldd	r24, Y+2	; 0x02
    1202:	9b 81       	ldd	r25, Y+3	; 0x03
    1204:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1208:	2c 8d       	ldd	r18, Y+28	; 0x1c
    120a:	8a 81       	ldd	r24, Y+2	; 0x02
    120c:	9b 81       	ldd	r25, Y+3	; 0x03
    120e:	82 0f       	add	r24, r18
    1210:	91 1d       	adc	r25, r1
    1212:	9b 83       	std	Y+3, r25	; 0x03
    1214:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1216:	2c 81       	ldd	r18, Y+4	; 0x04
    1218:	3d 81       	ldd	r19, Y+5	; 0x05
    121a:	82 17       	cp	r24, r18
    121c:	93 07       	cpc	r25, r19
    121e:	18 f1       	brcs	.+70     	; 0x1266 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1220:	88 81       	ld	r24, Y
    1222:	99 81       	ldd	r25, Y+1	; 0x01
    1224:	9b 83       	std	Y+3, r25	; 0x03
    1226:	8a 83       	std	Y+2, r24	; 0x02
    1228:	1e c0       	rjmp	.+60     	; 0x1266 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    122a:	8e 81       	ldd	r24, Y+6	; 0x06
    122c:	9f 81       	ldd	r25, Y+7	; 0x07
    122e:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1232:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	91 95       	neg	r25
    1238:	81 95       	neg	r24
    123a:	91 09       	sbc	r25, r1
    123c:	2e 81       	ldd	r18, Y+6	; 0x06
    123e:	3f 81       	ldd	r19, Y+7	; 0x07
    1240:	28 0f       	add	r18, r24
    1242:	39 1f       	adc	r19, r25
    1244:	3f 83       	std	Y+7, r19	; 0x07
    1246:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1248:	48 81       	ld	r20, Y
    124a:	59 81       	ldd	r21, Y+1	; 0x01
    124c:	24 17       	cp	r18, r20
    124e:	35 07       	cpc	r19, r21
    1250:	30 f4       	brcc	.+12     	; 0x125e <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1252:	2c 81       	ldd	r18, Y+4	; 0x04
    1254:	3d 81       	ldd	r19, Y+5	; 0x05
    1256:	82 0f       	add	r24, r18
    1258:	93 1f       	adc	r25, r19
    125a:	9f 83       	std	Y+7, r25	; 0x07
    125c:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    125e:	02 30       	cpi	r16, 0x02	; 2
    1260:	11 f4       	brne	.+4      	; 0x1266 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1262:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1264:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1266:	1f 5f       	subi	r17, 0xFF	; 255
    1268:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	df 91       	pop	r29
    126e:	cf 91       	pop	r28
    1270:	1f 91       	pop	r17
    1272:	0f 91       	pop	r16
    1274:	08 95       	ret

00001276 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1276:	fc 01       	movw	r30, r24
    1278:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    127a:	44 8d       	ldd	r20, Z+28	; 0x1c
    127c:	44 23       	and	r20, r20
    127e:	a1 f0       	breq	.+40     	; 0x12a8 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1280:	50 e0       	ldi	r21, 0x00	; 0
    1282:	26 81       	ldd	r18, Z+6	; 0x06
    1284:	37 81       	ldd	r19, Z+7	; 0x07
    1286:	24 0f       	add	r18, r20
    1288:	35 1f       	adc	r19, r21
    128a:	37 83       	std	Z+7, r19	; 0x07
    128c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    128e:	64 81       	ldd	r22, Z+4	; 0x04
    1290:	75 81       	ldd	r23, Z+5	; 0x05
    1292:	26 17       	cp	r18, r22
    1294:	37 07       	cpc	r19, r23
    1296:	20 f0       	brcs	.+8      	; 0x12a0 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1298:	20 81       	ld	r18, Z
    129a:	31 81       	ldd	r19, Z+1	; 0x01
    129c:	37 83       	std	Z+7, r19	; 0x07
    129e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    12a0:	66 81       	ldd	r22, Z+6	; 0x06
    12a2:	77 81       	ldd	r23, Z+7	; 0x07
    12a4:	0c 94 6b 12 	jmp	0x24d6	; 0x24d6 <memcpy>
    12a8:	08 95       	ret

000012aa <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    12aa:	ef 92       	push	r14
    12ac:	ff 92       	push	r15
    12ae:	1f 93       	push	r17
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
    12b4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    12b6:	0f b6       	in	r0, 0x3f	; 63
    12b8:	f8 94       	cli
    12ba:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    12bc:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12be:	7c 01       	movw	r14, r24
    12c0:	81 e1       	ldi	r24, 0x11	; 17
    12c2:	e8 0e       	add	r14, r24
    12c4:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    12c6:	11 16       	cp	r1, r17
    12c8:	5c f4       	brge	.+22     	; 0x12e0 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12ca:	89 89       	ldd	r24, Y+17	; 0x11
    12cc:	88 23       	and	r24, r24
    12ce:	41 f0       	breq	.+16     	; 0x12e0 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12d0:	c7 01       	movw	r24, r14
    12d2:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    12d6:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    12d8:	0e 94 ab 06 	call	0xd56	; 0xd56 <vTaskMissedYield>
    12dc:	11 50       	subi	r17, 0x01	; 1
    12de:	f3 cf       	rjmp	.-26     	; 0x12c6 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    12e0:	8f ef       	ldi	r24, 0xFF	; 255
    12e2:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    12e4:	0f 90       	pop	r0
    12e6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    12e8:	0f b6       	in	r0, 0x3f	; 63
    12ea:	f8 94       	cli
    12ec:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    12ee:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12f0:	7e 01       	movw	r14, r28
    12f2:	88 e0       	ldi	r24, 0x08	; 8
    12f4:	e8 0e       	add	r14, r24
    12f6:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    12f8:	11 16       	cp	r1, r17
    12fa:	5c f4       	brge	.+22     	; 0x1312 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12fc:	88 85       	ldd	r24, Y+8	; 0x08
    12fe:	88 23       	and	r24, r24
    1300:	41 f0       	breq	.+16     	; 0x1312 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1302:	c7 01       	movw	r24, r14
    1304:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    1308:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    130a:	0e 94 ab 06 	call	0xd56	; 0xd56 <vTaskMissedYield>
    130e:	11 50       	subi	r17, 0x01	; 1
    1310:	f3 cf       	rjmp	.-26     	; 0x12f8 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1312:	8f ef       	ldi	r24, 0xFF	; 255
    1314:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63
}
    131a:	df 91       	pop	r29
    131c:	cf 91       	pop	r28
    131e:	1f 91       	pop	r17
    1320:	ff 90       	pop	r15
    1322:	ef 90       	pop	r14
    1324:	08 95       	ret

00001326 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	f8 94       	cli
    1330:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1332:	48 81       	ld	r20, Y
    1334:	59 81       	ldd	r21, Y+1	; 0x01
    1336:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1338:	7c 8d       	ldd	r23, Y+28	; 0x1c
    133a:	9a 01       	movw	r18, r20
    133c:	87 9f       	mul	r24, r23
    133e:	20 0d       	add	r18, r0
    1340:	31 1d       	adc	r19, r1
    1342:	11 24       	eor	r1, r1
    1344:	3d 83       	std	Y+5, r19	; 0x05
    1346:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1348:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    134a:	5b 83       	std	Y+3, r21	; 0x03
    134c:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	01 97       	sbiw	r24, 0x01	; 1
    1352:	78 9f       	mul	r23, r24
    1354:	90 01       	movw	r18, r0
    1356:	79 9f       	mul	r23, r25
    1358:	30 0d       	add	r19, r0
    135a:	11 24       	eor	r1, r1
    135c:	ca 01       	movw	r24, r20
    135e:	82 0f       	add	r24, r18
    1360:	93 1f       	adc	r25, r19
    1362:	9f 83       	std	Y+7, r25	; 0x07
    1364:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1366:	8f ef       	ldi	r24, 0xFF	; 255
    1368:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    136a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    136c:	61 11       	cpse	r22, r1
    136e:	0c c0       	rjmp	.+24     	; 0x1388 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1370:	88 85       	ldd	r24, Y+8	; 0x08
    1372:	88 23       	and	r24, r24
    1374:	89 f0       	breq	.+34     	; 0x1398 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1376:	ce 01       	movw	r24, r28
    1378:	08 96       	adiw	r24, 0x08	; 8
    137a:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    137e:	88 23       	and	r24, r24
    1380:	59 f0       	breq	.+22     	; 0x1398 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1382:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
    1386:	08 c0       	rjmp	.+16     	; 0x1398 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1388:	ce 01       	movw	r24, r28
    138a:	08 96       	adiw	r24, 0x08	; 8
    138c:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1390:	ce 01       	movw	r24, r28
    1392:	41 96       	adiw	r24, 0x11	; 17
    1394:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1398:	0f 90       	pop	r0
    139a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    139c:	81 e0       	ldi	r24, 0x01	; 1
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
    13a2:	08 95       	ret

000013a4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    13a4:	0f 93       	push	r16
    13a6:	1f 93       	push	r17
    13a8:	cf 93       	push	r28
    13aa:	df 93       	push	r29
    13ac:	08 2f       	mov	r16, r24
    13ae:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    13b0:	66 23       	and	r22, r22
    13b2:	21 f0       	breq	.+8      	; 0x13bc <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13b4:	86 9f       	mul	r24, r22
    13b6:	c0 01       	movw	r24, r0
    13b8:	11 24       	eor	r1, r1
    13ba:	02 c0       	rjmp	.+4      	; 0x13c0 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    13c0:	4f 96       	adiw	r24, 0x1f	; 31
    13c2:	0e 94 29 10 	call	0x2052	; 0x2052 <pvPortMalloc>
    13c6:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    13c8:	00 97       	sbiw	r24, 0x00	; 0
    13ca:	71 f0       	breq	.+28     	; 0x13e8 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    13cc:	11 11       	cpse	r17, r1
    13ce:	03 c0       	rjmp	.+6      	; 0x13d6 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    13d0:	99 83       	std	Y+1, r25	; 0x01
    13d2:	88 83       	st	Y, r24
    13d4:	03 c0       	rjmp	.+6      	; 0x13dc <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    13d6:	4f 96       	adiw	r24, 0x1f	; 31
    13d8:	99 83       	std	Y+1, r25	; 0x01
    13da:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    13dc:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    13de:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    13e0:	61 e0       	ldi	r22, 0x01	; 1
    13e2:	ce 01       	movw	r24, r28
    13e4:	0e 94 93 09 	call	0x1326	; 0x1326 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    13e8:	ce 01       	movw	r24, r28
    13ea:	df 91       	pop	r29
    13ec:	cf 91       	pop	r28
    13ee:	1f 91       	pop	r17
    13f0:	0f 91       	pop	r16
    13f2:	08 95       	ret

000013f4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    13f4:	af 92       	push	r10
    13f6:	bf 92       	push	r11
    13f8:	cf 92       	push	r12
    13fa:	df 92       	push	r13
    13fc:	ff 92       	push	r15
    13fe:	0f 93       	push	r16
    1400:	1f 93       	push	r17
    1402:	cf 93       	push	r28
    1404:	df 93       	push	r29
    1406:	00 d0       	rcall	.+0      	; 0x1408 <xQueueGenericSend+0x14>
    1408:	00 d0       	rcall	.+0      	; 0x140a <xQueueGenericSend+0x16>
    140a:	1f 92       	push	r1
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	8c 01       	movw	r16, r24
    1412:	6b 01       	movw	r12, r22
    1414:	5d 83       	std	Y+5, r21	; 0x05
    1416:	4c 83       	std	Y+4, r20	; 0x04
    1418:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    141a:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    141c:	58 01       	movw	r10, r16
    141e:	98 e0       	ldi	r25, 0x08	; 8
    1420:	a9 0e       	add	r10, r25
    1422:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    142a:	f8 01       	movw	r30, r16
    142c:	22 8d       	ldd	r18, Z+26	; 0x1a
    142e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1430:	29 17       	cp	r18, r25
    1432:	18 f0       	brcs	.+6      	; 0x143a <xQueueGenericSend+0x46>
    1434:	f2 e0       	ldi	r31, 0x02	; 2
    1436:	ff 12       	cpse	r15, r31
    1438:	14 c0       	rjmp	.+40     	; 0x1462 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    143a:	4f 2d       	mov	r20, r15
    143c:	b6 01       	movw	r22, r12
    143e:	c8 01       	movw	r24, r16
    1440:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1444:	f8 01       	movw	r30, r16
    1446:	91 89       	ldd	r25, Z+17	; 0x11
    1448:	99 23       	and	r25, r25
    144a:	21 f0       	breq	.+8      	; 0x1454 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    144c:	c8 01       	movw	r24, r16
    144e:	41 96       	adiw	r24, 0x11	; 17
    1450:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    1454:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1456:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    145a:	0f 90       	pop	r0
    145c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	50 c0       	rjmp	.+160    	; 0x1502 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1462:	2c 81       	ldd	r18, Y+4	; 0x04
    1464:	3d 81       	ldd	r19, Y+5	; 0x05
    1466:	23 2b       	or	r18, r19
    1468:	19 f4       	brne	.+6      	; 0x1470 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    146a:	0f 90       	pop	r0
    146c:	0f be       	out	0x3f, r0	; 63
    146e:	48 c0       	rjmp	.+144    	; 0x1500 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1470:	81 11       	cpse	r24, r1
    1472:	04 c0       	rjmp	.+8      	; 0x147c <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1474:	ce 01       	movw	r24, r28
    1476:	01 96       	adiw	r24, 0x01	; 1
    1478:	0e 94 6d 06 	call	0xcda	; 0xcda <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    147c:	0f 90       	pop	r0
    147e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1480:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1484:	0f b6       	in	r0, 0x3f	; 63
    1486:	f8 94       	cli
    1488:	0f 92       	push	r0
    148a:	f8 01       	movw	r30, r16
    148c:	85 8d       	ldd	r24, Z+29	; 0x1d
    148e:	8f 3f       	cpi	r24, 0xFF	; 255
    1490:	09 f4       	brne	.+2      	; 0x1494 <xQueueGenericSend+0xa0>
    1492:	15 8e       	std	Z+29, r1	; 0x1d
    1494:	f8 01       	movw	r30, r16
    1496:	86 8d       	ldd	r24, Z+30	; 0x1e
    1498:	8f 3f       	cpi	r24, 0xFF	; 255
    149a:	09 f4       	brne	.+2      	; 0x149e <xQueueGenericSend+0xaa>
    149c:	16 8e       	std	Z+30, r1	; 0x1e
    149e:	0f 90       	pop	r0
    14a0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14a2:	be 01       	movw	r22, r28
    14a4:	6c 5f       	subi	r22, 0xFC	; 252
    14a6:	7f 4f       	sbci	r23, 0xFF	; 255
    14a8:	ce 01       	movw	r24, r28
    14aa:	01 96       	adiw	r24, 0x01	; 1
    14ac:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCheckForTimeOut>
    14b0:	81 11       	cpse	r24, r1
    14b2:	21 c0       	rjmp	.+66     	; 0x14f6 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	f8 94       	cli
    14b8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    14ba:	f8 01       	movw	r30, r16
    14bc:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    14c4:	98 13       	cpse	r25, r24
    14c6:	11 c0       	rjmp	.+34     	; 0x14ea <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14c8:	6c 81       	ldd	r22, Y+4	; 0x04
    14ca:	7d 81       	ldd	r23, Y+5	; 0x05
    14cc:	c5 01       	movw	r24, r10
    14ce:	0e 94 c2 05 	call	0xb84	; 0xb84 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14d2:	c8 01       	movw	r24, r16
    14d4:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14d8:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    14dc:	88 23       	and	r24, r24
    14de:	11 f0       	breq	.+4      	; 0x14e4 <xQueueGenericSend+0xf0>
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	a0 cf       	rjmp	.-192    	; 0x1424 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    14e4:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
    14e8:	fb cf       	rjmp	.-10     	; 0x14e0 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14ea:	c8 01       	movw	r24, r16
    14ec:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14f0:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    14f4:	f5 cf       	rjmp	.-22     	; 0x14e0 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    14f6:	c8 01       	movw	r24, r16
    14f8:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14fc:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1500:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1502:	0f 90       	pop	r0
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	0f 90       	pop	r0
    150c:	df 91       	pop	r29
    150e:	cf 91       	pop	r28
    1510:	1f 91       	pop	r17
    1512:	0f 91       	pop	r16
    1514:	ff 90       	pop	r15
    1516:	df 90       	pop	r13
    1518:	cf 90       	pop	r12
    151a:	bf 90       	pop	r11
    151c:	af 90       	pop	r10
    151e:	08 95       	ret

00001520 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1520:	ef 92       	push	r14
    1522:	ff 92       	push	r15
    1524:	1f 93       	push	r17
    1526:	cf 93       	push	r28
    1528:	df 93       	push	r29
    152a:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    152c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    152e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1530:	98 17       	cp	r25, r24
    1532:	10 f0       	brcs	.+4      	; 0x1538 <xQueueGenericSendFromISR+0x18>
    1534:	22 30       	cpi	r18, 0x02	; 2
    1536:	e1 f4       	brne	.+56     	; 0x1570 <xQueueGenericSendFromISR+0x50>
    1538:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    153a:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    153c:	42 2f       	mov	r20, r18
    153e:	ce 01       	movw	r24, r28
    1540:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1544:	1f 3f       	cpi	r17, 0xFF	; 255
    1546:	81 f4       	brne	.+32     	; 0x1568 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1548:	89 89       	ldd	r24, Y+17	; 0x11
    154a:	88 23       	and	r24, r24
    154c:	79 f0       	breq	.+30     	; 0x156c <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    154e:	ce 01       	movw	r24, r28
    1550:	41 96       	adiw	r24, 0x11	; 17
    1552:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    1556:	88 23       	and	r24, r24
    1558:	49 f0       	breq	.+18     	; 0x156c <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    155a:	e1 14       	cp	r14, r1
    155c:	f1 04       	cpc	r15, r1
    155e:	31 f0       	breq	.+12     	; 0x156c <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1560:	81 e0       	ldi	r24, 0x01	; 1
    1562:	f7 01       	movw	r30, r14
    1564:	80 83       	st	Z, r24
    1566:	05 c0       	rjmp	.+10     	; 0x1572 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1568:	1f 5f       	subi	r17, 0xFF	; 255
    156a:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	01 c0       	rjmp	.+2      	; 0x1572 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1570:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1572:	df 91       	pop	r29
    1574:	cf 91       	pop	r28
    1576:	1f 91       	pop	r17
    1578:	ff 90       	pop	r15
    157a:	ef 90       	pop	r14
    157c:	08 95       	ret

0000157e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1584:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1586:	83 8d       	ldd	r24, Z+27	; 0x1b
    1588:	98 17       	cp	r25, r24
    158a:	c0 f4       	brcc	.+48     	; 0x15bc <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    158c:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    158e:	9f 5f       	subi	r25, 0xFF	; 255
    1590:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1592:	8f 3f       	cpi	r24, 0xFF	; 255
    1594:	79 f4       	brne	.+30     	; 0x15b4 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1596:	81 89       	ldd	r24, Z+17	; 0x11
    1598:	88 23       	and	r24, r24
    159a:	71 f0       	breq	.+28     	; 0x15b8 <xQueueGiveFromISR+0x3a>
    159c:	eb 01       	movw	r28, r22
    159e:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15a0:	41 96       	adiw	r24, 0x11	; 17
    15a2:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    15a6:	88 23       	and	r24, r24
    15a8:	39 f0       	breq	.+14     	; 0x15b8 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15aa:	20 97       	sbiw	r28, 0x00	; 0
    15ac:	29 f0       	breq	.+10     	; 0x15b8 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15ae:	81 e0       	ldi	r24, 0x01	; 1
    15b0:	88 83       	st	Y, r24
    15b2:	05 c0       	rjmp	.+10     	; 0x15be <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15b4:	8f 5f       	subi	r24, 0xFF	; 255
    15b6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	01 c0       	rjmp	.+2      	; 0x15be <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15bc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	08 95       	ret

000015c4 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    15c4:	af 92       	push	r10
    15c6:	bf 92       	push	r11
    15c8:	cf 92       	push	r12
    15ca:	df 92       	push	r13
    15cc:	ff 92       	push	r15
    15ce:	0f 93       	push	r16
    15d0:	1f 93       	push	r17
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	00 d0       	rcall	.+0      	; 0x15d8 <xQueueReceive+0x14>
    15d8:	00 d0       	rcall	.+0      	; 0x15da <xQueueReceive+0x16>
    15da:	1f 92       	push	r1
    15dc:	cd b7       	in	r28, 0x3d	; 61
    15de:	de b7       	in	r29, 0x3e	; 62
    15e0:	8c 01       	movw	r16, r24
    15e2:	6b 01       	movw	r12, r22
    15e4:	5d 83       	std	Y+5, r21	; 0x05
    15e6:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    15e8:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15ea:	58 01       	movw	r10, r16
    15ec:	91 e1       	ldi	r25, 0x11	; 17
    15ee:	a9 0e       	add	r10, r25
    15f0:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15f2:	0f b6       	in	r0, 0x3f	; 63
    15f4:	f8 94       	cli
    15f6:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15f8:	f8 01       	movw	r30, r16
    15fa:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15fc:	ff 20       	and	r15, r15
    15fe:	a9 f0       	breq	.+42     	; 0x162a <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1600:	b6 01       	movw	r22, r12
    1602:	c8 01       	movw	r24, r16
    1604:	0e 94 3b 09 	call	0x1276	; 0x1276 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1608:	fa 94       	dec	r15
    160a:	f8 01       	movw	r30, r16
    160c:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    160e:	80 85       	ldd	r24, Z+8	; 0x08
    1610:	88 23       	and	r24, r24
    1612:	39 f0       	breq	.+14     	; 0x1622 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1614:	c8 01       	movw	r24, r16
    1616:	08 96       	adiw	r24, 0x08	; 8
    1618:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    161c:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    161e:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1622:	0f 90       	pop	r0
    1624:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	50 c0       	rjmp	.+160    	; 0x16ca <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    162a:	2c 81       	ldd	r18, Y+4	; 0x04
    162c:	3d 81       	ldd	r19, Y+5	; 0x05
    162e:	23 2b       	or	r18, r19
    1630:	19 f4       	brne	.+6      	; 0x1638 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1632:	0f 90       	pop	r0
    1634:	0f be       	out	0x3f, r0	; 63
    1636:	48 c0       	rjmp	.+144    	; 0x16c8 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1638:	81 11       	cpse	r24, r1
    163a:	04 c0       	rjmp	.+8      	; 0x1644 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    163c:	ce 01       	movw	r24, r28
    163e:	01 96       	adiw	r24, 0x01	; 1
    1640:	0e 94 6d 06 	call	0xcda	; 0xcda <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1644:	0f 90       	pop	r0
    1646:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1648:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	0f 92       	push	r0
    1652:	f8 01       	movw	r30, r16
    1654:	85 8d       	ldd	r24, Z+29	; 0x1d
    1656:	8f 3f       	cpi	r24, 0xFF	; 255
    1658:	09 f4       	brne	.+2      	; 0x165c <xQueueReceive+0x98>
    165a:	15 8e       	std	Z+29, r1	; 0x1d
    165c:	f8 01       	movw	r30, r16
    165e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1660:	8f 3f       	cpi	r24, 0xFF	; 255
    1662:	09 f4       	brne	.+2      	; 0x1666 <xQueueReceive+0xa2>
    1664:	16 8e       	std	Z+30, r1	; 0x1e
    1666:	0f 90       	pop	r0
    1668:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    166a:	be 01       	movw	r22, r28
    166c:	6c 5f       	subi	r22, 0xFC	; 252
    166e:	7f 4f       	sbci	r23, 0xFF	; 255
    1670:	ce 01       	movw	r24, r28
    1672:	01 96       	adiw	r24, 0x01	; 1
    1674:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCheckForTimeOut>
    1678:	81 11       	cpse	r24, r1
    167a:	1c c0       	rjmp	.+56     	; 0x16b4 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    167c:	c8 01       	movw	r24, r16
    167e:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <prvIsQueueEmpty>
    1682:	88 23       	and	r24, r24
    1684:	89 f0       	breq	.+34     	; 0x16a8 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1686:	6c 81       	ldd	r22, Y+4	; 0x04
    1688:	7d 81       	ldd	r23, Y+5	; 0x05
    168a:	c5 01       	movw	r24, r10
    168c:	0e 94 c2 05 	call	0xb84	; 0xb84 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1690:	c8 01       	movw	r24, r16
    1692:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1696:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    169a:	88 23       	and	r24, r24
    169c:	11 f0       	breq	.+4      	; 0x16a2 <xQueueReceive+0xde>
    169e:	81 e0       	ldi	r24, 0x01	; 1
    16a0:	a8 cf       	rjmp	.-176    	; 0x15f2 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    16a2:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
    16a6:	fb cf       	rjmp	.-10     	; 0x169e <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    16a8:	c8 01       	movw	r24, r16
    16aa:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16ae:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    16b2:	f5 cf       	rjmp	.-22     	; 0x169e <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    16b4:	c8 01       	movw	r24, r16
    16b6:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16ba:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16be:	c8 01       	movw	r24, r16
    16c0:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <prvIsQueueEmpty>
    16c4:	88 23       	and	r24, r24
    16c6:	59 f3       	breq	.-42     	; 0x169e <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    16c8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    16ca:	0f 90       	pop	r0
    16cc:	0f 90       	pop	r0
    16ce:	0f 90       	pop	r0
    16d0:	0f 90       	pop	r0
    16d2:	0f 90       	pop	r0
    16d4:	df 91       	pop	r29
    16d6:	cf 91       	pop	r28
    16d8:	1f 91       	pop	r17
    16da:	0f 91       	pop	r16
    16dc:	ff 90       	pop	r15
    16de:	df 90       	pop	r13
    16e0:	cf 90       	pop	r12
    16e2:	bf 90       	pop	r11
    16e4:	af 90       	pop	r10
    16e6:	08 95       	ret

000016e8 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    16e8:	ef 92       	push	r14
    16ea:	ff 92       	push	r15
    16ec:	0f 93       	push	r16
    16ee:	1f 93       	push	r17
    16f0:	cf 93       	push	r28
    16f2:	df 93       	push	r29
    16f4:	00 d0       	rcall	.+0      	; 0x16f6 <xQueueSemaphoreTake+0xe>
    16f6:	00 d0       	rcall	.+0      	; 0x16f8 <xQueueSemaphoreTake+0x10>
    16f8:	1f 92       	push	r1
    16fa:	cd b7       	in	r28, 0x3d	; 61
    16fc:	de b7       	in	r29, 0x3e	; 62
    16fe:	8c 01       	movw	r16, r24
    1700:	7d 83       	std	Y+5, r23	; 0x05
    1702:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1704:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1706:	78 01       	movw	r14, r16
    1708:	81 e1       	ldi	r24, 0x11	; 17
    170a:	e8 0e       	add	r14, r24
    170c:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    170e:	0f b6       	in	r0, 0x3f	; 63
    1710:	f8 94       	cli
    1712:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1714:	f8 01       	movw	r30, r16
    1716:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1718:	88 23       	and	r24, r24
    171a:	81 f0       	breq	.+32     	; 0x173c <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    171c:	81 50       	subi	r24, 0x01	; 1
    171e:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1720:	80 85       	ldd	r24, Z+8	; 0x08
    1722:	88 23       	and	r24, r24
    1724:	39 f0       	breq	.+14     	; 0x1734 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1726:	c8 01       	movw	r24, r16
    1728:	08 96       	adiw	r24, 0x08	; 8
    172a:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    172e:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1730:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1734:	0f 90       	pop	r0
    1736:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	50 c0       	rjmp	.+160    	; 0x17dc <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    173c:	2c 81       	ldd	r18, Y+4	; 0x04
    173e:	3d 81       	ldd	r19, Y+5	; 0x05
    1740:	23 2b       	or	r18, r19
    1742:	19 f4       	brne	.+6      	; 0x174a <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1744:	0f 90       	pop	r0
    1746:	0f be       	out	0x3f, r0	; 63
    1748:	48 c0       	rjmp	.+144    	; 0x17da <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    174a:	91 11       	cpse	r25, r1
    174c:	04 c0       	rjmp	.+8      	; 0x1756 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    174e:	ce 01       	movw	r24, r28
    1750:	01 96       	adiw	r24, 0x01	; 1
    1752:	0e 94 6d 06 	call	0xcda	; 0xcda <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1756:	0f 90       	pop	r0
    1758:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    175a:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	0f 92       	push	r0
    1764:	f8 01       	movw	r30, r16
    1766:	85 8d       	ldd	r24, Z+29	; 0x1d
    1768:	8f 3f       	cpi	r24, 0xFF	; 255
    176a:	09 f4       	brne	.+2      	; 0x176e <xQueueSemaphoreTake+0x86>
    176c:	15 8e       	std	Z+29, r1	; 0x1d
    176e:	f8 01       	movw	r30, r16
    1770:	86 8d       	ldd	r24, Z+30	; 0x1e
    1772:	8f 3f       	cpi	r24, 0xFF	; 255
    1774:	09 f4       	brne	.+2      	; 0x1778 <xQueueSemaphoreTake+0x90>
    1776:	16 8e       	std	Z+30, r1	; 0x1e
    1778:	0f 90       	pop	r0
    177a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    177c:	be 01       	movw	r22, r28
    177e:	6c 5f       	subi	r22, 0xFC	; 252
    1780:	7f 4f       	sbci	r23, 0xFF	; 255
    1782:	ce 01       	movw	r24, r28
    1784:	01 96       	adiw	r24, 0x01	; 1
    1786:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCheckForTimeOut>
    178a:	81 11       	cpse	r24, r1
    178c:	1c c0       	rjmp	.+56     	; 0x17c6 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    178e:	c8 01       	movw	r24, r16
    1790:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <prvIsQueueEmpty>
    1794:	88 23       	and	r24, r24
    1796:	89 f0       	breq	.+34     	; 0x17ba <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1798:	6c 81       	ldd	r22, Y+4	; 0x04
    179a:	7d 81       	ldd	r23, Y+5	; 0x05
    179c:	c7 01       	movw	r24, r14
    179e:	0e 94 c2 05 	call	0xb84	; 0xb84 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17a2:	c8 01       	movw	r24, r16
    17a4:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    17a8:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    17ac:	88 23       	and	r24, r24
    17ae:	11 f0       	breq	.+4      	; 0x17b4 <xQueueSemaphoreTake+0xcc>
    17b0:	91 e0       	ldi	r25, 0x01	; 1
    17b2:	ad cf       	rjmp	.-166    	; 0x170e <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    17b4:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
    17b8:	fb cf       	rjmp	.-10     	; 0x17b0 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    17ba:	c8 01       	movw	r24, r16
    17bc:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17c0:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    17c4:	f5 cf       	rjmp	.-22     	; 0x17b0 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    17c6:	c8 01       	movw	r24, r16
    17c8:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17cc:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17d0:	c8 01       	movw	r24, r16
    17d2:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <prvIsQueueEmpty>
    17d6:	88 23       	and	r24, r24
    17d8:	59 f3       	breq	.-42     	; 0x17b0 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17da:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17dc:	0f 90       	pop	r0
    17de:	0f 90       	pop	r0
    17e0:	0f 90       	pop	r0
    17e2:	0f 90       	pop	r0
    17e4:	0f 90       	pop	r0
    17e6:	df 91       	pop	r29
    17e8:	cf 91       	pop	r28
    17ea:	1f 91       	pop	r17
    17ec:	0f 91       	pop	r16
    17ee:	ff 90       	pop	r15
    17f0:	ef 90       	pop	r14
    17f2:	08 95       	ret

000017f4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    17f4:	cf 92       	push	r12
    17f6:	df 92       	push	r13
    17f8:	ef 92       	push	r14
    17fa:	ff 92       	push	r15
    17fc:	0f 93       	push	r16
    17fe:	1f 93       	push	r17
    1800:	cf 93       	push	r28
    1802:	df 93       	push	r29
    1804:	00 d0       	rcall	.+0      	; 0x1806 <xQueuePeek+0x12>
    1806:	00 d0       	rcall	.+0      	; 0x1808 <xQueuePeek+0x14>
    1808:	1f 92       	push	r1
    180a:	cd b7       	in	r28, 0x3d	; 61
    180c:	de b7       	in	r29, 0x3e	; 62
    180e:	8c 01       	movw	r16, r24
    1810:	7b 01       	movw	r14, r22
    1812:	5d 83       	std	Y+5, r21	; 0x05
    1814:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1816:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1818:	68 01       	movw	r12, r16
    181a:	91 e1       	ldi	r25, 0x11	; 17
    181c:	c9 0e       	add	r12, r25
    181e:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1826:	f8 01       	movw	r30, r16
    1828:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    182a:	99 23       	and	r25, r25
    182c:	b9 f0       	breq	.+46     	; 0x185c <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    182e:	c6 80       	ldd	r12, Z+6	; 0x06
    1830:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1832:	b7 01       	movw	r22, r14
    1834:	c8 01       	movw	r24, r16
    1836:	0e 94 3b 09 	call	0x1276	; 0x1276 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    183a:	f8 01       	movw	r30, r16
    183c:	d7 82       	std	Z+7, r13	; 0x07
    183e:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1840:	81 89       	ldd	r24, Z+17	; 0x11
    1842:	88 23       	and	r24, r24
    1844:	39 f0       	breq	.+14     	; 0x1854 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1846:	c8 01       	movw	r24, r16
    1848:	41 96       	adiw	r24, 0x11	; 17
    184a:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    184e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1850:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1854:	0f 90       	pop	r0
    1856:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1858:	81 e0       	ldi	r24, 0x01	; 1
    185a:	50 c0       	rjmp	.+160    	; 0x18fc <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    185c:	2c 81       	ldd	r18, Y+4	; 0x04
    185e:	3d 81       	ldd	r19, Y+5	; 0x05
    1860:	23 2b       	or	r18, r19
    1862:	19 f4       	brne	.+6      	; 0x186a <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63
    1868:	48 c0       	rjmp	.+144    	; 0x18fa <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    186a:	81 11       	cpse	r24, r1
    186c:	04 c0       	rjmp	.+8      	; 0x1876 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    186e:	ce 01       	movw	r24, r28
    1870:	01 96       	adiw	r24, 0x01	; 1
    1872:	0e 94 6d 06 	call	0xcda	; 0xcda <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1876:	0f 90       	pop	r0
    1878:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    187a:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    187e:	0f b6       	in	r0, 0x3f	; 63
    1880:	f8 94       	cli
    1882:	0f 92       	push	r0
    1884:	f8 01       	movw	r30, r16
    1886:	85 8d       	ldd	r24, Z+29	; 0x1d
    1888:	8f 3f       	cpi	r24, 0xFF	; 255
    188a:	09 f4       	brne	.+2      	; 0x188e <xQueuePeek+0x9a>
    188c:	15 8e       	std	Z+29, r1	; 0x1d
    188e:	f8 01       	movw	r30, r16
    1890:	86 8d       	ldd	r24, Z+30	; 0x1e
    1892:	8f 3f       	cpi	r24, 0xFF	; 255
    1894:	09 f4       	brne	.+2      	; 0x1898 <xQueuePeek+0xa4>
    1896:	16 8e       	std	Z+30, r1	; 0x1e
    1898:	0f 90       	pop	r0
    189a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    189c:	be 01       	movw	r22, r28
    189e:	6c 5f       	subi	r22, 0xFC	; 252
    18a0:	7f 4f       	sbci	r23, 0xFF	; 255
    18a2:	ce 01       	movw	r24, r28
    18a4:	01 96       	adiw	r24, 0x01	; 1
    18a6:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCheckForTimeOut>
    18aa:	81 11       	cpse	r24, r1
    18ac:	1c c0       	rjmp	.+56     	; 0x18e6 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18ae:	c8 01       	movw	r24, r16
    18b0:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <prvIsQueueEmpty>
    18b4:	88 23       	and	r24, r24
    18b6:	89 f0       	breq	.+34     	; 0x18da <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18b8:	6c 81       	ldd	r22, Y+4	; 0x04
    18ba:	7d 81       	ldd	r23, Y+5	; 0x05
    18bc:	c6 01       	movw	r24, r12
    18be:	0e 94 c2 05 	call	0xb84	; 0xb84 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18c2:	c8 01       	movw	r24, r16
    18c4:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18c8:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    18cc:	88 23       	and	r24, r24
    18ce:	11 f0       	breq	.+4      	; 0x18d4 <xQueuePeek+0xe0>
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	a6 cf       	rjmp	.-180    	; 0x1820 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    18d4:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
    18d8:	fb cf       	rjmp	.-10     	; 0x18d0 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18da:	c8 01       	movw	r24, r16
    18dc:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18e0:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
    18e4:	f5 cf       	rjmp	.-22     	; 0x18d0 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18e6:	c8 01       	movw	r24, r16
    18e8:	0e 94 55 09 	call	0x12aa	; 0x12aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18ec:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18f0:	c8 01       	movw	r24, r16
    18f2:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <prvIsQueueEmpty>
    18f6:	88 23       	and	r24, r24
    18f8:	59 f3       	breq	.-42     	; 0x18d0 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18fa:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18fc:	0f 90       	pop	r0
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	0f 90       	pop	r0
    1904:	0f 90       	pop	r0
    1906:	df 91       	pop	r29
    1908:	cf 91       	pop	r28
    190a:	1f 91       	pop	r17
    190c:	0f 91       	pop	r16
    190e:	ff 90       	pop	r15
    1910:	ef 90       	pop	r14
    1912:	df 90       	pop	r13
    1914:	cf 90       	pop	r12
    1916:	08 95       	ret

00001918 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1918:	ef 92       	push	r14
    191a:	ff 92       	push	r15
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1924:	fc 01       	movw	r30, r24
    1926:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1928:	00 23       	and	r16, r16
    192a:	e9 f0       	breq	.+58     	; 0x1966 <xQueueReceiveFromISR+0x4e>
    192c:	7a 01       	movw	r14, r20
    192e:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1930:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1932:	0e 94 3b 09 	call	0x1276	; 0x1276 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1936:	01 50       	subi	r16, 0x01	; 1
    1938:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    193a:	1f 3f       	cpi	r17, 0xFF	; 255
    193c:	81 f4       	brne	.+32     	; 0x195e <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    193e:	88 85       	ldd	r24, Y+8	; 0x08
    1940:	88 23       	and	r24, r24
    1942:	79 f0       	breq	.+30     	; 0x1962 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1944:	ce 01       	movw	r24, r28
    1946:	08 96       	adiw	r24, 0x08	; 8
    1948:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <xTaskRemoveFromEventList>
    194c:	88 23       	and	r24, r24
    194e:	49 f0       	breq	.+18     	; 0x1962 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1950:	e1 14       	cp	r14, r1
    1952:	f1 04       	cpc	r15, r1
    1954:	31 f0       	breq	.+12     	; 0x1962 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	f7 01       	movw	r30, r14
    195a:	80 83       	st	Z, r24
    195c:	05 c0       	rjmp	.+10     	; 0x1968 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    195e:	1f 5f       	subi	r17, 0xFF	; 255
    1960:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	01 c0       	rjmp	.+2      	; 0x1968 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1966:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	ff 90       	pop	r15
    1972:	ef 90       	pop	r14
    1974:	08 95       	ret

00001976 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1976:	0f 93       	push	r16
    1978:	1f 93       	push	r17
    197a:	cf 93       	push	r28
    197c:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    197e:	fc 01       	movw	r30, r24
    1980:	22 8d       	ldd	r18, Z+26	; 0x1a
    1982:	22 23       	and	r18, r18
    1984:	49 f0       	breq	.+18     	; 0x1998 <xQueuePeekFromISR+0x22>
    1986:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1988:	06 81       	ldd	r16, Z+6	; 0x06
    198a:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    198c:	0e 94 3b 09 	call	0x1276	; 0x1276 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1990:	1f 83       	std	Y+7, r17	; 0x07
    1992:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	01 c0       	rjmp	.+2      	; 0x199a <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1998:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	1f 91       	pop	r17
    19a0:	0f 91       	pop	r16
    19a2:	08 95       	ret

000019a4 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    19aa:	fc 01       	movw	r30, r24
    19ac:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19ae:	0f 90       	pop	r0
    19b0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19b2:	08 95       	ret

000019b4 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19b4:	0f b6       	in	r0, 0x3f	; 63
    19b6:	f8 94       	cli
    19b8:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19ba:	fc 01       	movw	r30, r24
    19bc:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19be:	0f 90       	pop	r0
    19c0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    19c2:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19c4:	82 1b       	sub	r24, r18
    19c6:	08 95       	ret

000019c8 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    19c8:	fc 01       	movw	r30, r24
    19ca:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19cc:	08 95       	ret

000019ce <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    19ce:	0c 94 5b 10 	jmp	0x20b6	; 0x20b6 <vPortFree>

000019d2 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19d2:	fc 01       	movw	r30, r24
    19d4:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19d6:	81 e0       	ldi	r24, 0x01	; 1
    19d8:	91 11       	cpse	r25, r1
    19da:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19dc:	08 95       	ret

000019de <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    19de:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19e0:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	23 8d       	ldd	r18, Z+27	; 0x1b
    19e6:	29 13       	cpse	r18, r25
    19e8:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19ea:	08 95       	ret

000019ec <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    19ec:	cf 93       	push	r28
    19ee:	df 93       	push	r29
    19f0:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    19f2:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19f4:	0f b6       	in	r0, 0x3f	; 63
    19f6:	f8 94       	cli
    19f8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19fa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19fc:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19fe:	0f 90       	pop	r0
    1a00:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a02:	89 13       	cpse	r24, r25
    1a04:	0f c0       	rjmp	.+30     	; 0x1a24 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a06:	41 15       	cp	r20, r1
    1a08:	51 05       	cpc	r21, r1
    1a0a:	49 f0       	breq	.+18     	; 0x1a1e <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1a0c:	be 01       	movw	r22, r28
    1a0e:	68 5f       	subi	r22, 0xF8	; 248
    1a10:	7f 4f       	sbci	r23, 0xFF	; 255
    1a12:	ca 01       	movw	r24, r20
    1a14:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a18:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a1a:	8c ef       	ldi	r24, 0xFC	; 252
    1a1c:	1b c0       	rjmp	.+54     	; 0x1a54 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a1e:	78 94       	sei
					return errQUEUE_FULL;
    1a20:	80 e0       	ldi	r24, 0x00	; 0
    1a22:	18 c0       	rjmp	.+48     	; 0x1a54 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1a24:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a26:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a28:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a2a:	89 17       	cp	r24, r25
    1a2c:	88 f4       	brcc	.+34     	; 0x1a50 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a2e:	40 e0       	ldi	r20, 0x00	; 0
    1a30:	ce 01       	movw	r24, r28
    1a32:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a36:	89 89       	ldd	r24, Y+17	; 0x11
    1a38:	81 11       	cpse	r24, r1
    1a3a:	02 c0       	rjmp	.+4      	; 0x1a40 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1a3c:	81 e0       	ldi	r24, 0x01	; 1
    1a3e:	09 c0       	rjmp	.+18     	; 0x1a52 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a40:	ce 01       	movw	r24, r28
    1a42:	41 96       	adiw	r24, 0x11	; 17
    1a44:	0e 94 04 10 	call	0x2008	; 0x2008 <xCoRoutineRemoveFromEventList>
    1a48:	88 23       	and	r24, r24
    1a4a:	c1 f3       	breq	.-16     	; 0x1a3c <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1a4c:	8b ef       	ldi	r24, 0xFB	; 251
    1a4e:	01 c0       	rjmp	.+2      	; 0x1a52 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1a50:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a52:	78 94       	sei

		return xReturn;
	}
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	08 95       	ret

00001a5a <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
    1a5e:	ec 01       	movw	r28, r24
    1a60:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a62:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a64:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a66:	81 11       	cpse	r24, r1
    1a68:	0f c0       	rjmp	.+30     	; 0x1a88 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a6a:	41 15       	cp	r20, r1
    1a6c:	51 05       	cpc	r21, r1
    1a6e:	49 f0       	breq	.+18     	; 0x1a82 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a70:	be 01       	movw	r22, r28
    1a72:	6f 5e       	subi	r22, 0xEF	; 239
    1a74:	7f 4f       	sbci	r23, 0xFF	; 255
    1a76:	ca 01       	movw	r24, r20
    1a78:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a7c:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a7e:	8c ef       	ldi	r24, 0xFC	; 252
    1a80:	30 c0       	rjmp	.+96     	; 0x1ae2 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a82:	78 94       	sei
					return errQUEUE_FULL;
    1a84:	80 e0       	ldi	r24, 0x00	; 0
    1a86:	2d c0       	rjmp	.+90     	; 0x1ae2 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1a88:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a8a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a8c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a8e:	88 23       	and	r24, r24
    1a90:	31 f1       	breq	.+76     	; 0x1ade <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1a92:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a94:	50 e0       	ldi	r21, 0x00	; 0
    1a96:	2e 81       	ldd	r18, Y+6	; 0x06
    1a98:	3f 81       	ldd	r19, Y+7	; 0x07
    1a9a:	24 0f       	add	r18, r20
    1a9c:	35 1f       	adc	r19, r21
    1a9e:	3f 83       	std	Y+7, r19	; 0x07
    1aa0:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1aa2:	8c 81       	ldd	r24, Y+4	; 0x04
    1aa4:	9d 81       	ldd	r25, Y+5	; 0x05
    1aa6:	28 17       	cp	r18, r24
    1aa8:	39 07       	cpc	r19, r25
    1aaa:	20 f0       	brcs	.+8      	; 0x1ab4 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1aac:	88 81       	ld	r24, Y
    1aae:	99 81       	ldd	r25, Y+1	; 0x01
    1ab0:	9f 83       	std	Y+7, r25	; 0x07
    1ab2:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1ab4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ab6:	91 50       	subi	r25, 0x01	; 1
    1ab8:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1aba:	6e 81       	ldd	r22, Y+6	; 0x06
    1abc:	7f 81       	ldd	r23, Y+7	; 0x07
    1abe:	cf 01       	movw	r24, r30
    1ac0:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ac4:	88 85       	ldd	r24, Y+8	; 0x08
    1ac6:	81 11       	cpse	r24, r1
    1ac8:	02 c0       	rjmp	.+4      	; 0x1ace <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1aca:	81 e0       	ldi	r24, 0x01	; 1
    1acc:	09 c0       	rjmp	.+18     	; 0x1ae0 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ace:	ce 01       	movw	r24, r28
    1ad0:	08 96       	adiw	r24, 0x08	; 8
    1ad2:	0e 94 04 10 	call	0x2008	; 0x2008 <xCoRoutineRemoveFromEventList>
    1ad6:	88 23       	and	r24, r24
    1ad8:	c1 f3       	breq	.-16     	; 0x1aca <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1ada:	8b ef       	ldi	r24, 0xFB	; 251
    1adc:	01 c0       	rjmp	.+2      	; 0x1ae0 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1ade:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1ae0:	78 94       	sei

		return xReturn;
	}
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1ae8:	0f 93       	push	r16
    1aea:	1f 93       	push	r17
    1aec:	cf 93       	push	r28
    1aee:	8c 01       	movw	r16, r24
    1af0:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1af2:	fc 01       	movw	r30, r24
    1af4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1af6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1af8:	98 17       	cp	r25, r24
    1afa:	10 f0       	brcs	.+4      	; 0x1b00 <xQueueCRSendFromISR+0x18>
    1afc:	4c 2f       	mov	r20, r28
    1afe:	12 c0       	rjmp	.+36     	; 0x1b24 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b00:	40 e0       	ldi	r20, 0x00	; 0
    1b02:	c8 01       	movw	r24, r16
    1b04:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1b08:	c1 11       	cpse	r28, r1
    1b0a:	f8 cf       	rjmp	.-16     	; 0x1afc <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b0c:	f8 01       	movw	r30, r16
    1b0e:	81 89       	ldd	r24, Z+17	; 0x11
    1b10:	88 23       	and	r24, r24
    1b12:	39 f0       	breq	.+14     	; 0x1b22 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b14:	c8 01       	movw	r24, r16
    1b16:	41 96       	adiw	r24, 0x11	; 17
    1b18:	0e 94 04 10 	call	0x2008	; 0x2008 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1b1c:	41 e0       	ldi	r20, 0x01	; 1
    1b1e:	81 11       	cpse	r24, r1
    1b20:	01 c0       	rjmp	.+2      	; 0x1b24 <xQueueCRSendFromISR+0x3c>
    1b22:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1b24:	84 2f       	mov	r24, r20
    1b26:	cf 91       	pop	r28
    1b28:	1f 91       	pop	r17
    1b2a:	0f 91       	pop	r16
    1b2c:	08 95       	ret

00001b2e <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1b2e:	0f 93       	push	r16
    1b30:	1f 93       	push	r17
    1b32:	cf 93       	push	r28
    1b34:	df 93       	push	r29
    1b36:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b38:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3a:	88 23       	and	r24, r24
    1b3c:	79 f1       	breq	.+94     	; 0x1b9c <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b3e:	24 8d       	ldd	r18, Z+28	; 0x1c
    1b40:	30 e0       	ldi	r19, 0x00	; 0
    1b42:	a6 81       	ldd	r26, Z+6	; 0x06
    1b44:	b7 81       	ldd	r27, Z+7	; 0x07
    1b46:	a2 0f       	add	r26, r18
    1b48:	b3 1f       	adc	r27, r19
    1b4a:	b7 83       	std	Z+7, r27	; 0x07
    1b4c:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b4e:	84 81       	ldd	r24, Z+4	; 0x04
    1b50:	95 81       	ldd	r25, Z+5	; 0x05
    1b52:	a8 17       	cp	r26, r24
    1b54:	b9 07       	cpc	r27, r25
    1b56:	20 f0       	brcs	.+8      	; 0x1b60 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b58:	80 81       	ld	r24, Z
    1b5a:	91 81       	ldd	r25, Z+1	; 0x01
    1b5c:	97 83       	std	Z+7, r25	; 0x07
    1b5e:	86 83       	std	Z+6, r24	; 0x06
    1b60:	8a 01       	movw	r16, r20
    1b62:	cb 01       	movw	r24, r22
    1b64:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b66:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b68:	41 50       	subi	r20, 0x01	; 1
    1b6a:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b6c:	66 81       	ldd	r22, Z+6	; 0x06
    1b6e:	77 81       	ldd	r23, Z+7	; 0x07
    1b70:	a9 01       	movw	r20, r18
    1b72:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b76:	f8 01       	movw	r30, r16
    1b78:	80 81       	ld	r24, Z
    1b7a:	88 23       	and	r24, r24
    1b7c:	11 f0       	breq	.+4      	; 0x1b82 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b7e:	81 e0       	ldi	r24, 0x01	; 1
    1b80:	0e c0       	rjmp	.+28     	; 0x1b9e <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b82:	88 85       	ldd	r24, Y+8	; 0x08
    1b84:	88 23       	and	r24, r24
    1b86:	d9 f3       	breq	.-10     	; 0x1b7e <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b88:	ce 01       	movw	r24, r28
    1b8a:	08 96       	adiw	r24, 0x08	; 8
    1b8c:	0e 94 04 10 	call	0x2008	; 0x2008 <xCoRoutineRemoveFromEventList>
    1b90:	88 23       	and	r24, r24
    1b92:	a9 f3       	breq	.-22     	; 0x1b7e <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	f8 01       	movw	r30, r16
    1b98:	80 83       	st	Z, r24
    1b9a:	01 c0       	rjmp	.+2      	; 0x1b9e <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b9c:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1b9e:	df 91       	pop	r29
    1ba0:	cf 91       	pop	r28
    1ba2:	1f 91       	pop	r17
    1ba4:	0f 91       	pop	r16
    1ba6:	08 95       	ret

00001ba8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ba8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1baa:	03 96       	adiw	r24, 0x03	; 3
    1bac:	92 83       	std	Z+2, r25	; 0x02
    1bae:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bb0:	2f ef       	ldi	r18, 0xFF	; 255
    1bb2:	3f ef       	ldi	r19, 0xFF	; 255
    1bb4:	34 83       	std	Z+4, r19	; 0x04
    1bb6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bb8:	96 83       	std	Z+6, r25	; 0x06
    1bba:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bbc:	90 87       	std	Z+8, r25	; 0x08
    1bbe:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bc0:	10 82       	st	Z, r1
    1bc2:	08 95       	ret

00001bc4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	11 86       	std	Z+9, r1	; 0x09
    1bc8:	10 86       	std	Z+8, r1	; 0x08
    1bca:	08 95       	ret

00001bcc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bcc:	cf 93       	push	r28
    1bce:	df 93       	push	r29
    1bd0:	9c 01       	movw	r18, r24
    1bd2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1bd4:	dc 01       	movw	r26, r24
    1bd6:	11 96       	adiw	r26, 0x01	; 1
    1bd8:	cd 91       	ld	r28, X+
    1bda:	dc 91       	ld	r29, X
    1bdc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bde:	d3 83       	std	Z+3, r29	; 0x03
    1be0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1be2:	8c 81       	ldd	r24, Y+4	; 0x04
    1be4:	9d 81       	ldd	r25, Y+5	; 0x05
    1be6:	95 83       	std	Z+5, r25	; 0x05
    1be8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1bea:	8c 81       	ldd	r24, Y+4	; 0x04
    1bec:	9d 81       	ldd	r25, Y+5	; 0x05
    1bee:	dc 01       	movw	r26, r24
    1bf0:	13 96       	adiw	r26, 0x03	; 3
    1bf2:	7c 93       	st	X, r23
    1bf4:	6e 93       	st	-X, r22
    1bf6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1bf8:	7d 83       	std	Y+5, r23	; 0x05
    1bfa:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1bfc:	31 87       	std	Z+9, r19	; 0x09
    1bfe:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c00:	f9 01       	movw	r30, r18
    1c02:	80 81       	ld	r24, Z
    1c04:	8f 5f       	subi	r24, 0xFF	; 255
    1c06:	80 83       	st	Z, r24
}
    1c08:	df 91       	pop	r29
    1c0a:	cf 91       	pop	r28
    1c0c:	08 95       	ret

00001c0e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	8c 01       	movw	r16, r24
    1c18:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c1a:	80 81       	ld	r24, Z
    1c1c:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c20:	2f ef       	ldi	r18, 0xFF	; 255
    1c22:	92 07       	cpc	r25, r18
    1c24:	21 f4       	brne	.+8      	; 0x1c2e <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c26:	e8 01       	movw	r28, r16
    1c28:	af 81       	ldd	r26, Y+7	; 0x07
    1c2a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c2c:	0e c0       	rjmp	.+28     	; 0x1c4a <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c2e:	d8 01       	movw	r26, r16
    1c30:	13 96       	adiw	r26, 0x03	; 3
    1c32:	12 96       	adiw	r26, 0x02	; 2
    1c34:	2d 91       	ld	r18, X+
    1c36:	3c 91       	ld	r19, X
    1c38:	13 97       	sbiw	r26, 0x03	; 3
    1c3a:	e9 01       	movw	r28, r18
    1c3c:	48 81       	ld	r20, Y
    1c3e:	59 81       	ldd	r21, Y+1	; 0x01
    1c40:	84 17       	cp	r24, r20
    1c42:	95 07       	cpc	r25, r21
    1c44:	10 f0       	brcs	.+4      	; 0x1c4a <vListInsert+0x3c>
    1c46:	d9 01       	movw	r26, r18
    1c48:	f4 cf       	rjmp	.-24     	; 0x1c32 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c4a:	12 96       	adiw	r26, 0x02	; 2
    1c4c:	8d 91       	ld	r24, X+
    1c4e:	9c 91       	ld	r25, X
    1c50:	13 97       	sbiw	r26, 0x03	; 3
    1c52:	93 83       	std	Z+3, r25	; 0x03
    1c54:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c56:	ec 01       	movw	r28, r24
    1c58:	fd 83       	std	Y+5, r31	; 0x05
    1c5a:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c5c:	b5 83       	std	Z+5, r27	; 0x05
    1c5e:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c60:	13 96       	adiw	r26, 0x03	; 3
    1c62:	fc 93       	st	X, r31
    1c64:	ee 93       	st	-X, r30
    1c66:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c68:	11 87       	std	Z+9, r17	; 0x09
    1c6a:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c6c:	f8 01       	movw	r30, r16
    1c6e:	80 81       	ld	r24, Z
    1c70:	8f 5f       	subi	r24, 0xFF	; 255
    1c72:	80 83       	st	Z, r24
}
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	08 95       	ret

00001c7e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c7e:	cf 93       	push	r28
    1c80:	df 93       	push	r29
    1c82:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c84:	a0 85       	ldd	r26, Z+8	; 0x08
    1c86:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c88:	82 81       	ldd	r24, Z+2	; 0x02
    1c8a:	93 81       	ldd	r25, Z+3	; 0x03
    1c8c:	24 81       	ldd	r18, Z+4	; 0x04
    1c8e:	35 81       	ldd	r19, Z+5	; 0x05
    1c90:	ec 01       	movw	r28, r24
    1c92:	3d 83       	std	Y+5, r19	; 0x05
    1c94:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c96:	c4 81       	ldd	r28, Z+4	; 0x04
    1c98:	d5 81       	ldd	r29, Z+5	; 0x05
    1c9a:	9b 83       	std	Y+3, r25	; 0x03
    1c9c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c9e:	11 96       	adiw	r26, 0x01	; 1
    1ca0:	8d 91       	ld	r24, X+
    1ca2:	9c 91       	ld	r25, X
    1ca4:	12 97       	sbiw	r26, 0x02	; 2
    1ca6:	e8 17       	cp	r30, r24
    1ca8:	f9 07       	cpc	r31, r25
    1caa:	21 f4       	brne	.+8      	; 0x1cb4 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cac:	12 96       	adiw	r26, 0x02	; 2
    1cae:	dc 93       	st	X, r29
    1cb0:	ce 93       	st	-X, r28
    1cb2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1cb4:	11 86       	std	Z+9, r1	; 0x09
    1cb6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cb8:	8c 91       	ld	r24, X
    1cba:	81 50       	subi	r24, 0x01	; 1
    1cbc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1cbe:	8c 91       	ld	r24, X
}
    1cc0:	df 91       	pop	r29
    1cc2:	cf 91       	pop	r28
    1cc4:	08 95       	ret

00001cc6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1cc6:	cf 92       	push	r12
    1cc8:	df 92       	push	r13
    1cca:	ef 92       	push	r14
    1ccc:	ff 92       	push	r15
    1cce:	1f 93       	push	r17
    1cd0:	cf 93       	push	r28
    1cd2:	df 93       	push	r29
    1cd4:	6c 01       	movw	r12, r24
    1cd6:	16 2f       	mov	r17, r22
    1cd8:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1cda:	8a e1       	ldi	r24, 0x1A	; 26
    1cdc:	90 e0       	ldi	r25, 0x00	; 0
    1cde:	0e 94 29 10 	call	0x2052	; 0x2052 <pvPortMalloc>
    1ce2:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1ce4:	89 2b       	or	r24, r25
    1ce6:	09 f4       	brne	.+2      	; 0x1cea <xCoRoutineCreate+0x24>
    1ce8:	57 c0       	rjmp	.+174    	; 0x1d98 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1cea:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pxCurrentCoRoutine>
    1cee:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pxCurrentCoRoutine+0x1>
    1cf2:	89 2b       	or	r24, r25
    1cf4:	21 f5       	brne	.+72     	; 0x1d3e <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1cf6:	d0 93 8d 01 	sts	0x018D, r29	; 0x80018d <pxCurrentCoRoutine+0x1>
    1cfa:	c0 93 8c 01 	sts	0x018C, r28	; 0x80018c <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1cfe:	84 eb       	ldi	r24, 0xB4	; 180
    1d00:	91 e0       	ldi	r25, 0x01	; 1
    1d02:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
    1d06:	8d eb       	ldi	r24, 0xBD	; 189
    1d08:	91 e0       	ldi	r25, 0x01	; 1
    1d0a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1d0e:	8b ea       	ldi	r24, 0xAB	; 171
    1d10:	91 e0       	ldi	r25, 0x01	; 1
    1d12:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1d16:	82 ea       	ldi	r24, 0xA2	; 162
    1d18:	91 e0       	ldi	r25, 0x01	; 1
    1d1a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1d1e:	85 e9       	ldi	r24, 0x95	; 149
    1d20:	91 e0       	ldi	r25, 0x01	; 1
    1d22:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1d26:	8b ea       	ldi	r24, 0xAB	; 171
    1d28:	91 e0       	ldi	r25, 0x01	; 1
    1d2a:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <pxDelayedCoRoutineList+0x1>
    1d2e:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1d32:	82 ea       	ldi	r24, 0xA2	; 162
    1d34:	91 e0       	ldi	r25, 0x01	; 1
    1d36:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <pxOverflowDelayedCoRoutineList+0x1>
    1d3a:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <pxOverflowDelayedCoRoutineList>
    1d3e:	11 11       	cpse	r17, r1
    1d40:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1d42:	19 8e       	std	Y+25, r1	; 0x19
    1d44:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1d46:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1d48:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1d4a:	fe 01       	movw	r30, r28
    1d4c:	c1 92       	st	Z+, r12
    1d4e:	d1 92       	st	Z+, r13
    1d50:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1d52:	cf 01       	movw	r24, r30
    1d54:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d58:	ce 01       	movw	r24, r28
    1d5a:	0c 96       	adiw	r24, 0x0c	; 12
    1d5c:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d60:	d9 87       	std	Y+9, r29	; 0x09
    1d62:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d64:	db 8b       	std	Y+19, r29	; 0x13
    1d66:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d68:	82 e0       	ldi	r24, 0x02	; 2
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	81 1b       	sub	r24, r17
    1d6e:	91 09       	sbc	r25, r1
    1d70:	9d 87       	std	Y+13, r25	; 0x0d
    1d72:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d74:	8e 89       	ldd	r24, Y+22	; 0x16
    1d76:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <uxTopCoRoutineReadyPriority>
    1d7a:	98 17       	cp	r25, r24
    1d7c:	10 f4       	brcc	.+4      	; 0x1d82 <xCoRoutineCreate+0xbc>
    1d7e:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <uxTopCoRoutineReadyPriority>
    1d82:	f9 e0       	ldi	r31, 0x09	; 9
    1d84:	8f 9f       	mul	r24, r31
    1d86:	c0 01       	movw	r24, r0
    1d88:	11 24       	eor	r1, r1
    1d8a:	b7 01       	movw	r22, r14
    1d8c:	8c 54       	subi	r24, 0x4C	; 76
    1d8e:	9e 4f       	sbci	r25, 0xFE	; 254
    1d90:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

		xReturn = pdPASS;
    1d94:	81 e0       	ldi	r24, 0x01	; 1
    1d96:	01 c0       	rjmp	.+2      	; 0x1d9a <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d98:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1d9a:	df 91       	pop	r29
    1d9c:	cf 91       	pop	r28
    1d9e:	1f 91       	pop	r17
    1da0:	ff 90       	pop	r15
    1da2:	ef 90       	pop	r14
    1da4:	df 90       	pop	r13
    1da6:	cf 90       	pop	r12
    1da8:	08 95       	ret

00001daa <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1daa:	0f 93       	push	r16
    1dac:	1f 93       	push	r17
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1db4:	c0 91 92 01 	lds	r28, 0x0192	; 0x800192 <xCoRoutineTickCount>
    1db8:	d0 91 93 01 	lds	r29, 0x0193	; 0x800193 <xCoRoutineTickCount+0x1>
    1dbc:	c8 0f       	add	r28, r24
    1dbe:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dc0:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pxCurrentCoRoutine>
    1dc4:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pxCurrentCoRoutine+0x1>
    1dc8:	02 96       	adiw	r24, 0x02	; 2
    1dca:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1dce:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pxCurrentCoRoutine>
    1dd2:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pxCurrentCoRoutine+0x1>
    1dd6:	d3 83       	std	Z+3, r29	; 0x03
    1dd8:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1dda:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <xCoRoutineTickCount>
    1dde:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <xCoRoutineTickCount+0x1>
    1de2:	bf 01       	movw	r22, r30
    1de4:	6e 5f       	subi	r22, 0xFE	; 254
    1de6:	7f 4f       	sbci	r23, 0xFF	; 255
    1de8:	c8 17       	cp	r28, r24
    1dea:	d9 07       	cpc	r29, r25
    1dec:	28 f4       	brcc	.+10     	; 0x1df8 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dee:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <pxOverflowDelayedCoRoutineList>
    1df2:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <pxOverflowDelayedCoRoutineList+0x1>
    1df6:	04 c0       	rjmp	.+8      	; 0x1e00 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1df8:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList>
    1dfc:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <pxDelayedCoRoutineList+0x1>
    1e00:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <vListInsert>
	}

	if( pxEventList )
    1e04:	01 15       	cp	r16, r1
    1e06:	11 05       	cpc	r17, r1
    1e08:	69 f0       	breq	.+26     	; 0x1e24 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e0a:	60 91 8c 01 	lds	r22, 0x018C	; 0x80018c <pxCurrentCoRoutine>
    1e0e:	70 91 8d 01 	lds	r23, 0x018D	; 0x80018d <pxCurrentCoRoutine+0x1>
    1e12:	64 5f       	subi	r22, 0xF4	; 244
    1e14:	7f 4f       	sbci	r23, 0xFF	; 255
    1e16:	c8 01       	movw	r24, r16
	}
}
    1e18:	df 91       	pop	r29
    1e1a:	cf 91       	pop	r28
    1e1c:	1f 91       	pop	r17
    1e1e:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e20:	0c 94 07 0e 	jmp	0x1c0e	; 0x1c0e <vListInsert>
	}
}
    1e24:	df 91       	pop	r29
    1e26:	cf 91       	pop	r28
    1e28:	1f 91       	pop	r17
    1e2a:	0f 91       	pop	r16
    1e2c:	08 95       	ret

00001e2e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e2e:	ff 92       	push	r15
    1e30:	0f 93       	push	r16
    1e32:	1f 93       	push	r17
    1e34:	cf 93       	push	r28
    1e36:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e38:	99 e0       	ldi	r25, 0x09	; 9
    1e3a:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1e3c:	80 91 95 01 	lds	r24, 0x0195	; 0x800195 <xPendingReadyCoRoutineList>
    1e40:	88 23       	and	r24, r24
    1e42:	11 f1       	breq	.+68     	; 0x1e88 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1e44:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1e46:	e0 91 9a 01 	lds	r30, 0x019A	; 0x80019a <xPendingReadyCoRoutineList+0x5>
    1e4a:	f0 91 9b 01 	lds	r31, 0x019B	; 0x80019b <xPendingReadyCoRoutineList+0x6>
    1e4e:	c6 81       	ldd	r28, Z+6	; 0x06
    1e50:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e52:	ce 01       	movw	r24, r28
    1e54:	0c 96       	adiw	r24, 0x0c	; 12
    1e56:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e5a:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e5c:	8e 01       	movw	r16, r28
    1e5e:	0e 5f       	subi	r16, 0xFE	; 254
    1e60:	1f 4f       	sbci	r17, 0xFF	; 255
    1e62:	c8 01       	movw	r24, r16
    1e64:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e68:	8e 89       	ldd	r24, Y+22	; 0x16
    1e6a:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <uxTopCoRoutineReadyPriority>
    1e6e:	98 17       	cp	r25, r24
    1e70:	10 f4       	brcc	.+4      	; 0x1e76 <vCoRoutineSchedule+0x48>
    1e72:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <uxTopCoRoutineReadyPriority>
    1e76:	f8 9e       	mul	r15, r24
    1e78:	c0 01       	movw	r24, r0
    1e7a:	11 24       	eor	r1, r1
    1e7c:	b8 01       	movw	r22, r16
    1e7e:	8c 54       	subi	r24, 0x4C	; 76
    1e80:	9e 4f       	sbci	r25, 0xFE	; 254
    1e82:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
    1e86:	da cf       	rjmp	.-76     	; 0x1e3c <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e88:	0e 94 a7 03 	call	0x74e	; 0x74e <xTaskGetTickCount>
    1e8c:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <xLastTickCount>
    1e90:	30 91 91 01 	lds	r19, 0x0191	; 0x800191 <xLastTickCount+0x1>
    1e94:	82 1b       	sub	r24, r18
    1e96:	93 0b       	sbc	r25, r19
    1e98:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <xPassedTicks+0x1>
    1e9c:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1ea0:	89 e0       	ldi	r24, 0x09	; 9
    1ea2:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1ea4:	20 91 8e 01 	lds	r18, 0x018E	; 0x80018e <xPassedTicks>
    1ea8:	30 91 8f 01 	lds	r19, 0x018F	; 0x80018f <xPassedTicks+0x1>
    1eac:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <xCoRoutineTickCount>
    1eb0:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <xCoRoutineTickCount+0x1>
    1eb4:	21 15       	cp	r18, r1
    1eb6:	31 05       	cpc	r19, r1
    1eb8:	09 f4       	brne	.+2      	; 0x1ebc <vCoRoutineSchedule+0x8e>
    1eba:	54 c0       	rjmp	.+168    	; 0x1f64 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1ebc:	01 96       	adiw	r24, 0x01	; 1
    1ebe:	90 93 93 01 	sts	0x0193, r25	; 0x800193 <xCoRoutineTickCount+0x1>
    1ec2:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <xCoRoutineTickCount>
		xPassedTicks--;
    1ec6:	21 50       	subi	r18, 0x01	; 1
    1ec8:	31 09       	sbc	r19, r1
    1eca:	30 93 8f 01 	sts	0x018F, r19	; 0x80018f <xPassedTicks+0x1>
    1ece:	20 93 8e 01 	sts	0x018E, r18	; 0x80018e <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1ed2:	89 2b       	or	r24, r25
    1ed4:	09 f0       	breq	.+2      	; 0x1ed8 <vCoRoutineSchedule+0xaa>
    1ed6:	3e c0       	rjmp	.+124    	; 0x1f54 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1ed8:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList>
    1edc:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1ee0:	20 91 9e 01 	lds	r18, 0x019E	; 0x80019e <pxOverflowDelayedCoRoutineList>
    1ee4:	30 91 9f 01 	lds	r19, 0x019F	; 0x80019f <pxOverflowDelayedCoRoutineList+0x1>
    1ee8:	30 93 a1 01 	sts	0x01A1, r19	; 0x8001a1 <pxDelayedCoRoutineList+0x1>
    1eec:	20 93 a0 01 	sts	0x01A0, r18	; 0x8001a0 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1ef0:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <pxOverflowDelayedCoRoutineList+0x1>
    1ef4:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <pxOverflowDelayedCoRoutineList>
    1ef8:	2d c0       	rjmp	.+90     	; 0x1f54 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1efa:	05 80       	ldd	r0, Z+5	; 0x05
    1efc:	f6 81       	ldd	r31, Z+6	; 0x06
    1efe:	e0 2d       	mov	r30, r0
    1f00:	c6 81       	ldd	r28, Z+6	; 0x06
    1f02:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1f04:	2a 81       	ldd	r18, Y+2	; 0x02
    1f06:	3b 81       	ldd	r19, Y+3	; 0x03
    1f08:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <xCoRoutineTickCount>
    1f0c:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <xCoRoutineTickCount+0x1>
    1f10:	82 17       	cp	r24, r18
    1f12:	93 07       	cpc	r25, r19
    1f14:	38 f2       	brcs	.-114    	; 0x1ea4 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1f16:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1f18:	8e 01       	movw	r16, r28
    1f1a:	0e 5f       	subi	r16, 0xFE	; 254
    1f1c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f1e:	c8 01       	movw	r24, r16
    1f20:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1f24:	8c 89       	ldd	r24, Y+20	; 0x14
    1f26:	9d 89       	ldd	r25, Y+21	; 0x15
    1f28:	89 2b       	or	r24, r25
    1f2a:	21 f0       	breq	.+8      	; 0x1f34 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1f2c:	ce 01       	movw	r24, r28
    1f2e:	0c 96       	adiw	r24, 0x0c	; 12
    1f30:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1f34:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f36:	8e 89       	ldd	r24, Y+22	; 0x16
    1f38:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <uxTopCoRoutineReadyPriority>
    1f3c:	98 17       	cp	r25, r24
    1f3e:	10 f4       	brcc	.+4      	; 0x1f44 <vCoRoutineSchedule+0x116>
    1f40:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <uxTopCoRoutineReadyPriority>
    1f44:	f8 9e       	mul	r15, r24
    1f46:	c0 01       	movw	r24, r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	b8 01       	movw	r22, r16
    1f4c:	8c 54       	subi	r24, 0x4C	; 76
    1f4e:	9e 4f       	sbci	r25, 0xFE	; 254
    1f50:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f54:	e0 91 a0 01 	lds	r30, 0x01A0	; 0x8001a0 <pxDelayedCoRoutineList>
    1f58:	f0 91 a1 01 	lds	r31, 0x01A1	; 0x8001a1 <pxDelayedCoRoutineList+0x1>
    1f5c:	80 81       	ld	r24, Z
    1f5e:	81 11       	cpse	r24, r1
    1f60:	cc cf       	rjmp	.-104    	; 0x1efa <vCoRoutineSchedule+0xcc>
    1f62:	a0 cf       	rjmp	.-192    	; 0x1ea4 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f64:	90 93 91 01 	sts	0x0191, r25	; 0x800191 <xLastTickCount+0x1>
    1f68:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <xLastTickCount>
    1f6c:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f70:	69 e0       	ldi	r22, 0x09	; 9
    1f72:	48 2f       	mov	r20, r24
    1f74:	50 e0       	ldi	r21, 0x00	; 0
    1f76:	64 9f       	mul	r22, r20
    1f78:	90 01       	movw	r18, r0
    1f7a:	65 9f       	mul	r22, r21
    1f7c:	30 0d       	add	r19, r0
    1f7e:	11 24       	eor	r1, r1
    1f80:	f9 01       	movw	r30, r18
    1f82:	ec 54       	subi	r30, 0x4C	; 76
    1f84:	fe 4f       	sbci	r31, 0xFE	; 254
    1f86:	90 81       	ld	r25, Z
    1f88:	91 11       	cpse	r25, r1
    1f8a:	0c c0       	rjmp	.+24     	; 0x1fa4 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	08 c0       	rjmp	.+16     	; 0x1fa0 <vCoRoutineSchedule+0x172>
    1f90:	10 92 94 01 	sts	0x0194, r1	; 0x800194 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1f94:	df 91       	pop	r29
    1f96:	cf 91       	pop	r28
    1f98:	1f 91       	pop	r17
    1f9a:	0f 91       	pop	r16
    1f9c:	ff 90       	pop	r15
    1f9e:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1fa0:	81 50       	subi	r24, 0x01	; 1
    1fa2:	e7 cf       	rjmp	.-50     	; 0x1f72 <vCoRoutineSchedule+0x144>
    1fa4:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1fa8:	a1 81       	ldd	r26, Z+1	; 0x01
    1faa:	b2 81       	ldd	r27, Z+2	; 0x02
    1fac:	12 96       	adiw	r26, 0x02	; 2
    1fae:	0d 90       	ld	r0, X+
    1fb0:	bc 91       	ld	r27, X
    1fb2:	a0 2d       	mov	r26, r0
    1fb4:	b2 83       	std	Z+2, r27	; 0x02
    1fb6:	a1 83       	std	Z+1, r26	; 0x01
    1fb8:	29 54       	subi	r18, 0x49	; 73
    1fba:	3e 4f       	sbci	r19, 0xFE	; 254
    1fbc:	a2 17       	cp	r26, r18
    1fbe:	b3 07       	cpc	r27, r19
    1fc0:	31 f4       	brne	.+12     	; 0x1fce <vCoRoutineSchedule+0x1a0>
    1fc2:	12 96       	adiw	r26, 0x02	; 2
    1fc4:	8d 91       	ld	r24, X+
    1fc6:	9c 91       	ld	r25, X
    1fc8:	13 97       	sbiw	r26, 0x03	; 3
    1fca:	92 83       	std	Z+2, r25	; 0x02
    1fcc:	81 83       	std	Z+1, r24	; 0x01
    1fce:	89 e0       	ldi	r24, 0x09	; 9
    1fd0:	84 9f       	mul	r24, r20
    1fd2:	f0 01       	movw	r30, r0
    1fd4:	85 9f       	mul	r24, r21
    1fd6:	f0 0d       	add	r31, r0
    1fd8:	11 24       	eor	r1, r1
    1fda:	ec 54       	subi	r30, 0x4C	; 76
    1fdc:	fe 4f       	sbci	r31, 0xFE	; 254
    1fde:	01 80       	ldd	r0, Z+1	; 0x01
    1fe0:	f2 81       	ldd	r31, Z+2	; 0x02
    1fe2:	e0 2d       	mov	r30, r0
    1fe4:	86 81       	ldd	r24, Z+6	; 0x06
    1fe6:	97 81       	ldd	r25, Z+7	; 0x07
    1fe8:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <pxCurrentCoRoutine+0x1>
    1fec:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1ff0:	dc 01       	movw	r26, r24
    1ff2:	ed 91       	ld	r30, X+
    1ff4:	fc 91       	ld	r31, X
    1ff6:	11 97       	sbiw	r26, 0x01	; 1
    1ff8:	57 96       	adiw	r26, 0x17	; 23
    1ffa:	6c 91       	ld	r22, X

	return;
}
    1ffc:	df 91       	pop	r29
    1ffe:	cf 91       	pop	r28
    2000:	1f 91       	pop	r17
    2002:	0f 91       	pop	r16
    2004:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2006:	09 94       	ijmp

00002008 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2008:	0f 93       	push	r16
    200a:	1f 93       	push	r17
    200c:	cf 93       	push	r28
    200e:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2010:	dc 01       	movw	r26, r24
    2012:	15 96       	adiw	r26, 0x05	; 5
    2014:	ed 91       	ld	r30, X+
    2016:	fc 91       	ld	r31, X
    2018:	16 97       	sbiw	r26, 0x06	; 6
    201a:	c6 81       	ldd	r28, Z+6	; 0x06
    201c:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    201e:	8e 01       	movw	r16, r28
    2020:	04 5f       	subi	r16, 0xF4	; 244
    2022:	1f 4f       	sbci	r17, 0xFF	; 255
    2024:	c8 01       	movw	r24, r16
    2026:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    202a:	b8 01       	movw	r22, r16
    202c:	85 e9       	ldi	r24, 0x95	; 149
    202e:	91 e0       	ldi	r25, 0x01	; 1
    2030:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2034:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pxCurrentCoRoutine>
    2038:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    203c:	81 e0       	ldi	r24, 0x01	; 1
    203e:	2e 89       	ldd	r18, Y+22	; 0x16
    2040:	96 89       	ldd	r25, Z+22	; 0x16
    2042:	29 17       	cp	r18, r25
    2044:	08 f4       	brcc	.+2      	; 0x2048 <xCoRoutineRemoveFromEventList+0x40>
    2046:	80 e0       	ldi	r24, 0x00	; 0
}
    2048:	df 91       	pop	r29
    204a:	cf 91       	pop	r28
    204c:	1f 91       	pop	r17
    204e:	0f 91       	pop	r16
    2050:	08 95       	ret

00002052 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2052:	cf 93       	push	r28
    2054:	df 93       	push	r29
    2056:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2058:	0e 94 a1 03 	call	0x742	; 0x742 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    205c:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <pucAlignedHeap.2081>
    2060:	90 91 c7 01 	lds	r25, 0x01C7	; 0x8001c7 <pucAlignedHeap.2081+0x1>
    2064:	89 2b       	or	r24, r25
    2066:	31 f4       	brne	.+12     	; 0x2074 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2068:	8b ec       	ldi	r24, 0xCB	; 203
    206a:	91 e0       	ldi	r25, 0x01	; 1
    206c:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <pucAlignedHeap.2081+0x1>
    2070:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2074:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <xNextFreeByte>
    2078:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <xNextFreeByte+0x1>
    207c:	c9 01       	movw	r24, r18
    207e:	8c 0f       	add	r24, r28
    2080:	9d 1f       	adc	r25, r29
    2082:	8b 3d       	cpi	r24, 0xDB	; 219
    2084:	45 e0       	ldi	r20, 0x05	; 5
    2086:	94 07       	cpc	r25, r20
    2088:	70 f4       	brcc	.+28     	; 0x20a6 <pvPortMalloc+0x54>
    208a:	28 17       	cp	r18, r24
    208c:	39 07       	cpc	r19, r25
    208e:	58 f4       	brcc	.+22     	; 0x20a6 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2090:	c0 91 c6 01 	lds	r28, 0x01C6	; 0x8001c6 <pucAlignedHeap.2081>
    2094:	d0 91 c7 01 	lds	r29, 0x01C7	; 0x8001c7 <pucAlignedHeap.2081+0x1>
    2098:	c2 0f       	add	r28, r18
    209a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    209c:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <xNextFreeByte+0x1>
    20a0:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <xNextFreeByte>
    20a4:	02 c0       	rjmp	.+4      	; 0x20aa <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    20a6:	c0 e0       	ldi	r28, 0x00	; 0
    20a8:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    20aa:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    20ae:	ce 01       	movw	r24, r28
    20b0:	df 91       	pop	r29
    20b2:	cf 91       	pop	r28
    20b4:	08 95       	ret

000020b6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    20b6:	08 95       	ret

000020b8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    20b8:	10 92 c9 01 	sts	0x01C9, r1	; 0x8001c9 <xNextFreeByte+0x1>
    20bc:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <xNextFreeByte>
    20c0:	08 95       	ret

000020c2 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    20c2:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <xNextFreeByte>
    20c6:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <xNextFreeByte+0x1>
}
    20ca:	8b ed       	ldi	r24, 0xDB	; 219
    20cc:	95 e0       	ldi	r25, 0x05	; 5
    20ce:	82 1b       	sub	r24, r18
    20d0:	93 0b       	sbc	r25, r19
    20d2:	08 95       	ret

000020d4 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    20d4:	31 e1       	ldi	r19, 0x11	; 17
    20d6:	fc 01       	movw	r30, r24
    20d8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    20da:	31 97       	sbiw	r30, 0x01	; 1
    20dc:	22 e2       	ldi	r18, 0x22	; 34
    20de:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    20e0:	31 97       	sbiw	r30, 0x01	; 1
    20e2:	a3 e3       	ldi	r26, 0x33	; 51
    20e4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20e6:	31 97       	sbiw	r30, 0x01	; 1
    20e8:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20ea:	31 97       	sbiw	r30, 0x01	; 1
    20ec:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    20ee:	31 97       	sbiw	r30, 0x01	; 1
    20f0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20f2:	31 97       	sbiw	r30, 0x01	; 1
    20f4:	60 e8       	ldi	r22, 0x80	; 128
    20f6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    20f8:	31 97       	sbiw	r30, 0x01	; 1
    20fa:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	62 e0       	ldi	r22, 0x02	; 2
    2100:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	63 e0       	ldi	r22, 0x03	; 3
    2106:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	64 e0       	ldi	r22, 0x04	; 4
    210c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	65 e0       	ldi	r22, 0x05	; 5
    2112:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2114:	31 97       	sbiw	r30, 0x01	; 1
    2116:	66 e0       	ldi	r22, 0x06	; 6
    2118:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    211a:	31 97       	sbiw	r30, 0x01	; 1
    211c:	67 e0       	ldi	r22, 0x07	; 7
    211e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2120:	31 97       	sbiw	r30, 0x01	; 1
    2122:	68 e0       	ldi	r22, 0x08	; 8
    2124:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2126:	31 97       	sbiw	r30, 0x01	; 1
    2128:	69 e0       	ldi	r22, 0x09	; 9
    212a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	60 e1       	ldi	r22, 0x10	; 16
    2130:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2132:	31 97       	sbiw	r30, 0x01	; 1
    2134:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	32 e1       	ldi	r19, 0x12	; 18
    213a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	33 e1       	ldi	r19, 0x13	; 19
    2140:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	34 e1       	ldi	r19, 0x14	; 20
    2146:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	35 e1       	ldi	r19, 0x15	; 21
    214c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    214e:	31 97       	sbiw	r30, 0x01	; 1
    2150:	36 e1       	ldi	r19, 0x16	; 22
    2152:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2154:	31 97       	sbiw	r30, 0x01	; 1
    2156:	37 e1       	ldi	r19, 0x17	; 23
    2158:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    215a:	31 97       	sbiw	r30, 0x01	; 1
    215c:	38 e1       	ldi	r19, 0x18	; 24
    215e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2160:	31 97       	sbiw	r30, 0x01	; 1
    2162:	39 e1       	ldi	r19, 0x19	; 25
    2164:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2166:	31 97       	sbiw	r30, 0x01	; 1
    2168:	30 e2       	ldi	r19, 0x20	; 32
    216a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    216c:	31 97       	sbiw	r30, 0x01	; 1
    216e:	31 e2       	ldi	r19, 0x21	; 33
    2170:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2172:	31 97       	sbiw	r30, 0x01	; 1
    2174:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2176:	31 97       	sbiw	r30, 0x01	; 1
    2178:	23 e2       	ldi	r18, 0x23	; 35
    217a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    217c:	31 97       	sbiw	r30, 0x01	; 1
    217e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2180:	31 97       	sbiw	r30, 0x01	; 1
    2182:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2184:	31 97       	sbiw	r30, 0x01	; 1
    2186:	26 e2       	ldi	r18, 0x26	; 38
    2188:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    218a:	31 97       	sbiw	r30, 0x01	; 1
    218c:	27 e2       	ldi	r18, 0x27	; 39
    218e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2190:	31 97       	sbiw	r30, 0x01	; 1
    2192:	28 e2       	ldi	r18, 0x28	; 40
    2194:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2196:	31 97       	sbiw	r30, 0x01	; 1
    2198:	29 e2       	ldi	r18, 0x29	; 41
    219a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    219c:	31 97       	sbiw	r30, 0x01	; 1
    219e:	20 e3       	ldi	r18, 0x30	; 48
    21a0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    21a2:	31 97       	sbiw	r30, 0x01	; 1
    21a4:	21 e3       	ldi	r18, 0x31	; 49
    21a6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    21a8:	86 97       	sbiw	r24, 0x26	; 38
    21aa:	08 95       	ret

000021ac <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    21ac:	89 ef       	ldi	r24, 0xF9	; 249
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    21b4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    21b8:	e0 e8       	ldi	r30, 0x80	; 128
    21ba:	f0 e0       	ldi	r31, 0x00	; 0
    21bc:	80 81       	ld	r24, Z
    21be:	8c 7f       	andi	r24, 0xFC	; 252
    21c0:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21c2:	8b e0       	ldi	r24, 0x0B	; 11
    21c4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    21c8:	ef e6       	ldi	r30, 0x6F	; 111
    21ca:	f0 e0       	ldi	r31, 0x00	; 0
    21cc:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21ce:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    21d0:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21d2:	a0 91 26 01 	lds	r26, 0x0126	; 0x800126 <__data_end>
    21d6:	b0 91 27 01 	lds	r27, 0x0127	; 0x800127 <__data_end+0x1>
    21da:	cd 91       	ld	r28, X+
    21dc:	cd bf       	out	0x3d, r28	; 61
    21de:	dd 91       	ld	r29, X+
    21e0:	de bf       	out	0x3e, r29	; 62
    21e2:	ff 91       	pop	r31
    21e4:	ef 91       	pop	r30
    21e6:	df 91       	pop	r29
    21e8:	cf 91       	pop	r28
    21ea:	bf 91       	pop	r27
    21ec:	af 91       	pop	r26
    21ee:	9f 91       	pop	r25
    21f0:	8f 91       	pop	r24
    21f2:	7f 91       	pop	r23
    21f4:	6f 91       	pop	r22
    21f6:	5f 91       	pop	r21
    21f8:	4f 91       	pop	r20
    21fa:	3f 91       	pop	r19
    21fc:	2f 91       	pop	r18
    21fe:	1f 91       	pop	r17
    2200:	0f 91       	pop	r16
    2202:	ff 90       	pop	r15
    2204:	ef 90       	pop	r14
    2206:	df 90       	pop	r13
    2208:	cf 90       	pop	r12
    220a:	bf 90       	pop	r11
    220c:	af 90       	pop	r10
    220e:	9f 90       	pop	r9
    2210:	8f 90       	pop	r8
    2212:	7f 90       	pop	r7
    2214:	6f 90       	pop	r6
    2216:	5f 90       	pop	r5
    2218:	4f 90       	pop	r4
    221a:	3f 90       	pop	r3
    221c:	2f 90       	pop	r2
    221e:	1f 90       	pop	r1
    2220:	0f 90       	pop	r0
    2222:	0f be       	out	0x3f, r0	; 63
    2224:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2226:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	08 95       	ret

0000222c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    222c:	08 95       	ret

0000222e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    222e:	0f 92       	push	r0
    2230:	0f b6       	in	r0, 0x3f	; 63
    2232:	f8 94       	cli
    2234:	0f 92       	push	r0
    2236:	1f 92       	push	r1
    2238:	11 24       	eor	r1, r1
    223a:	2f 92       	push	r2
    223c:	3f 92       	push	r3
    223e:	4f 92       	push	r4
    2240:	5f 92       	push	r5
    2242:	6f 92       	push	r6
    2244:	7f 92       	push	r7
    2246:	8f 92       	push	r8
    2248:	9f 92       	push	r9
    224a:	af 92       	push	r10
    224c:	bf 92       	push	r11
    224e:	cf 92       	push	r12
    2250:	df 92       	push	r13
    2252:	ef 92       	push	r14
    2254:	ff 92       	push	r15
    2256:	0f 93       	push	r16
    2258:	1f 93       	push	r17
    225a:	2f 93       	push	r18
    225c:	3f 93       	push	r19
    225e:	4f 93       	push	r20
    2260:	5f 93       	push	r21
    2262:	6f 93       	push	r22
    2264:	7f 93       	push	r23
    2266:	8f 93       	push	r24
    2268:	9f 93       	push	r25
    226a:	af 93       	push	r26
    226c:	bf 93       	push	r27
    226e:	cf 93       	push	r28
    2270:	df 93       	push	r29
    2272:	ef 93       	push	r30
    2274:	ff 93       	push	r31
    2276:	a0 91 26 01 	lds	r26, 0x0126	; 0x800126 <__data_end>
    227a:	b0 91 27 01 	lds	r27, 0x0127	; 0x800127 <__data_end+0x1>
    227e:	0d b6       	in	r0, 0x3d	; 61
    2280:	0d 92       	st	X+, r0
    2282:	0e b6       	in	r0, 0x3e	; 62
    2284:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2286:	0e 94 29 05 	call	0xa52	; 0xa52 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    228a:	a0 91 26 01 	lds	r26, 0x0126	; 0x800126 <__data_end>
    228e:	b0 91 27 01 	lds	r27, 0x0127	; 0x800127 <__data_end+0x1>
    2292:	cd 91       	ld	r28, X+
    2294:	cd bf       	out	0x3d, r28	; 61
    2296:	dd 91       	ld	r29, X+
    2298:	de bf       	out	0x3e, r29	; 62
    229a:	ff 91       	pop	r31
    229c:	ef 91       	pop	r30
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	bf 91       	pop	r27
    22a4:	af 91       	pop	r26
    22a6:	9f 91       	pop	r25
    22a8:	8f 91       	pop	r24
    22aa:	7f 91       	pop	r23
    22ac:	6f 91       	pop	r22
    22ae:	5f 91       	pop	r21
    22b0:	4f 91       	pop	r20
    22b2:	3f 91       	pop	r19
    22b4:	2f 91       	pop	r18
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	df 90       	pop	r13
    22c0:	cf 90       	pop	r12
    22c2:	bf 90       	pop	r11
    22c4:	af 90       	pop	r10
    22c6:	9f 90       	pop	r9
    22c8:	8f 90       	pop	r8
    22ca:	7f 90       	pop	r7
    22cc:	6f 90       	pop	r6
    22ce:	5f 90       	pop	r5
    22d0:	4f 90       	pop	r4
    22d2:	3f 90       	pop	r3
    22d4:	2f 90       	pop	r2
    22d6:	1f 90       	pop	r1
    22d8:	0f 90       	pop	r0
    22da:	0f be       	out	0x3f, r0	; 63
    22dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22de:	08 95       	ret

000022e0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22e0:	0f 92       	push	r0
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	f8 94       	cli
    22e6:	0f 92       	push	r0
    22e8:	1f 92       	push	r1
    22ea:	11 24       	eor	r1, r1
    22ec:	2f 92       	push	r2
    22ee:	3f 92       	push	r3
    22f0:	4f 92       	push	r4
    22f2:	5f 92       	push	r5
    22f4:	6f 92       	push	r6
    22f6:	7f 92       	push	r7
    22f8:	8f 92       	push	r8
    22fa:	9f 92       	push	r9
    22fc:	af 92       	push	r10
    22fe:	bf 92       	push	r11
    2300:	cf 92       	push	r12
    2302:	df 92       	push	r13
    2304:	ef 92       	push	r14
    2306:	ff 92       	push	r15
    2308:	0f 93       	push	r16
    230a:	1f 93       	push	r17
    230c:	2f 93       	push	r18
    230e:	3f 93       	push	r19
    2310:	4f 93       	push	r20
    2312:	5f 93       	push	r21
    2314:	6f 93       	push	r22
    2316:	7f 93       	push	r23
    2318:	8f 93       	push	r24
    231a:	9f 93       	push	r25
    231c:	af 93       	push	r26
    231e:	bf 93       	push	r27
    2320:	cf 93       	push	r28
    2322:	df 93       	push	r29
    2324:	ef 93       	push	r30
    2326:	ff 93       	push	r31
    2328:	a0 91 26 01 	lds	r26, 0x0126	; 0x800126 <__data_end>
    232c:	b0 91 27 01 	lds	r27, 0x0127	; 0x800127 <__data_end+0x1>
    2330:	0d b6       	in	r0, 0x3d	; 61
    2332:	0d 92       	st	X+, r0
    2334:	0e b6       	in	r0, 0x3e	; 62
    2336:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2338:	0e 94 c1 03 	call	0x782	; 0x782 <xTaskIncrementTick>
    233c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    233e:	0e 94 29 05 	call	0xa52	; 0xa52 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2342:	a0 91 26 01 	lds	r26, 0x0126	; 0x800126 <__data_end>
    2346:	b0 91 27 01 	lds	r27, 0x0127	; 0x800127 <__data_end+0x1>
    234a:	cd 91       	ld	r28, X+
    234c:	cd bf       	out	0x3d, r28	; 61
    234e:	dd 91       	ld	r29, X+
    2350:	de bf       	out	0x3e, r29	; 62
    2352:	ff 91       	pop	r31
    2354:	ef 91       	pop	r30
    2356:	df 91       	pop	r29
    2358:	cf 91       	pop	r28
    235a:	bf 91       	pop	r27
    235c:	af 91       	pop	r26
    235e:	9f 91       	pop	r25
    2360:	8f 91       	pop	r24
    2362:	7f 91       	pop	r23
    2364:	6f 91       	pop	r22
    2366:	5f 91       	pop	r21
    2368:	4f 91       	pop	r20
    236a:	3f 91       	pop	r19
    236c:	2f 91       	pop	r18
    236e:	1f 91       	pop	r17
    2370:	0f 91       	pop	r16
    2372:	ff 90       	pop	r15
    2374:	ef 90       	pop	r14
    2376:	df 90       	pop	r13
    2378:	cf 90       	pop	r12
    237a:	bf 90       	pop	r11
    237c:	af 90       	pop	r10
    237e:	9f 90       	pop	r9
    2380:	8f 90       	pop	r8
    2382:	7f 90       	pop	r7
    2384:	6f 90       	pop	r6
    2386:	5f 90       	pop	r5
    2388:	4f 90       	pop	r4
    238a:	3f 90       	pop	r3
    238c:	2f 90       	pop	r2
    238e:	1f 90       	pop	r1
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2396:	08 95       	ret

00002398 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2398:	0e 94 70 11 	call	0x22e0	; 0x22e0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    239c:	18 95       	reti

0000239e <uart_transmit>:
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0) | _BV(RXCIE0) | _BV(UDRIE0); /* Enable RX and TX i wczamy interupty na RX i interupty na UDRE */
}

int uart_transmit(char c, FILE *stream)
{
    239e:	cf 93       	push	r28
    23a0:	df 93       	push	r29
    23a2:	1f 92       	push	r1
    23a4:	cd b7       	in	r28, 0x3d	; 61
    23a6:	de b7       	in	r29, 0x3e	; 62
    23a8:	89 83       	std	Y+1, r24	; 0x01
  if(uxQueueSpacesAvailable(out) == 0)
    23aa:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <out>
    23ae:	90 91 a9 07 	lds	r25, 0x07A9	; 0x8007a9 <out+0x1>
    23b2:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <uxQueueSpacesAvailable>
    23b6:	81 11       	cpse	r24, r1
    23b8:	07 c0       	rjmp	.+14     	; 0x23c8 <uart_transmit+0x2a>
    while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
    23ba:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    23be:	85 fd       	sbrc	r24, 5
    23c0:	03 c0       	rjmp	.+6      	; 0x23c8 <uart_transmit+0x2a>
    23c2:	0e 94 17 11 	call	0x222e	; 0x222e <vPortYield>
    23c6:	f9 cf       	rjmp	.-14     	; 0x23ba <uart_transmit+0x1c>

  xQueueSend(out, (void*)&c, (TickType_t)0);
    23c8:	20 e0       	ldi	r18, 0x00	; 0
    23ca:	40 e0       	ldi	r20, 0x00	; 0
    23cc:	50 e0       	ldi	r21, 0x00	; 0
    23ce:	be 01       	movw	r22, r28
    23d0:	6f 5f       	subi	r22, 0xFF	; 255
    23d2:	7f 4f       	sbci	r23, 0xFF	; 255
    23d4:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <out>
    23d8:	90 91 a9 07 	lds	r25, 0x07A9	; 0x8007a9 <out+0x1>
    23dc:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xQueueGenericSend>
  return 0;
}
    23e0:	80 e0       	ldi	r24, 0x00	; 0
    23e2:	90 e0       	ldi	r25, 0x00	; 0
    23e4:	0f 90       	pop	r0
    23e6:	df 91       	pop	r29
    23e8:	cf 91       	pop	r28
    23ea:	08 95       	ret

000023ec <uart_receive>:

int uart_receive(FILE *stream)
{
    23ec:	cf 93       	push	r28
    23ee:	df 93       	push	r29
    23f0:	1f 92       	push	r1
    23f2:	cd b7       	in	r28, 0x3d	; 61
    23f4:	de b7       	in	r29, 0x3e	; 62
  uint8_t data;
  while(xQueueReceive(in, (void*)&data, (TickType_t)0) == pdFALSE) // xQueueReceiveFromISR useless
    23f6:	40 e0       	ldi	r20, 0x00	; 0
    23f8:	50 e0       	ldi	r21, 0x00	; 0
    23fa:	be 01       	movw	r22, r28
    23fc:	6f 5f       	subi	r22, 0xFF	; 255
    23fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2400:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <in>
    2404:	90 91 a7 07 	lds	r25, 0x07A7	; 0x8007a7 <in+0x1>
    2408:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <xQueueReceive>
    240c:	81 11       	cpse	r24, r1
    240e:	05 c0       	rjmp	.+10     	; 0x241a <uart_receive+0x2e>
    vTaskDelay(10 / portTICK_PERIOD_MS);
    2410:	8a e0       	ldi	r24, 0x0A	; 10
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	0e 94 14 05 	call	0xa28	; 0xa28 <vTaskDelay>
    2418:	ee cf       	rjmp	.-36     	; 0x23f6 <uart_receive+0xa>
  return (char)data;
    241a:	89 81       	ldd	r24, Y+1	; 0x01
}
    241c:	08 2e       	mov	r0, r24
    241e:	00 0c       	add	r0, r0
    2420:	99 0b       	sbc	r25, r25
    2422:	0f 90       	pop	r0
    2424:	df 91       	pop	r29
    2426:	cf 91       	pop	r28
    2428:	08 95       	ret

0000242a <uart_init>:
    242a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    242e:	87 e6       	ldi	r24, 0x67	; 103
    2430:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    2434:	e0 ec       	ldi	r30, 0xC0	; 192
    2436:	f0 e0       	ldi	r31, 0x00	; 0
    2438:	80 81       	ld	r24, Z
    243a:	8d 7f       	andi	r24, 0xFD	; 253
    243c:	80 83       	st	Z, r24
    243e:	86 e0       	ldi	r24, 0x06	; 6
    2440:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    2444:	88 eb       	ldi	r24, 0xB8	; 184
    2446:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    244a:	08 95       	ret

0000244c <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    244c:	ef 92       	push	r14
    244e:	ff 92       	push	r15
    2450:	0f 93       	push	r16
    2452:	cf 93       	push	r28
    2454:	df 93       	push	r29
    2456:	00 d0       	rcall	.+0      	; 0x2458 <main+0xc>
    2458:	00 d0       	rcall	.+0      	; 0x245a <main+0xe>
    245a:	cd b7       	in	r28, 0x3d	; 61
    245c:	de b7       	in	r29, 0x3e	; 62
    QueueHandle_t in;
    QueueHandle_t out; */
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    in = xQueueCreate(10, sizeof(char));
    245e:	40 e0       	ldi	r20, 0x00	; 0
    2460:	61 e0       	ldi	r22, 0x01	; 1
    2462:	8a e0       	ldi	r24, 0x0A	; 10
    2464:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <xQueueGenericCreate>
    2468:	90 93 a7 07 	sts	0x07A7, r25	; 0x8007a7 <in+0x1>
    246c:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <in>
    out = xQueueCreate(10, sizeof(char));
    2470:	40 e0       	ldi	r20, 0x00	; 0
    2472:	61 e0       	ldi	r22, 0x01	; 1
    2474:	8a e0       	ldi	r24, 0x0A	; 10
    2476:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <xQueueGenericCreate>
    247a:	90 93 a9 07 	sts	0x07A9, r25	; 0x8007a9 <out+0x1>
    247e:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <out>

    xTaskCreate
    2482:	ce 01       	movw	r24, r28
    2484:	03 96       	adiw	r24, 0x03	; 3
    2486:	7c 01       	movw	r14, r24
    2488:	01 e0       	ldi	r16, 0x01	; 1
    248a:	20 e0       	ldi	r18, 0x00	; 0
    248c:	30 e0       	ldi	r19, 0x00	; 0
    248e:	45 e5       	ldi	r20, 0x55	; 85
    2490:	50 e0       	ldi	r21, 0x00	; 0
    2492:	63 e1       	ldi	r22, 0x13	; 19
    2494:	71 e0       	ldi	r23, 0x01	; 1
    2496:	8a e7       	ldi	r24, 0x7A	; 122
    2498:	90 e0       	ldi	r25, 0x00	; 0
    249a:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskCreate>
         NULL,
         mainLED_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    249e:	ce 01       	movw	r24, r28
    24a0:	01 96       	adiw	r24, 0x01	; 1
    24a2:	7c 01       	movw	r14, r24
    24a4:	02 e0       	ldi	r16, 0x02	; 2
    24a6:	20 e0       	ldi	r18, 0x00	; 0
    24a8:	30 e0       	ldi	r19, 0x00	; 0
    24aa:	45 e5       	ldi	r20, 0x55	; 85
    24ac:	50 e0       	ldi	r21, 0x00	; 0
    24ae:	69 e1       	ldi	r22, 0x19	; 25
    24b0:	71 e0       	ldi	r23, 0x01	; 1
    24b2:	83 e5       	ldi	r24, 0x53	; 83
    24b4:	90 e0       	ldi	r25, 0x00	; 0
    24b6:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskCreate>
         mainSERIAL_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    24ba:	0e 94 72 03 	call	0x6e4	; 0x6e4 <vTaskStartScheduler>

    return 0;
}
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	0f 90       	pop	r0
    24c4:	0f 90       	pop	r0
    24c6:	0f 90       	pop	r0
    24c8:	0f 90       	pop	r0
    24ca:	df 91       	pop	r29
    24cc:	cf 91       	pop	r28
    24ce:	0f 91       	pop	r16
    24d0:	ff 90       	pop	r15
    24d2:	ef 90       	pop	r14
    24d4:	08 95       	ret

000024d6 <memcpy>:
    24d6:	fb 01       	movw	r30, r22
    24d8:	dc 01       	movw	r26, r24
    24da:	02 c0       	rjmp	.+4      	; 0x24e0 <memcpy+0xa>
    24dc:	01 90       	ld	r0, Z+
    24de:	0d 92       	st	X+, r0
    24e0:	41 50       	subi	r20, 0x01	; 1
    24e2:	50 40       	sbci	r21, 0x00	; 0
    24e4:	d8 f7       	brcc	.-10     	; 0x24dc <memcpy+0x6>
    24e6:	08 95       	ret

000024e8 <fgetc>:
    24e8:	cf 93       	push	r28
    24ea:	df 93       	push	r29
    24ec:	ec 01       	movw	r28, r24
    24ee:	2b 81       	ldd	r18, Y+3	; 0x03
    24f0:	20 ff       	sbrs	r18, 0
    24f2:	33 c0       	rjmp	.+102    	; 0x255a <fgetc+0x72>
    24f4:	26 ff       	sbrs	r18, 6
    24f6:	0a c0       	rjmp	.+20     	; 0x250c <fgetc+0x24>
    24f8:	2f 7b       	andi	r18, 0xBF	; 191
    24fa:	2b 83       	std	Y+3, r18	; 0x03
    24fc:	8e 81       	ldd	r24, Y+6	; 0x06
    24fe:	9f 81       	ldd	r25, Y+7	; 0x07
    2500:	01 96       	adiw	r24, 0x01	; 1
    2502:	9f 83       	std	Y+7, r25	; 0x07
    2504:	8e 83       	std	Y+6, r24	; 0x06
    2506:	8a 81       	ldd	r24, Y+2	; 0x02
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	29 c0       	rjmp	.+82     	; 0x255e <fgetc+0x76>
    250c:	22 ff       	sbrs	r18, 2
    250e:	0f c0       	rjmp	.+30     	; 0x252e <fgetc+0x46>
    2510:	e8 81       	ld	r30, Y
    2512:	f9 81       	ldd	r31, Y+1	; 0x01
    2514:	80 81       	ld	r24, Z
    2516:	08 2e       	mov	r0, r24
    2518:	00 0c       	add	r0, r0
    251a:	99 0b       	sbc	r25, r25
    251c:	00 97       	sbiw	r24, 0x00	; 0
    251e:	19 f4       	brne	.+6      	; 0x2526 <fgetc+0x3e>
    2520:	20 62       	ori	r18, 0x20	; 32
    2522:	2b 83       	std	Y+3, r18	; 0x03
    2524:	1a c0       	rjmp	.+52     	; 0x255a <fgetc+0x72>
    2526:	31 96       	adiw	r30, 0x01	; 1
    2528:	f9 83       	std	Y+1, r31	; 0x01
    252a:	e8 83       	st	Y, r30
    252c:	0e c0       	rjmp	.+28     	; 0x254a <fgetc+0x62>
    252e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2530:	fb 85       	ldd	r31, Y+11	; 0x0b
    2532:	09 95       	icall
    2534:	97 ff       	sbrs	r25, 7
    2536:	09 c0       	rjmp	.+18     	; 0x254a <fgetc+0x62>
    2538:	2b 81       	ldd	r18, Y+3	; 0x03
    253a:	01 96       	adiw	r24, 0x01	; 1
    253c:	11 f0       	breq	.+4      	; 0x2542 <fgetc+0x5a>
    253e:	80 e2       	ldi	r24, 0x20	; 32
    2540:	01 c0       	rjmp	.+2      	; 0x2544 <fgetc+0x5c>
    2542:	80 e1       	ldi	r24, 0x10	; 16
    2544:	82 2b       	or	r24, r18
    2546:	8b 83       	std	Y+3, r24	; 0x03
    2548:	08 c0       	rjmp	.+16     	; 0x255a <fgetc+0x72>
    254a:	2e 81       	ldd	r18, Y+6	; 0x06
    254c:	3f 81       	ldd	r19, Y+7	; 0x07
    254e:	2f 5f       	subi	r18, 0xFF	; 255
    2550:	3f 4f       	sbci	r19, 0xFF	; 255
    2552:	3f 83       	std	Y+7, r19	; 0x07
    2554:	2e 83       	std	Y+6, r18	; 0x06
    2556:	99 27       	eor	r25, r25
    2558:	02 c0       	rjmp	.+4      	; 0x255e <fgetc+0x76>
    255a:	8f ef       	ldi	r24, 0xFF	; 255
    255c:	9f ef       	ldi	r25, 0xFF	; 255
    255e:	df 91       	pop	r29
    2560:	cf 91       	pop	r28
    2562:	08 95       	ret

00002564 <printf>:
    2564:	a0 e0       	ldi	r26, 0x00	; 0
    2566:	b0 e0       	ldi	r27, 0x00	; 0
    2568:	e8 eb       	ldi	r30, 0xB8	; 184
    256a:	f2 e1       	ldi	r31, 0x12	; 18
    256c:	0c 94 69 15 	jmp	0x2ad2	; 0x2ad2 <__prologue_saves__+0x20>
    2570:	ae 01       	movw	r20, r28
    2572:	4b 5f       	subi	r20, 0xFB	; 251
    2574:	5f 4f       	sbci	r21, 0xFF	; 255
    2576:	fa 01       	movw	r30, r20
    2578:	61 91       	ld	r22, Z+
    257a:	71 91       	ld	r23, Z+
    257c:	af 01       	movw	r20, r30
    257e:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <__iob+0x2>
    2582:	90 91 ad 07 	lds	r25, 0x07AD	; 0x8007ad <__iob+0x3>
    2586:	0e 94 c8 12 	call	0x2590	; 0x2590 <vfprintf>
    258a:	e2 e0       	ldi	r30, 0x02	; 2
    258c:	0c 94 85 15 	jmp	0x2b0a	; 0x2b0a <__epilogue_restores__+0x20>

00002590 <vfprintf>:
    2590:	ab e0       	ldi	r26, 0x0B	; 11
    2592:	b0 e0       	ldi	r27, 0x00	; 0
    2594:	ee ec       	ldi	r30, 0xCE	; 206
    2596:	f2 e1       	ldi	r31, 0x12	; 18
    2598:	0c 94 59 15 	jmp	0x2ab2	; 0x2ab2 <__prologue_saves__>
    259c:	6c 01       	movw	r12, r24
    259e:	7b 01       	movw	r14, r22
    25a0:	8a 01       	movw	r16, r20
    25a2:	fc 01       	movw	r30, r24
    25a4:	17 82       	std	Z+7, r1	; 0x07
    25a6:	16 82       	std	Z+6, r1	; 0x06
    25a8:	83 81       	ldd	r24, Z+3	; 0x03
    25aa:	81 ff       	sbrs	r24, 1
    25ac:	cc c1       	rjmp	.+920    	; 0x2946 <vfprintf+0x3b6>
    25ae:	ce 01       	movw	r24, r28
    25b0:	01 96       	adiw	r24, 0x01	; 1
    25b2:	3c 01       	movw	r6, r24
    25b4:	f6 01       	movw	r30, r12
    25b6:	93 81       	ldd	r25, Z+3	; 0x03
    25b8:	f7 01       	movw	r30, r14
    25ba:	93 fd       	sbrc	r25, 3
    25bc:	85 91       	lpm	r24, Z+
    25be:	93 ff       	sbrs	r25, 3
    25c0:	81 91       	ld	r24, Z+
    25c2:	7f 01       	movw	r14, r30
    25c4:	88 23       	and	r24, r24
    25c6:	09 f4       	brne	.+2      	; 0x25ca <vfprintf+0x3a>
    25c8:	ba c1       	rjmp	.+884    	; 0x293e <vfprintf+0x3ae>
    25ca:	85 32       	cpi	r24, 0x25	; 37
    25cc:	39 f4       	brne	.+14     	; 0x25dc <vfprintf+0x4c>
    25ce:	93 fd       	sbrc	r25, 3
    25d0:	85 91       	lpm	r24, Z+
    25d2:	93 ff       	sbrs	r25, 3
    25d4:	81 91       	ld	r24, Z+
    25d6:	7f 01       	movw	r14, r30
    25d8:	85 32       	cpi	r24, 0x25	; 37
    25da:	29 f4       	brne	.+10     	; 0x25e6 <vfprintf+0x56>
    25dc:	b6 01       	movw	r22, r12
    25de:	90 e0       	ldi	r25, 0x00	; 0
    25e0:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    25e4:	e7 cf       	rjmp	.-50     	; 0x25b4 <vfprintf+0x24>
    25e6:	91 2c       	mov	r9, r1
    25e8:	21 2c       	mov	r2, r1
    25ea:	31 2c       	mov	r3, r1
    25ec:	ff e1       	ldi	r31, 0x1F	; 31
    25ee:	f3 15       	cp	r31, r3
    25f0:	d8 f0       	brcs	.+54     	; 0x2628 <vfprintf+0x98>
    25f2:	8b 32       	cpi	r24, 0x2B	; 43
    25f4:	79 f0       	breq	.+30     	; 0x2614 <vfprintf+0x84>
    25f6:	38 f4       	brcc	.+14     	; 0x2606 <vfprintf+0x76>
    25f8:	80 32       	cpi	r24, 0x20	; 32
    25fa:	79 f0       	breq	.+30     	; 0x261a <vfprintf+0x8a>
    25fc:	83 32       	cpi	r24, 0x23	; 35
    25fe:	a1 f4       	brne	.+40     	; 0x2628 <vfprintf+0x98>
    2600:	23 2d       	mov	r18, r3
    2602:	20 61       	ori	r18, 0x10	; 16
    2604:	1d c0       	rjmp	.+58     	; 0x2640 <vfprintf+0xb0>
    2606:	8d 32       	cpi	r24, 0x2D	; 45
    2608:	61 f0       	breq	.+24     	; 0x2622 <vfprintf+0x92>
    260a:	80 33       	cpi	r24, 0x30	; 48
    260c:	69 f4       	brne	.+26     	; 0x2628 <vfprintf+0x98>
    260e:	23 2d       	mov	r18, r3
    2610:	21 60       	ori	r18, 0x01	; 1
    2612:	16 c0       	rjmp	.+44     	; 0x2640 <vfprintf+0xb0>
    2614:	83 2d       	mov	r24, r3
    2616:	82 60       	ori	r24, 0x02	; 2
    2618:	38 2e       	mov	r3, r24
    261a:	e3 2d       	mov	r30, r3
    261c:	e4 60       	ori	r30, 0x04	; 4
    261e:	3e 2e       	mov	r3, r30
    2620:	2a c0       	rjmp	.+84     	; 0x2676 <vfprintf+0xe6>
    2622:	f3 2d       	mov	r31, r3
    2624:	f8 60       	ori	r31, 0x08	; 8
    2626:	1d c0       	rjmp	.+58     	; 0x2662 <vfprintf+0xd2>
    2628:	37 fc       	sbrc	r3, 7
    262a:	2d c0       	rjmp	.+90     	; 0x2686 <vfprintf+0xf6>
    262c:	20 ed       	ldi	r18, 0xD0	; 208
    262e:	28 0f       	add	r18, r24
    2630:	2a 30       	cpi	r18, 0x0A	; 10
    2632:	40 f0       	brcs	.+16     	; 0x2644 <vfprintf+0xb4>
    2634:	8e 32       	cpi	r24, 0x2E	; 46
    2636:	b9 f4       	brne	.+46     	; 0x2666 <vfprintf+0xd6>
    2638:	36 fc       	sbrc	r3, 6
    263a:	81 c1       	rjmp	.+770    	; 0x293e <vfprintf+0x3ae>
    263c:	23 2d       	mov	r18, r3
    263e:	20 64       	ori	r18, 0x40	; 64
    2640:	32 2e       	mov	r3, r18
    2642:	19 c0       	rjmp	.+50     	; 0x2676 <vfprintf+0xe6>
    2644:	36 fe       	sbrs	r3, 6
    2646:	06 c0       	rjmp	.+12     	; 0x2654 <vfprintf+0xc4>
    2648:	8a e0       	ldi	r24, 0x0A	; 10
    264a:	98 9e       	mul	r9, r24
    264c:	20 0d       	add	r18, r0
    264e:	11 24       	eor	r1, r1
    2650:	92 2e       	mov	r9, r18
    2652:	11 c0       	rjmp	.+34     	; 0x2676 <vfprintf+0xe6>
    2654:	ea e0       	ldi	r30, 0x0A	; 10
    2656:	2e 9e       	mul	r2, r30
    2658:	20 0d       	add	r18, r0
    265a:	11 24       	eor	r1, r1
    265c:	22 2e       	mov	r2, r18
    265e:	f3 2d       	mov	r31, r3
    2660:	f0 62       	ori	r31, 0x20	; 32
    2662:	3f 2e       	mov	r3, r31
    2664:	08 c0       	rjmp	.+16     	; 0x2676 <vfprintf+0xe6>
    2666:	8c 36       	cpi	r24, 0x6C	; 108
    2668:	21 f4       	brne	.+8      	; 0x2672 <vfprintf+0xe2>
    266a:	83 2d       	mov	r24, r3
    266c:	80 68       	ori	r24, 0x80	; 128
    266e:	38 2e       	mov	r3, r24
    2670:	02 c0       	rjmp	.+4      	; 0x2676 <vfprintf+0xe6>
    2672:	88 36       	cpi	r24, 0x68	; 104
    2674:	41 f4       	brne	.+16     	; 0x2686 <vfprintf+0xf6>
    2676:	f7 01       	movw	r30, r14
    2678:	93 fd       	sbrc	r25, 3
    267a:	85 91       	lpm	r24, Z+
    267c:	93 ff       	sbrs	r25, 3
    267e:	81 91       	ld	r24, Z+
    2680:	7f 01       	movw	r14, r30
    2682:	81 11       	cpse	r24, r1
    2684:	b3 cf       	rjmp	.-154    	; 0x25ec <vfprintf+0x5c>
    2686:	98 2f       	mov	r25, r24
    2688:	9f 7d       	andi	r25, 0xDF	; 223
    268a:	95 54       	subi	r25, 0x45	; 69
    268c:	93 30       	cpi	r25, 0x03	; 3
    268e:	28 f4       	brcc	.+10     	; 0x269a <vfprintf+0x10a>
    2690:	0c 5f       	subi	r16, 0xFC	; 252
    2692:	1f 4f       	sbci	r17, 0xFF	; 255
    2694:	9f e3       	ldi	r25, 0x3F	; 63
    2696:	99 83       	std	Y+1, r25	; 0x01
    2698:	0d c0       	rjmp	.+26     	; 0x26b4 <vfprintf+0x124>
    269a:	83 36       	cpi	r24, 0x63	; 99
    269c:	31 f0       	breq	.+12     	; 0x26aa <vfprintf+0x11a>
    269e:	83 37       	cpi	r24, 0x73	; 115
    26a0:	71 f0       	breq	.+28     	; 0x26be <vfprintf+0x12e>
    26a2:	83 35       	cpi	r24, 0x53	; 83
    26a4:	09 f0       	breq	.+2      	; 0x26a8 <vfprintf+0x118>
    26a6:	59 c0       	rjmp	.+178    	; 0x275a <vfprintf+0x1ca>
    26a8:	21 c0       	rjmp	.+66     	; 0x26ec <vfprintf+0x15c>
    26aa:	f8 01       	movw	r30, r16
    26ac:	80 81       	ld	r24, Z
    26ae:	89 83       	std	Y+1, r24	; 0x01
    26b0:	0e 5f       	subi	r16, 0xFE	; 254
    26b2:	1f 4f       	sbci	r17, 0xFF	; 255
    26b4:	88 24       	eor	r8, r8
    26b6:	83 94       	inc	r8
    26b8:	91 2c       	mov	r9, r1
    26ba:	53 01       	movw	r10, r6
    26bc:	13 c0       	rjmp	.+38     	; 0x26e4 <vfprintf+0x154>
    26be:	28 01       	movw	r4, r16
    26c0:	f2 e0       	ldi	r31, 0x02	; 2
    26c2:	4f 0e       	add	r4, r31
    26c4:	51 1c       	adc	r5, r1
    26c6:	f8 01       	movw	r30, r16
    26c8:	a0 80       	ld	r10, Z
    26ca:	b1 80       	ldd	r11, Z+1	; 0x01
    26cc:	36 fe       	sbrs	r3, 6
    26ce:	03 c0       	rjmp	.+6      	; 0x26d6 <vfprintf+0x146>
    26d0:	69 2d       	mov	r22, r9
    26d2:	70 e0       	ldi	r23, 0x00	; 0
    26d4:	02 c0       	rjmp	.+4      	; 0x26da <vfprintf+0x14a>
    26d6:	6f ef       	ldi	r22, 0xFF	; 255
    26d8:	7f ef       	ldi	r23, 0xFF	; 255
    26da:	c5 01       	movw	r24, r10
    26dc:	0e 94 b4 14 	call	0x2968	; 0x2968 <strnlen>
    26e0:	4c 01       	movw	r8, r24
    26e2:	82 01       	movw	r16, r4
    26e4:	f3 2d       	mov	r31, r3
    26e6:	ff 77       	andi	r31, 0x7F	; 127
    26e8:	3f 2e       	mov	r3, r31
    26ea:	16 c0       	rjmp	.+44     	; 0x2718 <vfprintf+0x188>
    26ec:	28 01       	movw	r4, r16
    26ee:	22 e0       	ldi	r18, 0x02	; 2
    26f0:	42 0e       	add	r4, r18
    26f2:	51 1c       	adc	r5, r1
    26f4:	f8 01       	movw	r30, r16
    26f6:	a0 80       	ld	r10, Z
    26f8:	b1 80       	ldd	r11, Z+1	; 0x01
    26fa:	36 fe       	sbrs	r3, 6
    26fc:	03 c0       	rjmp	.+6      	; 0x2704 <vfprintf+0x174>
    26fe:	69 2d       	mov	r22, r9
    2700:	70 e0       	ldi	r23, 0x00	; 0
    2702:	02 c0       	rjmp	.+4      	; 0x2708 <vfprintf+0x178>
    2704:	6f ef       	ldi	r22, 0xFF	; 255
    2706:	7f ef       	ldi	r23, 0xFF	; 255
    2708:	c5 01       	movw	r24, r10
    270a:	0e 94 a9 14 	call	0x2952	; 0x2952 <strnlen_P>
    270e:	4c 01       	movw	r8, r24
    2710:	f3 2d       	mov	r31, r3
    2712:	f0 68       	ori	r31, 0x80	; 128
    2714:	3f 2e       	mov	r3, r31
    2716:	82 01       	movw	r16, r4
    2718:	33 fc       	sbrc	r3, 3
    271a:	1b c0       	rjmp	.+54     	; 0x2752 <vfprintf+0x1c2>
    271c:	82 2d       	mov	r24, r2
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	88 16       	cp	r8, r24
    2722:	99 06       	cpc	r9, r25
    2724:	b0 f4       	brcc	.+44     	; 0x2752 <vfprintf+0x1c2>
    2726:	b6 01       	movw	r22, r12
    2728:	80 e2       	ldi	r24, 0x20	; 32
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    2730:	2a 94       	dec	r2
    2732:	f4 cf       	rjmp	.-24     	; 0x271c <vfprintf+0x18c>
    2734:	f5 01       	movw	r30, r10
    2736:	37 fc       	sbrc	r3, 7
    2738:	85 91       	lpm	r24, Z+
    273a:	37 fe       	sbrs	r3, 7
    273c:	81 91       	ld	r24, Z+
    273e:	5f 01       	movw	r10, r30
    2740:	b6 01       	movw	r22, r12
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    2748:	21 10       	cpse	r2, r1
    274a:	2a 94       	dec	r2
    274c:	21 e0       	ldi	r18, 0x01	; 1
    274e:	82 1a       	sub	r8, r18
    2750:	91 08       	sbc	r9, r1
    2752:	81 14       	cp	r8, r1
    2754:	91 04       	cpc	r9, r1
    2756:	71 f7       	brne	.-36     	; 0x2734 <vfprintf+0x1a4>
    2758:	e8 c0       	rjmp	.+464    	; 0x292a <vfprintf+0x39a>
    275a:	84 36       	cpi	r24, 0x64	; 100
    275c:	11 f0       	breq	.+4      	; 0x2762 <vfprintf+0x1d2>
    275e:	89 36       	cpi	r24, 0x69	; 105
    2760:	41 f5       	brne	.+80     	; 0x27b2 <vfprintf+0x222>
    2762:	f8 01       	movw	r30, r16
    2764:	37 fe       	sbrs	r3, 7
    2766:	07 c0       	rjmp	.+14     	; 0x2776 <vfprintf+0x1e6>
    2768:	60 81       	ld	r22, Z
    276a:	71 81       	ldd	r23, Z+1	; 0x01
    276c:	82 81       	ldd	r24, Z+2	; 0x02
    276e:	93 81       	ldd	r25, Z+3	; 0x03
    2770:	0c 5f       	subi	r16, 0xFC	; 252
    2772:	1f 4f       	sbci	r17, 0xFF	; 255
    2774:	08 c0       	rjmp	.+16     	; 0x2786 <vfprintf+0x1f6>
    2776:	60 81       	ld	r22, Z
    2778:	71 81       	ldd	r23, Z+1	; 0x01
    277a:	07 2e       	mov	r0, r23
    277c:	00 0c       	add	r0, r0
    277e:	88 0b       	sbc	r24, r24
    2780:	99 0b       	sbc	r25, r25
    2782:	0e 5f       	subi	r16, 0xFE	; 254
    2784:	1f 4f       	sbci	r17, 0xFF	; 255
    2786:	f3 2d       	mov	r31, r3
    2788:	ff 76       	andi	r31, 0x6F	; 111
    278a:	3f 2e       	mov	r3, r31
    278c:	97 ff       	sbrs	r25, 7
    278e:	09 c0       	rjmp	.+18     	; 0x27a2 <vfprintf+0x212>
    2790:	90 95       	com	r25
    2792:	80 95       	com	r24
    2794:	70 95       	com	r23
    2796:	61 95       	neg	r22
    2798:	7f 4f       	sbci	r23, 0xFF	; 255
    279a:	8f 4f       	sbci	r24, 0xFF	; 255
    279c:	9f 4f       	sbci	r25, 0xFF	; 255
    279e:	f0 68       	ori	r31, 0x80	; 128
    27a0:	3f 2e       	mov	r3, r31
    27a2:	2a e0       	ldi	r18, 0x0A	; 10
    27a4:	30 e0       	ldi	r19, 0x00	; 0
    27a6:	a3 01       	movw	r20, r6
    27a8:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <__ultoa_invert>
    27ac:	88 2e       	mov	r8, r24
    27ae:	86 18       	sub	r8, r6
    27b0:	45 c0       	rjmp	.+138    	; 0x283c <vfprintf+0x2ac>
    27b2:	85 37       	cpi	r24, 0x75	; 117
    27b4:	31 f4       	brne	.+12     	; 0x27c2 <vfprintf+0x232>
    27b6:	23 2d       	mov	r18, r3
    27b8:	2f 7e       	andi	r18, 0xEF	; 239
    27ba:	b2 2e       	mov	r11, r18
    27bc:	2a e0       	ldi	r18, 0x0A	; 10
    27be:	30 e0       	ldi	r19, 0x00	; 0
    27c0:	25 c0       	rjmp	.+74     	; 0x280c <vfprintf+0x27c>
    27c2:	93 2d       	mov	r25, r3
    27c4:	99 7f       	andi	r25, 0xF9	; 249
    27c6:	b9 2e       	mov	r11, r25
    27c8:	8f 36       	cpi	r24, 0x6F	; 111
    27ca:	c1 f0       	breq	.+48     	; 0x27fc <vfprintf+0x26c>
    27cc:	18 f4       	brcc	.+6      	; 0x27d4 <vfprintf+0x244>
    27ce:	88 35       	cpi	r24, 0x58	; 88
    27d0:	79 f0       	breq	.+30     	; 0x27f0 <vfprintf+0x260>
    27d2:	b5 c0       	rjmp	.+362    	; 0x293e <vfprintf+0x3ae>
    27d4:	80 37       	cpi	r24, 0x70	; 112
    27d6:	19 f0       	breq	.+6      	; 0x27de <vfprintf+0x24e>
    27d8:	88 37       	cpi	r24, 0x78	; 120
    27da:	21 f0       	breq	.+8      	; 0x27e4 <vfprintf+0x254>
    27dc:	b0 c0       	rjmp	.+352    	; 0x293e <vfprintf+0x3ae>
    27de:	e9 2f       	mov	r30, r25
    27e0:	e0 61       	ori	r30, 0x10	; 16
    27e2:	be 2e       	mov	r11, r30
    27e4:	b4 fe       	sbrs	r11, 4
    27e6:	0d c0       	rjmp	.+26     	; 0x2802 <vfprintf+0x272>
    27e8:	fb 2d       	mov	r31, r11
    27ea:	f4 60       	ori	r31, 0x04	; 4
    27ec:	bf 2e       	mov	r11, r31
    27ee:	09 c0       	rjmp	.+18     	; 0x2802 <vfprintf+0x272>
    27f0:	34 fe       	sbrs	r3, 4
    27f2:	0a c0       	rjmp	.+20     	; 0x2808 <vfprintf+0x278>
    27f4:	29 2f       	mov	r18, r25
    27f6:	26 60       	ori	r18, 0x06	; 6
    27f8:	b2 2e       	mov	r11, r18
    27fa:	06 c0       	rjmp	.+12     	; 0x2808 <vfprintf+0x278>
    27fc:	28 e0       	ldi	r18, 0x08	; 8
    27fe:	30 e0       	ldi	r19, 0x00	; 0
    2800:	05 c0       	rjmp	.+10     	; 0x280c <vfprintf+0x27c>
    2802:	20 e1       	ldi	r18, 0x10	; 16
    2804:	30 e0       	ldi	r19, 0x00	; 0
    2806:	02 c0       	rjmp	.+4      	; 0x280c <vfprintf+0x27c>
    2808:	20 e1       	ldi	r18, 0x10	; 16
    280a:	32 e0       	ldi	r19, 0x02	; 2
    280c:	f8 01       	movw	r30, r16
    280e:	b7 fe       	sbrs	r11, 7
    2810:	07 c0       	rjmp	.+14     	; 0x2820 <vfprintf+0x290>
    2812:	60 81       	ld	r22, Z
    2814:	71 81       	ldd	r23, Z+1	; 0x01
    2816:	82 81       	ldd	r24, Z+2	; 0x02
    2818:	93 81       	ldd	r25, Z+3	; 0x03
    281a:	0c 5f       	subi	r16, 0xFC	; 252
    281c:	1f 4f       	sbci	r17, 0xFF	; 255
    281e:	06 c0       	rjmp	.+12     	; 0x282c <vfprintf+0x29c>
    2820:	60 81       	ld	r22, Z
    2822:	71 81       	ldd	r23, Z+1	; 0x01
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	90 e0       	ldi	r25, 0x00	; 0
    2828:	0e 5f       	subi	r16, 0xFE	; 254
    282a:	1f 4f       	sbci	r17, 0xFF	; 255
    282c:	a3 01       	movw	r20, r6
    282e:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <__ultoa_invert>
    2832:	88 2e       	mov	r8, r24
    2834:	86 18       	sub	r8, r6
    2836:	fb 2d       	mov	r31, r11
    2838:	ff 77       	andi	r31, 0x7F	; 127
    283a:	3f 2e       	mov	r3, r31
    283c:	36 fe       	sbrs	r3, 6
    283e:	0d c0       	rjmp	.+26     	; 0x285a <vfprintf+0x2ca>
    2840:	23 2d       	mov	r18, r3
    2842:	2e 7f       	andi	r18, 0xFE	; 254
    2844:	a2 2e       	mov	r10, r18
    2846:	89 14       	cp	r8, r9
    2848:	58 f4       	brcc	.+22     	; 0x2860 <vfprintf+0x2d0>
    284a:	34 fe       	sbrs	r3, 4
    284c:	0b c0       	rjmp	.+22     	; 0x2864 <vfprintf+0x2d4>
    284e:	32 fc       	sbrc	r3, 2
    2850:	09 c0       	rjmp	.+18     	; 0x2864 <vfprintf+0x2d4>
    2852:	83 2d       	mov	r24, r3
    2854:	8e 7e       	andi	r24, 0xEE	; 238
    2856:	a8 2e       	mov	r10, r24
    2858:	05 c0       	rjmp	.+10     	; 0x2864 <vfprintf+0x2d4>
    285a:	b8 2c       	mov	r11, r8
    285c:	a3 2c       	mov	r10, r3
    285e:	03 c0       	rjmp	.+6      	; 0x2866 <vfprintf+0x2d6>
    2860:	b8 2c       	mov	r11, r8
    2862:	01 c0       	rjmp	.+2      	; 0x2866 <vfprintf+0x2d6>
    2864:	b9 2c       	mov	r11, r9
    2866:	a4 fe       	sbrs	r10, 4
    2868:	0f c0       	rjmp	.+30     	; 0x2888 <vfprintf+0x2f8>
    286a:	fe 01       	movw	r30, r28
    286c:	e8 0d       	add	r30, r8
    286e:	f1 1d       	adc	r31, r1
    2870:	80 81       	ld	r24, Z
    2872:	80 33       	cpi	r24, 0x30	; 48
    2874:	21 f4       	brne	.+8      	; 0x287e <vfprintf+0x2ee>
    2876:	9a 2d       	mov	r25, r10
    2878:	99 7e       	andi	r25, 0xE9	; 233
    287a:	a9 2e       	mov	r10, r25
    287c:	09 c0       	rjmp	.+18     	; 0x2890 <vfprintf+0x300>
    287e:	a2 fe       	sbrs	r10, 2
    2880:	06 c0       	rjmp	.+12     	; 0x288e <vfprintf+0x2fe>
    2882:	b3 94       	inc	r11
    2884:	b3 94       	inc	r11
    2886:	04 c0       	rjmp	.+8      	; 0x2890 <vfprintf+0x300>
    2888:	8a 2d       	mov	r24, r10
    288a:	86 78       	andi	r24, 0x86	; 134
    288c:	09 f0       	breq	.+2      	; 0x2890 <vfprintf+0x300>
    288e:	b3 94       	inc	r11
    2890:	a3 fc       	sbrc	r10, 3
    2892:	11 c0       	rjmp	.+34     	; 0x28b6 <vfprintf+0x326>
    2894:	a0 fe       	sbrs	r10, 0
    2896:	06 c0       	rjmp	.+12     	; 0x28a4 <vfprintf+0x314>
    2898:	b2 14       	cp	r11, r2
    289a:	88 f4       	brcc	.+34     	; 0x28be <vfprintf+0x32e>
    289c:	28 0c       	add	r2, r8
    289e:	92 2c       	mov	r9, r2
    28a0:	9b 18       	sub	r9, r11
    28a2:	0e c0       	rjmp	.+28     	; 0x28c0 <vfprintf+0x330>
    28a4:	b2 14       	cp	r11, r2
    28a6:	60 f4       	brcc	.+24     	; 0x28c0 <vfprintf+0x330>
    28a8:	b6 01       	movw	r22, r12
    28aa:	80 e2       	ldi	r24, 0x20	; 32
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    28b2:	b3 94       	inc	r11
    28b4:	f7 cf       	rjmp	.-18     	; 0x28a4 <vfprintf+0x314>
    28b6:	b2 14       	cp	r11, r2
    28b8:	18 f4       	brcc	.+6      	; 0x28c0 <vfprintf+0x330>
    28ba:	2b 18       	sub	r2, r11
    28bc:	02 c0       	rjmp	.+4      	; 0x28c2 <vfprintf+0x332>
    28be:	98 2c       	mov	r9, r8
    28c0:	21 2c       	mov	r2, r1
    28c2:	a4 fe       	sbrs	r10, 4
    28c4:	10 c0       	rjmp	.+32     	; 0x28e6 <vfprintf+0x356>
    28c6:	b6 01       	movw	r22, r12
    28c8:	80 e3       	ldi	r24, 0x30	; 48
    28ca:	90 e0       	ldi	r25, 0x00	; 0
    28cc:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    28d0:	a2 fe       	sbrs	r10, 2
    28d2:	17 c0       	rjmp	.+46     	; 0x2902 <vfprintf+0x372>
    28d4:	a1 fc       	sbrc	r10, 1
    28d6:	03 c0       	rjmp	.+6      	; 0x28de <vfprintf+0x34e>
    28d8:	88 e7       	ldi	r24, 0x78	; 120
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	02 c0       	rjmp	.+4      	; 0x28e2 <vfprintf+0x352>
    28de:	88 e5       	ldi	r24, 0x58	; 88
    28e0:	90 e0       	ldi	r25, 0x00	; 0
    28e2:	b6 01       	movw	r22, r12
    28e4:	0c c0       	rjmp	.+24     	; 0x28fe <vfprintf+0x36e>
    28e6:	8a 2d       	mov	r24, r10
    28e8:	86 78       	andi	r24, 0x86	; 134
    28ea:	59 f0       	breq	.+22     	; 0x2902 <vfprintf+0x372>
    28ec:	a1 fe       	sbrs	r10, 1
    28ee:	02 c0       	rjmp	.+4      	; 0x28f4 <vfprintf+0x364>
    28f0:	8b e2       	ldi	r24, 0x2B	; 43
    28f2:	01 c0       	rjmp	.+2      	; 0x28f6 <vfprintf+0x366>
    28f4:	80 e2       	ldi	r24, 0x20	; 32
    28f6:	a7 fc       	sbrc	r10, 7
    28f8:	8d e2       	ldi	r24, 0x2D	; 45
    28fa:	b6 01       	movw	r22, r12
    28fc:	90 e0       	ldi	r25, 0x00	; 0
    28fe:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    2902:	89 14       	cp	r8, r9
    2904:	38 f4       	brcc	.+14     	; 0x2914 <vfprintf+0x384>
    2906:	b6 01       	movw	r22, r12
    2908:	80 e3       	ldi	r24, 0x30	; 48
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    2910:	9a 94       	dec	r9
    2912:	f7 cf       	rjmp	.-18     	; 0x2902 <vfprintf+0x372>
    2914:	8a 94       	dec	r8
    2916:	f3 01       	movw	r30, r6
    2918:	e8 0d       	add	r30, r8
    291a:	f1 1d       	adc	r31, r1
    291c:	80 81       	ld	r24, Z
    291e:	b6 01       	movw	r22, r12
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    2926:	81 10       	cpse	r8, r1
    2928:	f5 cf       	rjmp	.-22     	; 0x2914 <vfprintf+0x384>
    292a:	22 20       	and	r2, r2
    292c:	09 f4       	brne	.+2      	; 0x2930 <vfprintf+0x3a0>
    292e:	42 ce       	rjmp	.-892    	; 0x25b4 <vfprintf+0x24>
    2930:	b6 01       	movw	r22, r12
    2932:	80 e2       	ldi	r24, 0x20	; 32
    2934:	90 e0       	ldi	r25, 0x00	; 0
    2936:	0e 94 bf 14 	call	0x297e	; 0x297e <fputc>
    293a:	2a 94       	dec	r2
    293c:	f6 cf       	rjmp	.-20     	; 0x292a <vfprintf+0x39a>
    293e:	f6 01       	movw	r30, r12
    2940:	86 81       	ldd	r24, Z+6	; 0x06
    2942:	97 81       	ldd	r25, Z+7	; 0x07
    2944:	02 c0       	rjmp	.+4      	; 0x294a <vfprintf+0x3ba>
    2946:	8f ef       	ldi	r24, 0xFF	; 255
    2948:	9f ef       	ldi	r25, 0xFF	; 255
    294a:	2b 96       	adiw	r28, 0x0b	; 11
    294c:	e2 e1       	ldi	r30, 0x12	; 18
    294e:	0c 94 75 15 	jmp	0x2aea	; 0x2aea <__epilogue_restores__>

00002952 <strnlen_P>:
    2952:	fc 01       	movw	r30, r24
    2954:	05 90       	lpm	r0, Z+
    2956:	61 50       	subi	r22, 0x01	; 1
    2958:	70 40       	sbci	r23, 0x00	; 0
    295a:	01 10       	cpse	r0, r1
    295c:	d8 f7       	brcc	.-10     	; 0x2954 <strnlen_P+0x2>
    295e:	80 95       	com	r24
    2960:	90 95       	com	r25
    2962:	8e 0f       	add	r24, r30
    2964:	9f 1f       	adc	r25, r31
    2966:	08 95       	ret

00002968 <strnlen>:
    2968:	fc 01       	movw	r30, r24
    296a:	61 50       	subi	r22, 0x01	; 1
    296c:	70 40       	sbci	r23, 0x00	; 0
    296e:	01 90       	ld	r0, Z+
    2970:	01 10       	cpse	r0, r1
    2972:	d8 f7       	brcc	.-10     	; 0x296a <strnlen+0x2>
    2974:	80 95       	com	r24
    2976:	90 95       	com	r25
    2978:	8e 0f       	add	r24, r30
    297a:	9f 1f       	adc	r25, r31
    297c:	08 95       	ret

0000297e <fputc>:
    297e:	0f 93       	push	r16
    2980:	1f 93       	push	r17
    2982:	cf 93       	push	r28
    2984:	df 93       	push	r29
    2986:	fb 01       	movw	r30, r22
    2988:	23 81       	ldd	r18, Z+3	; 0x03
    298a:	21 fd       	sbrc	r18, 1
    298c:	03 c0       	rjmp	.+6      	; 0x2994 <fputc+0x16>
    298e:	8f ef       	ldi	r24, 0xFF	; 255
    2990:	9f ef       	ldi	r25, 0xFF	; 255
    2992:	2c c0       	rjmp	.+88     	; 0x29ec <fputc+0x6e>
    2994:	22 ff       	sbrs	r18, 2
    2996:	16 c0       	rjmp	.+44     	; 0x29c4 <fputc+0x46>
    2998:	46 81       	ldd	r20, Z+6	; 0x06
    299a:	57 81       	ldd	r21, Z+7	; 0x07
    299c:	24 81       	ldd	r18, Z+4	; 0x04
    299e:	35 81       	ldd	r19, Z+5	; 0x05
    29a0:	42 17       	cp	r20, r18
    29a2:	53 07       	cpc	r21, r19
    29a4:	44 f4       	brge	.+16     	; 0x29b6 <fputc+0x38>
    29a6:	a0 81       	ld	r26, Z
    29a8:	b1 81       	ldd	r27, Z+1	; 0x01
    29aa:	9d 01       	movw	r18, r26
    29ac:	2f 5f       	subi	r18, 0xFF	; 255
    29ae:	3f 4f       	sbci	r19, 0xFF	; 255
    29b0:	31 83       	std	Z+1, r19	; 0x01
    29b2:	20 83       	st	Z, r18
    29b4:	8c 93       	st	X, r24
    29b6:	26 81       	ldd	r18, Z+6	; 0x06
    29b8:	37 81       	ldd	r19, Z+7	; 0x07
    29ba:	2f 5f       	subi	r18, 0xFF	; 255
    29bc:	3f 4f       	sbci	r19, 0xFF	; 255
    29be:	37 83       	std	Z+7, r19	; 0x07
    29c0:	26 83       	std	Z+6, r18	; 0x06
    29c2:	14 c0       	rjmp	.+40     	; 0x29ec <fputc+0x6e>
    29c4:	8b 01       	movw	r16, r22
    29c6:	ec 01       	movw	r28, r24
    29c8:	fb 01       	movw	r30, r22
    29ca:	00 84       	ldd	r0, Z+8	; 0x08
    29cc:	f1 85       	ldd	r31, Z+9	; 0x09
    29ce:	e0 2d       	mov	r30, r0
    29d0:	09 95       	icall
    29d2:	89 2b       	or	r24, r25
    29d4:	e1 f6       	brne	.-72     	; 0x298e <fputc+0x10>
    29d6:	d8 01       	movw	r26, r16
    29d8:	16 96       	adiw	r26, 0x06	; 6
    29da:	8d 91       	ld	r24, X+
    29dc:	9c 91       	ld	r25, X
    29de:	17 97       	sbiw	r26, 0x07	; 7
    29e0:	01 96       	adiw	r24, 0x01	; 1
    29e2:	17 96       	adiw	r26, 0x07	; 7
    29e4:	9c 93       	st	X, r25
    29e6:	8e 93       	st	-X, r24
    29e8:	16 97       	sbiw	r26, 0x06	; 6
    29ea:	ce 01       	movw	r24, r28
    29ec:	df 91       	pop	r29
    29ee:	cf 91       	pop	r28
    29f0:	1f 91       	pop	r17
    29f2:	0f 91       	pop	r16
    29f4:	08 95       	ret

000029f6 <__ultoa_invert>:
    29f6:	fa 01       	movw	r30, r20
    29f8:	aa 27       	eor	r26, r26
    29fa:	28 30       	cpi	r18, 0x08	; 8
    29fc:	51 f1       	breq	.+84     	; 0x2a52 <__ultoa_invert+0x5c>
    29fe:	20 31       	cpi	r18, 0x10	; 16
    2a00:	81 f1       	breq	.+96     	; 0x2a62 <__ultoa_invert+0x6c>
    2a02:	e8 94       	clt
    2a04:	6f 93       	push	r22
    2a06:	6e 7f       	andi	r22, 0xFE	; 254
    2a08:	6e 5f       	subi	r22, 0xFE	; 254
    2a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0c:	8f 4f       	sbci	r24, 0xFF	; 255
    2a0e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a10:	af 4f       	sbci	r26, 0xFF	; 255
    2a12:	b1 e0       	ldi	r27, 0x01	; 1
    2a14:	3e d0       	rcall	.+124    	; 0x2a92 <__ultoa_invert+0x9c>
    2a16:	b4 e0       	ldi	r27, 0x04	; 4
    2a18:	3c d0       	rcall	.+120    	; 0x2a92 <__ultoa_invert+0x9c>
    2a1a:	67 0f       	add	r22, r23
    2a1c:	78 1f       	adc	r23, r24
    2a1e:	89 1f       	adc	r24, r25
    2a20:	9a 1f       	adc	r25, r26
    2a22:	a1 1d       	adc	r26, r1
    2a24:	68 0f       	add	r22, r24
    2a26:	79 1f       	adc	r23, r25
    2a28:	8a 1f       	adc	r24, r26
    2a2a:	91 1d       	adc	r25, r1
    2a2c:	a1 1d       	adc	r26, r1
    2a2e:	6a 0f       	add	r22, r26
    2a30:	71 1d       	adc	r23, r1
    2a32:	81 1d       	adc	r24, r1
    2a34:	91 1d       	adc	r25, r1
    2a36:	a1 1d       	adc	r26, r1
    2a38:	20 d0       	rcall	.+64     	; 0x2a7a <__ultoa_invert+0x84>
    2a3a:	09 f4       	brne	.+2      	; 0x2a3e <__ultoa_invert+0x48>
    2a3c:	68 94       	set
    2a3e:	3f 91       	pop	r19
    2a40:	2a e0       	ldi	r18, 0x0A	; 10
    2a42:	26 9f       	mul	r18, r22
    2a44:	11 24       	eor	r1, r1
    2a46:	30 19       	sub	r19, r0
    2a48:	30 5d       	subi	r19, 0xD0	; 208
    2a4a:	31 93       	st	Z+, r19
    2a4c:	de f6       	brtc	.-74     	; 0x2a04 <__ultoa_invert+0xe>
    2a4e:	cf 01       	movw	r24, r30
    2a50:	08 95       	ret
    2a52:	46 2f       	mov	r20, r22
    2a54:	47 70       	andi	r20, 0x07	; 7
    2a56:	40 5d       	subi	r20, 0xD0	; 208
    2a58:	41 93       	st	Z+, r20
    2a5a:	b3 e0       	ldi	r27, 0x03	; 3
    2a5c:	0f d0       	rcall	.+30     	; 0x2a7c <__ultoa_invert+0x86>
    2a5e:	c9 f7       	brne	.-14     	; 0x2a52 <__ultoa_invert+0x5c>
    2a60:	f6 cf       	rjmp	.-20     	; 0x2a4e <__ultoa_invert+0x58>
    2a62:	46 2f       	mov	r20, r22
    2a64:	4f 70       	andi	r20, 0x0F	; 15
    2a66:	40 5d       	subi	r20, 0xD0	; 208
    2a68:	4a 33       	cpi	r20, 0x3A	; 58
    2a6a:	18 f0       	brcs	.+6      	; 0x2a72 <__ultoa_invert+0x7c>
    2a6c:	49 5d       	subi	r20, 0xD9	; 217
    2a6e:	31 fd       	sbrc	r19, 1
    2a70:	40 52       	subi	r20, 0x20	; 32
    2a72:	41 93       	st	Z+, r20
    2a74:	02 d0       	rcall	.+4      	; 0x2a7a <__ultoa_invert+0x84>
    2a76:	a9 f7       	brne	.-22     	; 0x2a62 <__ultoa_invert+0x6c>
    2a78:	ea cf       	rjmp	.-44     	; 0x2a4e <__ultoa_invert+0x58>
    2a7a:	b4 e0       	ldi	r27, 0x04	; 4
    2a7c:	a6 95       	lsr	r26
    2a7e:	97 95       	ror	r25
    2a80:	87 95       	ror	r24
    2a82:	77 95       	ror	r23
    2a84:	67 95       	ror	r22
    2a86:	ba 95       	dec	r27
    2a88:	c9 f7       	brne	.-14     	; 0x2a7c <__ultoa_invert+0x86>
    2a8a:	00 97       	sbiw	r24, 0x00	; 0
    2a8c:	61 05       	cpc	r22, r1
    2a8e:	71 05       	cpc	r23, r1
    2a90:	08 95       	ret
    2a92:	9b 01       	movw	r18, r22
    2a94:	ac 01       	movw	r20, r24
    2a96:	0a 2e       	mov	r0, r26
    2a98:	06 94       	lsr	r0
    2a9a:	57 95       	ror	r21
    2a9c:	47 95       	ror	r20
    2a9e:	37 95       	ror	r19
    2aa0:	27 95       	ror	r18
    2aa2:	ba 95       	dec	r27
    2aa4:	c9 f7       	brne	.-14     	; 0x2a98 <__ultoa_invert+0xa2>
    2aa6:	62 0f       	add	r22, r18
    2aa8:	73 1f       	adc	r23, r19
    2aaa:	84 1f       	adc	r24, r20
    2aac:	95 1f       	adc	r25, r21
    2aae:	a0 1d       	adc	r26, r0
    2ab0:	08 95       	ret

00002ab2 <__prologue_saves__>:
    2ab2:	2f 92       	push	r2
    2ab4:	3f 92       	push	r3
    2ab6:	4f 92       	push	r4
    2ab8:	5f 92       	push	r5
    2aba:	6f 92       	push	r6
    2abc:	7f 92       	push	r7
    2abe:	8f 92       	push	r8
    2ac0:	9f 92       	push	r9
    2ac2:	af 92       	push	r10
    2ac4:	bf 92       	push	r11
    2ac6:	cf 92       	push	r12
    2ac8:	df 92       	push	r13
    2aca:	ef 92       	push	r14
    2acc:	ff 92       	push	r15
    2ace:	0f 93       	push	r16
    2ad0:	1f 93       	push	r17
    2ad2:	cf 93       	push	r28
    2ad4:	df 93       	push	r29
    2ad6:	cd b7       	in	r28, 0x3d	; 61
    2ad8:	de b7       	in	r29, 0x3e	; 62
    2ada:	ca 1b       	sub	r28, r26
    2adc:	db 0b       	sbc	r29, r27
    2ade:	0f b6       	in	r0, 0x3f	; 63
    2ae0:	f8 94       	cli
    2ae2:	de bf       	out	0x3e, r29	; 62
    2ae4:	0f be       	out	0x3f, r0	; 63
    2ae6:	cd bf       	out	0x3d, r28	; 61
    2ae8:	09 94       	ijmp

00002aea <__epilogue_restores__>:
    2aea:	2a 88       	ldd	r2, Y+18	; 0x12
    2aec:	39 88       	ldd	r3, Y+17	; 0x11
    2aee:	48 88       	ldd	r4, Y+16	; 0x10
    2af0:	5f 84       	ldd	r5, Y+15	; 0x0f
    2af2:	6e 84       	ldd	r6, Y+14	; 0x0e
    2af4:	7d 84       	ldd	r7, Y+13	; 0x0d
    2af6:	8c 84       	ldd	r8, Y+12	; 0x0c
    2af8:	9b 84       	ldd	r9, Y+11	; 0x0b
    2afa:	aa 84       	ldd	r10, Y+10	; 0x0a
    2afc:	b9 84       	ldd	r11, Y+9	; 0x09
    2afe:	c8 84       	ldd	r12, Y+8	; 0x08
    2b00:	df 80       	ldd	r13, Y+7	; 0x07
    2b02:	ee 80       	ldd	r14, Y+6	; 0x06
    2b04:	fd 80       	ldd	r15, Y+5	; 0x05
    2b06:	0c 81       	ldd	r16, Y+4	; 0x04
    2b08:	1b 81       	ldd	r17, Y+3	; 0x03
    2b0a:	aa 81       	ldd	r26, Y+2	; 0x02
    2b0c:	b9 81       	ldd	r27, Y+1	; 0x01
    2b0e:	ce 0f       	add	r28, r30
    2b10:	d1 1d       	adc	r29, r1
    2b12:	0f b6       	in	r0, 0x3f	; 63
    2b14:	f8 94       	cli
    2b16:	de bf       	out	0x3e, r29	; 62
    2b18:	0f be       	out	0x3f, r0	; 63
    2b1a:	cd bf       	out	0x3d, r28	; 61
    2b1c:	ed 01       	movw	r28, r26
    2b1e:	08 95       	ret

00002b20 <_exit>:
    2b20:	f8 94       	cli

00002b22 <__stop_program>:
    2b22:	ff cf       	rjmp	.-2      	; 0x2b22 <__stop_program>
