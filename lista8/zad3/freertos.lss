
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  0000252a  000025be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000252a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068a  00800120  00800120  000025de  2**0
                  ALLOC
  3 .stab         000076c8  00000000  00000000  000025e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004398  00000000  00000000  00009ca8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e040  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e054  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e094  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000e688  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000ec2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000ec44  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 c5 11 	jmp	0x238a	; 0x238a <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 b4 00 	jmp	0x168	; 0x168 <__vector_18>
      4c:	0c 94 80 00 	jmp	0x100	; 0x100 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ea e2       	ldi	r30, 0x2A	; 42
      7c:	f5 e2       	ldi	r31, 0x25	; 37
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 32       	cpi	r26, 0x20	; 32
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a0 e2       	ldi	r26, 0x20	; 32
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	aa 3a       	cpi	r26, 0xAA	; 170
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 09 12 	call	0x2412	; 0x2412 <main>
      9e:	0c 94 93 12 	jmp	0x2526	; 0x2526 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
    uart_init();
      a6:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <uart_init>
    stdin = stdout = stderr = &uart_file;
      aa:	80 e0       	ldi	r24, 0x00	; 0
      ac:	91 e0       	ldi	r25, 0x01	; 1
      ae:	90 93 a9 07 	sts	0x07A9, r25	; 0x8007a9 <__iob+0x5>
      b2:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <__iob+0x4>
      b6:	90 93 a7 07 	sts	0x07A7, r25	; 0x8007a7 <__iob+0x3>
      ba:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <__iob+0x2>
      be:	90 93 a5 07 	sts	0x07A5, r25	; 0x8007a5 <__iob+0x1>
      c2:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <__iob>

    char input;

    for ( ;; )
    {
      sei();
      c6:	78 94       	sei
      c8:	c0 e3       	ldi	r28, 0x30	; 48
      ca:	d0 e0       	ldi	r29, 0x00	; 0
      input = getchar;
      for(int i =0; i<10; i++)
        //printf("%d\r\n", i);
        putchar('0'+i);
      cc:	60 91 a6 07 	lds	r22, 0x07A6	; 0x8007a6 <__iob+0x2>
      d0:	70 91 a7 07 	lds	r23, 0x07A7	; 0x8007a7 <__iob+0x3>
      d4:	ce 01       	movw	r24, r28
      d6:	0e 94 57 12 	call	0x24ae	; 0x24ae <fputc>
      da:	21 96       	adiw	r28, 0x01	; 1

    for ( ;; )
    {
      sei();
      input = getchar;
      for(int i =0; i<10; i++)
      dc:	ca 33       	cpi	r28, 0x3A	; 58
      de:	d1 05       	cpc	r29, r1
      e0:	a9 f7       	brne	.-22     	; 0xcc <vSerial+0x26>
        //printf("%d\r\n", i);
        putchar('0'+i);
      cli();
      e2:	f8 94       	cli
    }
      e4:	f0 cf       	rjmp	.-32     	; 0xc6 <vSerial+0x20>

000000e6 <vBlinkLed>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
    DDRB |= _BV(PB5);
      e6:	25 9a       	sbi	0x04, 5	; 4

    for ( ;; )
    {
        LED_PORT &= ~_BV(LED);
      e8:	2d 98       	cbi	0x05, 5	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
      ea:	84 ef       	ldi	r24, 0xF4	; 244
      ec:	91 e0       	ldi	r25, 0x01	; 1
      ee:	0e 94 0d 05 	call	0xa1a	; 0xa1a <vTaskDelay>
        LED_PORT |= _BV(LED);
      f2:	2d 9a       	sbi	0x05, 5	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
      f4:	84 ef       	ldi	r24, 0xF4	; 244
      f6:	91 e0       	ldi	r25, 0x01	; 1
      f8:	0e 94 0d 05 	call	0xa1a	; 0xa1a <vTaskDelay>
      fc:	f5 cf       	rjmp	.-22     	; 0xe8 <vBlinkLed+0x2>

000000fe <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
      fe:	08 95       	ret

00000100 <__vector_19>:
      cli();
    }
}

ISR(USART_UDRE_vect)
{
     100:	1f 92       	push	r1
     102:	0f 92       	push	r0
     104:	0f b6       	in	r0, 0x3f	; 63
     106:	0f 92       	push	r0
     108:	11 24       	eor	r1, r1
     10a:	2f 93       	push	r18
     10c:	3f 93       	push	r19
     10e:	4f 93       	push	r20
     110:	5f 93       	push	r21
     112:	6f 93       	push	r22
     114:	7f 93       	push	r23
     116:	8f 93       	push	r24
     118:	9f 93       	push	r25
     11a:	af 93       	push	r26
     11c:	bf 93       	push	r27
     11e:	ef 93       	push	r30
     120:	ff 93       	push	r31
  if(xQueueIsQueueEmptyFromISR(out) == pdFALSE)
     122:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <out>
     126:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <out+0x1>
     12a:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xQueueIsQueueEmptyFromISR>
     12e:	81 11       	cpse	r24, r1
     130:	0a c0       	rjmp	.+20     	; 0x146 <__vector_19+0x46>
    xQueueReceiveFromISR(out, (void*)&UDR0, NULL);
     132:	40 e0       	ldi	r20, 0x00	; 0
     134:	50 e0       	ldi	r21, 0x00	; 0
     136:	66 ec       	ldi	r22, 0xC6	; 198
     138:	70 e0       	ldi	r23, 0x00	; 0
     13a:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <out>
     13e:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <out+0x1>
     142:	0e 94 85 0c 	call	0x190a	; 0x190a <xQueueReceiveFromISR>
}
     146:	ff 91       	pop	r31
     148:	ef 91       	pop	r30
     14a:	bf 91       	pop	r27
     14c:	af 91       	pop	r26
     14e:	9f 91       	pop	r25
     150:	8f 91       	pop	r24
     152:	7f 91       	pop	r23
     154:	6f 91       	pop	r22
     156:	5f 91       	pop	r21
     158:	4f 91       	pop	r20
     15a:	3f 91       	pop	r19
     15c:	2f 91       	pop	r18
     15e:	0f 90       	pop	r0
     160:	0f be       	out	0x3f, r0	; 63
     162:	0f 90       	pop	r0
     164:	1f 90       	pop	r1
     166:	18 95       	reti

00000168 <__vector_18>:

ISR(USART_RX_vect)
{
     168:	1f 92       	push	r1
     16a:	0f 92       	push	r0
     16c:	0f b6       	in	r0, 0x3f	; 63
     16e:	0f 92       	push	r0
     170:	11 24       	eor	r1, r1
     172:	2f 93       	push	r18
     174:	3f 93       	push	r19
     176:	4f 93       	push	r20
     178:	5f 93       	push	r21
     17a:	6f 93       	push	r22
     17c:	7f 93       	push	r23
     17e:	8f 93       	push	r24
     180:	9f 93       	push	r25
     182:	af 93       	push	r26
     184:	bf 93       	push	r27
     186:	ef 93       	push	r30
     188:	ff 93       	push	r31
  xQueueSendFromISR(in, (void*)&UDR0, NULL);
     18a:	20 e0       	ldi	r18, 0x00	; 0
     18c:	40 e0       	ldi	r20, 0x00	; 0
     18e:	50 e0       	ldi	r21, 0x00	; 0
     190:	66 ec       	ldi	r22, 0xC6	; 198
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <in>
     198:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <in+0x1>
     19c:	0e 94 89 0a 	call	0x1512	; 0x1512 <xQueueGenericSendFromISR>
}
     1a0:	ff 91       	pop	r31
     1a2:	ef 91       	pop	r30
     1a4:	bf 91       	pop	r27
     1a6:	af 91       	pop	r26
     1a8:	9f 91       	pop	r25
     1aa:	8f 91       	pop	r24
     1ac:	7f 91       	pop	r23
     1ae:	6f 91       	pop	r22
     1b0:	5f 91       	pop	r21
     1b2:	4f 91       	pop	r20
     1b4:	3f 91       	pop	r19
     1b6:	2f 91       	pop	r18
     1b8:	0f 90       	pop	r0
     1ba:	0f be       	out	0x3f, r0	; 63
     1bc:	0f 90       	pop	r0
     1be:	1f 90       	pop	r1
     1c0:	18 95       	reti

000001c2 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1c2:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     1c6:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     1ca:	80 81       	ld	r24, Z
     1cc:	81 11       	cpse	r24, r1
     1ce:	03 c0       	rjmp	.+6      	; 0x1d6 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1d0:	8f ef       	ldi	r24, 0xFF	; 255
     1d2:	9f ef       	ldi	r25, 0xFF	; 255
     1d4:	0c c0       	rjmp	.+24     	; 0x1ee <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     1d6:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     1da:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     1de:	05 80       	ldd	r0, Z+5	; 0x05
     1e0:	f6 81       	ldd	r31, Z+6	; 0x06
     1e2:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     1e4:	06 80       	ldd	r0, Z+6	; 0x06
     1e6:	f7 81       	ldd	r31, Z+7	; 0x07
     1e8:	e0 2d       	mov	r30, r0
     1ea:	82 81       	ldd	r24, Z+2	; 0x02
     1ec:	93 81       	ldd	r25, Z+3	; 0x03
     1ee:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <xNextTaskUnblockTime+0x1>
     1f2:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <xNextTaskUnblockTime>
     1f6:	08 95       	ret

000001f8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     1f8:	ff 92       	push	r15
     1fa:	0f 93       	push	r16
     1fc:	1f 93       	push	r17
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
     204:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     206:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <xTickCount>
     20a:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     20e:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     212:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     216:	02 96       	adiw	r24, 0x02	; 2
     218:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     21c:	cf 3f       	cpi	r28, 0xFF	; 255
     21e:	8f ef       	ldi	r24, 0xFF	; 255
     220:	d8 07       	cpc	r29, r24
     222:	89 f4       	brne	.+34     	; 0x246 <prvAddCurrentTaskToDelayedList+0x4e>
     224:	ff 20       	and	r15, r15
     226:	79 f0       	breq	.+30     	; 0x246 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     228:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     22c:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     230:	6e 5f       	subi	r22, 0xFE	; 254
     232:	7f 4f       	sbci	r23, 0xFF	; 255
     234:	80 e3       	ldi	r24, 0x30	; 48
     236:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	0f 91       	pop	r16
     240:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     242:	0c 94 df 0d 	jmp	0x1bbe	; 0x1bbe <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     246:	c0 0f       	add	r28, r16
     248:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     24a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     24e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     252:	d3 83       	std	Z+3, r29	; 0x03
     254:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     256:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     25a:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     25e:	c0 17       	cp	r28, r16
     260:	d1 07       	cpc	r29, r17
     262:	68 f4       	brcc	.+26     	; 0x27e <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     264:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <pxOverflowDelayedTaskList>
     268:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     26c:	6e 5f       	subi	r22, 0xFE	; 254
     26e:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     270:	df 91       	pop	r29
     272:	cf 91       	pop	r28
     274:	1f 91       	pop	r17
     276:	0f 91       	pop	r16
     278:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     27a:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     27e:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <pxDelayedTaskList>
     282:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     286:	6e 5f       	subi	r22, 0xFE	; 254
     288:	7f 4f       	sbci	r23, 0xFF	; 255
     28a:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     28e:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <xNextTaskUnblockTime>
     292:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <xNextTaskUnblockTime+0x1>
     296:	c8 17       	cp	r28, r24
     298:	d9 07       	cpc	r29, r25
     29a:	20 f4       	brcc	.+8      	; 0x2a4 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     29c:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <xNextTaskUnblockTime+0x1>
     2a0:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2a4:	df 91       	pop	r29
     2a6:	cf 91       	pop	r28
     2a8:	1f 91       	pop	r17
     2aa:	0f 91       	pop	r16
     2ac:	ff 90       	pop	r15
     2ae:	08 95       	ret

000002b0 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     2b0:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     2b4:	88 23       	and	r24, r24
     2b6:	09 f1       	breq	.+66     	; 0x2fa <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     2b8:	0f b6       	in	r0, 0x3f	; 63
     2ba:	f8 94       	cli
     2bc:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2be:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <xTasksWaitingTermination+0x5>
     2c2:	f0 91 40 01 	lds	r31, 0x0140	; 0x800140 <xTasksWaitingTermination+0x6>
     2c6:	c6 81       	ldd	r28, Z+6	; 0x06
     2c8:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     2ca:	ce 01       	movw	r24, r28
     2cc:	02 96       	adiw	r24, 0x02	; 2
     2ce:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
				--uxCurrentNumberOfTasks;
     2d2:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     2d6:	81 50       	subi	r24, 0x01	; 1
     2d8:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     2dc:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     2e0:	81 50       	subi	r24, 0x01	; 1
     2e2:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     2e6:	0f 90       	pop	r0
     2e8:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     2ea:	8f 89       	ldd	r24, Y+23	; 0x17
     2ec:	98 8d       	ldd	r25, Y+24	; 0x18
     2ee:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortFree>
			vPortFree( pxTCB );
     2f2:	ce 01       	movw	r24, r28
     2f4:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortFree>
     2f8:	db cf       	rjmp	.-74     	; 0x2b0 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     2fa:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxReadyTasksLists>
     2fe:	82 30       	cpi	r24, 0x02	; 2
     300:	10 f0       	brcs	.+4      	; 0x306 <prvIdleTask+0x56>
			{
				taskYIELD();
     302:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     306:	0e 94 7f 00 	call	0xfe	; 0xfe <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     30a:	d2 cf       	rjmp	.-92     	; 0x2b0 <prvIdleTask>

0000030c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     30c:	3f 92       	push	r3
     30e:	4f 92       	push	r4
     310:	5f 92       	push	r5
     312:	6f 92       	push	r6
     314:	7f 92       	push	r7
     316:	8f 92       	push	r8
     318:	9f 92       	push	r9
     31a:	af 92       	push	r10
     31c:	bf 92       	push	r11
     31e:	cf 92       	push	r12
     320:	df 92       	push	r13
     322:	ef 92       	push	r14
     324:	ff 92       	push	r15
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	cf 93       	push	r28
     32c:	df 93       	push	r29
     32e:	4c 01       	movw	r8, r24
     330:	16 2f       	mov	r17, r22
     332:	37 2e       	mov	r3, r23
     334:	6a 01       	movw	r12, r20
     336:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     338:	ca 01       	movw	r24, r20
     33a:	0e 94 22 10 	call	0x2044	; 0x2044 <pvPortMalloc>
     33e:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     340:	89 2b       	or	r24, r25
     342:	09 f4       	brne	.+2      	; 0x346 <xTaskCreate+0x3a>
     344:	d1 c0       	rjmp	.+418    	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     346:	86 e2       	ldi	r24, 0x26	; 38
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	0e 94 22 10 	call	0x2044	; 0x2044 <pvPortMalloc>
     34e:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     350:	89 2b       	or	r24, r25
     352:	79 f0       	breq	.+30     	; 0x372 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     354:	58 8e       	std	Y+24, r5	; 0x18
     356:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     358:	c6 01       	movw	r24, r12
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	32 01       	movw	r6, r4
     35e:	68 0e       	add	r6, r24
     360:	79 1e       	adc	r7, r25
     362:	be 01       	movw	r22, r28
     364:	67 5e       	subi	r22, 0xE7	; 231
     366:	7f 4f       	sbci	r23, 0xFF	; 255
     368:	e1 2f       	mov	r30, r17
     36a:	f3 2d       	mov	r31, r3
     36c:	cf 01       	movw	r24, r30
     36e:	08 96       	adiw	r24, 0x08	; 8
     370:	07 c0       	rjmp	.+14     	; 0x380 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     372:	c2 01       	movw	r24, r4
     374:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortFree>
     378:	b7 c0       	rjmp	.+366    	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     37a:	e8 17       	cp	r30, r24
     37c:	f9 07       	cpc	r31, r25
     37e:	49 f0       	breq	.+18     	; 0x392 <xTaskCreate+0x86>
     380:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     382:	41 91       	ld	r20, Z+
     384:	db 01       	movw	r26, r22
     386:	4d 93       	st	X+, r20
     388:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     38a:	d9 01       	movw	r26, r18
     38c:	2c 91       	ld	r18, X
     38e:	21 11       	cpse	r18, r1
     390:	f4 cf       	rjmp	.-24     	; 0x37a <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     392:	18 a2       	std	Y+32, r1	; 0x20
     394:	04 30       	cpi	r16, 0x04	; 4
     396:	08 f0       	brcs	.+2      	; 0x39a <xTaskCreate+0x8e>
     398:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     39a:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     39c:	6e 01       	movw	r12, r28
     39e:	b2 e0       	ldi	r27, 0x02	; 2
     3a0:	cb 0e       	add	r12, r27
     3a2:	d1 1c       	adc	r13, r1
     3a4:	c6 01       	movw	r24, r12
     3a6:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     3aa:	ce 01       	movw	r24, r28
     3ac:	0c 96       	adiw	r24, 0x0c	; 12
     3ae:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     3b2:	d9 87       	std	Y+9, r29	; 0x09
     3b4:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     3b6:	84 e0       	ldi	r24, 0x04	; 4
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	80 1b       	sub	r24, r16
     3bc:	91 09       	sbc	r25, r1
     3be:	9d 87       	std	Y+13, r25	; 0x0d
     3c0:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     3c2:	db 8b       	std	Y+19, r29	; 0x13
     3c4:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     3c6:	19 a2       	std	Y+33, r1	; 0x21
     3c8:	1a a2       	std	Y+34, r1	; 0x22
     3ca:	1b a2       	std	Y+35, r1	; 0x23
     3cc:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     3ce:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     3d0:	a5 01       	movw	r20, r10
     3d2:	b4 01       	movw	r22, r8
     3d4:	c3 01       	movw	r24, r6
     3d6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <pxPortInitialiseStack>
     3da:	99 83       	std	Y+1, r25	; 0x01
     3dc:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     3de:	e1 14       	cp	r14, r1
     3e0:	f1 04       	cpc	r15, r1
     3e2:	19 f0       	breq	.+6      	; 0x3ea <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     3e4:	f7 01       	movw	r30, r14
     3e6:	d1 83       	std	Z+1, r29	; 0x01
     3e8:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     3ea:	0f b6       	in	r0, 0x3f	; 63
     3ec:	f8 94       	cli
     3ee:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     3f0:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     3f4:	8f 5f       	subi	r24, 0xFF	; 255
     3f6:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     3fa:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     3fe:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     402:	89 2b       	or	r24, r25
     404:	d1 f5       	brne	.+116    	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     406:	d0 93 21 01 	sts	0x0121, r29	; 0x800121 <__data_end+0x1>
     40a:	c0 93 20 01 	sts	0x0120, r28	; 0x800120 <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     40e:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     412:	81 30       	cpi	r24, 0x01	; 1
     414:	09 f0       	breq	.+2      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     416:	41 c0       	rjmp	.+130    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     418:	82 e6       	ldi	r24, 0x62	; 98
     41a:	91 e0       	ldi	r25, 0x01	; 1
     41c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
     420:	8b e6       	ldi	r24, 0x6B	; 107
     422:	91 e0       	ldi	r25, 0x01	; 1
     424:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
     428:	84 e7       	ldi	r24, 0x74	; 116
     42a:	91 e0       	ldi	r25, 0x01	; 1
     42c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
     430:	8d e7       	ldi	r24, 0x7D	; 125
     432:	91 e0       	ldi	r25, 0x01	; 1
     434:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     438:	89 e5       	ldi	r24, 0x59	; 89
     43a:	91 e0       	ldi	r25, 0x01	; 1
     43c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     440:	80 e5       	ldi	r24, 0x50	; 80
     442:	91 e0       	ldi	r25, 0x01	; 1
     444:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	vListInitialise( &xPendingReadyList );
     448:	83 e4       	ldi	r24, 0x43	; 67
     44a:	91 e0       	ldi	r25, 0x01	; 1
     44c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     450:	8a e3       	ldi	r24, 0x3A	; 58
     452:	91 e0       	ldi	r25, 0x01	; 1
     454:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     458:	80 e3       	ldi	r24, 0x30	; 48
     45a:	91 e0       	ldi	r25, 0x01	; 1
     45c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     460:	89 e5       	ldi	r24, 0x59	; 89
     462:	91 e0       	ldi	r25, 0x01	; 1
     464:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <pxDelayedTaskList+0x1>
     468:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     46c:	80 e5       	ldi	r24, 0x50	; 80
     46e:	91 e0       	ldi	r25, 0x01	; 1
     470:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     474:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <pxOverflowDelayedTaskList>
     478:	10 c0       	rjmp	.+32     	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     47a:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     47e:	81 11       	cpse	r24, r1
     480:	0c c0       	rjmp	.+24     	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     482:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     486:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     48a:	96 89       	ldd	r25, Z+22	; 0x16
     48c:	8e 89       	ldd	r24, Y+22	; 0x16
     48e:	89 17       	cp	r24, r25
     490:	20 f0       	brcs	.+8      	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
				{
					pxCurrentTCB = pxNewTCB;
     492:	d0 93 21 01 	sts	0x0121, r29	; 0x800121 <__data_end+0x1>
     496:	c0 93 20 01 	sts	0x0120, r28	; 0x800120 <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     49a:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxTaskNumber>
     49e:	8f 5f       	subi	r24, 0xFF	; 255
     4a0:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     4a4:	8e 89       	ldd	r24, Y+22	; 0x16
     4a6:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     4aa:	98 17       	cp	r25, r24
     4ac:	10 f4       	brcc	.+4      	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
     4ae:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     4b2:	f9 e0       	ldi	r31, 0x09	; 9
     4b4:	8f 9f       	mul	r24, r31
     4b6:	c0 01       	movw	r24, r0
     4b8:	11 24       	eor	r1, r1
     4ba:	b6 01       	movw	r22, r12
     4bc:	8e 59       	subi	r24, 0x9E	; 158
     4be:	9e 4f       	sbci	r25, 0xFE	; 254
     4c0:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     4c4:	0f 90       	pop	r0
     4c6:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     4c8:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     4cc:	88 23       	and	r24, r24
     4ce:	51 f0       	breq	.+20     	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     4d0:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     4d4:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     4d8:	96 89       	ldd	r25, Z+22	; 0x16
     4da:	8e 89       	ldd	r24, Y+22	; 0x16
     4dc:	98 17       	cp	r25, r24
     4de:	10 f4       	brcc	.+4      	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
     4e0:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	01 c0       	rjmp	.+2      	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     4e8:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     4ea:	df 91       	pop	r29
     4ec:	cf 91       	pop	r28
     4ee:	1f 91       	pop	r17
     4f0:	0f 91       	pop	r16
     4f2:	ff 90       	pop	r15
     4f4:	ef 90       	pop	r14
     4f6:	df 90       	pop	r13
     4f8:	cf 90       	pop	r12
     4fa:	bf 90       	pop	r11
     4fc:	af 90       	pop	r10
     4fe:	9f 90       	pop	r9
     500:	8f 90       	pop	r8
     502:	7f 90       	pop	r7
     504:	6f 90       	pop	r6
     506:	5f 90       	pop	r5
     508:	4f 90       	pop	r4
     50a:	3f 90       	pop	r3
     50c:	08 95       	ret

0000050e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     50e:	0f 93       	push	r16
     510:	1f 93       	push	r17
     512:	cf 93       	push	r28
     514:	df 93       	push	r29
     516:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     518:	0f b6       	in	r0, 0x3f	; 63
     51a:	f8 94       	cli
     51c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     51e:	89 2b       	or	r24, r25
     520:	21 f4       	brne	.+8      	; 0x52a <vTaskDelete+0x1c>
     522:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
     526:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     52a:	8e 01       	movw	r16, r28
     52c:	0e 5f       	subi	r16, 0xFE	; 254
     52e:	1f 4f       	sbci	r17, 0xFF	; 255
     530:	c8 01       	movw	r24, r16
     532:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     536:	8c 89       	ldd	r24, Y+20	; 0x14
     538:	9d 89       	ldd	r25, Y+21	; 0x15
     53a:	89 2b       	or	r24, r25
     53c:	21 f0       	breq	.+8      	; 0x546 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     53e:	ce 01       	movw	r24, r28
     540:	0c 96       	adiw	r24, 0x0c	; 12
     542:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     546:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxTaskNumber>
     54a:	8f 5f       	subi	r24, 0xFF	; 255
     54c:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     550:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     554:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     558:	c8 17       	cp	r28, r24
     55a:	d9 07       	cpc	r29, r25
     55c:	59 f4       	brne	.+22     	; 0x574 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     55e:	b8 01       	movw	r22, r16
     560:	8a e3       	ldi	r24, 0x3A	; 58
     562:	91 e0       	ldi	r25, 0x01	; 1
     564:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     568:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     56c:	8f 5f       	subi	r24, 0xFF	; 255
     56e:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     572:	0e c0       	rjmp	.+28     	; 0x590 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     574:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     578:	81 50       	subi	r24, 0x01	; 1
     57a:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     57e:	8f 89       	ldd	r24, Y+23	; 0x17
     580:	98 8d       	ldd	r25, Y+24	; 0x18
     582:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortFree>
			vPortFree( pxTCB );
     586:	ce 01       	movw	r24, r28
     588:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     58c:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     590:	0f 90       	pop	r0
     592:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     594:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     598:	88 23       	and	r24, r24
     59a:	49 f0       	breq	.+18     	; 0x5ae <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     59c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     5a0:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     5a4:	c8 17       	cp	r28, r24
     5a6:	d9 07       	cpc	r29, r25
     5a8:	11 f4       	brne	.+4      	; 0x5ae <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     5aa:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     5ae:	df 91       	pop	r29
     5b0:	cf 91       	pop	r28
     5b2:	1f 91       	pop	r17
     5b4:	0f 91       	pop	r16
     5b6:	08 95       	ret

000005b8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     5b8:	0f 93       	push	r16
     5ba:	1f 93       	push	r17
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     5c0:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <__data_end>
     5c4:	30 91 21 01 	lds	r19, 0x0121	; 0x800121 <__data_end+0x1>
     5c8:	82 17       	cp	r24, r18
     5ca:	93 07       	cpc	r25, r19
     5cc:	b9 f1       	breq	.+110    	; 0x63c <vTaskResume+0x84>
     5ce:	00 97       	sbiw	r24, 0x00	; 0
     5d0:	a9 f1       	breq	.+106    	; 0x63c <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     5d8:	fc 01       	movw	r30, r24
     5da:	22 85       	ldd	r18, Z+10	; 0x0a
     5dc:	33 85       	ldd	r19, Z+11	; 0x0b
     5de:	20 53       	subi	r18, 0x30	; 48
     5e0:	31 40       	sbci	r19, 0x01	; 1
     5e2:	51 f5       	brne	.+84     	; 0x638 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     5e4:	fc 01       	movw	r30, r24
     5e6:	24 89       	ldd	r18, Z+20	; 0x14
     5e8:	35 89       	ldd	r19, Z+21	; 0x15
     5ea:	f1 e0       	ldi	r31, 0x01	; 1
     5ec:	23 34       	cpi	r18, 0x43	; 67
     5ee:	3f 07       	cpc	r19, r31
     5f0:	19 f1       	breq	.+70     	; 0x638 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     5f2:	23 2b       	or	r18, r19
     5f4:	09 f5       	brne	.+66     	; 0x638 <vTaskResume+0x80>
     5f6:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     5f8:	8c 01       	movw	r16, r24
     5fa:	0e 5f       	subi	r16, 0xFE	; 254
     5fc:	1f 4f       	sbci	r17, 0xFF	; 255
     5fe:	c8 01       	movw	r24, r16
     600:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     604:	8e 89       	ldd	r24, Y+22	; 0x16
     606:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     60a:	98 17       	cp	r25, r24
     60c:	10 f4       	brcc	.+4      	; 0x612 <vTaskResume+0x5a>
     60e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     612:	29 e0       	ldi	r18, 0x09	; 9
     614:	82 9f       	mul	r24, r18
     616:	c0 01       	movw	r24, r0
     618:	11 24       	eor	r1, r1
     61a:	b8 01       	movw	r22, r16
     61c:	8e 59       	subi	r24, 0x9E	; 158
     61e:	9e 4f       	sbci	r25, 0xFE	; 254
     620:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     624:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     628:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     62c:	9e 89       	ldd	r25, Y+22	; 0x16
     62e:	86 89       	ldd	r24, Z+22	; 0x16
     630:	98 17       	cp	r25, r24
     632:	10 f0       	brcs	.+4      	; 0x638 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     634:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     638:	0f 90       	pop	r0
     63a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     63c:	df 91       	pop	r29
     63e:	cf 91       	pop	r28
     640:	1f 91       	pop	r17
     642:	0f 91       	pop	r16
     644:	08 95       	ret

00000646 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     646:	ef 92       	push	r14
     648:	ff 92       	push	r15
     64a:	1f 93       	push	r17
     64c:	cf 93       	push	r28
     64e:	df 93       	push	r29
     650:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     652:	8a 85       	ldd	r24, Y+10	; 0x0a
     654:	9b 85       	ldd	r25, Y+11	; 0x0b
     656:	80 53       	subi	r24, 0x30	; 48
     658:	91 40       	sbci	r25, 0x01	; 1
     65a:	99 f4       	brne	.+38     	; 0x682 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     65c:	8c 89       	ldd	r24, Y+20	; 0x14
     65e:	9d 89       	ldd	r25, Y+21	; 0x15
     660:	21 e0       	ldi	r18, 0x01	; 1
     662:	83 34       	cpi	r24, 0x43	; 67
     664:	92 07       	cpc	r25, r18
     666:	69 f0       	breq	.+26     	; 0x682 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     668:	89 2b       	or	r24, r25
     66a:	59 f4       	brne	.+22     	; 0x682 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     66c:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     670:	88 23       	and	r24, r24
     672:	49 f0       	breq	.+18     	; 0x686 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     674:	be 01       	movw	r22, r28
     676:	64 5f       	subi	r22, 0xF4	; 244
     678:	7f 4f       	sbci	r23, 0xFF	; 255
     67a:	83 e4       	ldi	r24, 0x43	; 67
     67c:	91 e0       	ldi	r25, 0x01	; 1
     67e:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     682:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     684:	21 c0       	rjmp	.+66     	; 0x6c8 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     686:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     68a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     68e:	11 e0       	ldi	r17, 0x01	; 1
     690:	9e 89       	ldd	r25, Y+22	; 0x16
     692:	86 89       	ldd	r24, Z+22	; 0x16
     694:	98 17       	cp	r25, r24
     696:	08 f4       	brcc	.+2      	; 0x69a <xTaskResumeFromISR+0x54>
     698:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     69a:	7e 01       	movw	r14, r28
     69c:	82 e0       	ldi	r24, 0x02	; 2
     69e:	e8 0e       	add	r14, r24
     6a0:	f1 1c       	adc	r15, r1
     6a2:	c7 01       	movw	r24, r14
     6a4:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6a8:	8e 89       	ldd	r24, Y+22	; 0x16
     6aa:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     6ae:	98 17       	cp	r25, r24
     6b0:	10 f4       	brcc	.+4      	; 0x6b6 <xTaskResumeFromISR+0x70>
     6b2:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     6b6:	29 e0       	ldi	r18, 0x09	; 9
     6b8:	82 9f       	mul	r24, r18
     6ba:	c0 01       	movw	r24, r0
     6bc:	11 24       	eor	r1, r1
     6be:	b7 01       	movw	r22, r14
     6c0:	8e 59       	subi	r24, 0x9E	; 158
     6c2:	9e 4f       	sbci	r25, 0xFE	; 254
     6c4:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     6c8:	81 2f       	mov	r24, r17
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	1f 91       	pop	r17
     6d0:	ff 90       	pop	r15
     6d2:	ef 90       	pop	r14
     6d4:	08 95       	ret

000006d6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     6d6:	ef 92       	push	r14
     6d8:	ff 92       	push	r15
     6da:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     6dc:	83 e2       	ldi	r24, 0x23	; 35
     6de:	e8 2e       	mov	r14, r24
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	f8 2e       	mov	r15, r24
     6e4:	00 e0       	ldi	r16, 0x00	; 0
     6e6:	20 e0       	ldi	r18, 0x00	; 0
     6e8:	30 e0       	ldi	r19, 0x00	; 0
     6ea:	45 e5       	ldi	r20, 0x55	; 85
     6ec:	50 e0       	ldi	r21, 0x00	; 0
     6ee:	6b e1       	ldi	r22, 0x1B	; 27
     6f0:	71 e0       	ldi	r23, 0x01	; 1
     6f2:	88 e5       	ldi	r24, 0x58	; 88
     6f4:	91 e0       	ldi	r25, 0x01	; 1
     6f6:	0e 94 86 01 	call	0x30c	; 0x30c <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     6fa:	81 30       	cpi	r24, 0x01	; 1
     6fc:	91 f4       	brne	.+36     	; 0x722 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     6fe:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     700:	2f ef       	ldi	r18, 0xFF	; 255
     702:	3f ef       	ldi	r19, 0xFF	; 255
     704:	30 93 26 01 	sts	0x0126, r19	; 0x800126 <xNextTaskUnblockTime+0x1>
     708:	20 93 25 01 	sts	0x0125, r18	; 0x800125 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     70c:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     710:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <xTickCount+0x1>
     714:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     718:	0f 91       	pop	r16
     71a:	ff 90       	pop	r15
     71c:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     71e:	0c 94 cf 10 	jmp	0x219e	; 0x219e <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     722:	0f 91       	pop	r16
     724:	ff 90       	pop	r15
     726:	ef 90       	pop	r14
     728:	08 95       	ret

0000072a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     72a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     72c:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <xSchedulerRunning>
	vPortEndScheduler();
     730:	0c 94 0f 11 	jmp	0x221e	; 0x221e <vPortEndScheduler>

00000734 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     734:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     738:	8f 5f       	subi	r24, 0xFF	; 255
     73a:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <uxSchedulerSuspended>
     73e:	08 95       	ret

00000740 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     740:	0f b6       	in	r0, 0x3f	; 63
     742:	f8 94       	cli
     744:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     746:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xTickCount>
     74a:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     74e:	0f 90       	pop	r0
     750:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     752:	08 95       	ret

00000754 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     754:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xTickCount>
     758:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     75c:	08 95       	ret

0000075e <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     75e:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
}
     762:	08 95       	ret

00000764 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     764:	00 97       	sbiw	r24, 0x00	; 0
     766:	21 f4       	brne	.+8      	; 0x770 <pcTaskGetName+0xc>
     768:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     76c:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     770:	49 96       	adiw	r24, 0x19	; 25
     772:	08 95       	ret

00000774 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     774:	cf 92       	push	r12
     776:	df 92       	push	r13
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
     77e:	1f 93       	push	r17
     780:	cf 93       	push	r28
     782:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     784:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     788:	81 11       	cpse	r24, r1
     78a:	8c c0       	rjmp	.+280    	; 0x8a4 <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     78c:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <xTickCount>
     790:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <xTickCount+0x1>
     794:	0f 5f       	subi	r16, 0xFF	; 255
     796:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     798:	10 93 2e 01 	sts	0x012E, r17	; 0x80012e <xTickCount+0x1>
     79c:	00 93 2d 01 	sts	0x012D, r16	; 0x80012d <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     7a0:	01 15       	cp	r16, r1
     7a2:	11 05       	cpc	r17, r1
     7a4:	b9 f4       	brne	.+46     	; 0x7d4 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     7a6:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <pxDelayedTaskList>
     7aa:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     7ae:	20 91 4c 01 	lds	r18, 0x014C	; 0x80014c <pxOverflowDelayedTaskList>
     7b2:	30 91 4d 01 	lds	r19, 0x014D	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     7b6:	30 93 4f 01 	sts	0x014F, r19	; 0x80014f <pxDelayedTaskList+0x1>
     7ba:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <pxDelayedTaskList>
     7be:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     7c2:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <pxOverflowDelayedTaskList>
     7c6:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <xNumOfOverflows>
     7ca:	8f 5f       	subi	r24, 0xFF	; 255
     7cc:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <xNumOfOverflows>
     7d0:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     7d4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <xNextTaskUnblockTime>
     7d8:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <xNextTaskUnblockTime+0x1>
     7dc:	c0 e0       	ldi	r28, 0x00	; 0
     7de:	08 17       	cp	r16, r24
     7e0:	19 07       	cpc	r17, r25
     7e2:	08 f4       	brcc	.+2      	; 0x7e6 <xTaskIncrementTick+0x72>
     7e4:	4f c0       	rjmp	.+158    	; 0x884 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     7e6:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     7e8:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     7ec:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     7f0:	80 81       	ld	r24, Z
     7f2:	81 11       	cpse	r24, r1
     7f4:	03 c0       	rjmp	.+6      	; 0x7fc <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7f6:	8f ef       	ldi	r24, 0xFF	; 255
     7f8:	9f ef       	ldi	r25, 0xFF	; 255
     7fa:	11 c0       	rjmp	.+34     	; 0x81e <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     7fc:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     800:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     804:	05 80       	ldd	r0, Z+5	; 0x05
     806:	f6 81       	ldd	r31, Z+6	; 0x06
     808:	e0 2d       	mov	r30, r0
     80a:	e6 80       	ldd	r14, Z+6	; 0x06
     80c:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     80e:	d7 01       	movw	r26, r14
     810:	12 96       	adiw	r26, 0x02	; 2
     812:	8d 91       	ld	r24, X+
     814:	9c 91       	ld	r25, X
     816:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     818:	08 17       	cp	r16, r24
     81a:	19 07       	cpc	r17, r25
     81c:	28 f4       	brcc	.+10     	; 0x828 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     81e:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <xNextTaskUnblockTime+0x1>
     822:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     826:	2e c0       	rjmp	.+92     	; 0x884 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     828:	67 01       	movw	r12, r14
     82a:	b2 e0       	ldi	r27, 0x02	; 2
     82c:	cb 0e       	add	r12, r27
     82e:	d1 1c       	adc	r13, r1
     830:	c6 01       	movw	r24, r12
     832:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     836:	f7 01       	movw	r30, r14
     838:	84 89       	ldd	r24, Z+20	; 0x14
     83a:	95 89       	ldd	r25, Z+21	; 0x15
     83c:	89 2b       	or	r24, r25
     83e:	21 f0       	breq	.+8      	; 0x848 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     840:	c7 01       	movw	r24, r14
     842:	0c 96       	adiw	r24, 0x0c	; 12
     844:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     848:	d7 01       	movw	r26, r14
     84a:	56 96       	adiw	r26, 0x16	; 22
     84c:	8c 91       	ld	r24, X
     84e:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     852:	98 17       	cp	r25, r24
     854:	10 f4       	brcc	.+4      	; 0x85a <xTaskIncrementTick+0xe6>
     856:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     85a:	d8 9f       	mul	r29, r24
     85c:	c0 01       	movw	r24, r0
     85e:	11 24       	eor	r1, r1
     860:	b6 01       	movw	r22, r12
     862:	8e 59       	subi	r24, 0x9E	; 158
     864:	9e 4f       	sbci	r25, 0xFE	; 254
     866:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     86a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     86e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     872:	d7 01       	movw	r26, r14
     874:	56 96       	adiw	r26, 0x16	; 22
     876:	9c 91       	ld	r25, X
     878:	86 89       	ldd	r24, Z+22	; 0x16
     87a:	98 17       	cp	r25, r24
     87c:	08 f4       	brcc	.+2      	; 0x880 <xTaskIncrementTick+0x10c>
     87e:	b4 cf       	rjmp	.-152    	; 0x7e8 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     880:	c1 e0       	ldi	r28, 0x01	; 1
     882:	b2 cf       	rjmp	.-156    	; 0x7e8 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     884:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     888:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     88c:	e6 89       	ldd	r30, Z+22	; 0x16
     88e:	b9 e0       	ldi	r27, 0x09	; 9
     890:	eb 9f       	mul	r30, r27
     892:	f0 01       	movw	r30, r0
     894:	11 24       	eor	r1, r1
     896:	ee 59       	subi	r30, 0x9E	; 158
     898:	fe 4f       	sbci	r31, 0xFE	; 254
     89a:	80 81       	ld	r24, Z
     89c:	82 30       	cpi	r24, 0x02	; 2
     89e:	40 f0       	brcs	.+16     	; 0x8b0 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     8a0:	c1 e0       	ldi	r28, 0x01	; 1
     8a2:	06 c0       	rjmp	.+12     	; 0x8b0 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     8a4:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <uxPendedTicks>
     8a8:	8f 5f       	subi	r24, 0xFF	; 255
     8aa:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     8ae:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     8b0:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <xYieldPending>
     8b4:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     8b6:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     8b8:	8c 2f       	mov	r24, r28
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	1f 91       	pop	r17
     8c0:	0f 91       	pop	r16
     8c2:	ff 90       	pop	r15
     8c4:	ef 90       	pop	r14
     8c6:	df 90       	pop	r13
     8c8:	cf 90       	pop	r12
     8ca:	08 95       	ret

000008cc <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     8cc:	ef 92       	push	r14
     8ce:	ff 92       	push	r15
     8d0:	0f 93       	push	r16
     8d2:	1f 93       	push	r17
     8d4:	cf 93       	push	r28
     8d6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     8d8:	0f b6       	in	r0, 0x3f	; 63
     8da:	f8 94       	cli
     8dc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     8de:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     8e2:	81 50       	subi	r24, 0x01	; 1
     8e4:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8e8:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     8ec:	88 23       	and	r24, r24
     8ee:	11 f0       	breq	.+4      	; 0x8f4 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     8f0:	80 e0       	ldi	r24, 0x00	; 0
     8f2:	52 c0       	rjmp	.+164    	; 0x998 <__stack+0x99>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     8f4:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     8f8:	88 23       	and	r24, r24
     8fa:	d1 f3       	breq	.-12     	; 0x8f0 <xTaskResumeAll+0x24>
     8fc:	c0 e0       	ldi	r28, 0x00	; 0
     8fe:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     900:	89 e0       	ldi	r24, 0x09	; 9
     902:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     904:	ee 24       	eor	r14, r14
     906:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     908:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xPendingReadyList>
     90c:	88 23       	and	r24, r24
     90e:	51 f1       	breq	.+84     	; 0x964 <__stack+0x65>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     910:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <xPendingReadyList+0x5>
     914:	f0 91 49 01 	lds	r31, 0x0149	; 0x800149 <xPendingReadyList+0x6>
     918:	c6 81       	ldd	r28, Z+6	; 0x06
     91a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     91c:	ce 01       	movw	r24, r28
     91e:	0c 96       	adiw	r24, 0x0c	; 12
     920:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     924:	8e 01       	movw	r16, r28
     926:	0e 5f       	subi	r16, 0xFE	; 254
     928:	1f 4f       	sbci	r17, 0xFF	; 255
     92a:	c8 01       	movw	r24, r16
     92c:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     930:	8e 89       	ldd	r24, Y+22	; 0x16
     932:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     936:	98 17       	cp	r25, r24
     938:	10 f4       	brcc	.+4      	; 0x93e <__stack+0x3f>
     93a:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     93e:	f8 9e       	mul	r15, r24
     940:	c0 01       	movw	r24, r0
     942:	11 24       	eor	r1, r1
     944:	b8 01       	movw	r22, r16
     946:	8e 59       	subi	r24, 0x9E	; 158
     948:	9e 4f       	sbci	r25, 0xFE	; 254
     94a:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     94e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     952:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     956:	9e 89       	ldd	r25, Y+22	; 0x16
     958:	86 89       	ldd	r24, Z+22	; 0x16
     95a:	98 17       	cp	r25, r24
     95c:	a8 f2       	brcs	.-86     	; 0x908 <__stack+0x9>
					{
						xYieldPending = pdTRUE;
     95e:	e0 92 29 01 	sts	0x0129, r14	; 0x800129 <xYieldPending>
     962:	d2 cf       	rjmp	.-92     	; 0x908 <__stack+0x9>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     964:	cd 2b       	or	r28, r29
     966:	11 f0       	breq	.+4      	; 0x96c <__stack+0x6d>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     968:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     96c:	c0 91 2a 01 	lds	r28, 0x012A	; 0x80012a <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     970:	cc 23       	and	r28, r28
     972:	51 f0       	breq	.+20     	; 0x988 <__stack+0x89>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     974:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     976:	0e 94 ba 03 	call	0x774	; 0x774 <xTaskIncrementTick>
     97a:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     97c:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     980:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     982:	c9 f7       	brne	.-14     	; 0x976 <__stack+0x77>

						uxPendedTicks = 0;
     984:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     988:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <xYieldPending>
     98c:	88 23       	and	r24, r24
     98e:	09 f4       	brne	.+2      	; 0x992 <__stack+0x93>
     990:	af cf       	rjmp	.-162    	; 0x8f0 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     992:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     996:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     998:	0f 90       	pop	r0
     99a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	1f 91       	pop	r17
     9a2:	0f 91       	pop	r16
     9a4:	ff 90       	pop	r15
     9a6:	ef 90       	pop	r14
     9a8:	08 95       	ret

000009aa <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	8c 01       	movw	r16, r24
     9b4:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     9b6:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     9ba:	40 91 2d 01 	lds	r20, 0x012D	; 0x80012d <xTickCount>
     9be:	50 91 2e 01 	lds	r21, 0x012E	; 0x80012e <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     9c2:	f8 01       	movw	r30, r16
     9c4:	20 81       	ld	r18, Z
     9c6:	31 81       	ldd	r19, Z+1	; 0x01
     9c8:	c9 01       	movw	r24, r18
     9ca:	8c 0f       	add	r24, r28
     9cc:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     9ce:	42 17       	cp	r20, r18
     9d0:	53 07       	cpc	r21, r19
     9d2:	20 f4       	brcc	.+8      	; 0x9dc <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     9d4:	82 17       	cp	r24, r18
     9d6:	93 07       	cpc	r25, r19
     9d8:	40 f4       	brcc	.+16     	; 0x9ea <vTaskDelayUntil+0x40>
     9da:	03 c0       	rjmp	.+6      	; 0x9e2 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     9dc:	82 17       	cp	r24, r18
     9de:	93 07       	cpc	r25, r19
     9e0:	30 f0       	brcs	.+12     	; 0x9ee <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     9e2:	21 e0       	ldi	r18, 0x01	; 1
     9e4:	48 17       	cp	r20, r24
     9e6:	59 07       	cpc	r21, r25
     9e8:	18 f0       	brcs	.+6      	; 0x9f0 <vTaskDelayUntil+0x46>
     9ea:	20 e0       	ldi	r18, 0x00	; 0
     9ec:	01 c0       	rjmp	.+2      	; 0x9f0 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     9ee:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     9f0:	f8 01       	movw	r30, r16
     9f2:	91 83       	std	Z+1, r25	; 0x01
     9f4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     9f6:	22 23       	and	r18, r18
     9f8:	29 f0       	breq	.+10     	; 0xa04 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	84 1b       	sub	r24, r20
     9fe:	95 0b       	sbc	r25, r21
     a00:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a04:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a08:	81 11       	cpse	r24, r1
     a0a:	02 c0       	rjmp	.+4      	; 0xa10 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a0c:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	1f 91       	pop	r17
     a16:	0f 91       	pop	r16
     a18:	08 95       	ret

00000a1a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     a20:	89 2b       	or	r24, r25
     a22:	19 f4       	brne	.+6      	; 0xa2a <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     a24:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
     a28:	0a c0       	rjmp	.+20     	; 0xa3e <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     a2a:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     a2e:	60 e0       	ldi	r22, 0x00	; 0
     a30:	ce 01       	movw	r24, r28
     a32:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a36:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a3a:	88 23       	and	r24, r24
     a3c:	99 f3       	breq	.-26     	; 0xa24 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	08 95       	ret

00000a44 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a44:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     a48:	88 23       	and	r24, r24
     a4a:	21 f0       	breq	.+8      	; 0xa54 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a4c:	81 e0       	ldi	r24, 0x01	; 1
     a4e:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     a52:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a54:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a58:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTopReadyPriority>
     a5c:	69 e0       	ldi	r22, 0x09	; 9
     a5e:	48 2f       	mov	r20, r24
     a60:	50 e0       	ldi	r21, 0x00	; 0
     a62:	64 9f       	mul	r22, r20
     a64:	90 01       	movw	r18, r0
     a66:	65 9f       	mul	r22, r21
     a68:	30 0d       	add	r19, r0
     a6a:	11 24       	eor	r1, r1
     a6c:	f9 01       	movw	r30, r18
     a6e:	ee 59       	subi	r30, 0x9E	; 158
     a70:	fe 4f       	sbci	r31, 0xFE	; 254
     a72:	90 81       	ld	r25, Z
     a74:	91 11       	cpse	r25, r1
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <vTaskSwitchContext+0x38>
     a78:	81 50       	subi	r24, 0x01	; 1
     a7a:	f1 cf       	rjmp	.-30     	; 0xa5e <vTaskSwitchContext+0x1a>
     a7c:	a1 81       	ldd	r26, Z+1	; 0x01
     a7e:	b2 81       	ldd	r27, Z+2	; 0x02
     a80:	12 96       	adiw	r26, 0x02	; 2
     a82:	0d 90       	ld	r0, X+
     a84:	bc 91       	ld	r27, X
     a86:	a0 2d       	mov	r26, r0
     a88:	b2 83       	std	Z+2, r27	; 0x02
     a8a:	a1 83       	std	Z+1, r26	; 0x01
     a8c:	2b 59       	subi	r18, 0x9B	; 155
     a8e:	3e 4f       	sbci	r19, 0xFE	; 254
     a90:	a2 17       	cp	r26, r18
     a92:	b3 07       	cpc	r27, r19
     a94:	31 f4       	brne	.+12     	; 0xaa2 <vTaskSwitchContext+0x5e>
     a96:	12 96       	adiw	r26, 0x02	; 2
     a98:	2d 91       	ld	r18, X+
     a9a:	3c 91       	ld	r19, X
     a9c:	13 97       	sbiw	r26, 0x03	; 3
     a9e:	32 83       	std	Z+2, r19	; 0x02
     aa0:	21 83       	std	Z+1, r18	; 0x01
     aa2:	99 e0       	ldi	r25, 0x09	; 9
     aa4:	94 9f       	mul	r25, r20
     aa6:	f0 01       	movw	r30, r0
     aa8:	95 9f       	mul	r25, r21
     aaa:	f0 0d       	add	r31, r0
     aac:	11 24       	eor	r1, r1
     aae:	ee 59       	subi	r30, 0x9E	; 158
     ab0:	fe 4f       	sbci	r31, 0xFE	; 254
     ab2:	01 80       	ldd	r0, Z+1	; 0x01
     ab4:	f2 81       	ldd	r31, Z+2	; 0x02
     ab6:	e0 2d       	mov	r30, r0
     ab8:	26 81       	ldd	r18, Z+6	; 0x06
     aba:	37 81       	ldd	r19, Z+7	; 0x07
     abc:	30 93 21 01 	sts	0x0121, r19	; 0x800121 <__data_end+0x1>
     ac0:	20 93 20 01 	sts	0x0120, r18	; 0x800120 <__data_end>
     ac4:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     ac8:	08 95       	ret

00000aca <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     aca:	0f 93       	push	r16
     acc:	1f 93       	push	r17
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     ad4:	0f b6       	in	r0, 0x3f	; 63
     ad6:	f8 94       	cli
     ad8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     ada:	89 2b       	or	r24, r25
     adc:	21 f4       	brne	.+8      	; 0xae6 <vTaskSuspend+0x1c>
     ade:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
     ae2:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     ae6:	8e 01       	movw	r16, r28
     ae8:	0e 5f       	subi	r16, 0xFE	; 254
     aea:	1f 4f       	sbci	r17, 0xFF	; 255
     aec:	c8 01       	movw	r24, r16
     aee:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     af2:	8c 89       	ldd	r24, Y+20	; 0x14
     af4:	9d 89       	ldd	r25, Y+21	; 0x15
     af6:	89 2b       	or	r24, r25
     af8:	21 f0       	breq	.+8      	; 0xb02 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     afa:	ce 01       	movw	r24, r28
     afc:	0c 96       	adiw	r24, 0x0c	; 12
     afe:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     b02:	b8 01       	movw	r22, r16
     b04:	80 e3       	ldi	r24, 0x30	; 48
     b06:	91 e0       	ldi	r25, 0x01	; 1
     b08:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b0c:	8d a1       	ldd	r24, Y+37	; 0x25
     b0e:	81 30       	cpi	r24, 0x01	; 1
     b10:	09 f4       	brne	.+2      	; 0xb14 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b12:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b14:	0f 90       	pop	r0
     b16:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b18:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     b1c:	88 23       	and	r24, r24
     b1e:	39 f0       	breq	.+14     	; 0xb2e <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	f8 94       	cli
     b24:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     b26:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     b2a:	0f 90       	pop	r0
     b2c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     b2e:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     b32:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     b36:	c8 17       	cp	r28, r24
     b38:	d9 07       	cpc	r29, r25
     b3a:	c1 f4       	brne	.+48     	; 0xb6c <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b3c:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     b40:	88 23       	and	r24, r24
     b42:	19 f0       	breq	.+6      	; 0xb4a <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b44:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
     b48:	11 c0       	rjmp	.+34     	; 0xb6c <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b4a:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <xSuspendedTaskList>
     b4e:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     b52:	98 13       	cpse	r25, r24
     b54:	05 c0       	rjmp	.+10     	; 0xb60 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b56:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <__data_end+0x1>
     b5a:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__data_end>
     b5e:	06 c0       	rjmp	.+12     	; 0xb6c <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b60:	df 91       	pop	r29
     b62:	cf 91       	pop	r28
     b64:	1f 91       	pop	r17
     b66:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b68:	0c 94 22 05 	jmp	0xa44	; 0xa44 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b6c:	df 91       	pop	r29
     b6e:	cf 91       	pop	r28
     b70:	1f 91       	pop	r17
     b72:	0f 91       	pop	r16
     b74:	08 95       	ret

00000b76 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     b76:	cf 93       	push	r28
     b78:	df 93       	push	r29
     b7a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b7c:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     b80:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     b84:	64 5f       	subi	r22, 0xF4	; 244
     b86:	7f 4f       	sbci	r23, 0xFF	; 255
     b88:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b8c:	61 e0       	ldi	r22, 0x01	; 1
     b8e:	ce 01       	movw	r24, r28
}
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b94:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <prvAddCurrentTaskToDelayedList>

00000b98 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b9e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     ba2:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     ba6:	70 68       	ori	r23, 0x80	; 128
     ba8:	75 87       	std	Z+13, r23	; 0x0d
     baa:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     bac:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     bb0:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     bb4:	64 5f       	subi	r22, 0xF4	; 244
     bb6:	7f 4f       	sbci	r23, 0xFF	; 255
     bb8:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bbc:	61 e0       	ldi	r22, 0x01	; 1
     bbe:	ce 01       	movw	r24, r28
}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bc4:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <prvAddCurrentTaskToDelayedList>

00000bc8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     bd0:	dc 01       	movw	r26, r24
     bd2:	15 96       	adiw	r26, 0x05	; 5
     bd4:	ed 91       	ld	r30, X+
     bd6:	fc 91       	ld	r31, X
     bd8:	16 97       	sbiw	r26, 0x06	; 6
     bda:	c6 81       	ldd	r28, Z+6	; 0x06
     bdc:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     bde:	8e 01       	movw	r16, r28
     be0:	04 5f       	subi	r16, 0xF4	; 244
     be2:	1f 4f       	sbci	r17, 0xFF	; 255
     be4:	c8 01       	movw	r24, r16
     be6:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     bea:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     bee:	81 11       	cpse	r24, r1
     bf0:	14 c0       	rjmp	.+40     	; 0xc1a <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     bf2:	0a 50       	subi	r16, 0x0A	; 10
     bf4:	11 09       	sbc	r17, r1
     bf6:	c8 01       	movw	r24, r16
     bf8:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     bfc:	8e 89       	ldd	r24, Y+22	; 0x16
     bfe:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     c02:	98 17       	cp	r25, r24
     c04:	10 f4       	brcc	.+4      	; 0xc0a <xTaskRemoveFromEventList+0x42>
     c06:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     c0a:	b9 e0       	ldi	r27, 0x09	; 9
     c0c:	8b 9f       	mul	r24, r27
     c0e:	c0 01       	movw	r24, r0
     c10:	11 24       	eor	r1, r1
     c12:	b8 01       	movw	r22, r16
     c14:	8e 59       	subi	r24, 0x9E	; 158
     c16:	9e 4f       	sbci	r25, 0xFE	; 254
     c18:	03 c0       	rjmp	.+6      	; 0xc20 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c1a:	b8 01       	movw	r22, r16
     c1c:	83 e4       	ldi	r24, 0x43	; 67
     c1e:	91 e0       	ldi	r25, 0x01	; 1
     c20:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c24:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     c28:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     c2c:	9e 89       	ldd	r25, Y+22	; 0x16
     c2e:	86 89       	ldd	r24, Z+22	; 0x16
     c30:	89 17       	cp	r24, r25
     c32:	20 f4       	brcc	.+8      	; 0xc3c <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c34:	81 e0       	ldi	r24, 0x01	; 1
     c36:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     c3a:	01 c0       	rjmp	.+2      	; 0xc3e <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c3c:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	1f 91       	pop	r17
     c44:	0f 91       	pop	r16
     c46:	08 95       	ret

00000c48 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c48:	0f 93       	push	r16
     c4a:	1f 93       	push	r17
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c50:	70 68       	ori	r23, 0x80	; 128
     c52:	fc 01       	movw	r30, r24
     c54:	71 83       	std	Z+1, r23	; 0x01
     c56:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c58:	c6 81       	ldd	r28, Z+6	; 0x06
     c5a:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c5c:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c60:	8e 01       	movw	r16, r28
     c62:	0e 5f       	subi	r16, 0xFE	; 254
     c64:	1f 4f       	sbci	r17, 0xFF	; 255
     c66:	c8 01       	movw	r24, r16
     c68:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c6c:	8e 89       	ldd	r24, Y+22	; 0x16
     c6e:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     c72:	98 17       	cp	r25, r24
     c74:	10 f4       	brcc	.+4      	; 0xc7a <vTaskRemoveFromUnorderedEventList+0x32>
     c76:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     c7a:	f9 e0       	ldi	r31, 0x09	; 9
     c7c:	8f 9f       	mul	r24, r31
     c7e:	c0 01       	movw	r24, r0
     c80:	11 24       	eor	r1, r1
     c82:	b8 01       	movw	r22, r16
     c84:	8e 59       	subi	r24, 0x9E	; 158
     c86:	9e 4f       	sbci	r25, 0xFE	; 254
     c88:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c8c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     c90:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     c94:	9e 89       	ldd	r25, Y+22	; 0x16
     c96:	86 89       	ldd	r24, Z+22	; 0x16
     c98:	89 17       	cp	r24, r25
     c9a:	18 f4       	brcc	.+6      	; 0xca2 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     c9c:	81 e0       	ldi	r24, 0x01	; 1
     c9e:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
	}
}
     ca2:	df 91       	pop	r29
     ca4:	cf 91       	pop	r28
     ca6:	1f 91       	pop	r17
     ca8:	0f 91       	pop	r16
     caa:	08 95       	ret

00000cac <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     cac:	0f b6       	in	r0, 0x3f	; 63
     cae:	f8 94       	cli
     cb0:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     cb2:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <xNumOfOverflows>
     cb6:	fc 01       	movw	r30, r24
     cb8:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     cba:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xTickCount>
     cbe:	30 91 2e 01 	lds	r19, 0x012E	; 0x80012e <xTickCount+0x1>
     cc2:	32 83       	std	Z+2, r19	; 0x02
     cc4:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     cc6:	0f 90       	pop	r0
     cc8:	0f be       	out	0x3f, r0	; 63
     cca:	08 95       	ret

00000ccc <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     ccc:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <xNumOfOverflows>
     cd0:	fc 01       	movw	r30, r24
     cd2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     cd4:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xTickCount>
     cd8:	30 91 2e 01 	lds	r19, 0x012E	; 0x80012e <xTickCount+0x1>
     cdc:	32 83       	std	Z+2, r19	; 0x02
     cde:	21 83       	std	Z+1, r18	; 0x01
     ce0:	08 95       	ret

00000ce2 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     ce6:	0f b6       	in	r0, 0x3f	; 63
     ce8:	f8 94       	cli
     cea:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     cec:	40 91 2d 01 	lds	r20, 0x012D	; 0x80012d <xTickCount>
     cf0:	50 91 2e 01 	lds	r21, 0x012E	; 0x80012e <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     cf4:	db 01       	movw	r26, r22
     cf6:	2d 91       	ld	r18, X+
     cf8:	3c 91       	ld	r19, X
     cfa:	2f 3f       	cpi	r18, 0xFF	; 255
     cfc:	bf ef       	ldi	r27, 0xFF	; 255
     cfe:	3b 07       	cpc	r19, r27
     d00:	d9 f0       	breq	.+54     	; 0xd38 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d02:	ec 01       	movw	r28, r24
     d04:	e9 81       	ldd	r30, Y+1	; 0x01
     d06:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d08:	a0 91 28 01 	lds	r26, 0x0128	; 0x800128 <xNumOfOverflows>
     d0c:	b8 81       	ld	r27, Y
     d0e:	ba 17       	cp	r27, r26
     d10:	19 f0       	breq	.+6      	; 0xd18 <xTaskCheckForTimeOut+0x36>
     d12:	4e 17       	cp	r20, r30
     d14:	5f 07       	cpc	r21, r31
     d16:	90 f4       	brcc	.+36     	; 0xd3c <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d18:	4e 1b       	sub	r20, r30
     d1a:	5f 0b       	sbc	r21, r31
     d1c:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     d1e:	42 17       	cp	r20, r18
     d20:	53 07       	cpc	r21, r19
     d22:	38 f4       	brcc	.+14     	; 0xd32 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     d24:	24 1b       	sub	r18, r20
     d26:	35 0b       	sbc	r19, r21
     d28:	31 83       	std	Z+1, r19	; 0x01
     d2a:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     d2c:	0e 94 66 06 	call	0xccc	; 0xccc <vTaskInternalSetTimeOutState>
     d30:	03 c0       	rjmp	.+6      	; 0xd38 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     d32:	11 82       	std	Z+1, r1	; 0x01
     d34:	10 82       	st	Z, r1
     d36:	02 c0       	rjmp	.+4      	; 0xd3c <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     d38:	80 e0       	ldi	r24, 0x00	; 0
     d3a:	01 c0       	rjmp	.+2      	; 0xd3e <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d3c:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d3e:	0f 90       	pop	r0
     d40:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	08 95       	ret

00000d48 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     d4e:	08 95       	ret

00000d50 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d50:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d54:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d58:	84 85       	ldd	r24, Z+12	; 0x0c
     d5a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d5c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d60:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d64:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
     d68:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
     d6c:	56 96       	adiw	r26, 0x16	; 22
     d6e:	4c 91       	ld	r20, X
     d70:	24 e0       	ldi	r18, 0x04	; 4
     d72:	30 e0       	ldi	r19, 0x00	; 0
     d74:	24 1b       	sub	r18, r20
     d76:	31 09       	sbc	r19, r1
     d78:	35 87       	std	Z+13, r19	; 0x0d
     d7a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     d7c:	08 95       	ret

00000d7e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     d7e:	0f 93       	push	r16
     d80:	1f 93       	push	r17
     d82:	18 2f       	mov	r17, r24
     d84:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     d86:	0f b6       	in	r0, 0x3f	; 63
     d88:	f8 94       	cli
     d8a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     d8c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d90:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d94:	41 a1       	ldd	r20, Z+33	; 0x21
     d96:	52 a1       	ldd	r21, Z+34	; 0x22
     d98:	63 a1       	ldd	r22, Z+35	; 0x23
     d9a:	74 a1       	ldd	r23, Z+36	; 0x24
     d9c:	45 2b       	or	r20, r21
     d9e:	46 2b       	or	r20, r22
     da0:	47 2b       	or	r20, r23
     da2:	69 f4       	brne	.+26     	; 0xdbe <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     da4:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     da8:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     dac:	21 e0       	ldi	r18, 0x01	; 1
     dae:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     db0:	00 97       	sbiw	r24, 0x00	; 0
     db2:	29 f0       	breq	.+10     	; 0xdbe <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     db4:	61 e0       	ldi	r22, 0x01	; 1
     db6:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     dba:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     dbe:	0f 90       	pop	r0
     dc0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     dc8:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     dcc:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     dd0:	61 a1       	ldd	r22, Z+33	; 0x21
     dd2:	72 a1       	ldd	r23, Z+34	; 0x22
     dd4:	83 a1       	ldd	r24, Z+35	; 0x23
     dd6:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     dd8:	61 15       	cp	r22, r1
     dda:	71 05       	cpc	r23, r1
     ddc:	81 05       	cpc	r24, r1
     dde:	91 05       	cpc	r25, r1
     de0:	a9 f0       	breq	.+42     	; 0xe0c <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     de2:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     de6:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     dea:	11 23       	and	r17, r17
     dec:	29 f0       	breq	.+10     	; 0xdf8 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     dee:	11 a2       	std	Z+33, r1	; 0x21
     df0:	12 a2       	std	Z+34, r1	; 0x22
     df2:	13 a2       	std	Z+35, r1	; 0x23
     df4:	14 a2       	std	Z+36, r1	; 0x24
     df6:	0a c0       	rjmp	.+20     	; 0xe0c <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     df8:	8b 01       	movw	r16, r22
     dfa:	9c 01       	movw	r18, r24
     dfc:	01 50       	subi	r16, 0x01	; 1
     dfe:	11 09       	sbc	r17, r1
     e00:	21 09       	sbc	r18, r1
     e02:	31 09       	sbc	r19, r1
     e04:	01 a3       	std	Z+33, r16	; 0x21
     e06:	12 a3       	std	Z+34, r17	; 0x22
     e08:	23 a3       	std	Z+35, r18	; 0x23
     e0a:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e0c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e10:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e14:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     e16:	0f 90       	pop	r0
     e18:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     e1a:	1f 91       	pop	r17
     e1c:	0f 91       	pop	r16
     e1e:	08 95       	ret

00000e20 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     e20:	4f 92       	push	r4
     e22:	5f 92       	push	r5
     e24:	6f 92       	push	r6
     e26:	7f 92       	push	r7
     e28:	8f 92       	push	r8
     e2a:	9f 92       	push	r9
     e2c:	af 92       	push	r10
     e2e:	bf 92       	push	r11
     e30:	ef 92       	push	r14
     e32:	ff 92       	push	r15
     e34:	0f 93       	push	r16
     e36:	1f 93       	push	r17
     e38:	49 01       	movw	r8, r18
     e3a:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     e3c:	0f b6       	in	r0, 0x3f	; 63
     e3e:	f8 94       	cli
     e40:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e42:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e46:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e4a:	25 a1       	ldd	r18, Z+37	; 0x25
     e4c:	22 30       	cpi	r18, 0x02	; 2
     e4e:	39 f1       	breq	.+78     	; 0xe9e <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e50:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e54:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e58:	21 a1       	ldd	r18, Z+33	; 0x21
     e5a:	32 a1       	ldd	r19, Z+34	; 0x22
     e5c:	43 a1       	ldd	r20, Z+35	; 0x23
     e5e:	54 a1       	ldd	r21, Z+36	; 0x24
     e60:	2b 01       	movw	r4, r22
     e62:	3c 01       	movw	r6, r24
     e64:	40 94       	com	r4
     e66:	50 94       	com	r5
     e68:	60 94       	com	r6
     e6a:	70 94       	com	r7
     e6c:	d3 01       	movw	r26, r6
     e6e:	c2 01       	movw	r24, r4
     e70:	82 23       	and	r24, r18
     e72:	93 23       	and	r25, r19
     e74:	a4 23       	and	r26, r20
     e76:	b5 23       	and	r27, r21
     e78:	81 a3       	std	Z+33, r24	; 0x21
     e7a:	92 a3       	std	Z+34, r25	; 0x22
     e7c:	a3 a3       	std	Z+35, r26	; 0x23
     e7e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e80:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e84:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e8c:	e1 14       	cp	r14, r1
     e8e:	f1 04       	cpc	r15, r1
     e90:	31 f0       	breq	.+12     	; 0xe9e <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e92:	61 e0       	ldi	r22, 0x01	; 1
     e94:	c7 01       	movw	r24, r14
     e96:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e9a:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e9e:	0f 90       	pop	r0
     ea0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     ea2:	0f b6       	in	r0, 0x3f	; 63
     ea4:	f8 94       	cli
     ea6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     ea8:	01 15       	cp	r16, r1
     eaa:	11 05       	cpc	r17, r1
     eac:	69 f0       	breq	.+26     	; 0xec8 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     eae:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     eb2:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     eb6:	81 a1       	ldd	r24, Z+33	; 0x21
     eb8:	92 a1       	ldd	r25, Z+34	; 0x22
     eba:	a3 a1       	ldd	r26, Z+35	; 0x23
     ebc:	b4 a1       	ldd	r27, Z+36	; 0x24
     ebe:	f8 01       	movw	r30, r16
     ec0:	80 83       	st	Z, r24
     ec2:	91 83       	std	Z+1, r25	; 0x01
     ec4:	a2 83       	std	Z+2, r26	; 0x02
     ec6:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     ec8:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     ecc:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     ed0:	85 a1       	ldd	r24, Z+37	; 0x25
     ed2:	82 30       	cpi	r24, 0x02	; 2
     ed4:	c1 f4       	brne	.+48     	; 0xf06 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     ed6:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     eda:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     ede:	41 a1       	ldd	r20, Z+33	; 0x21
     ee0:	52 a1       	ldd	r21, Z+34	; 0x22
     ee2:	63 a1       	ldd	r22, Z+35	; 0x23
     ee4:	74 a1       	ldd	r23, Z+36	; 0x24
     ee6:	d5 01       	movw	r26, r10
     ee8:	c4 01       	movw	r24, r8
     eea:	80 95       	com	r24
     eec:	90 95       	com	r25
     eee:	a0 95       	com	r26
     ef0:	b0 95       	com	r27
     ef2:	84 23       	and	r24, r20
     ef4:	95 23       	and	r25, r21
     ef6:	a6 23       	and	r26, r22
     ef8:	b7 23       	and	r27, r23
     efa:	81 a3       	std	Z+33, r24	; 0x21
     efc:	92 a3       	std	Z+34, r25	; 0x22
     efe:	a3 a3       	std	Z+35, r26	; 0x23
     f00:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	01 c0       	rjmp	.+2      	; 0xf08 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     f06:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     f08:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f0c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f10:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f12:	0f 90       	pop	r0
     f14:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	ff 90       	pop	r15
     f1c:	ef 90       	pop	r14
     f1e:	bf 90       	pop	r11
     f20:	af 90       	pop	r10
     f22:	9f 90       	pop	r9
     f24:	8f 90       	pop	r8
     f26:	7f 90       	pop	r7
     f28:	6f 90       	pop	r6
     f2a:	5f 90       	pop	r5
     f2c:	4f 90       	pop	r4
     f2e:	08 95       	ret

00000f30 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     f30:	0f 93       	push	r16
     f32:	1f 93       	push	r17
     f34:	cf 93       	push	r28
     f36:	df 93       	push	r29
     f38:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     f3a:	0f b6       	in	r0, 0x3f	; 63
     f3c:	f8 94       	cli
     f3e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     f40:	01 15       	cp	r16, r1
     f42:	11 05       	cpc	r17, r1
     f44:	49 f0       	breq	.+18     	; 0xf58 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f46:	81 a1       	ldd	r24, Z+33	; 0x21
     f48:	92 a1       	ldd	r25, Z+34	; 0x22
     f4a:	a3 a1       	ldd	r26, Z+35	; 0x23
     f4c:	b4 a1       	ldd	r27, Z+36	; 0x24
     f4e:	e8 01       	movw	r28, r16
     f50:	88 83       	st	Y, r24
     f52:	99 83       	std	Y+1, r25	; 0x01
     f54:	aa 83       	std	Y+2, r26	; 0x02
     f56:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f58:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f5a:	82 e0       	ldi	r24, 0x02	; 2
     f5c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f5e:	22 30       	cpi	r18, 0x02	; 2
     f60:	89 f0       	breq	.+34     	; 0xf84 <xTaskGenericNotify+0x54>
     f62:	58 f4       	brcc	.+22     	; 0xf7a <xTaskGenericNotify+0x4a>
     f64:	21 30       	cpi	r18, 0x01	; 1
     f66:	01 f5       	brne	.+64     	; 0xfa8 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f68:	81 a1       	ldd	r24, Z+33	; 0x21
     f6a:	92 a1       	ldd	r25, Z+34	; 0x22
     f6c:	a3 a1       	ldd	r26, Z+35	; 0x23
     f6e:	b4 a1       	ldd	r27, Z+36	; 0x24
     f70:	48 2b       	or	r20, r24
     f72:	59 2b       	or	r21, r25
     f74:	6a 2b       	or	r22, r26
     f76:	7b 2b       	or	r23, r27
     f78:	13 c0       	rjmp	.+38     	; 0xfa0 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     f7a:	23 30       	cpi	r18, 0x03	; 3
     f7c:	89 f0       	breq	.+34     	; 0xfa0 <xTaskGenericNotify+0x70>
     f7e:	24 30       	cpi	r18, 0x04	; 4
     f80:	69 f0       	breq	.+26     	; 0xf9c <xTaskGenericNotify+0x6c>
     f82:	12 c0       	rjmp	.+36     	; 0xfa8 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     f84:	81 a1       	ldd	r24, Z+33	; 0x21
     f86:	92 a1       	ldd	r25, Z+34	; 0x22
     f88:	a3 a1       	ldd	r26, Z+35	; 0x23
     f8a:	b4 a1       	ldd	r27, Z+36	; 0x24
     f8c:	01 96       	adiw	r24, 0x01	; 1
     f8e:	a1 1d       	adc	r26, r1
     f90:	b1 1d       	adc	r27, r1
     f92:	81 a3       	std	Z+33, r24	; 0x21
     f94:	92 a3       	std	Z+34, r25	; 0x22
     f96:	a3 a3       	std	Z+35, r26	; 0x23
     f98:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     f9a:	06 c0       	rjmp	.+12     	; 0xfa8 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     f9c:	32 30       	cpi	r19, 0x02	; 2
     f9e:	49 f1       	breq	.+82     	; 0xff2 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     fa0:	41 a3       	std	Z+33, r20	; 0x21
     fa2:	52 a3       	std	Z+34, r21	; 0x22
     fa4:	63 a3       	std	Z+35, r22	; 0x23
     fa6:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     fa8:	31 30       	cpi	r19, 0x01	; 1
     faa:	09 f5       	brne	.+66     	; 0xfee <xTaskGenericNotify+0xbe>
     fac:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     fae:	8f 01       	movw	r16, r30
     fb0:	0e 5f       	subi	r16, 0xFE	; 254
     fb2:	1f 4f       	sbci	r17, 0xFF	; 255
     fb4:	c8 01       	movw	r24, r16
     fb6:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     fba:	8e 89       	ldd	r24, Y+22	; 0x16
     fbc:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     fc0:	98 17       	cp	r25, r24
     fc2:	10 f4       	brcc	.+4      	; 0xfc8 <xTaskGenericNotify+0x98>
     fc4:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     fc8:	29 e0       	ldi	r18, 0x09	; 9
     fca:	82 9f       	mul	r24, r18
     fcc:	c0 01       	movw	r24, r0
     fce:	11 24       	eor	r1, r1
     fd0:	b8 01       	movw	r22, r16
     fd2:	8e 59       	subi	r24, 0x9E	; 158
     fd4:	9e 4f       	sbci	r25, 0xFE	; 254
     fd6:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     fda:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     fde:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     fe2:	9e 89       	ldd	r25, Y+22	; 0x16
     fe4:	86 89       	ldd	r24, Z+22	; 0x16
     fe6:	89 17       	cp	r24, r25
     fe8:	10 f4       	brcc	.+4      	; 0xfee <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     fea:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
     fee:	81 e0       	ldi	r24, 0x01	; 1
     ff0:	01 c0       	rjmp	.+2      	; 0xff4 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     ff2:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	08 95       	ret

00001002 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1002:	ef 92       	push	r14
    1004:	ff 92       	push	r15
    1006:	0f 93       	push	r16
    1008:	1f 93       	push	r17
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
    100e:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1010:	01 15       	cp	r16, r1
    1012:	11 05       	cpc	r17, r1
    1014:	49 f0       	breq	.+18     	; 0x1028 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1016:	81 a1       	ldd	r24, Z+33	; 0x21
    1018:	92 a1       	ldd	r25, Z+34	; 0x22
    101a:	a3 a1       	ldd	r26, Z+35	; 0x23
    101c:	b4 a1       	ldd	r27, Z+36	; 0x24
    101e:	e8 01       	movw	r28, r16
    1020:	88 83       	st	Y, r24
    1022:	99 83       	std	Y+1, r25	; 0x01
    1024:	aa 83       	std	Y+2, r26	; 0x02
    1026:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1028:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    102a:	82 e0       	ldi	r24, 0x02	; 2
    102c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    102e:	22 30       	cpi	r18, 0x02	; 2
    1030:	89 f0       	breq	.+34     	; 0x1054 <xTaskGenericNotifyFromISR+0x52>
    1032:	58 f4       	brcc	.+22     	; 0x104a <xTaskGenericNotifyFromISR+0x48>
    1034:	21 30       	cpi	r18, 0x01	; 1
    1036:	01 f5       	brne	.+64     	; 0x1078 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1038:	81 a1       	ldd	r24, Z+33	; 0x21
    103a:	92 a1       	ldd	r25, Z+34	; 0x22
    103c:	a3 a1       	ldd	r26, Z+35	; 0x23
    103e:	b4 a1       	ldd	r27, Z+36	; 0x24
    1040:	48 2b       	or	r20, r24
    1042:	59 2b       	or	r21, r25
    1044:	6a 2b       	or	r22, r26
    1046:	7b 2b       	or	r23, r27
    1048:	13 c0       	rjmp	.+38     	; 0x1070 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    104a:	23 30       	cpi	r18, 0x03	; 3
    104c:	89 f0       	breq	.+34     	; 0x1070 <xTaskGenericNotifyFromISR+0x6e>
    104e:	24 30       	cpi	r18, 0x04	; 4
    1050:	69 f0       	breq	.+26     	; 0x106c <xTaskGenericNotifyFromISR+0x6a>
    1052:	12 c0       	rjmp	.+36     	; 0x1078 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1054:	81 a1       	ldd	r24, Z+33	; 0x21
    1056:	92 a1       	ldd	r25, Z+34	; 0x22
    1058:	a3 a1       	ldd	r26, Z+35	; 0x23
    105a:	b4 a1       	ldd	r27, Z+36	; 0x24
    105c:	01 96       	adiw	r24, 0x01	; 1
    105e:	a1 1d       	adc	r26, r1
    1060:	b1 1d       	adc	r27, r1
    1062:	81 a3       	std	Z+33, r24	; 0x21
    1064:	92 a3       	std	Z+34, r25	; 0x22
    1066:	a3 a3       	std	Z+35, r26	; 0x23
    1068:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    106a:	06 c0       	rjmp	.+12     	; 0x1078 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    106c:	32 30       	cpi	r19, 0x02	; 2
    106e:	d9 f1       	breq	.+118    	; 0x10e6 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1070:	41 a3       	std	Z+33, r20	; 0x21
    1072:	52 a3       	std	Z+34, r21	; 0x22
    1074:	63 a3       	std	Z+35, r22	; 0x23
    1076:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1078:	31 30       	cpi	r19, 0x01	; 1
    107a:	11 f0       	breq	.+4      	; 0x1080 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    107c:	81 e0       	ldi	r24, 0x01	; 1
    107e:	34 c0       	rjmp	.+104    	; 0x10e8 <xTaskGenericNotifyFromISR+0xe6>
    1080:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1082:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
    1086:	81 11       	cpse	r24, r1
    1088:	15 c0       	rjmp	.+42     	; 0x10b4 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    108a:	8f 01       	movw	r16, r30
    108c:	0e 5f       	subi	r16, 0xFE	; 254
    108e:	1f 4f       	sbci	r17, 0xFF	; 255
    1090:	c8 01       	movw	r24, r16
    1092:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1096:	8e 89       	ldd	r24, Y+22	; 0x16
    1098:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    109c:	98 17       	cp	r25, r24
    109e:	10 f4       	brcc	.+4      	; 0x10a4 <xTaskGenericNotifyFromISR+0xa2>
    10a0:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    10a4:	e9 e0       	ldi	r30, 0x09	; 9
    10a6:	8e 9f       	mul	r24, r30
    10a8:	c0 01       	movw	r24, r0
    10aa:	11 24       	eor	r1, r1
    10ac:	b8 01       	movw	r22, r16
    10ae:	8e 59       	subi	r24, 0x9E	; 158
    10b0:	9e 4f       	sbci	r25, 0xFE	; 254
    10b2:	05 c0       	rjmp	.+10     	; 0x10be <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    10b4:	bf 01       	movw	r22, r30
    10b6:	64 5f       	subi	r22, 0xF4	; 244
    10b8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ba:	83 e4       	ldi	r24, 0x43	; 67
    10bc:	91 e0       	ldi	r25, 0x01	; 1
    10be:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10c2:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    10c6:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    10ca:	9e 89       	ldd	r25, Y+22	; 0x16
    10cc:	86 89       	ldd	r24, Z+22	; 0x16
    10ce:	89 17       	cp	r24, r25
    10d0:	a8 f6       	brcc	.-86     	; 0x107c <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    10d2:	e1 14       	cp	r14, r1
    10d4:	f1 04       	cpc	r15, r1
    10d6:	19 f0       	breq	.+6      	; 0x10de <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    10d8:	81 e0       	ldi	r24, 0x01	; 1
    10da:	e7 01       	movw	r28, r14
    10dc:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
    10e4:	01 c0       	rjmp	.+2      	; 0x10e8 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10e6:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    10e8:	df 91       	pop	r29
    10ea:	cf 91       	pop	r28
    10ec:	1f 91       	pop	r17
    10ee:	0f 91       	pop	r16
    10f0:	ff 90       	pop	r15
    10f2:	ef 90       	pop	r14
    10f4:	08 95       	ret

000010f6 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10f6:	ef 92       	push	r14
    10f8:	ff 92       	push	r15
    10fa:	0f 93       	push	r16
    10fc:	1f 93       	push	r17
    10fe:	cf 93       	push	r28
    1100:	df 93       	push	r29
    1102:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1104:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1106:	82 e0       	ldi	r24, 0x02	; 2
    1108:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    110a:	81 a1       	ldd	r24, Z+33	; 0x21
    110c:	92 a1       	ldd	r25, Z+34	; 0x22
    110e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1110:	b4 a1       	ldd	r27, Z+36	; 0x24
    1112:	01 96       	adiw	r24, 0x01	; 1
    1114:	a1 1d       	adc	r26, r1
    1116:	b1 1d       	adc	r27, r1
    1118:	81 a3       	std	Z+33, r24	; 0x21
    111a:	92 a3       	std	Z+34, r25	; 0x22
    111c:	a3 a3       	std	Z+35, r26	; 0x23
    111e:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1120:	21 30       	cpi	r18, 0x01	; 1
    1122:	a1 f5       	brne	.+104    	; 0x118c <vTaskNotifyGiveFromISR+0x96>
    1124:	8b 01       	movw	r16, r22
    1126:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1128:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
    112c:	81 11       	cpse	r24, r1
    112e:	16 c0       	rjmp	.+44     	; 0x115c <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1130:	7f 01       	movw	r14, r30
    1132:	22 e0       	ldi	r18, 0x02	; 2
    1134:	e2 0e       	add	r14, r18
    1136:	f1 1c       	adc	r15, r1
    1138:	c7 01       	movw	r24, r14
    113a:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    113e:	8e 89       	ldd	r24, Y+22	; 0x16
    1140:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    1144:	98 17       	cp	r25, r24
    1146:	10 f4       	brcc	.+4      	; 0x114c <vTaskNotifyGiveFromISR+0x56>
    1148:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    114c:	e9 e0       	ldi	r30, 0x09	; 9
    114e:	8e 9f       	mul	r24, r30
    1150:	c0 01       	movw	r24, r0
    1152:	11 24       	eor	r1, r1
    1154:	b7 01       	movw	r22, r14
    1156:	8e 59       	subi	r24, 0x9E	; 158
    1158:	9e 4f       	sbci	r25, 0xFE	; 254
    115a:	05 c0       	rjmp	.+10     	; 0x1166 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    115c:	bf 01       	movw	r22, r30
    115e:	64 5f       	subi	r22, 0xF4	; 244
    1160:	7f 4f       	sbci	r23, 0xFF	; 255
    1162:	83 e4       	ldi	r24, 0x43	; 67
    1164:	91 e0       	ldi	r25, 0x01	; 1
    1166:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    116a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    116e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    1172:	9e 89       	ldd	r25, Y+22	; 0x16
    1174:	86 89       	ldd	r24, Z+22	; 0x16
    1176:	89 17       	cp	r24, r25
    1178:	48 f4       	brcc	.+18     	; 0x118c <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    117a:	01 15       	cp	r16, r1
    117c:	11 05       	cpc	r17, r1
    117e:	19 f0       	breq	.+6      	; 0x1186 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	f8 01       	movw	r30, r16
    1184:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1186:	81 e0       	ldi	r24, 0x01	; 1
    1188:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
    1198:	08 95       	ret

0000119a <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    119a:	00 97       	sbiw	r24, 0x00	; 0
    119c:	21 f4       	brne	.+8      	; 0x11a6 <xTaskNotifyStateClear+0xc>
    119e:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
    11a2:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>

		taskENTER_CRITICAL();
    11a6:	0f b6       	in	r0, 0x3f	; 63
    11a8:	f8 94       	cli
    11aa:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    11ac:	fc 01       	movw	r30, r24
    11ae:	25 a1       	ldd	r18, Z+37	; 0x25
    11b0:	22 30       	cpi	r18, 0x02	; 2
    11b2:	19 f4       	brne	.+6      	; 0x11ba <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11b4:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	01 c0       	rjmp	.+2      	; 0x11bc <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    11ba:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    11bc:	0f 90       	pop	r0
    11be:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11c0:	08 95       	ret

000011c2 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	f8 94       	cli
    11c6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    11c8:	fc 01       	movw	r30, r24
    11ca:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    11cc:	0f 90       	pop	r0
    11ce:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	91 11       	cpse	r25, r1
    11d4:	80 e0       	ldi	r24, 0x00	; 0
}
    11d6:	08 95       	ret

000011d8 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	ec 01       	movw	r28, r24
    11e2:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11e4:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    11e6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11e8:	44 23       	and	r20, r20
    11ea:	b1 f1       	breq	.+108    	; 0x1258 <prvCopyDataToQueue+0x80>
    11ec:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    11ee:	01 11       	cpse	r16, r1
    11f0:	15 c0       	rjmp	.+42     	; 0x121c <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    11f2:	8a 81       	ldd	r24, Y+2	; 0x02
    11f4:	9b 81       	ldd	r25, Y+3	; 0x03
    11f6:	0e 94 4e 12 	call	0x249c	; 0x249c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    11fa:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1200:	82 0f       	add	r24, r18
    1202:	91 1d       	adc	r25, r1
    1204:	9b 83       	std	Y+3, r25	; 0x03
    1206:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1208:	2c 81       	ldd	r18, Y+4	; 0x04
    120a:	3d 81       	ldd	r19, Y+5	; 0x05
    120c:	82 17       	cp	r24, r18
    120e:	93 07       	cpc	r25, r19
    1210:	18 f1       	brcs	.+70     	; 0x1258 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1212:	88 81       	ld	r24, Y
    1214:	99 81       	ldd	r25, Y+1	; 0x01
    1216:	9b 83       	std	Y+3, r25	; 0x03
    1218:	8a 83       	std	Y+2, r24	; 0x02
    121a:	1e c0       	rjmp	.+60     	; 0x1258 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    121c:	8e 81       	ldd	r24, Y+6	; 0x06
    121e:	9f 81       	ldd	r25, Y+7	; 0x07
    1220:	0e 94 4e 12 	call	0x249c	; 0x249c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1224:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	91 95       	neg	r25
    122a:	81 95       	neg	r24
    122c:	91 09       	sbc	r25, r1
    122e:	2e 81       	ldd	r18, Y+6	; 0x06
    1230:	3f 81       	ldd	r19, Y+7	; 0x07
    1232:	28 0f       	add	r18, r24
    1234:	39 1f       	adc	r19, r25
    1236:	3f 83       	std	Y+7, r19	; 0x07
    1238:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    123a:	48 81       	ld	r20, Y
    123c:	59 81       	ldd	r21, Y+1	; 0x01
    123e:	24 17       	cp	r18, r20
    1240:	35 07       	cpc	r19, r21
    1242:	30 f4       	brcc	.+12     	; 0x1250 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1244:	2c 81       	ldd	r18, Y+4	; 0x04
    1246:	3d 81       	ldd	r19, Y+5	; 0x05
    1248:	82 0f       	add	r24, r18
    124a:	93 1f       	adc	r25, r19
    124c:	9f 83       	std	Y+7, r25	; 0x07
    124e:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1250:	02 30       	cpi	r16, 0x02	; 2
    1252:	11 f4       	brne	.+4      	; 0x1258 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1254:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1256:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1258:	1f 5f       	subi	r17, 0xFF	; 255
    125a:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    125c:	80 e0       	ldi	r24, 0x00	; 0
    125e:	df 91       	pop	r29
    1260:	cf 91       	pop	r28
    1262:	1f 91       	pop	r17
    1264:	0f 91       	pop	r16
    1266:	08 95       	ret

00001268 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1268:	fc 01       	movw	r30, r24
    126a:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    126c:	44 8d       	ldd	r20, Z+28	; 0x1c
    126e:	44 23       	and	r20, r20
    1270:	a1 f0       	breq	.+40     	; 0x129a <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1272:	50 e0       	ldi	r21, 0x00	; 0
    1274:	26 81       	ldd	r18, Z+6	; 0x06
    1276:	37 81       	ldd	r19, Z+7	; 0x07
    1278:	24 0f       	add	r18, r20
    127a:	35 1f       	adc	r19, r21
    127c:	37 83       	std	Z+7, r19	; 0x07
    127e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1280:	64 81       	ldd	r22, Z+4	; 0x04
    1282:	75 81       	ldd	r23, Z+5	; 0x05
    1284:	26 17       	cp	r18, r22
    1286:	37 07       	cpc	r19, r23
    1288:	20 f0       	brcs	.+8      	; 0x1292 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    128a:	20 81       	ld	r18, Z
    128c:	31 81       	ldd	r19, Z+1	; 0x01
    128e:	37 83       	std	Z+7, r19	; 0x07
    1290:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1292:	66 81       	ldd	r22, Z+6	; 0x06
    1294:	77 81       	ldd	r23, Z+7	; 0x07
    1296:	0c 94 4e 12 	jmp	0x249c	; 0x249c <memcpy>
    129a:	08 95       	ret

0000129c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    129c:	ef 92       	push	r14
    129e:	ff 92       	push	r15
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    12a8:	0f b6       	in	r0, 0x3f	; 63
    12aa:	f8 94       	cli
    12ac:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    12ae:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12b0:	7c 01       	movw	r14, r24
    12b2:	81 e1       	ldi	r24, 0x11	; 17
    12b4:	e8 0e       	add	r14, r24
    12b6:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    12b8:	11 16       	cp	r1, r17
    12ba:	5c f4       	brge	.+22     	; 0x12d2 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12bc:	89 89       	ldd	r24, Y+17	; 0x11
    12be:	88 23       	and	r24, r24
    12c0:	41 f0       	breq	.+16     	; 0x12d2 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12c2:	c7 01       	movw	r24, r14
    12c4:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    12c8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    12ca:	0e 94 a4 06 	call	0xd48	; 0xd48 <vTaskMissedYield>
    12ce:	11 50       	subi	r17, 0x01	; 1
    12d0:	f3 cf       	rjmp	.-26     	; 0x12b8 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    12d2:	8f ef       	ldi	r24, 0xFF	; 255
    12d4:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    12d6:	0f 90       	pop	r0
    12d8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    12da:	0f b6       	in	r0, 0x3f	; 63
    12dc:	f8 94       	cli
    12de:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    12e0:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12e2:	7e 01       	movw	r14, r28
    12e4:	88 e0       	ldi	r24, 0x08	; 8
    12e6:	e8 0e       	add	r14, r24
    12e8:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    12ea:	11 16       	cp	r1, r17
    12ec:	5c f4       	brge	.+22     	; 0x1304 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12ee:	88 85       	ldd	r24, Y+8	; 0x08
    12f0:	88 23       	and	r24, r24
    12f2:	41 f0       	breq	.+16     	; 0x1304 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12f4:	c7 01       	movw	r24, r14
    12f6:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    12fa:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    12fc:	0e 94 a4 06 	call	0xd48	; 0xd48 <vTaskMissedYield>
    1300:	11 50       	subi	r17, 0x01	; 1
    1302:	f3 cf       	rjmp	.-26     	; 0x12ea <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1304:	8f ef       	ldi	r24, 0xFF	; 255
    1306:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
}
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	ff 90       	pop	r15
    1314:	ef 90       	pop	r14
    1316:	08 95       	ret

00001318 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    131e:	0f b6       	in	r0, 0x3f	; 63
    1320:	f8 94       	cli
    1322:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1324:	48 81       	ld	r20, Y
    1326:	59 81       	ldd	r21, Y+1	; 0x01
    1328:	8b 8d       	ldd	r24, Y+27	; 0x1b
    132a:	7c 8d       	ldd	r23, Y+28	; 0x1c
    132c:	9a 01       	movw	r18, r20
    132e:	87 9f       	mul	r24, r23
    1330:	20 0d       	add	r18, r0
    1332:	31 1d       	adc	r19, r1
    1334:	11 24       	eor	r1, r1
    1336:	3d 83       	std	Y+5, r19	; 0x05
    1338:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    133a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    133c:	5b 83       	std	Y+3, r21	; 0x03
    133e:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	01 97       	sbiw	r24, 0x01	; 1
    1344:	78 9f       	mul	r23, r24
    1346:	90 01       	movw	r18, r0
    1348:	79 9f       	mul	r23, r25
    134a:	30 0d       	add	r19, r0
    134c:	11 24       	eor	r1, r1
    134e:	ca 01       	movw	r24, r20
    1350:	82 0f       	add	r24, r18
    1352:	93 1f       	adc	r25, r19
    1354:	9f 83       	std	Y+7, r25	; 0x07
    1356:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1358:	8f ef       	ldi	r24, 0xFF	; 255
    135a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    135c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    135e:	61 11       	cpse	r22, r1
    1360:	0c c0       	rjmp	.+24     	; 0x137a <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1362:	88 85       	ldd	r24, Y+8	; 0x08
    1364:	88 23       	and	r24, r24
    1366:	89 f0       	breq	.+34     	; 0x138a <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1368:	ce 01       	movw	r24, r28
    136a:	08 96       	adiw	r24, 0x08	; 8
    136c:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    1370:	88 23       	and	r24, r24
    1372:	59 f0       	breq	.+22     	; 0x138a <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1374:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
    1378:	08 c0       	rjmp	.+16     	; 0x138a <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    137a:	ce 01       	movw	r24, r28
    137c:	08 96       	adiw	r24, 0x08	; 8
    137e:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1382:	ce 01       	movw	r24, r28
    1384:	41 96       	adiw	r24, 0x11	; 17
    1386:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    138a:	0f 90       	pop	r0
    138c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	08 95       	ret

00001396 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	08 2f       	mov	r16, r24
    13a0:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    13a2:	66 23       	and	r22, r22
    13a4:	21 f0       	breq	.+8      	; 0x13ae <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13a6:	86 9f       	mul	r24, r22
    13a8:	c0 01       	movw	r24, r0
    13aa:	11 24       	eor	r1, r1
    13ac:	02 c0       	rjmp	.+4      	; 0x13b2 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    13b2:	4f 96       	adiw	r24, 0x1f	; 31
    13b4:	0e 94 22 10 	call	0x2044	; 0x2044 <pvPortMalloc>
    13b8:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    13ba:	00 97       	sbiw	r24, 0x00	; 0
    13bc:	71 f0       	breq	.+28     	; 0x13da <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    13be:	11 11       	cpse	r17, r1
    13c0:	03 c0       	rjmp	.+6      	; 0x13c8 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    13c2:	99 83       	std	Y+1, r25	; 0x01
    13c4:	88 83       	st	Y, r24
    13c6:	03 c0       	rjmp	.+6      	; 0x13ce <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    13c8:	4f 96       	adiw	r24, 0x1f	; 31
    13ca:	99 83       	std	Y+1, r25	; 0x01
    13cc:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    13ce:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    13d0:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    13d2:	61 e0       	ldi	r22, 0x01	; 1
    13d4:	ce 01       	movw	r24, r28
    13d6:	0e 94 8c 09 	call	0x1318	; 0x1318 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    13da:	ce 01       	movw	r24, r28
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	1f 91       	pop	r17
    13e2:	0f 91       	pop	r16
    13e4:	08 95       	ret

000013e6 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    13e6:	af 92       	push	r10
    13e8:	bf 92       	push	r11
    13ea:	cf 92       	push	r12
    13ec:	df 92       	push	r13
    13ee:	ff 92       	push	r15
    13f0:	0f 93       	push	r16
    13f2:	1f 93       	push	r17
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
    13f8:	00 d0       	rcall	.+0      	; 0x13fa <xQueueGenericSend+0x14>
    13fa:	00 d0       	rcall	.+0      	; 0x13fc <xQueueGenericSend+0x16>
    13fc:	1f 92       	push	r1
    13fe:	cd b7       	in	r28, 0x3d	; 61
    1400:	de b7       	in	r29, 0x3e	; 62
    1402:	8c 01       	movw	r16, r24
    1404:	6b 01       	movw	r12, r22
    1406:	5d 83       	std	Y+5, r21	; 0x05
    1408:	4c 83       	std	Y+4, r20	; 0x04
    140a:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    140c:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    140e:	58 01       	movw	r10, r16
    1410:	98 e0       	ldi	r25, 0x08	; 8
    1412:	a9 0e       	add	r10, r25
    1414:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1416:	0f b6       	in	r0, 0x3f	; 63
    1418:	f8 94       	cli
    141a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    141c:	f8 01       	movw	r30, r16
    141e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1420:	93 8d       	ldd	r25, Z+27	; 0x1b
    1422:	29 17       	cp	r18, r25
    1424:	18 f0       	brcs	.+6      	; 0x142c <xQueueGenericSend+0x46>
    1426:	f2 e0       	ldi	r31, 0x02	; 2
    1428:	ff 12       	cpse	r15, r31
    142a:	14 c0       	rjmp	.+40     	; 0x1454 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    142c:	4f 2d       	mov	r20, r15
    142e:	b6 01       	movw	r22, r12
    1430:	c8 01       	movw	r24, r16
    1432:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1436:	f8 01       	movw	r30, r16
    1438:	91 89       	ldd	r25, Z+17	; 0x11
    143a:	99 23       	and	r25, r25
    143c:	21 f0       	breq	.+8      	; 0x1446 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    143e:	c8 01       	movw	r24, r16
    1440:	41 96       	adiw	r24, 0x11	; 17
    1442:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    1446:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1448:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    144c:	0f 90       	pop	r0
    144e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	50 c0       	rjmp	.+160    	; 0x14f4 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1454:	2c 81       	ldd	r18, Y+4	; 0x04
    1456:	3d 81       	ldd	r19, Y+5	; 0x05
    1458:	23 2b       	or	r18, r19
    145a:	19 f4       	brne	.+6      	; 0x1462 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    145c:	0f 90       	pop	r0
    145e:	0f be       	out	0x3f, r0	; 63
    1460:	48 c0       	rjmp	.+144    	; 0x14f2 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1462:	81 11       	cpse	r24, r1
    1464:	04 c0       	rjmp	.+8      	; 0x146e <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1466:	ce 01       	movw	r24, r28
    1468:	01 96       	adiw	r24, 0x01	; 1
    146a:	0e 94 66 06 	call	0xccc	; 0xccc <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    146e:	0f 90       	pop	r0
    1470:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1472:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	0f 92       	push	r0
    147c:	f8 01       	movw	r30, r16
    147e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1480:	8f 3f       	cpi	r24, 0xFF	; 255
    1482:	09 f4       	brne	.+2      	; 0x1486 <xQueueGenericSend+0xa0>
    1484:	15 8e       	std	Z+29, r1	; 0x1d
    1486:	f8 01       	movw	r30, r16
    1488:	86 8d       	ldd	r24, Z+30	; 0x1e
    148a:	8f 3f       	cpi	r24, 0xFF	; 255
    148c:	09 f4       	brne	.+2      	; 0x1490 <xQueueGenericSend+0xaa>
    148e:	16 8e       	std	Z+30, r1	; 0x1e
    1490:	0f 90       	pop	r0
    1492:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1494:	be 01       	movw	r22, r28
    1496:	6c 5f       	subi	r22, 0xFC	; 252
    1498:	7f 4f       	sbci	r23, 0xFF	; 255
    149a:	ce 01       	movw	r24, r28
    149c:	01 96       	adiw	r24, 0x01	; 1
    149e:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskCheckForTimeOut>
    14a2:	81 11       	cpse	r24, r1
    14a4:	21 c0       	rjmp	.+66     	; 0x14e8 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14a6:	0f b6       	in	r0, 0x3f	; 63
    14a8:	f8 94       	cli
    14aa:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    14ac:	f8 01       	movw	r30, r16
    14ae:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    14b6:	98 13       	cpse	r25, r24
    14b8:	11 c0       	rjmp	.+34     	; 0x14dc <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14ba:	6c 81       	ldd	r22, Y+4	; 0x04
    14bc:	7d 81       	ldd	r23, Y+5	; 0x05
    14be:	c5 01       	movw	r24, r10
    14c0:	0e 94 bb 05 	call	0xb76	; 0xb76 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14c4:	c8 01       	movw	r24, r16
    14c6:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14ca:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    14ce:	88 23       	and	r24, r24
    14d0:	11 f0       	breq	.+4      	; 0x14d6 <xQueueGenericSend+0xf0>
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	a0 cf       	rjmp	.-192    	; 0x1416 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    14d6:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
    14da:	fb cf       	rjmp	.-10     	; 0x14d2 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14dc:	c8 01       	movw	r24, r16
    14de:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14e2:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    14e6:	f5 cf       	rjmp	.-22     	; 0x14d2 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    14e8:	c8 01       	movw	r24, r16
    14ea:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14ee:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    14f2:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    14f4:	0f 90       	pop	r0
    14f6:	0f 90       	pop	r0
    14f8:	0f 90       	pop	r0
    14fa:	0f 90       	pop	r0
    14fc:	0f 90       	pop	r0
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	ff 90       	pop	r15
    1508:	df 90       	pop	r13
    150a:	cf 90       	pop	r12
    150c:	bf 90       	pop	r11
    150e:	af 90       	pop	r10
    1510:	08 95       	ret

00001512 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1512:	ef 92       	push	r14
    1514:	ff 92       	push	r15
    1516:	1f 93       	push	r17
    1518:	cf 93       	push	r28
    151a:	df 93       	push	r29
    151c:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    151e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1520:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1522:	98 17       	cp	r25, r24
    1524:	10 f0       	brcs	.+4      	; 0x152a <xQueueGenericSendFromISR+0x18>
    1526:	22 30       	cpi	r18, 0x02	; 2
    1528:	e1 f4       	brne	.+56     	; 0x1562 <xQueueGenericSendFromISR+0x50>
    152a:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    152c:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    152e:	42 2f       	mov	r20, r18
    1530:	ce 01       	movw	r24, r28
    1532:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1536:	1f 3f       	cpi	r17, 0xFF	; 255
    1538:	81 f4       	brne	.+32     	; 0x155a <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    153a:	89 89       	ldd	r24, Y+17	; 0x11
    153c:	88 23       	and	r24, r24
    153e:	79 f0       	breq	.+30     	; 0x155e <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1540:	ce 01       	movw	r24, r28
    1542:	41 96       	adiw	r24, 0x11	; 17
    1544:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    1548:	88 23       	and	r24, r24
    154a:	49 f0       	breq	.+18     	; 0x155e <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    154c:	e1 14       	cp	r14, r1
    154e:	f1 04       	cpc	r15, r1
    1550:	31 f0       	breq	.+12     	; 0x155e <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1552:	81 e0       	ldi	r24, 0x01	; 1
    1554:	f7 01       	movw	r30, r14
    1556:	80 83       	st	Z, r24
    1558:	05 c0       	rjmp	.+10     	; 0x1564 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    155a:	1f 5f       	subi	r17, 0xFF	; 255
    155c:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	01 c0       	rjmp	.+2      	; 0x1564 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1562:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	1f 91       	pop	r17
    156a:	ff 90       	pop	r15
    156c:	ef 90       	pop	r14
    156e:	08 95       	ret

00001570 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1570:	cf 93       	push	r28
    1572:	df 93       	push	r29
    1574:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1576:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1578:	83 8d       	ldd	r24, Z+27	; 0x1b
    157a:	98 17       	cp	r25, r24
    157c:	c0 f4       	brcc	.+48     	; 0x15ae <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    157e:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1580:	9f 5f       	subi	r25, 0xFF	; 255
    1582:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1584:	8f 3f       	cpi	r24, 0xFF	; 255
    1586:	79 f4       	brne	.+30     	; 0x15a6 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1588:	81 89       	ldd	r24, Z+17	; 0x11
    158a:	88 23       	and	r24, r24
    158c:	71 f0       	breq	.+28     	; 0x15aa <xQueueGiveFromISR+0x3a>
    158e:	eb 01       	movw	r28, r22
    1590:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1592:	41 96       	adiw	r24, 0x11	; 17
    1594:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    1598:	88 23       	and	r24, r24
    159a:	39 f0       	breq	.+14     	; 0x15aa <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    159c:	20 97       	sbiw	r28, 0x00	; 0
    159e:	29 f0       	breq	.+10     	; 0x15aa <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	88 83       	st	Y, r24
    15a4:	05 c0       	rjmp	.+10     	; 0x15b0 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15a6:	8f 5f       	subi	r24, 0xFF	; 255
    15a8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	01 c0       	rjmp	.+2      	; 0x15b0 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15ae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15b0:	df 91       	pop	r29
    15b2:	cf 91       	pop	r28
    15b4:	08 95       	ret

000015b6 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    15b6:	af 92       	push	r10
    15b8:	bf 92       	push	r11
    15ba:	cf 92       	push	r12
    15bc:	df 92       	push	r13
    15be:	ff 92       	push	r15
    15c0:	0f 93       	push	r16
    15c2:	1f 93       	push	r17
    15c4:	cf 93       	push	r28
    15c6:	df 93       	push	r29
    15c8:	00 d0       	rcall	.+0      	; 0x15ca <xQueueReceive+0x14>
    15ca:	00 d0       	rcall	.+0      	; 0x15cc <xQueueReceive+0x16>
    15cc:	1f 92       	push	r1
    15ce:	cd b7       	in	r28, 0x3d	; 61
    15d0:	de b7       	in	r29, 0x3e	; 62
    15d2:	8c 01       	movw	r16, r24
    15d4:	6b 01       	movw	r12, r22
    15d6:	5d 83       	std	Y+5, r21	; 0x05
    15d8:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    15da:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15dc:	58 01       	movw	r10, r16
    15de:	91 e1       	ldi	r25, 0x11	; 17
    15e0:	a9 0e       	add	r10, r25
    15e2:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15e4:	0f b6       	in	r0, 0x3f	; 63
    15e6:	f8 94       	cli
    15e8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15ea:	f8 01       	movw	r30, r16
    15ec:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15ee:	ff 20       	and	r15, r15
    15f0:	a9 f0       	breq	.+42     	; 0x161c <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15f2:	b6 01       	movw	r22, r12
    15f4:	c8 01       	movw	r24, r16
    15f6:	0e 94 34 09 	call	0x1268	; 0x1268 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15fa:	fa 94       	dec	r15
    15fc:	f8 01       	movw	r30, r16
    15fe:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1600:	80 85       	ldd	r24, Z+8	; 0x08
    1602:	88 23       	and	r24, r24
    1604:	39 f0       	breq	.+14     	; 0x1614 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1606:	c8 01       	movw	r24, r16
    1608:	08 96       	adiw	r24, 0x08	; 8
    160a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    160e:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1610:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1614:	0f 90       	pop	r0
    1616:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	50 c0       	rjmp	.+160    	; 0x16bc <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    161c:	2c 81       	ldd	r18, Y+4	; 0x04
    161e:	3d 81       	ldd	r19, Y+5	; 0x05
    1620:	23 2b       	or	r18, r19
    1622:	19 f4       	brne	.+6      	; 0x162a <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1624:	0f 90       	pop	r0
    1626:	0f be       	out	0x3f, r0	; 63
    1628:	48 c0       	rjmp	.+144    	; 0x16ba <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    162a:	81 11       	cpse	r24, r1
    162c:	04 c0       	rjmp	.+8      	; 0x1636 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    162e:	ce 01       	movw	r24, r28
    1630:	01 96       	adiw	r24, 0x01	; 1
    1632:	0e 94 66 06 	call	0xccc	; 0xccc <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1636:	0f 90       	pop	r0
    1638:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    163a:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    163e:	0f b6       	in	r0, 0x3f	; 63
    1640:	f8 94       	cli
    1642:	0f 92       	push	r0
    1644:	f8 01       	movw	r30, r16
    1646:	85 8d       	ldd	r24, Z+29	; 0x1d
    1648:	8f 3f       	cpi	r24, 0xFF	; 255
    164a:	09 f4       	brne	.+2      	; 0x164e <xQueueReceive+0x98>
    164c:	15 8e       	std	Z+29, r1	; 0x1d
    164e:	f8 01       	movw	r30, r16
    1650:	86 8d       	ldd	r24, Z+30	; 0x1e
    1652:	8f 3f       	cpi	r24, 0xFF	; 255
    1654:	09 f4       	brne	.+2      	; 0x1658 <xQueueReceive+0xa2>
    1656:	16 8e       	std	Z+30, r1	; 0x1e
    1658:	0f 90       	pop	r0
    165a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    165c:	be 01       	movw	r22, r28
    165e:	6c 5f       	subi	r22, 0xFC	; 252
    1660:	7f 4f       	sbci	r23, 0xFF	; 255
    1662:	ce 01       	movw	r24, r28
    1664:	01 96       	adiw	r24, 0x01	; 1
    1666:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskCheckForTimeOut>
    166a:	81 11       	cpse	r24, r1
    166c:	1c c0       	rjmp	.+56     	; 0x16a6 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    166e:	c8 01       	movw	r24, r16
    1670:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvIsQueueEmpty>
    1674:	88 23       	and	r24, r24
    1676:	89 f0       	breq	.+34     	; 0x169a <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1678:	6c 81       	ldd	r22, Y+4	; 0x04
    167a:	7d 81       	ldd	r23, Y+5	; 0x05
    167c:	c5 01       	movw	r24, r10
    167e:	0e 94 bb 05 	call	0xb76	; 0xb76 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1682:	c8 01       	movw	r24, r16
    1684:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1688:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    168c:	88 23       	and	r24, r24
    168e:	11 f0       	breq	.+4      	; 0x1694 <xQueueReceive+0xde>
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	a8 cf       	rjmp	.-176    	; 0x15e4 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1694:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
    1698:	fb cf       	rjmp	.-10     	; 0x1690 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    169a:	c8 01       	movw	r24, r16
    169c:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16a0:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    16a4:	f5 cf       	rjmp	.-22     	; 0x1690 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    16a6:	c8 01       	movw	r24, r16
    16a8:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16ac:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16b0:	c8 01       	movw	r24, r16
    16b2:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvIsQueueEmpty>
    16b6:	88 23       	and	r24, r24
    16b8:	59 f3       	breq	.-42     	; 0x1690 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    16ba:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    16bc:	0f 90       	pop	r0
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	df 91       	pop	r29
    16c8:	cf 91       	pop	r28
    16ca:	1f 91       	pop	r17
    16cc:	0f 91       	pop	r16
    16ce:	ff 90       	pop	r15
    16d0:	df 90       	pop	r13
    16d2:	cf 90       	pop	r12
    16d4:	bf 90       	pop	r11
    16d6:	af 90       	pop	r10
    16d8:	08 95       	ret

000016da <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	00 d0       	rcall	.+0      	; 0x16e8 <xQueueSemaphoreTake+0xe>
    16e8:	00 d0       	rcall	.+0      	; 0x16ea <xQueueSemaphoreTake+0x10>
    16ea:	1f 92       	push	r1
    16ec:	cd b7       	in	r28, 0x3d	; 61
    16ee:	de b7       	in	r29, 0x3e	; 62
    16f0:	8c 01       	movw	r16, r24
    16f2:	7d 83       	std	Y+5, r23	; 0x05
    16f4:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    16f6:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16f8:	78 01       	movw	r14, r16
    16fa:	81 e1       	ldi	r24, 0x11	; 17
    16fc:	e8 0e       	add	r14, r24
    16fe:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1700:	0f b6       	in	r0, 0x3f	; 63
    1702:	f8 94       	cli
    1704:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1706:	f8 01       	movw	r30, r16
    1708:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    170a:	88 23       	and	r24, r24
    170c:	81 f0       	breq	.+32     	; 0x172e <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    170e:	81 50       	subi	r24, 0x01	; 1
    1710:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1712:	80 85       	ldd	r24, Z+8	; 0x08
    1714:	88 23       	and	r24, r24
    1716:	39 f0       	breq	.+14     	; 0x1726 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1718:	c8 01       	movw	r24, r16
    171a:	08 96       	adiw	r24, 0x08	; 8
    171c:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    1720:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1722:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1726:	0f 90       	pop	r0
    1728:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    172a:	81 e0       	ldi	r24, 0x01	; 1
    172c:	50 c0       	rjmp	.+160    	; 0x17ce <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    172e:	2c 81       	ldd	r18, Y+4	; 0x04
    1730:	3d 81       	ldd	r19, Y+5	; 0x05
    1732:	23 2b       	or	r18, r19
    1734:	19 f4       	brne	.+6      	; 0x173c <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1736:	0f 90       	pop	r0
    1738:	0f be       	out	0x3f, r0	; 63
    173a:	48 c0       	rjmp	.+144    	; 0x17cc <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    173c:	91 11       	cpse	r25, r1
    173e:	04 c0       	rjmp	.+8      	; 0x1748 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1740:	ce 01       	movw	r24, r28
    1742:	01 96       	adiw	r24, 0x01	; 1
    1744:	0e 94 66 06 	call	0xccc	; 0xccc <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1748:	0f 90       	pop	r0
    174a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    174c:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1750:	0f b6       	in	r0, 0x3f	; 63
    1752:	f8 94       	cli
    1754:	0f 92       	push	r0
    1756:	f8 01       	movw	r30, r16
    1758:	85 8d       	ldd	r24, Z+29	; 0x1d
    175a:	8f 3f       	cpi	r24, 0xFF	; 255
    175c:	09 f4       	brne	.+2      	; 0x1760 <xQueueSemaphoreTake+0x86>
    175e:	15 8e       	std	Z+29, r1	; 0x1d
    1760:	f8 01       	movw	r30, r16
    1762:	86 8d       	ldd	r24, Z+30	; 0x1e
    1764:	8f 3f       	cpi	r24, 0xFF	; 255
    1766:	09 f4       	brne	.+2      	; 0x176a <xQueueSemaphoreTake+0x90>
    1768:	16 8e       	std	Z+30, r1	; 0x1e
    176a:	0f 90       	pop	r0
    176c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    176e:	be 01       	movw	r22, r28
    1770:	6c 5f       	subi	r22, 0xFC	; 252
    1772:	7f 4f       	sbci	r23, 0xFF	; 255
    1774:	ce 01       	movw	r24, r28
    1776:	01 96       	adiw	r24, 0x01	; 1
    1778:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskCheckForTimeOut>
    177c:	81 11       	cpse	r24, r1
    177e:	1c c0       	rjmp	.+56     	; 0x17b8 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1780:	c8 01       	movw	r24, r16
    1782:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvIsQueueEmpty>
    1786:	88 23       	and	r24, r24
    1788:	89 f0       	breq	.+34     	; 0x17ac <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    178a:	6c 81       	ldd	r22, Y+4	; 0x04
    178c:	7d 81       	ldd	r23, Y+5	; 0x05
    178e:	c7 01       	movw	r24, r14
    1790:	0e 94 bb 05 	call	0xb76	; 0xb76 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1794:	c8 01       	movw	r24, r16
    1796:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    179a:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    179e:	88 23       	and	r24, r24
    17a0:	11 f0       	breq	.+4      	; 0x17a6 <xQueueSemaphoreTake+0xcc>
    17a2:	91 e0       	ldi	r25, 0x01	; 1
    17a4:	ad cf       	rjmp	.-166    	; 0x1700 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    17a6:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
    17aa:	fb cf       	rjmp	.-10     	; 0x17a2 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    17ac:	c8 01       	movw	r24, r16
    17ae:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17b2:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    17b6:	f5 cf       	rjmp	.-22     	; 0x17a2 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    17b8:	c8 01       	movw	r24, r16
    17ba:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17be:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17c2:	c8 01       	movw	r24, r16
    17c4:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvIsQueueEmpty>
    17c8:	88 23       	and	r24, r24
    17ca:	59 f3       	breq	.-42     	; 0x17a2 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17cc:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17ce:	0f 90       	pop	r0
    17d0:	0f 90       	pop	r0
    17d2:	0f 90       	pop	r0
    17d4:	0f 90       	pop	r0
    17d6:	0f 90       	pop	r0
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	ff 90       	pop	r15
    17e2:	ef 90       	pop	r14
    17e4:	08 95       	ret

000017e6 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    17e6:	cf 92       	push	r12
    17e8:	df 92       	push	r13
    17ea:	ef 92       	push	r14
    17ec:	ff 92       	push	r15
    17ee:	0f 93       	push	r16
    17f0:	1f 93       	push	r17
    17f2:	cf 93       	push	r28
    17f4:	df 93       	push	r29
    17f6:	00 d0       	rcall	.+0      	; 0x17f8 <xQueuePeek+0x12>
    17f8:	00 d0       	rcall	.+0      	; 0x17fa <xQueuePeek+0x14>
    17fa:	1f 92       	push	r1
    17fc:	cd b7       	in	r28, 0x3d	; 61
    17fe:	de b7       	in	r29, 0x3e	; 62
    1800:	8c 01       	movw	r16, r24
    1802:	7b 01       	movw	r14, r22
    1804:	5d 83       	std	Y+5, r21	; 0x05
    1806:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1808:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    180a:	68 01       	movw	r12, r16
    180c:	91 e1       	ldi	r25, 0x11	; 17
    180e:	c9 0e       	add	r12, r25
    1810:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1812:	0f b6       	in	r0, 0x3f	; 63
    1814:	f8 94       	cli
    1816:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1818:	f8 01       	movw	r30, r16
    181a:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    181c:	99 23       	and	r25, r25
    181e:	b9 f0       	breq	.+46     	; 0x184e <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1820:	c6 80       	ldd	r12, Z+6	; 0x06
    1822:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1824:	b7 01       	movw	r22, r14
    1826:	c8 01       	movw	r24, r16
    1828:	0e 94 34 09 	call	0x1268	; 0x1268 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    182c:	f8 01       	movw	r30, r16
    182e:	d7 82       	std	Z+7, r13	; 0x07
    1830:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1832:	81 89       	ldd	r24, Z+17	; 0x11
    1834:	88 23       	and	r24, r24
    1836:	39 f0       	breq	.+14     	; 0x1846 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1838:	c8 01       	movw	r24, r16
    183a:	41 96       	adiw	r24, 0x11	; 17
    183c:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    1840:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1842:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    184a:	81 e0       	ldi	r24, 0x01	; 1
    184c:	50 c0       	rjmp	.+160    	; 0x18ee <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    184e:	2c 81       	ldd	r18, Y+4	; 0x04
    1850:	3d 81       	ldd	r19, Y+5	; 0x05
    1852:	23 2b       	or	r18, r19
    1854:	19 f4       	brne	.+6      	; 0x185c <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63
    185a:	48 c0       	rjmp	.+144    	; 0x18ec <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    185c:	81 11       	cpse	r24, r1
    185e:	04 c0       	rjmp	.+8      	; 0x1868 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1860:	ce 01       	movw	r24, r28
    1862:	01 96       	adiw	r24, 0x01	; 1
    1864:	0e 94 66 06 	call	0xccc	; 0xccc <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1868:	0f 90       	pop	r0
    186a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    186c:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1870:	0f b6       	in	r0, 0x3f	; 63
    1872:	f8 94       	cli
    1874:	0f 92       	push	r0
    1876:	f8 01       	movw	r30, r16
    1878:	85 8d       	ldd	r24, Z+29	; 0x1d
    187a:	8f 3f       	cpi	r24, 0xFF	; 255
    187c:	09 f4       	brne	.+2      	; 0x1880 <xQueuePeek+0x9a>
    187e:	15 8e       	std	Z+29, r1	; 0x1d
    1880:	f8 01       	movw	r30, r16
    1882:	86 8d       	ldd	r24, Z+30	; 0x1e
    1884:	8f 3f       	cpi	r24, 0xFF	; 255
    1886:	09 f4       	brne	.+2      	; 0x188a <xQueuePeek+0xa4>
    1888:	16 8e       	std	Z+30, r1	; 0x1e
    188a:	0f 90       	pop	r0
    188c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    188e:	be 01       	movw	r22, r28
    1890:	6c 5f       	subi	r22, 0xFC	; 252
    1892:	7f 4f       	sbci	r23, 0xFF	; 255
    1894:	ce 01       	movw	r24, r28
    1896:	01 96       	adiw	r24, 0x01	; 1
    1898:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskCheckForTimeOut>
    189c:	81 11       	cpse	r24, r1
    189e:	1c c0       	rjmp	.+56     	; 0x18d8 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18a0:	c8 01       	movw	r24, r16
    18a2:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvIsQueueEmpty>
    18a6:	88 23       	and	r24, r24
    18a8:	89 f0       	breq	.+34     	; 0x18cc <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18aa:	6c 81       	ldd	r22, Y+4	; 0x04
    18ac:	7d 81       	ldd	r23, Y+5	; 0x05
    18ae:	c6 01       	movw	r24, r12
    18b0:	0e 94 bb 05 	call	0xb76	; 0xb76 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18b4:	c8 01       	movw	r24, r16
    18b6:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18ba:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    18be:	88 23       	and	r24, r24
    18c0:	11 f0       	breq	.+4      	; 0x18c6 <xQueuePeek+0xe0>
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	a6 cf       	rjmp	.-180    	; 0x1812 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    18c6:	0e 94 10 11 	call	0x2220	; 0x2220 <vPortYield>
    18ca:	fb cf       	rjmp	.-10     	; 0x18c2 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18cc:	c8 01       	movw	r24, r16
    18ce:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18d2:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
    18d6:	f5 cf       	rjmp	.-22     	; 0x18c2 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18d8:	c8 01       	movw	r24, r16
    18da:	0e 94 4e 09 	call	0x129c	; 0x129c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18de:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18e2:	c8 01       	movw	r24, r16
    18e4:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvIsQueueEmpty>
    18e8:	88 23       	and	r24, r24
    18ea:	59 f3       	breq	.-42     	; 0x18c2 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18ec:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18ee:	0f 90       	pop	r0
    18f0:	0f 90       	pop	r0
    18f2:	0f 90       	pop	r0
    18f4:	0f 90       	pop	r0
    18f6:	0f 90       	pop	r0
    18f8:	df 91       	pop	r29
    18fa:	cf 91       	pop	r28
    18fc:	1f 91       	pop	r17
    18fe:	0f 91       	pop	r16
    1900:	ff 90       	pop	r15
    1902:	ef 90       	pop	r14
    1904:	df 90       	pop	r13
    1906:	cf 90       	pop	r12
    1908:	08 95       	ret

0000190a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    190a:	ef 92       	push	r14
    190c:	ff 92       	push	r15
    190e:	0f 93       	push	r16
    1910:	1f 93       	push	r17
    1912:	cf 93       	push	r28
    1914:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1916:	fc 01       	movw	r30, r24
    1918:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    191a:	00 23       	and	r16, r16
    191c:	e9 f0       	breq	.+58     	; 0x1958 <xQueueReceiveFromISR+0x4e>
    191e:	7a 01       	movw	r14, r20
    1920:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1922:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1924:	0e 94 34 09 	call	0x1268	; 0x1268 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1928:	01 50       	subi	r16, 0x01	; 1
    192a:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    192c:	1f 3f       	cpi	r17, 0xFF	; 255
    192e:	81 f4       	brne	.+32     	; 0x1950 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1930:	88 85       	ldd	r24, Y+8	; 0x08
    1932:	88 23       	and	r24, r24
    1934:	79 f0       	breq	.+30     	; 0x1954 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1936:	ce 01       	movw	r24, r28
    1938:	08 96       	adiw	r24, 0x08	; 8
    193a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <xTaskRemoveFromEventList>
    193e:	88 23       	and	r24, r24
    1940:	49 f0       	breq	.+18     	; 0x1954 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1942:	e1 14       	cp	r14, r1
    1944:	f1 04       	cpc	r15, r1
    1946:	31 f0       	breq	.+12     	; 0x1954 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1948:	81 e0       	ldi	r24, 0x01	; 1
    194a:	f7 01       	movw	r30, r14
    194c:	80 83       	st	Z, r24
    194e:	05 c0       	rjmp	.+10     	; 0x195a <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1950:	1f 5f       	subi	r17, 0xFF	; 255
    1952:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	01 c0       	rjmp	.+2      	; 0x195a <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1958:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	1f 91       	pop	r17
    1960:	0f 91       	pop	r16
    1962:	ff 90       	pop	r15
    1964:	ef 90       	pop	r14
    1966:	08 95       	ret

00001968 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1970:	fc 01       	movw	r30, r24
    1972:	22 8d       	ldd	r18, Z+26	; 0x1a
    1974:	22 23       	and	r18, r18
    1976:	49 f0       	breq	.+18     	; 0x198a <xQueuePeekFromISR+0x22>
    1978:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    197a:	06 81       	ldd	r16, Z+6	; 0x06
    197c:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    197e:	0e 94 34 09 	call	0x1268	; 0x1268 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1982:	1f 83       	std	Y+7, r17	; 0x07
    1984:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1986:	81 e0       	ldi	r24, 0x01	; 1
    1988:	01 c0       	rjmp	.+2      	; 0x198c <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    198a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    198c:	df 91       	pop	r29
    198e:	cf 91       	pop	r28
    1990:	1f 91       	pop	r17
    1992:	0f 91       	pop	r16
    1994:	08 95       	ret

00001996 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    199c:	fc 01       	movw	r30, r24
    199e:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19a0:	0f 90       	pop	r0
    19a2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19a4:	08 95       	ret

000019a6 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19a6:	0f b6       	in	r0, 0x3f	; 63
    19a8:	f8 94       	cli
    19aa:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19ac:	fc 01       	movw	r30, r24
    19ae:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19b0:	0f 90       	pop	r0
    19b2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    19b4:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19b6:	82 1b       	sub	r24, r18
    19b8:	08 95       	ret

000019ba <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    19ba:	fc 01       	movw	r30, r24
    19bc:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19be:	08 95       	ret

000019c0 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    19c0:	0c 94 54 10 	jmp	0x20a8	; 0x20a8 <vPortFree>

000019c4 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19c4:	fc 01       	movw	r30, r24
    19c6:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	91 11       	cpse	r25, r1
    19cc:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19ce:	08 95       	ret

000019d0 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    19d0:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19d2:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	23 8d       	ldd	r18, Z+27	; 0x1b
    19d8:	29 13       	cpse	r18, r25
    19da:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19dc:	08 95       	ret

000019de <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    19e4:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19e6:	0f b6       	in	r0, 0x3f	; 63
    19e8:	f8 94       	cli
    19ea:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19ee:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19f4:	89 13       	cpse	r24, r25
    19f6:	0f c0       	rjmp	.+30     	; 0x1a16 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    19f8:	41 15       	cp	r20, r1
    19fa:	51 05       	cpc	r21, r1
    19fc:	49 f0       	breq	.+18     	; 0x1a10 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    19fe:	be 01       	movw	r22, r28
    1a00:	68 5f       	subi	r22, 0xF8	; 248
    1a02:	7f 4f       	sbci	r23, 0xFF	; 255
    1a04:	ca 01       	movw	r24, r20
    1a06:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a0a:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a0c:	8c ef       	ldi	r24, 0xFC	; 252
    1a0e:	1b c0       	rjmp	.+54     	; 0x1a46 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a10:	78 94       	sei
					return errQUEUE_FULL;
    1a12:	80 e0       	ldi	r24, 0x00	; 0
    1a14:	18 c0       	rjmp	.+48     	; 0x1a46 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1a16:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a18:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a1a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a1c:	89 17       	cp	r24, r25
    1a1e:	88 f4       	brcc	.+34     	; 0x1a42 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a20:	40 e0       	ldi	r20, 0x00	; 0
    1a22:	ce 01       	movw	r24, r28
    1a24:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a28:	89 89       	ldd	r24, Y+17	; 0x11
    1a2a:	81 11       	cpse	r24, r1
    1a2c:	02 c0       	rjmp	.+4      	; 0x1a32 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	09 c0       	rjmp	.+18     	; 0x1a44 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a32:	ce 01       	movw	r24, r28
    1a34:	41 96       	adiw	r24, 0x11	; 17
    1a36:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <xCoRoutineRemoveFromEventList>
    1a3a:	88 23       	and	r24, r24
    1a3c:	c1 f3       	breq	.-16     	; 0x1a2e <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1a3e:	8b ef       	ldi	r24, 0xFB	; 251
    1a40:	01 c0       	rjmp	.+2      	; 0x1a44 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1a42:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a44:	78 94       	sei

		return xReturn;
	}
    1a46:	df 91       	pop	r29
    1a48:	cf 91       	pop	r28
    1a4a:	08 95       	ret

00001a4c <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a4c:	cf 93       	push	r28
    1a4e:	df 93       	push	r29
    1a50:	ec 01       	movw	r28, r24
    1a52:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a54:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a56:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a58:	81 11       	cpse	r24, r1
    1a5a:	0f c0       	rjmp	.+30     	; 0x1a7a <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a5c:	41 15       	cp	r20, r1
    1a5e:	51 05       	cpc	r21, r1
    1a60:	49 f0       	breq	.+18     	; 0x1a74 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a62:	be 01       	movw	r22, r28
    1a64:	6f 5e       	subi	r22, 0xEF	; 239
    1a66:	7f 4f       	sbci	r23, 0xFF	; 255
    1a68:	ca 01       	movw	r24, r20
    1a6a:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a6e:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a70:	8c ef       	ldi	r24, 0xFC	; 252
    1a72:	30 c0       	rjmp	.+96     	; 0x1ad4 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a74:	78 94       	sei
					return errQUEUE_FULL;
    1a76:	80 e0       	ldi	r24, 0x00	; 0
    1a78:	2d c0       	rjmp	.+90     	; 0x1ad4 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1a7a:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a7c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a7e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a80:	88 23       	and	r24, r24
    1a82:	31 f1       	breq	.+76     	; 0x1ad0 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1a84:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a86:	50 e0       	ldi	r21, 0x00	; 0
    1a88:	2e 81       	ldd	r18, Y+6	; 0x06
    1a8a:	3f 81       	ldd	r19, Y+7	; 0x07
    1a8c:	24 0f       	add	r18, r20
    1a8e:	35 1f       	adc	r19, r21
    1a90:	3f 83       	std	Y+7, r19	; 0x07
    1a92:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1a94:	8c 81       	ldd	r24, Y+4	; 0x04
    1a96:	9d 81       	ldd	r25, Y+5	; 0x05
    1a98:	28 17       	cp	r18, r24
    1a9a:	39 07       	cpc	r19, r25
    1a9c:	20 f0       	brcs	.+8      	; 0x1aa6 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1a9e:	88 81       	ld	r24, Y
    1aa0:	99 81       	ldd	r25, Y+1	; 0x01
    1aa2:	9f 83       	std	Y+7, r25	; 0x07
    1aa4:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1aa6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1aa8:	91 50       	subi	r25, 0x01	; 1
    1aaa:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1aac:	6e 81       	ldd	r22, Y+6	; 0x06
    1aae:	7f 81       	ldd	r23, Y+7	; 0x07
    1ab0:	cf 01       	movw	r24, r30
    1ab2:	0e 94 4e 12 	call	0x249c	; 0x249c <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ab6:	88 85       	ldd	r24, Y+8	; 0x08
    1ab8:	81 11       	cpse	r24, r1
    1aba:	02 c0       	rjmp	.+4      	; 0x1ac0 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1abc:	81 e0       	ldi	r24, 0x01	; 1
    1abe:	09 c0       	rjmp	.+18     	; 0x1ad2 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ac0:	ce 01       	movw	r24, r28
    1ac2:	08 96       	adiw	r24, 0x08	; 8
    1ac4:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <xCoRoutineRemoveFromEventList>
    1ac8:	88 23       	and	r24, r24
    1aca:	c1 f3       	breq	.-16     	; 0x1abc <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1acc:	8b ef       	ldi	r24, 0xFB	; 251
    1ace:	01 c0       	rjmp	.+2      	; 0x1ad2 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1ad2:	78 94       	sei

		return xReturn;
	}
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	08 95       	ret

00001ada <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1ada:	0f 93       	push	r16
    1adc:	1f 93       	push	r17
    1ade:	cf 93       	push	r28
    1ae0:	8c 01       	movw	r16, r24
    1ae2:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ae4:	fc 01       	movw	r30, r24
    1ae6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ae8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1aea:	98 17       	cp	r25, r24
    1aec:	10 f0       	brcs	.+4      	; 0x1af2 <xQueueCRSendFromISR+0x18>
    1aee:	4c 2f       	mov	r20, r28
    1af0:	12 c0       	rjmp	.+36     	; 0x1b16 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1af2:	40 e0       	ldi	r20, 0x00	; 0
    1af4:	c8 01       	movw	r24, r16
    1af6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1afa:	c1 11       	cpse	r28, r1
    1afc:	f8 cf       	rjmp	.-16     	; 0x1aee <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1afe:	f8 01       	movw	r30, r16
    1b00:	81 89       	ldd	r24, Z+17	; 0x11
    1b02:	88 23       	and	r24, r24
    1b04:	39 f0       	breq	.+14     	; 0x1b14 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b06:	c8 01       	movw	r24, r16
    1b08:	41 96       	adiw	r24, 0x11	; 17
    1b0a:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1b0e:	41 e0       	ldi	r20, 0x01	; 1
    1b10:	81 11       	cpse	r24, r1
    1b12:	01 c0       	rjmp	.+2      	; 0x1b16 <xQueueCRSendFromISR+0x3c>
    1b14:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1b16:	84 2f       	mov	r24, r20
    1b18:	cf 91       	pop	r28
    1b1a:	1f 91       	pop	r17
    1b1c:	0f 91       	pop	r16
    1b1e:	08 95       	ret

00001b20 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1b20:	0f 93       	push	r16
    1b22:	1f 93       	push	r17
    1b24:	cf 93       	push	r28
    1b26:	df 93       	push	r29
    1b28:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b2c:	88 23       	and	r24, r24
    1b2e:	79 f1       	breq	.+94     	; 0x1b8e <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b30:	24 8d       	ldd	r18, Z+28	; 0x1c
    1b32:	30 e0       	ldi	r19, 0x00	; 0
    1b34:	a6 81       	ldd	r26, Z+6	; 0x06
    1b36:	b7 81       	ldd	r27, Z+7	; 0x07
    1b38:	a2 0f       	add	r26, r18
    1b3a:	b3 1f       	adc	r27, r19
    1b3c:	b7 83       	std	Z+7, r27	; 0x07
    1b3e:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b40:	84 81       	ldd	r24, Z+4	; 0x04
    1b42:	95 81       	ldd	r25, Z+5	; 0x05
    1b44:	a8 17       	cp	r26, r24
    1b46:	b9 07       	cpc	r27, r25
    1b48:	20 f0       	brcs	.+8      	; 0x1b52 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b4a:	80 81       	ld	r24, Z
    1b4c:	91 81       	ldd	r25, Z+1	; 0x01
    1b4e:	97 83       	std	Z+7, r25	; 0x07
    1b50:	86 83       	std	Z+6, r24	; 0x06
    1b52:	8a 01       	movw	r16, r20
    1b54:	cb 01       	movw	r24, r22
    1b56:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b58:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b5a:	41 50       	subi	r20, 0x01	; 1
    1b5c:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b5e:	66 81       	ldd	r22, Z+6	; 0x06
    1b60:	77 81       	ldd	r23, Z+7	; 0x07
    1b62:	a9 01       	movw	r20, r18
    1b64:	0e 94 4e 12 	call	0x249c	; 0x249c <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b68:	f8 01       	movw	r30, r16
    1b6a:	80 81       	ld	r24, Z
    1b6c:	88 23       	and	r24, r24
    1b6e:	11 f0       	breq	.+4      	; 0x1b74 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b70:	81 e0       	ldi	r24, 0x01	; 1
    1b72:	0e c0       	rjmp	.+28     	; 0x1b90 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b74:	88 85       	ldd	r24, Y+8	; 0x08
    1b76:	88 23       	and	r24, r24
    1b78:	d9 f3       	breq	.-10     	; 0x1b70 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b7a:	ce 01       	movw	r24, r28
    1b7c:	08 96       	adiw	r24, 0x08	; 8
    1b7e:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <xCoRoutineRemoveFromEventList>
    1b82:	88 23       	and	r24, r24
    1b84:	a9 f3       	breq	.-22     	; 0x1b70 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1b86:	81 e0       	ldi	r24, 0x01	; 1
    1b88:	f8 01       	movw	r30, r16
    1b8a:	80 83       	st	Z, r24
    1b8c:	01 c0       	rjmp	.+2      	; 0x1b90 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b8e:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1b90:	df 91       	pop	r29
    1b92:	cf 91       	pop	r28
    1b94:	1f 91       	pop	r17
    1b96:	0f 91       	pop	r16
    1b98:	08 95       	ret

00001b9a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b9a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b9c:	03 96       	adiw	r24, 0x03	; 3
    1b9e:	92 83       	std	Z+2, r25	; 0x02
    1ba0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1ba2:	2f ef       	ldi	r18, 0xFF	; 255
    1ba4:	3f ef       	ldi	r19, 0xFF	; 255
    1ba6:	34 83       	std	Z+4, r19	; 0x04
    1ba8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1baa:	96 83       	std	Z+6, r25	; 0x06
    1bac:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bae:	90 87       	std	Z+8, r25	; 0x08
    1bb0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bb2:	10 82       	st	Z, r1
    1bb4:	08 95       	ret

00001bb6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	11 86       	std	Z+9, r1	; 0x09
    1bba:	10 86       	std	Z+8, r1	; 0x08
    1bbc:	08 95       	ret

00001bbe <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bbe:	cf 93       	push	r28
    1bc0:	df 93       	push	r29
    1bc2:	9c 01       	movw	r18, r24
    1bc4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1bc6:	dc 01       	movw	r26, r24
    1bc8:	11 96       	adiw	r26, 0x01	; 1
    1bca:	cd 91       	ld	r28, X+
    1bcc:	dc 91       	ld	r29, X
    1bce:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bd0:	d3 83       	std	Z+3, r29	; 0x03
    1bd2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bd8:	95 83       	std	Z+5, r25	; 0x05
    1bda:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1bdc:	8c 81       	ldd	r24, Y+4	; 0x04
    1bde:	9d 81       	ldd	r25, Y+5	; 0x05
    1be0:	dc 01       	movw	r26, r24
    1be2:	13 96       	adiw	r26, 0x03	; 3
    1be4:	7c 93       	st	X, r23
    1be6:	6e 93       	st	-X, r22
    1be8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1bea:	7d 83       	std	Y+5, r23	; 0x05
    1bec:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1bee:	31 87       	std	Z+9, r19	; 0x09
    1bf0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1bf2:	f9 01       	movw	r30, r18
    1bf4:	80 81       	ld	r24, Z
    1bf6:	8f 5f       	subi	r24, 0xFF	; 255
    1bf8:	80 83       	st	Z, r24
}
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	08 95       	ret

00001c00 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c00:	0f 93       	push	r16
    1c02:	1f 93       	push	r17
    1c04:	cf 93       	push	r28
    1c06:	df 93       	push	r29
    1c08:	8c 01       	movw	r16, r24
    1c0a:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c0c:	80 81       	ld	r24, Z
    1c0e:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c10:	8f 3f       	cpi	r24, 0xFF	; 255
    1c12:	2f ef       	ldi	r18, 0xFF	; 255
    1c14:	92 07       	cpc	r25, r18
    1c16:	21 f4       	brne	.+8      	; 0x1c20 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c18:	e8 01       	movw	r28, r16
    1c1a:	af 81       	ldd	r26, Y+7	; 0x07
    1c1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c1e:	0e c0       	rjmp	.+28     	; 0x1c3c <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c20:	d8 01       	movw	r26, r16
    1c22:	13 96       	adiw	r26, 0x03	; 3
    1c24:	12 96       	adiw	r26, 0x02	; 2
    1c26:	2d 91       	ld	r18, X+
    1c28:	3c 91       	ld	r19, X
    1c2a:	13 97       	sbiw	r26, 0x03	; 3
    1c2c:	e9 01       	movw	r28, r18
    1c2e:	48 81       	ld	r20, Y
    1c30:	59 81       	ldd	r21, Y+1	; 0x01
    1c32:	84 17       	cp	r24, r20
    1c34:	95 07       	cpc	r25, r21
    1c36:	10 f0       	brcs	.+4      	; 0x1c3c <vListInsert+0x3c>
    1c38:	d9 01       	movw	r26, r18
    1c3a:	f4 cf       	rjmp	.-24     	; 0x1c24 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c3c:	12 96       	adiw	r26, 0x02	; 2
    1c3e:	8d 91       	ld	r24, X+
    1c40:	9c 91       	ld	r25, X
    1c42:	13 97       	sbiw	r26, 0x03	; 3
    1c44:	93 83       	std	Z+3, r25	; 0x03
    1c46:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c48:	ec 01       	movw	r28, r24
    1c4a:	fd 83       	std	Y+5, r31	; 0x05
    1c4c:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c4e:	b5 83       	std	Z+5, r27	; 0x05
    1c50:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c52:	13 96       	adiw	r26, 0x03	; 3
    1c54:	fc 93       	st	X, r31
    1c56:	ee 93       	st	-X, r30
    1c58:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c5a:	11 87       	std	Z+9, r17	; 0x09
    1c5c:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c5e:	f8 01       	movw	r30, r16
    1c60:	80 81       	ld	r24, Z
    1c62:	8f 5f       	subi	r24, 0xFF	; 255
    1c64:	80 83       	st	Z, r24
}
    1c66:	df 91       	pop	r29
    1c68:	cf 91       	pop	r28
    1c6a:	1f 91       	pop	r17
    1c6c:	0f 91       	pop	r16
    1c6e:	08 95       	ret

00001c70 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c70:	cf 93       	push	r28
    1c72:	df 93       	push	r29
    1c74:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c76:	a0 85       	ldd	r26, Z+8	; 0x08
    1c78:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c7a:	82 81       	ldd	r24, Z+2	; 0x02
    1c7c:	93 81       	ldd	r25, Z+3	; 0x03
    1c7e:	24 81       	ldd	r18, Z+4	; 0x04
    1c80:	35 81       	ldd	r19, Z+5	; 0x05
    1c82:	ec 01       	movw	r28, r24
    1c84:	3d 83       	std	Y+5, r19	; 0x05
    1c86:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c88:	c4 81       	ldd	r28, Z+4	; 0x04
    1c8a:	d5 81       	ldd	r29, Z+5	; 0x05
    1c8c:	9b 83       	std	Y+3, r25	; 0x03
    1c8e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c90:	11 96       	adiw	r26, 0x01	; 1
    1c92:	8d 91       	ld	r24, X+
    1c94:	9c 91       	ld	r25, X
    1c96:	12 97       	sbiw	r26, 0x02	; 2
    1c98:	e8 17       	cp	r30, r24
    1c9a:	f9 07       	cpc	r31, r25
    1c9c:	21 f4       	brne	.+8      	; 0x1ca6 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c9e:	12 96       	adiw	r26, 0x02	; 2
    1ca0:	dc 93       	st	X, r29
    1ca2:	ce 93       	st	-X, r28
    1ca4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1ca6:	11 86       	std	Z+9, r1	; 0x09
    1ca8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1caa:	8c 91       	ld	r24, X
    1cac:	81 50       	subi	r24, 0x01	; 1
    1cae:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1cb0:	8c 91       	ld	r24, X
}
    1cb2:	df 91       	pop	r29
    1cb4:	cf 91       	pop	r28
    1cb6:	08 95       	ret

00001cb8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1cb8:	cf 92       	push	r12
    1cba:	df 92       	push	r13
    1cbc:	ef 92       	push	r14
    1cbe:	ff 92       	push	r15
    1cc0:	1f 93       	push	r17
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	6c 01       	movw	r12, r24
    1cc8:	16 2f       	mov	r17, r22
    1cca:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1ccc:	8a e1       	ldi	r24, 0x1A	; 26
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	0e 94 22 10 	call	0x2044	; 0x2044 <pvPortMalloc>
    1cd4:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1cd6:	89 2b       	or	r24, r25
    1cd8:	09 f4       	brne	.+2      	; 0x1cdc <xCoRoutineCreate+0x24>
    1cda:	57 c0       	rjmp	.+174    	; 0x1d8a <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1cdc:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1ce0:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1ce4:	89 2b       	or	r24, r25
    1ce6:	21 f5       	brne	.+72     	; 0x1d30 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1ce8:	d0 93 87 01 	sts	0x0187, r29	; 0x800187 <pxCurrentCoRoutine+0x1>
    1cec:	c0 93 86 01 	sts	0x0186, r28	; 0x800186 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1cf0:	8e ea       	ldi	r24, 0xAE	; 174
    1cf2:	91 e0       	ldi	r25, 0x01	; 1
    1cf4:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
    1cf8:	87 eb       	ldi	r24, 0xB7	; 183
    1cfa:	91 e0       	ldi	r25, 0x01	; 1
    1cfc:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1d00:	85 ea       	ldi	r24, 0xA5	; 165
    1d02:	91 e0       	ldi	r25, 0x01	; 1
    1d04:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1d08:	8c e9       	ldi	r24, 0x9C	; 156
    1d0a:	91 e0       	ldi	r25, 0x01	; 1
    1d0c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1d10:	8f e8       	ldi	r24, 0x8F	; 143
    1d12:	91 e0       	ldi	r25, 0x01	; 1
    1d14:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1d18:	85 ea       	ldi	r24, 0xA5	; 165
    1d1a:	91 e0       	ldi	r25, 0x01	; 1
    1d1c:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1d20:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1d24:	8c e9       	ldi	r24, 0x9C	; 156
    1d26:	91 e0       	ldi	r25, 0x01	; 1
    1d28:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1d2c:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1d30:	11 11       	cpse	r17, r1
    1d32:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1d34:	19 8e       	std	Y+25, r1	; 0x19
    1d36:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1d38:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1d3a:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1d3c:	fe 01       	movw	r30, r28
    1d3e:	c1 92       	st	Z+, r12
    1d40:	d1 92       	st	Z+, r13
    1d42:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1d44:	cf 01       	movw	r24, r30
    1d46:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d4a:	ce 01       	movw	r24, r28
    1d4c:	0c 96       	adiw	r24, 0x0c	; 12
    1d4e:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d52:	d9 87       	std	Y+9, r29	; 0x09
    1d54:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d56:	db 8b       	std	Y+19, r29	; 0x13
    1d58:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d5a:	82 e0       	ldi	r24, 0x02	; 2
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	81 1b       	sub	r24, r17
    1d60:	91 09       	sbc	r25, r1
    1d62:	9d 87       	std	Y+13, r25	; 0x0d
    1d64:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d66:	8e 89       	ldd	r24, Y+22	; 0x16
    1d68:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1d6c:	98 17       	cp	r25, r24
    1d6e:	10 f4       	brcc	.+4      	; 0x1d74 <xCoRoutineCreate+0xbc>
    1d70:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1d74:	f9 e0       	ldi	r31, 0x09	; 9
    1d76:	8f 9f       	mul	r24, r31
    1d78:	c0 01       	movw	r24, r0
    1d7a:	11 24       	eor	r1, r1
    1d7c:	b7 01       	movw	r22, r14
    1d7e:	82 55       	subi	r24, 0x52	; 82
    1d80:	9e 4f       	sbci	r25, 0xFE	; 254
    1d82:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

		xReturn = pdPASS;
    1d86:	81 e0       	ldi	r24, 0x01	; 1
    1d88:	01 c0       	rjmp	.+2      	; 0x1d8c <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d8a:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1d8c:	df 91       	pop	r29
    1d8e:	cf 91       	pop	r28
    1d90:	1f 91       	pop	r17
    1d92:	ff 90       	pop	r15
    1d94:	ef 90       	pop	r14
    1d96:	df 90       	pop	r13
    1d98:	cf 90       	pop	r12
    1d9a:	08 95       	ret

00001d9c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1d9c:	0f 93       	push	r16
    1d9e:	1f 93       	push	r17
    1da0:	cf 93       	push	r28
    1da2:	df 93       	push	r29
    1da4:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1da6:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1daa:	d0 91 8d 01 	lds	r29, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1dae:	c8 0f       	add	r28, r24
    1db0:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1db2:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1db6:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1dba:	02 96       	adiw	r24, 0x02	; 2
    1dbc:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1dc0:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1dc4:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1dc8:	d3 83       	std	Z+3, r29	; 0x03
    1dca:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1dcc:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1dd0:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1dd4:	bf 01       	movw	r22, r30
    1dd6:	6e 5f       	subi	r22, 0xFE	; 254
    1dd8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dda:	c8 17       	cp	r28, r24
    1ddc:	d9 07       	cpc	r29, r25
    1dde:	28 f4       	brcc	.+10     	; 0x1dea <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1de0:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1de4:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1de8:	04 c0       	rjmp	.+8      	; 0x1df2 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dea:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1dee:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1df2:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vListInsert>
	}

	if( pxEventList )
    1df6:	01 15       	cp	r16, r1
    1df8:	11 05       	cpc	r17, r1
    1dfa:	69 f0       	breq	.+26     	; 0x1e16 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1dfc:	60 91 86 01 	lds	r22, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1e00:	70 91 87 01 	lds	r23, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1e04:	64 5f       	subi	r22, 0xF4	; 244
    1e06:	7f 4f       	sbci	r23, 0xFF	; 255
    1e08:	c8 01       	movw	r24, r16
	}
}
    1e0a:	df 91       	pop	r29
    1e0c:	cf 91       	pop	r28
    1e0e:	1f 91       	pop	r17
    1e10:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e12:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <vListInsert>
	}
}
    1e16:	df 91       	pop	r29
    1e18:	cf 91       	pop	r28
    1e1a:	1f 91       	pop	r17
    1e1c:	0f 91       	pop	r16
    1e1e:	08 95       	ret

00001e20 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e20:	ff 92       	push	r15
    1e22:	0f 93       	push	r16
    1e24:	1f 93       	push	r17
    1e26:	cf 93       	push	r28
    1e28:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e2a:	99 e0       	ldi	r25, 0x09	; 9
    1e2c:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1e2e:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <xPendingReadyCoRoutineList>
    1e32:	88 23       	and	r24, r24
    1e34:	11 f1       	breq	.+68     	; 0x1e7a <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1e36:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1e38:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <xPendingReadyCoRoutineList+0x5>
    1e3c:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <xPendingReadyCoRoutineList+0x6>
    1e40:	c6 81       	ldd	r28, Z+6	; 0x06
    1e42:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e44:	ce 01       	movw	r24, r28
    1e46:	0c 96       	adiw	r24, 0x0c	; 12
    1e48:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e4c:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e4e:	8e 01       	movw	r16, r28
    1e50:	0e 5f       	subi	r16, 0xFE	; 254
    1e52:	1f 4f       	sbci	r17, 0xFF	; 255
    1e54:	c8 01       	movw	r24, r16
    1e56:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e5a:	8e 89       	ldd	r24, Y+22	; 0x16
    1e5c:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1e60:	98 17       	cp	r25, r24
    1e62:	10 f4       	brcc	.+4      	; 0x1e68 <vCoRoutineSchedule+0x48>
    1e64:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1e68:	f8 9e       	mul	r15, r24
    1e6a:	c0 01       	movw	r24, r0
    1e6c:	11 24       	eor	r1, r1
    1e6e:	b8 01       	movw	r22, r16
    1e70:	82 55       	subi	r24, 0x52	; 82
    1e72:	9e 4f       	sbci	r25, 0xFE	; 254
    1e74:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
    1e78:	da cf       	rjmp	.-76     	; 0x1e2e <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e7a:	0e 94 a0 03 	call	0x740	; 0x740 <xTaskGetTickCount>
    1e7e:	20 91 8a 01 	lds	r18, 0x018A	; 0x80018a <xLastTickCount>
    1e82:	30 91 8b 01 	lds	r19, 0x018B	; 0x80018b <xLastTickCount+0x1>
    1e86:	82 1b       	sub	r24, r18
    1e88:	93 0b       	sbc	r25, r19
    1e8a:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <xPassedTicks+0x1>
    1e8e:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1e92:	89 e0       	ldi	r24, 0x09	; 9
    1e94:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e96:	20 91 88 01 	lds	r18, 0x0188	; 0x800188 <xPassedTicks>
    1e9a:	30 91 89 01 	lds	r19, 0x0189	; 0x800189 <xPassedTicks+0x1>
    1e9e:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1ea2:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1ea6:	21 15       	cp	r18, r1
    1ea8:	31 05       	cpc	r19, r1
    1eaa:	09 f4       	brne	.+2      	; 0x1eae <vCoRoutineSchedule+0x8e>
    1eac:	54 c0       	rjmp	.+168    	; 0x1f56 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1eae:	01 96       	adiw	r24, 0x01	; 1
    1eb0:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <xCoRoutineTickCount+0x1>
    1eb4:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <xCoRoutineTickCount>
		xPassedTicks--;
    1eb8:	21 50       	subi	r18, 0x01	; 1
    1eba:	31 09       	sbc	r19, r1
    1ebc:	30 93 89 01 	sts	0x0189, r19	; 0x800189 <xPassedTicks+0x1>
    1ec0:	20 93 88 01 	sts	0x0188, r18	; 0x800188 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1ec4:	89 2b       	or	r24, r25
    1ec6:	09 f0       	breq	.+2      	; 0x1eca <vCoRoutineSchedule+0xaa>
    1ec8:	3e c0       	rjmp	.+124    	; 0x1f46 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1eca:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1ece:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1ed2:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1ed6:	30 91 99 01 	lds	r19, 0x0199	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1eda:	30 93 9b 01 	sts	0x019B, r19	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1ede:	20 93 9a 01 	sts	0x019A, r18	; 0x80019a <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1ee2:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1ee6:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1eea:	2d c0       	rjmp	.+90     	; 0x1f46 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1eec:	05 80       	ldd	r0, Z+5	; 0x05
    1eee:	f6 81       	ldd	r31, Z+6	; 0x06
    1ef0:	e0 2d       	mov	r30, r0
    1ef2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ef4:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1ef6:	2a 81       	ldd	r18, Y+2	; 0x02
    1ef8:	3b 81       	ldd	r19, Y+3	; 0x03
    1efa:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1efe:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1f02:	82 17       	cp	r24, r18
    1f04:	93 07       	cpc	r25, r19
    1f06:	38 f2       	brcs	.-114    	; 0x1e96 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1f08:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1f0a:	8e 01       	movw	r16, r28
    1f0c:	0e 5f       	subi	r16, 0xFE	; 254
    1f0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f10:	c8 01       	movw	r24, r16
    1f12:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1f16:	8c 89       	ldd	r24, Y+20	; 0x14
    1f18:	9d 89       	ldd	r25, Y+21	; 0x15
    1f1a:	89 2b       	or	r24, r25
    1f1c:	21 f0       	breq	.+8      	; 0x1f26 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1f1e:	ce 01       	movw	r24, r28
    1f20:	0c 96       	adiw	r24, 0x0c	; 12
    1f22:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1f26:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f28:	8e 89       	ldd	r24, Y+22	; 0x16
    1f2a:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1f2e:	98 17       	cp	r25, r24
    1f30:	10 f4       	brcc	.+4      	; 0x1f36 <vCoRoutineSchedule+0x116>
    1f32:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1f36:	f8 9e       	mul	r15, r24
    1f38:	c0 01       	movw	r24, r0
    1f3a:	11 24       	eor	r1, r1
    1f3c:	b8 01       	movw	r22, r16
    1f3e:	82 55       	subi	r24, 0x52	; 82
    1f40:	9e 4f       	sbci	r25, 0xFE	; 254
    1f42:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f46:	e0 91 9a 01 	lds	r30, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1f4a:	f0 91 9b 01 	lds	r31, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1f4e:	80 81       	ld	r24, Z
    1f50:	81 11       	cpse	r24, r1
    1f52:	cc cf       	rjmp	.-104    	; 0x1eec <vCoRoutineSchedule+0xcc>
    1f54:	a0 cf       	rjmp	.-192    	; 0x1e96 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f56:	90 93 8b 01 	sts	0x018B, r25	; 0x80018b <xLastTickCount+0x1>
    1f5a:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <xLastTickCount>
    1f5e:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f62:	69 e0       	ldi	r22, 0x09	; 9
    1f64:	48 2f       	mov	r20, r24
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	64 9f       	mul	r22, r20
    1f6a:	90 01       	movw	r18, r0
    1f6c:	65 9f       	mul	r22, r21
    1f6e:	30 0d       	add	r19, r0
    1f70:	11 24       	eor	r1, r1
    1f72:	f9 01       	movw	r30, r18
    1f74:	e2 55       	subi	r30, 0x52	; 82
    1f76:	fe 4f       	sbci	r31, 0xFE	; 254
    1f78:	90 81       	ld	r25, Z
    1f7a:	91 11       	cpse	r25, r1
    1f7c:	0c c0       	rjmp	.+24     	; 0x1f96 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1f7e:	81 11       	cpse	r24, r1
    1f80:	08 c0       	rjmp	.+16     	; 0x1f92 <vCoRoutineSchedule+0x172>
    1f82:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	1f 91       	pop	r17
    1f8c:	0f 91       	pop	r16
    1f8e:	ff 90       	pop	r15
    1f90:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1f92:	81 50       	subi	r24, 0x01	; 1
    1f94:	e7 cf       	rjmp	.-50     	; 0x1f64 <vCoRoutineSchedule+0x144>
    1f96:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f9a:	a1 81       	ldd	r26, Z+1	; 0x01
    1f9c:	b2 81       	ldd	r27, Z+2	; 0x02
    1f9e:	12 96       	adiw	r26, 0x02	; 2
    1fa0:	0d 90       	ld	r0, X+
    1fa2:	bc 91       	ld	r27, X
    1fa4:	a0 2d       	mov	r26, r0
    1fa6:	b2 83       	std	Z+2, r27	; 0x02
    1fa8:	a1 83       	std	Z+1, r26	; 0x01
    1faa:	2f 54       	subi	r18, 0x4F	; 79
    1fac:	3e 4f       	sbci	r19, 0xFE	; 254
    1fae:	a2 17       	cp	r26, r18
    1fb0:	b3 07       	cpc	r27, r19
    1fb2:	31 f4       	brne	.+12     	; 0x1fc0 <vCoRoutineSchedule+0x1a0>
    1fb4:	12 96       	adiw	r26, 0x02	; 2
    1fb6:	8d 91       	ld	r24, X+
    1fb8:	9c 91       	ld	r25, X
    1fba:	13 97       	sbiw	r26, 0x03	; 3
    1fbc:	92 83       	std	Z+2, r25	; 0x02
    1fbe:	81 83       	std	Z+1, r24	; 0x01
    1fc0:	89 e0       	ldi	r24, 0x09	; 9
    1fc2:	84 9f       	mul	r24, r20
    1fc4:	f0 01       	movw	r30, r0
    1fc6:	85 9f       	mul	r24, r21
    1fc8:	f0 0d       	add	r31, r0
    1fca:	11 24       	eor	r1, r1
    1fcc:	e2 55       	subi	r30, 0x52	; 82
    1fce:	fe 4f       	sbci	r31, 0xFE	; 254
    1fd0:	01 80       	ldd	r0, Z+1	; 0x01
    1fd2:	f2 81       	ldd	r31, Z+2	; 0x02
    1fd4:	e0 2d       	mov	r30, r0
    1fd6:	86 81       	ldd	r24, Z+6	; 0x06
    1fd8:	97 81       	ldd	r25, Z+7	; 0x07
    1fda:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <pxCurrentCoRoutine+0x1>
    1fde:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fe2:	dc 01       	movw	r26, r24
    1fe4:	ed 91       	ld	r30, X+
    1fe6:	fc 91       	ld	r31, X
    1fe8:	11 97       	sbiw	r26, 0x01	; 1
    1fea:	57 96       	adiw	r26, 0x17	; 23
    1fec:	6c 91       	ld	r22, X

	return;
}
    1fee:	df 91       	pop	r29
    1ff0:	cf 91       	pop	r28
    1ff2:	1f 91       	pop	r17
    1ff4:	0f 91       	pop	r16
    1ff6:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1ff8:	09 94       	ijmp

00001ffa <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2002:	dc 01       	movw	r26, r24
    2004:	15 96       	adiw	r26, 0x05	; 5
    2006:	ed 91       	ld	r30, X+
    2008:	fc 91       	ld	r31, X
    200a:	16 97       	sbiw	r26, 0x06	; 6
    200c:	c6 81       	ldd	r28, Z+6	; 0x06
    200e:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2010:	8e 01       	movw	r16, r28
    2012:	04 5f       	subi	r16, 0xF4	; 244
    2014:	1f 4f       	sbci	r17, 0xFF	; 255
    2016:	c8 01       	movw	r24, r16
    2018:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    201c:	b8 01       	movw	r22, r16
    201e:	8f e8       	ldi	r24, 0x8F	; 143
    2020:	91 e0       	ldi	r25, 0x01	; 1
    2022:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2026:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    202a:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	2e 89       	ldd	r18, Y+22	; 0x16
    2032:	96 89       	ldd	r25, Z+22	; 0x16
    2034:	29 17       	cp	r18, r25
    2036:	08 f4       	brcc	.+2      	; 0x203a <xCoRoutineRemoveFromEventList+0x40>
    2038:	80 e0       	ldi	r24, 0x00	; 0
}
    203a:	df 91       	pop	r29
    203c:	cf 91       	pop	r28
    203e:	1f 91       	pop	r17
    2040:	0f 91       	pop	r16
    2042:	08 95       	ret

00002044 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    204a:	0e 94 9a 03 	call	0x734	; 0x734 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    204e:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <pucAlignedHeap.2081>
    2052:	90 91 c1 01 	lds	r25, 0x01C1	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    2056:	89 2b       	or	r24, r25
    2058:	31 f4       	brne	.+12     	; 0x2066 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    205a:	85 ec       	ldi	r24, 0xC5	; 197
    205c:	91 e0       	ldi	r25, 0x01	; 1
    205e:	90 93 c1 01 	sts	0x01C1, r25	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    2062:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2066:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <xNextFreeByte>
    206a:	30 91 c3 01 	lds	r19, 0x01C3	; 0x8001c3 <xNextFreeByte+0x1>
    206e:	c9 01       	movw	r24, r18
    2070:	8c 0f       	add	r24, r28
    2072:	9d 1f       	adc	r25, r29
    2074:	8b 3d       	cpi	r24, 0xDB	; 219
    2076:	45 e0       	ldi	r20, 0x05	; 5
    2078:	94 07       	cpc	r25, r20
    207a:	70 f4       	brcc	.+28     	; 0x2098 <pvPortMalloc+0x54>
    207c:	28 17       	cp	r18, r24
    207e:	39 07       	cpc	r19, r25
    2080:	58 f4       	brcc	.+22     	; 0x2098 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2082:	c0 91 c0 01 	lds	r28, 0x01C0	; 0x8001c0 <pucAlignedHeap.2081>
    2086:	d0 91 c1 01 	lds	r29, 0x01C1	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    208a:	c2 0f       	add	r28, r18
    208c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    208e:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <xNextFreeByte+0x1>
    2092:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <xNextFreeByte>
    2096:	02 c0       	rjmp	.+4      	; 0x209c <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2098:	c0 e0       	ldi	r28, 0x00	; 0
    209a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    209c:	0e 94 66 04 	call	0x8cc	; 0x8cc <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    20a0:	ce 01       	movw	r24, r28
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	08 95       	ret

000020a8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    20a8:	08 95       	ret

000020aa <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    20aa:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <xNextFreeByte+0x1>
    20ae:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <xNextFreeByte>
    20b2:	08 95       	ret

000020b4 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    20b4:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <xNextFreeByte>
    20b8:	30 91 c3 01 	lds	r19, 0x01C3	; 0x8001c3 <xNextFreeByte+0x1>
}
    20bc:	8b ed       	ldi	r24, 0xDB	; 219
    20be:	95 e0       	ldi	r25, 0x05	; 5
    20c0:	82 1b       	sub	r24, r18
    20c2:	93 0b       	sbc	r25, r19
    20c4:	08 95       	ret

000020c6 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    20c6:	31 e1       	ldi	r19, 0x11	; 17
    20c8:	fc 01       	movw	r30, r24
    20ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    20cc:	31 97       	sbiw	r30, 0x01	; 1
    20ce:	22 e2       	ldi	r18, 0x22	; 34
    20d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    20d2:	31 97       	sbiw	r30, 0x01	; 1
    20d4:	a3 e3       	ldi	r26, 0x33	; 51
    20d6:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20d8:	31 97       	sbiw	r30, 0x01	; 1
    20da:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20dc:	31 97       	sbiw	r30, 0x01	; 1
    20de:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    20e0:	31 97       	sbiw	r30, 0x01	; 1
    20e2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20e4:	31 97       	sbiw	r30, 0x01	; 1
    20e6:	60 e8       	ldi	r22, 0x80	; 128
    20e8:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    20ea:	31 97       	sbiw	r30, 0x01	; 1
    20ec:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    20ee:	31 97       	sbiw	r30, 0x01	; 1
    20f0:	62 e0       	ldi	r22, 0x02	; 2
    20f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    20f4:	31 97       	sbiw	r30, 0x01	; 1
    20f6:	63 e0       	ldi	r22, 0x03	; 3
    20f8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    20fa:	31 97       	sbiw	r30, 0x01	; 1
    20fc:	64 e0       	ldi	r22, 0x04	; 4
    20fe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2100:	31 97       	sbiw	r30, 0x01	; 1
    2102:	65 e0       	ldi	r22, 0x05	; 5
    2104:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2106:	31 97       	sbiw	r30, 0x01	; 1
    2108:	66 e0       	ldi	r22, 0x06	; 6
    210a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    210c:	31 97       	sbiw	r30, 0x01	; 1
    210e:	67 e0       	ldi	r22, 0x07	; 7
    2110:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2112:	31 97       	sbiw	r30, 0x01	; 1
    2114:	68 e0       	ldi	r22, 0x08	; 8
    2116:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2118:	31 97       	sbiw	r30, 0x01	; 1
    211a:	69 e0       	ldi	r22, 0x09	; 9
    211c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    211e:	31 97       	sbiw	r30, 0x01	; 1
    2120:	60 e1       	ldi	r22, 0x10	; 16
    2122:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2124:	31 97       	sbiw	r30, 0x01	; 1
    2126:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2128:	31 97       	sbiw	r30, 0x01	; 1
    212a:	32 e1       	ldi	r19, 0x12	; 18
    212c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    212e:	31 97       	sbiw	r30, 0x01	; 1
    2130:	33 e1       	ldi	r19, 0x13	; 19
    2132:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2134:	31 97       	sbiw	r30, 0x01	; 1
    2136:	34 e1       	ldi	r19, 0x14	; 20
    2138:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    213a:	31 97       	sbiw	r30, 0x01	; 1
    213c:	35 e1       	ldi	r19, 0x15	; 21
    213e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2140:	31 97       	sbiw	r30, 0x01	; 1
    2142:	36 e1       	ldi	r19, 0x16	; 22
    2144:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2146:	31 97       	sbiw	r30, 0x01	; 1
    2148:	37 e1       	ldi	r19, 0x17	; 23
    214a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    214c:	31 97       	sbiw	r30, 0x01	; 1
    214e:	38 e1       	ldi	r19, 0x18	; 24
    2150:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2152:	31 97       	sbiw	r30, 0x01	; 1
    2154:	39 e1       	ldi	r19, 0x19	; 25
    2156:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2158:	31 97       	sbiw	r30, 0x01	; 1
    215a:	30 e2       	ldi	r19, 0x20	; 32
    215c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    215e:	31 97       	sbiw	r30, 0x01	; 1
    2160:	31 e2       	ldi	r19, 0x21	; 33
    2162:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2164:	31 97       	sbiw	r30, 0x01	; 1
    2166:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2168:	31 97       	sbiw	r30, 0x01	; 1
    216a:	23 e2       	ldi	r18, 0x23	; 35
    216c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    216e:	31 97       	sbiw	r30, 0x01	; 1
    2170:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2172:	31 97       	sbiw	r30, 0x01	; 1
    2174:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2176:	31 97       	sbiw	r30, 0x01	; 1
    2178:	26 e2       	ldi	r18, 0x26	; 38
    217a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    217c:	31 97       	sbiw	r30, 0x01	; 1
    217e:	27 e2       	ldi	r18, 0x27	; 39
    2180:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2182:	31 97       	sbiw	r30, 0x01	; 1
    2184:	28 e2       	ldi	r18, 0x28	; 40
    2186:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2188:	31 97       	sbiw	r30, 0x01	; 1
    218a:	29 e2       	ldi	r18, 0x29	; 41
    218c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    218e:	31 97       	sbiw	r30, 0x01	; 1
    2190:	20 e3       	ldi	r18, 0x30	; 48
    2192:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2194:	31 97       	sbiw	r30, 0x01	; 1
    2196:	21 e3       	ldi	r18, 0x31	; 49
    2198:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    219a:	86 97       	sbiw	r24, 0x26	; 38
    219c:	08 95       	ret

0000219e <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    219e:	89 ef       	ldi	r24, 0xF9	; 249
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    21a6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    21aa:	e0 e8       	ldi	r30, 0x80	; 128
    21ac:	f0 e0       	ldi	r31, 0x00	; 0
    21ae:	80 81       	ld	r24, Z
    21b0:	8c 7f       	andi	r24, 0xFC	; 252
    21b2:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21b4:	8b e0       	ldi	r24, 0x0B	; 11
    21b6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    21ba:	ef e6       	ldi	r30, 0x6F	; 111
    21bc:	f0 e0       	ldi	r31, 0x00	; 0
    21be:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21c0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    21c2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21c4:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    21c8:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    21cc:	cd 91       	ld	r28, X+
    21ce:	cd bf       	out	0x3d, r28	; 61
    21d0:	dd 91       	ld	r29, X+
    21d2:	de bf       	out	0x3e, r29	; 62
    21d4:	ff 91       	pop	r31
    21d6:	ef 91       	pop	r30
    21d8:	df 91       	pop	r29
    21da:	cf 91       	pop	r28
    21dc:	bf 91       	pop	r27
    21de:	af 91       	pop	r26
    21e0:	9f 91       	pop	r25
    21e2:	8f 91       	pop	r24
    21e4:	7f 91       	pop	r23
    21e6:	6f 91       	pop	r22
    21e8:	5f 91       	pop	r21
    21ea:	4f 91       	pop	r20
    21ec:	3f 91       	pop	r19
    21ee:	2f 91       	pop	r18
    21f0:	1f 91       	pop	r17
    21f2:	0f 91       	pop	r16
    21f4:	ff 90       	pop	r15
    21f6:	ef 90       	pop	r14
    21f8:	df 90       	pop	r13
    21fa:	cf 90       	pop	r12
    21fc:	bf 90       	pop	r11
    21fe:	af 90       	pop	r10
    2200:	9f 90       	pop	r9
    2202:	8f 90       	pop	r8
    2204:	7f 90       	pop	r7
    2206:	6f 90       	pop	r6
    2208:	5f 90       	pop	r5
    220a:	4f 90       	pop	r4
    220c:	3f 90       	pop	r3
    220e:	2f 90       	pop	r2
    2210:	1f 90       	pop	r1
    2212:	0f 90       	pop	r0
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2218:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	08 95       	ret

0000221e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    221e:	08 95       	ret

00002220 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2220:	0f 92       	push	r0
    2222:	0f b6       	in	r0, 0x3f	; 63
    2224:	f8 94       	cli
    2226:	0f 92       	push	r0
    2228:	1f 92       	push	r1
    222a:	11 24       	eor	r1, r1
    222c:	2f 92       	push	r2
    222e:	3f 92       	push	r3
    2230:	4f 92       	push	r4
    2232:	5f 92       	push	r5
    2234:	6f 92       	push	r6
    2236:	7f 92       	push	r7
    2238:	8f 92       	push	r8
    223a:	9f 92       	push	r9
    223c:	af 92       	push	r10
    223e:	bf 92       	push	r11
    2240:	cf 92       	push	r12
    2242:	df 92       	push	r13
    2244:	ef 92       	push	r14
    2246:	ff 92       	push	r15
    2248:	0f 93       	push	r16
    224a:	1f 93       	push	r17
    224c:	2f 93       	push	r18
    224e:	3f 93       	push	r19
    2250:	4f 93       	push	r20
    2252:	5f 93       	push	r21
    2254:	6f 93       	push	r22
    2256:	7f 93       	push	r23
    2258:	8f 93       	push	r24
    225a:	9f 93       	push	r25
    225c:	af 93       	push	r26
    225e:	bf 93       	push	r27
    2260:	cf 93       	push	r28
    2262:	df 93       	push	r29
    2264:	ef 93       	push	r30
    2266:	ff 93       	push	r31
    2268:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    226c:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2270:	0d b6       	in	r0, 0x3d	; 61
    2272:	0d 92       	st	X+, r0
    2274:	0e b6       	in	r0, 0x3e	; 62
    2276:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2278:	0e 94 22 05 	call	0xa44	; 0xa44 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    227c:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2280:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2284:	cd 91       	ld	r28, X+
    2286:	cd bf       	out	0x3d, r28	; 61
    2288:	dd 91       	ld	r29, X+
    228a:	de bf       	out	0x3e, r29	; 62
    228c:	ff 91       	pop	r31
    228e:	ef 91       	pop	r30
    2290:	df 91       	pop	r29
    2292:	cf 91       	pop	r28
    2294:	bf 91       	pop	r27
    2296:	af 91       	pop	r26
    2298:	9f 91       	pop	r25
    229a:	8f 91       	pop	r24
    229c:	7f 91       	pop	r23
    229e:	6f 91       	pop	r22
    22a0:	5f 91       	pop	r21
    22a2:	4f 91       	pop	r20
    22a4:	3f 91       	pop	r19
    22a6:	2f 91       	pop	r18
    22a8:	1f 91       	pop	r17
    22aa:	0f 91       	pop	r16
    22ac:	ff 90       	pop	r15
    22ae:	ef 90       	pop	r14
    22b0:	df 90       	pop	r13
    22b2:	cf 90       	pop	r12
    22b4:	bf 90       	pop	r11
    22b6:	af 90       	pop	r10
    22b8:	9f 90       	pop	r9
    22ba:	8f 90       	pop	r8
    22bc:	7f 90       	pop	r7
    22be:	6f 90       	pop	r6
    22c0:	5f 90       	pop	r5
    22c2:	4f 90       	pop	r4
    22c4:	3f 90       	pop	r3
    22c6:	2f 90       	pop	r2
    22c8:	1f 90       	pop	r1
    22ca:	0f 90       	pop	r0
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22d0:	08 95       	ret

000022d2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22d2:	0f 92       	push	r0
    22d4:	0f b6       	in	r0, 0x3f	; 63
    22d6:	f8 94       	cli
    22d8:	0f 92       	push	r0
    22da:	1f 92       	push	r1
    22dc:	11 24       	eor	r1, r1
    22de:	2f 92       	push	r2
    22e0:	3f 92       	push	r3
    22e2:	4f 92       	push	r4
    22e4:	5f 92       	push	r5
    22e6:	6f 92       	push	r6
    22e8:	7f 92       	push	r7
    22ea:	8f 92       	push	r8
    22ec:	9f 92       	push	r9
    22ee:	af 92       	push	r10
    22f0:	bf 92       	push	r11
    22f2:	cf 92       	push	r12
    22f4:	df 92       	push	r13
    22f6:	ef 92       	push	r14
    22f8:	ff 92       	push	r15
    22fa:	0f 93       	push	r16
    22fc:	1f 93       	push	r17
    22fe:	2f 93       	push	r18
    2300:	3f 93       	push	r19
    2302:	4f 93       	push	r20
    2304:	5f 93       	push	r21
    2306:	6f 93       	push	r22
    2308:	7f 93       	push	r23
    230a:	8f 93       	push	r24
    230c:	9f 93       	push	r25
    230e:	af 93       	push	r26
    2310:	bf 93       	push	r27
    2312:	cf 93       	push	r28
    2314:	df 93       	push	r29
    2316:	ef 93       	push	r30
    2318:	ff 93       	push	r31
    231a:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    231e:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2322:	0d b6       	in	r0, 0x3d	; 61
    2324:	0d 92       	st	X+, r0
    2326:	0e b6       	in	r0, 0x3e	; 62
    2328:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    232a:	0e 94 ba 03 	call	0x774	; 0x774 <xTaskIncrementTick>
    232e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2330:	0e 94 22 05 	call	0xa44	; 0xa44 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2334:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2338:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    233c:	cd 91       	ld	r28, X+
    233e:	cd bf       	out	0x3d, r28	; 61
    2340:	dd 91       	ld	r29, X+
    2342:	de bf       	out	0x3e, r29	; 62
    2344:	ff 91       	pop	r31
    2346:	ef 91       	pop	r30
    2348:	df 91       	pop	r29
    234a:	cf 91       	pop	r28
    234c:	bf 91       	pop	r27
    234e:	af 91       	pop	r26
    2350:	9f 91       	pop	r25
    2352:	8f 91       	pop	r24
    2354:	7f 91       	pop	r23
    2356:	6f 91       	pop	r22
    2358:	5f 91       	pop	r21
    235a:	4f 91       	pop	r20
    235c:	3f 91       	pop	r19
    235e:	2f 91       	pop	r18
    2360:	1f 91       	pop	r17
    2362:	0f 91       	pop	r16
    2364:	ff 90       	pop	r15
    2366:	ef 90       	pop	r14
    2368:	df 90       	pop	r13
    236a:	cf 90       	pop	r12
    236c:	bf 90       	pop	r11
    236e:	af 90       	pop	r10
    2370:	9f 90       	pop	r9
    2372:	8f 90       	pop	r8
    2374:	7f 90       	pop	r7
    2376:	6f 90       	pop	r6
    2378:	5f 90       	pop	r5
    237a:	4f 90       	pop	r4
    237c:	3f 90       	pop	r3
    237e:	2f 90       	pop	r2
    2380:	1f 90       	pop	r1
    2382:	0f 90       	pop	r0
    2384:	0f be       	out	0x3f, r0	; 63
    2386:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2388:	08 95       	ret

0000238a <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    238a:	0e 94 69 11 	call	0x22d2	; 0x22d2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    238e:	18 95       	reti

00002390 <uart_transmit>:
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0) | _BV(RXCIE0) | _BV(UDRIE0); /* Enable RX and TX i włączamy interupty na RX i interupty na UDRE */
}

int uart_transmit(char c, FILE *stream)
{
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	1f 92       	push	r1
    2396:	cd b7       	in	r28, 0x3d	; 61
    2398:	de b7       	in	r29, 0x3e	; 62
    239a:	89 83       	std	Y+1, r24	; 0x01
  /*
  if(uxQueueSpacesAvailable(out) == 0)
    while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
  */
  xQueueSend(out, (void*)&c, (TickType_t)portMAX_DELAY);
    239c:	20 e0       	ldi	r18, 0x00	; 0
    239e:	4f ef       	ldi	r20, 0xFF	; 255
    23a0:	5f ef       	ldi	r21, 0xFF	; 255
    23a2:	be 01       	movw	r22, r28
    23a4:	6f 5f       	subi	r22, 0xFF	; 255
    23a6:	7f 4f       	sbci	r23, 0xFF	; 255
    23a8:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <out>
    23ac:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <out+0x1>
    23b0:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <xQueueGenericSend>

  return 0;
}
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	0f 90       	pop	r0
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	08 95       	ret

000023c0 <uart_receive>:

int uart_receive(FILE *stream)
{
    23c0:	cf 93       	push	r28
    23c2:	df 93       	push	r29
    23c4:	1f 92       	push	r1
    23c6:	cd b7       	in	r28, 0x3d	; 61
    23c8:	de b7       	in	r29, 0x3e	; 62
  uint8_t data;
  /*
  while(xQueueReceive(in, (void*)&data, (TickType_t)0) == pdFALSE) // xQueueReceiveFromISR useless
    vTaskDelay(10 / portTICK_PERIOD_MS);
    */
  xQueueReceive(in, (void*)&data, (TickType_t)portMAX_DELAY);
    23ca:	4f ef       	ldi	r20, 0xFF	; 255
    23cc:	5f ef       	ldi	r21, 0xFF	; 255
    23ce:	be 01       	movw	r22, r28
    23d0:	6f 5f       	subi	r22, 0xFF	; 255
    23d2:	7f 4f       	sbci	r23, 0xFF	; 255
    23d4:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <in>
    23d8:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <in+0x1>
    23dc:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <xQueueReceive>
  return (char)data;
    23e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    23e2:	08 2e       	mov	r0, r24
    23e4:	00 0c       	add	r0, r0
    23e6:	99 0b       	sbc	r25, r25
    23e8:	0f 90       	pop	r0
    23ea:	df 91       	pop	r29
    23ec:	cf 91       	pop	r28
    23ee:	08 95       	ret

000023f0 <uart_init>:
    23f0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    23f4:	87 e6       	ldi	r24, 0x67	; 103
    23f6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    23fa:	e0 ec       	ldi	r30, 0xC0	; 192
    23fc:	f0 e0       	ldi	r31, 0x00	; 0
    23fe:	80 81       	ld	r24, Z
    2400:	8d 7f       	andi	r24, 0xFD	; 253
    2402:	80 83       	st	Z, r24
    2404:	86 e0       	ldi	r24, 0x06	; 6
    2406:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    240a:	88 eb       	ldi	r24, 0xB8	; 184
    240c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    2410:	08 95       	ret

00002412 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    2412:	ef 92       	push	r14
    2414:	ff 92       	push	r15
    2416:	0f 93       	push	r16
    2418:	cf 93       	push	r28
    241a:	df 93       	push	r29
    241c:	00 d0       	rcall	.+0      	; 0x241e <main+0xc>
    241e:	00 d0       	rcall	.+0      	; 0x2420 <main+0xe>
    2420:	cd b7       	in	r28, 0x3d	; 61
    2422:	de b7       	in	r29, 0x3e	; 62
    QueueHandle_t in;
    QueueHandle_t out; */
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    in = xQueueCreate(10, sizeof(char));
    2424:	40 e0       	ldi	r20, 0x00	; 0
    2426:	61 e0       	ldi	r22, 0x01	; 1
    2428:	8a e0       	ldi	r24, 0x0A	; 10
    242a:	0e 94 cb 09 	call	0x1396	; 0x1396 <xQueueGenericCreate>
    242e:	90 93 a1 07 	sts	0x07A1, r25	; 0x8007a1 <in+0x1>
    2432:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <in>
    out = xQueueCreate(10, sizeof(char));
    2436:	40 e0       	ldi	r20, 0x00	; 0
    2438:	61 e0       	ldi	r22, 0x01	; 1
    243a:	8a e0       	ldi	r24, 0x0A	; 10
    243c:	0e 94 cb 09 	call	0x1396	; 0x1396 <xQueueGenericCreate>
    2440:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <out+0x1>
    2444:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <out>

    xTaskCreate
    2448:	ce 01       	movw	r24, r28
    244a:	03 96       	adiw	r24, 0x03	; 3
    244c:	7c 01       	movw	r14, r24
    244e:	01 e0       	ldi	r16, 0x01	; 1
    2450:	20 e0       	ldi	r18, 0x00	; 0
    2452:	30 e0       	ldi	r19, 0x00	; 0
    2454:	45 e5       	ldi	r20, 0x55	; 85
    2456:	50 e0       	ldi	r21, 0x00	; 0
    2458:	6e e0       	ldi	r22, 0x0E	; 14
    245a:	71 e0       	ldi	r23, 0x01	; 1
    245c:	83 e7       	ldi	r24, 0x73	; 115
    245e:	90 e0       	ldi	r25, 0x00	; 0
    2460:	0e 94 86 01 	call	0x30c	; 0x30c <xTaskCreate>
         NULL,
         mainLED_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    2464:	ce 01       	movw	r24, r28
    2466:	01 96       	adiw	r24, 0x01	; 1
    2468:	7c 01       	movw	r14, r24
    246a:	02 e0       	ldi	r16, 0x02	; 2
    246c:	20 e0       	ldi	r18, 0x00	; 0
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	45 e5       	ldi	r20, 0x55	; 85
    2472:	50 e0       	ldi	r21, 0x00	; 0
    2474:	64 e1       	ldi	r22, 0x14	; 20
    2476:	71 e0       	ldi	r23, 0x01	; 1
    2478:	83 e5       	ldi	r24, 0x53	; 83
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	0e 94 86 01 	call	0x30c	; 0x30c <xTaskCreate>
         mainSERIAL_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    2480:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vTaskStartScheduler>

    return 0;
}
    2484:	80 e0       	ldi	r24, 0x00	; 0
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	0f 90       	pop	r0
    248a:	0f 90       	pop	r0
    248c:	0f 90       	pop	r0
    248e:	0f 90       	pop	r0
    2490:	df 91       	pop	r29
    2492:	cf 91       	pop	r28
    2494:	0f 91       	pop	r16
    2496:	ff 90       	pop	r15
    2498:	ef 90       	pop	r14
    249a:	08 95       	ret

0000249c <memcpy>:
    249c:	fb 01       	movw	r30, r22
    249e:	dc 01       	movw	r26, r24
    24a0:	02 c0       	rjmp	.+4      	; 0x24a6 <memcpy+0xa>
    24a2:	01 90       	ld	r0, Z+
    24a4:	0d 92       	st	X+, r0
    24a6:	41 50       	subi	r20, 0x01	; 1
    24a8:	50 40       	sbci	r21, 0x00	; 0
    24aa:	d8 f7       	brcc	.-10     	; 0x24a2 <memcpy+0x6>
    24ac:	08 95       	ret

000024ae <fputc>:
    24ae:	0f 93       	push	r16
    24b0:	1f 93       	push	r17
    24b2:	cf 93       	push	r28
    24b4:	df 93       	push	r29
    24b6:	fb 01       	movw	r30, r22
    24b8:	23 81       	ldd	r18, Z+3	; 0x03
    24ba:	21 fd       	sbrc	r18, 1
    24bc:	03 c0       	rjmp	.+6      	; 0x24c4 <fputc+0x16>
    24be:	8f ef       	ldi	r24, 0xFF	; 255
    24c0:	9f ef       	ldi	r25, 0xFF	; 255
    24c2:	2c c0       	rjmp	.+88     	; 0x251c <fputc+0x6e>
    24c4:	22 ff       	sbrs	r18, 2
    24c6:	16 c0       	rjmp	.+44     	; 0x24f4 <fputc+0x46>
    24c8:	46 81       	ldd	r20, Z+6	; 0x06
    24ca:	57 81       	ldd	r21, Z+7	; 0x07
    24cc:	24 81       	ldd	r18, Z+4	; 0x04
    24ce:	35 81       	ldd	r19, Z+5	; 0x05
    24d0:	42 17       	cp	r20, r18
    24d2:	53 07       	cpc	r21, r19
    24d4:	44 f4       	brge	.+16     	; 0x24e6 <fputc+0x38>
    24d6:	a0 81       	ld	r26, Z
    24d8:	b1 81       	ldd	r27, Z+1	; 0x01
    24da:	9d 01       	movw	r18, r26
    24dc:	2f 5f       	subi	r18, 0xFF	; 255
    24de:	3f 4f       	sbci	r19, 0xFF	; 255
    24e0:	31 83       	std	Z+1, r19	; 0x01
    24e2:	20 83       	st	Z, r18
    24e4:	8c 93       	st	X, r24
    24e6:	26 81       	ldd	r18, Z+6	; 0x06
    24e8:	37 81       	ldd	r19, Z+7	; 0x07
    24ea:	2f 5f       	subi	r18, 0xFF	; 255
    24ec:	3f 4f       	sbci	r19, 0xFF	; 255
    24ee:	37 83       	std	Z+7, r19	; 0x07
    24f0:	26 83       	std	Z+6, r18	; 0x06
    24f2:	14 c0       	rjmp	.+40     	; 0x251c <fputc+0x6e>
    24f4:	8b 01       	movw	r16, r22
    24f6:	ec 01       	movw	r28, r24
    24f8:	fb 01       	movw	r30, r22
    24fa:	00 84       	ldd	r0, Z+8	; 0x08
    24fc:	f1 85       	ldd	r31, Z+9	; 0x09
    24fe:	e0 2d       	mov	r30, r0
    2500:	09 95       	icall
    2502:	89 2b       	or	r24, r25
    2504:	e1 f6       	brne	.-72     	; 0x24be <fputc+0x10>
    2506:	d8 01       	movw	r26, r16
    2508:	16 96       	adiw	r26, 0x06	; 6
    250a:	8d 91       	ld	r24, X+
    250c:	9c 91       	ld	r25, X
    250e:	17 97       	sbiw	r26, 0x07	; 7
    2510:	01 96       	adiw	r24, 0x01	; 1
    2512:	17 96       	adiw	r26, 0x07	; 7
    2514:	9c 93       	st	X, r25
    2516:	8e 93       	st	-X, r24
    2518:	16 97       	sbiw	r26, 0x06	; 6
    251a:	ce 01       	movw	r24, r28
    251c:	df 91       	pop	r29
    251e:	cf 91       	pop	r28
    2520:	1f 91       	pop	r17
    2522:	0f 91       	pop	r16
    2524:	08 95       	ret

00002526 <_exit>:
    2526:	f8 94       	cli

00002528 <__stop_program>:
    2528:	ff cf       	rjmp	.-2      	; 0x2528 <__stop_program>
