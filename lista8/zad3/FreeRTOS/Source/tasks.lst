   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 187               	prvResetNextTaskUnblockTime:
 188               		.stabd	46,0,0
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/Source/tasks.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/tasks.c ****  *
   5:FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/tasks.c ****  *
  12:FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/tasks.c ****  *
  15:FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/tasks.c ****  *
  22:FreeRTOS/Source/tasks.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/tasks.c ****  *
  25:FreeRTOS/Source/tasks.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/tasks.c ****  */
  27:FreeRTOS/Source/tasks.c **** 
  28:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  29:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  30:FreeRTOS/Source/tasks.c **** #include <string.h>
  31:FreeRTOS/Source/tasks.c **** 
  32:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  35:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/Source/tasks.c **** 
  37:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  38:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  39:FreeRTOS/Source/tasks.c **** #include "task.h"
  40:FreeRTOS/Source/tasks.c **** #include "timers.h"
  41:FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:FreeRTOS/Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:FreeRTOS/Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:FreeRTOS/Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:FreeRTOS/Source/tasks.c **** 
  49:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  51:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  57:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:FreeRTOS/Source/tasks.c **** #else
  64:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:FreeRTOS/Source/tasks.c **** #endif
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:FreeRTOS/Source/tasks.c **** 
  72:FreeRTOS/Source/tasks.c **** /*
  73:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:FreeRTOS/Source/tasks.c ****  */
  76:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:FreeRTOS/Source/tasks.c **** 
  78:FreeRTOS/Source/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  79:FreeRTOS/Source/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  80:FreeRTOS/Source/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  81:FreeRTOS/Source/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  82:FreeRTOS/Source/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  83:FreeRTOS/Source/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  84:FreeRTOS/Source/tasks.c **** settings allow a task to be created using either statically or dynamically
  85:FreeRTOS/Source/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  86:FreeRTOS/Source/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  87:FreeRTOS/Source/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  88:FreeRTOS/Source/tasks.c **** made to free the RAM that was allocated statically.
  89:FreeRTOS/Source/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
  90:FreeRTOS/Source/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  91:FreeRTOS/Source/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  92:FreeRTOS/Source/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  93:FreeRTOS/Source/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  94:FreeRTOS/Source/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  95:FreeRTOS/Source/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  96:FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  97:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  98:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  99:FreeRTOS/Source/tasks.c **** 
 100:FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 101:FreeRTOS/Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
 102:FreeRTOS/Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 103:FreeRTOS/Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 104:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 105:FreeRTOS/Source/tasks.c **** #else
 106:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 107:FreeRTOS/Source/tasks.c **** #endif
 108:FreeRTOS/Source/tasks.c **** 
 109:FreeRTOS/Source/tasks.c **** /*
 110:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 111:FreeRTOS/Source/tasks.c ****  */
 112:FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
 113:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** /*
 119:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 121:FreeRTOS/Source/tasks.c ****  */
 122:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:FreeRTOS/Source/tasks.c **** 	#define static
 124:FreeRTOS/Source/tasks.c **** #endif
 125:FreeRTOS/Source/tasks.c **** 
 126:FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:FreeRTOS/Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:FreeRTOS/Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:FreeRTOS/Source/tasks.c **** #endif
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 137:FreeRTOS/Source/tasks.c **** 
 138:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:FreeRTOS/Source/tasks.c **** 	state task. */
 140:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:FreeRTOS/Source/tasks.c **** 	{																									\
 142:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:FreeRTOS/Source/tasks.c **** 		{																								\
 144:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:FreeRTOS/Source/tasks.c **** 		}																								\
 146:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:FreeRTOS/Source/tasks.c **** 	{																									\
 152:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:FreeRTOS/Source/tasks.c **** 																										\
 154:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:FreeRTOS/Source/tasks.c **** 		{																								\
 157:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:FreeRTOS/Source/tasks.c **** 			--uxTopPriority;																			\
 159:FreeRTOS/Source/tasks.c **** 		}																								\
 160:FreeRTOS/Source/tasks.c **** 																										\
 161:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Source/tasks.c **** 
 169:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:FreeRTOS/Source/tasks.c **** 	being used. */
 172:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:FreeRTOS/Source/tasks.c **** 
 177:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:FreeRTOS/Source/tasks.c **** 
 184:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 185:FreeRTOS/Source/tasks.c **** 
 186:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:FreeRTOS/Source/tasks.c **** 	{																								\
 188:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:FreeRTOS/Source/tasks.c **** 																									\
 190:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:FreeRTOS/Source/tasks.c **** 
 196:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 197:FreeRTOS/Source/tasks.c **** 
 198:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:FreeRTOS/Source/tasks.c **** 	{																									\
 203:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 204:FreeRTOS/Source/tasks.c **** 		{																								\
 205:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:FreeRTOS/Source/tasks.c **** 		}																								\
 207:FreeRTOS/Source/tasks.c **** 	}
 208:FreeRTOS/Source/tasks.c **** 
 209:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:FreeRTOS/Source/tasks.c **** 
 211:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 212:FreeRTOS/Source/tasks.c **** 
 213:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:FreeRTOS/Source/tasks.c **** count overflows. */
 215:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:FreeRTOS/Source/tasks.c **** {																									\
 217:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 218:FreeRTOS/Source/tasks.c **** 																									\
 219:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:FreeRTOS/Source/tasks.c **** 																									\
 222:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 226:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:FreeRTOS/Source/tasks.c **** }
 228:FreeRTOS/Source/tasks.c **** 
 229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 230:FreeRTOS/Source/tasks.c **** 
 231:FreeRTOS/Source/tasks.c **** /*
 232:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:FreeRTOS/Source/tasks.c ****  */
 235:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:FreeRTOS/Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 241:FreeRTOS/Source/tasks.c **** 
 242:FreeRTOS/Source/tasks.c **** /*
 243:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:FreeRTOS/Source/tasks.c ****  */
 248:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 249:FreeRTOS/Source/tasks.c **** 
 250:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 258:FreeRTOS/Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:FreeRTOS/Source/tasks.c **** #else
 261:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:FreeRTOS/Source/tasks.c **** #endif
 263:FreeRTOS/Source/tasks.c **** 
 264:FreeRTOS/Source/tasks.c **** /*
 265:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 268:FreeRTOS/Source/tasks.c ****  */
 269:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel 
 270:FreeRTOS/Source/tasks.c **** {
 271:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:FreeRTOS/Source/tasks.c **** 
 273:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:FreeRTOS/Source/tasks.c **** 	#endif
 276:FreeRTOS/Source/tasks.c **** 
 277:FreeRTOS/Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:FreeRTOS/Source/tasks.c **** 
 283:FreeRTOS/Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:FreeRTOS/Source/tasks.c **** 	#endif
 286:FreeRTOS/Source/tasks.c **** 
 287:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:FreeRTOS/Source/tasks.c **** 	#endif
 290:FreeRTOS/Source/tasks.c **** 
 291:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:FreeRTOS/Source/tasks.c **** 	#endif
 295:FreeRTOS/Source/tasks.c **** 
 296:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:FreeRTOS/Source/tasks.c **** 	#endif
 300:FreeRTOS/Source/tasks.c **** 
 301:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:FreeRTOS/Source/tasks.c **** 	#endif
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:FreeRTOS/Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:FreeRTOS/Source/tasks.c **** 	#endif
 308:FreeRTOS/Source/tasks.c **** 
 309:FreeRTOS/Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:FreeRTOS/Source/tasks.c **** 	#endif
 312:FreeRTOS/Source/tasks.c **** 
 313:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 318:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:FreeRTOS/Source/tasks.c **** 		struct	_reent xNewLib_reent;
 322:FreeRTOS/Source/tasks.c **** 	#endif
 323:FreeRTOS/Source/tasks.c **** 
 324:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:FreeRTOS/Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:FreeRTOS/Source/tasks.c **** 	#endif
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** 	/* See the comments above the definition of
 330:FreeRTOS/Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:FreeRTOS/Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 332:FreeRTOS/Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:FreeRTOS/Source/tasks.c **** 	#endif
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:FreeRTOS/Source/tasks.c **** 		uint8_t ucDelayAborted;
 337:FreeRTOS/Source/tasks.c **** 	#endif
 338:FreeRTOS/Source/tasks.c **** 
 339:FreeRTOS/Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 340:FreeRTOS/Source/tasks.c **** 		int iTaskErrno;
 341:FreeRTOS/Source/tasks.c **** 	#endif
 342:FreeRTOS/Source/tasks.c **** 
 343:FreeRTOS/Source/tasks.c **** } tskTCB;
 344:FreeRTOS/Source/tasks.c **** 
 345:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 346:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 347:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 348:FreeRTOS/Source/tasks.c **** 
 349:FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 350:FreeRTOS/Source/tasks.c **** which static variables must be declared volatile. */
 351:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 354:FreeRTOS/Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 355:FreeRTOS/Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 356:FreeRTOS/Source/tasks.c **** the static qualifier. */
 357:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 358:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 359:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 360:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 361:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 362:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 363:FreeRTOS/Source/tasks.c **** 
 364:FreeRTOS/Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 367:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 368:FreeRTOS/Source/tasks.c **** 
 369:FreeRTOS/Source/tasks.c **** #endif
 370:FreeRTOS/Source/tasks.c **** 
 371:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 372:FreeRTOS/Source/tasks.c **** 
 373:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** #endif
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 378:FreeRTOS/Source/tasks.c **** the errno of the currently running task. */
 379:FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 380:FreeRTOS/Source/tasks.c **** 	int FreeRTOS_errno = 0;
 381:FreeRTOS/Source/tasks.c **** #endif
 382:FreeRTOS/Source/tasks.c **** 
 383:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 384:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 385:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 386:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 387:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 388:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 389:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 390:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 391:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 392:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 393:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 394:FreeRTOS/Source/tasks.c **** 
 395:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 396:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 397:FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 398:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 399:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 400:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 401:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 402:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 403:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 404:FreeRTOS/Source/tasks.c **** 
 405:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 406:FreeRTOS/Source/tasks.c **** 
 407:FreeRTOS/Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 408:FreeRTOS/Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 409:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 410:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 411:FreeRTOS/Source/tasks.c **** 
 412:FreeRTOS/Source/tasks.c **** #endif
 413:FreeRTOS/Source/tasks.c **** 
 414:FreeRTOS/Source/tasks.c **** /*lint -restore */
 415:FreeRTOS/Source/tasks.c **** 
 416:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 417:FreeRTOS/Source/tasks.c **** 
 418:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 419:FreeRTOS/Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 420:FreeRTOS/Source/tasks.c **** 
 421:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 422:FreeRTOS/Source/tasks.c **** 
 423:FreeRTOS/Source/tasks.c **** #endif
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** #endif
 430:FreeRTOS/Source/tasks.c **** 
 431:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 434:FreeRTOS/Source/tasks.c **** 
 435:FreeRTOS/Source/tasks.c **** #endif
 436:FreeRTOS/Source/tasks.c **** 
 437:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 438:FreeRTOS/Source/tasks.c **** 
 439:FreeRTOS/Source/tasks.c **** /**
 440:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 441:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 442:FreeRTOS/Source/tasks.c ****  * is in any other state.
 443:FreeRTOS/Source/tasks.c ****  */
 444:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 445:FreeRTOS/Source/tasks.c **** 
 446:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 447:FreeRTOS/Source/tasks.c **** 
 448:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 449:FreeRTOS/Source/tasks.c **** 
 450:FreeRTOS/Source/tasks.c **** /*
 451:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 452:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 453:FreeRTOS/Source/tasks.c ****  */
 454:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 455:FreeRTOS/Source/tasks.c **** 
 456:FreeRTOS/Source/tasks.c **** /*
 457:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 458:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 459:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 460:FreeRTOS/Source/tasks.c ****  *
 461:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 462:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 463:FreeRTOS/Source/tasks.c ****  *
 464:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 465:FreeRTOS/Source/tasks.c ****  *
 466:FreeRTOS/Source/tasks.c ****  */
 467:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 468:FreeRTOS/Source/tasks.c **** 
 469:FreeRTOS/Source/tasks.c **** /*
 470:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 471:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 472:FreeRTOS/Source/tasks.c ****  *
 473:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 474:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 475:FreeRTOS/Source/tasks.c ****  */
 476:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 477:FreeRTOS/Source/tasks.c **** 
 478:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 479:FreeRTOS/Source/tasks.c **** 
 480:FreeRTOS/Source/tasks.c **** #endif
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** /*
 483:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 484:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 485:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 486:FreeRTOS/Source/tasks.c ****  */
 487:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** /*
 490:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 491:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 492:FreeRTOS/Source/tasks.c ****  */
 493:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 494:FreeRTOS/Source/tasks.c **** 
 495:FreeRTOS/Source/tasks.c **** /*
 496:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 497:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 498:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 499:FreeRTOS/Source/tasks.c ****  *
 500:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 501:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 502:FreeRTOS/Source/tasks.c ****  */
 503:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 504:FreeRTOS/Source/tasks.c **** 
 505:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 506:FreeRTOS/Source/tasks.c **** 
 507:FreeRTOS/Source/tasks.c **** #endif
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** /*
 510:FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 511:FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 512:FreeRTOS/Source/tasks.c ****  */
 513:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 514:FreeRTOS/Source/tasks.c **** 
 515:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 516:FreeRTOS/Source/tasks.c **** 
 517:FreeRTOS/Source/tasks.c **** #endif
 518:FreeRTOS/Source/tasks.c **** 
 519:FreeRTOS/Source/tasks.c **** /*
 520:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 521:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 522:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 523:FreeRTOS/Source/tasks.c ****  */
 524:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 525:FreeRTOS/Source/tasks.c **** 
 526:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** #endif
 529:FreeRTOS/Source/tasks.c **** 
 530:FreeRTOS/Source/tasks.c **** /*
 531:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 532:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 533:FreeRTOS/Source/tasks.c ****  *
 534:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 535:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 536:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 537:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 538:FreeRTOS/Source/tasks.c ****  */
 539:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 540:FreeRTOS/Source/tasks.c **** 
 541:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 542:FreeRTOS/Source/tasks.c **** 
 543:FreeRTOS/Source/tasks.c **** #endif
 544:FreeRTOS/Source/tasks.c **** 
 545:FreeRTOS/Source/tasks.c **** /*
 546:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 547:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 548:FreeRTOS/Source/tasks.c ****  */
 549:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 550:FreeRTOS/Source/tasks.c **** 
 551:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 552:FreeRTOS/Source/tasks.c **** 
 553:FreeRTOS/Source/tasks.c **** 	/*
 554:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 555:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 556:FreeRTOS/Source/tasks.c **** 	 */
 557:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 558:FreeRTOS/Source/tasks.c **** 
 559:FreeRTOS/Source/tasks.c **** #endif
 560:FreeRTOS/Source/tasks.c **** 
 561:FreeRTOS/Source/tasks.c **** /*
 562:FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 563:FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 564:FreeRTOS/Source/tasks.c ****  */
 565:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 566:FreeRTOS/Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 567:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 568:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 569:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 570:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 571:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 572:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 573:FreeRTOS/Source/tasks.c **** 
 574:FreeRTOS/Source/tasks.c **** /*
 575:FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 576:FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 577:FreeRTOS/Source/tasks.c ****  */
 578:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 579:FreeRTOS/Source/tasks.c **** 
 580:FreeRTOS/Source/tasks.c **** /*
 581:FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 582:FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 583:FreeRTOS/Source/tasks.c ****  * called by the function.
 584:FreeRTOS/Source/tasks.c ****  */
 585:FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 586:FreeRTOS/Source/tasks.c **** 
 587:FreeRTOS/Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 588:FreeRTOS/Source/tasks.c **** 
 589:FreeRTOS/Source/tasks.c **** #endif
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 592:FreeRTOS/Source/tasks.c **** 
 593:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 596:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 597:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 598:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 599:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 600:FreeRTOS/Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 601:FreeRTOS/Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 602:FreeRTOS/Source/tasks.c **** 	{
 603:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 604:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 605:FreeRTOS/Source/tasks.c **** 
 606:FreeRTOS/Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 607:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 608:FreeRTOS/Source/tasks.c **** 
 609:FreeRTOS/Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 610:FreeRTOS/Source/tasks.c **** 		{
 611:FreeRTOS/Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 612:FreeRTOS/Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 613:FreeRTOS/Source/tasks.c **** 			structure. */
 614:FreeRTOS/Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 615:FreeRTOS/Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 616:FreeRTOS/Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 617:FreeRTOS/Source/tasks.c **** 		}
 618:FreeRTOS/Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 619:FreeRTOS/Source/tasks.c **** 
 620:FreeRTOS/Source/tasks.c **** 
 621:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 622:FreeRTOS/Source/tasks.c **** 		{
 623:FreeRTOS/Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 624:FreeRTOS/Source/tasks.c **** 			function - use them. */
 625:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 626:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 627:FreeRTOS/Source/tasks.c **** 
 628:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 629:FreeRTOS/Source/tasks.c **** 			{
 630:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 631:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 632:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 633:FreeRTOS/Source/tasks.c **** 			}
 634:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 637:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 638:FreeRTOS/Source/tasks.c **** 		}
 639:FreeRTOS/Source/tasks.c **** 		else
 640:FreeRTOS/Source/tasks.c **** 		{
 641:FreeRTOS/Source/tasks.c **** 			xReturn = NULL;
 642:FreeRTOS/Source/tasks.c **** 		}
 643:FreeRTOS/Source/tasks.c **** 
 644:FreeRTOS/Source/tasks.c **** 		return xReturn;
 645:FreeRTOS/Source/tasks.c **** 	}
 646:FreeRTOS/Source/tasks.c **** 
 647:FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 648:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 653:FreeRTOS/Source/tasks.c **** 	{
 654:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 655:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 658:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 659:FreeRTOS/Source/tasks.c **** 
 660:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 661:FreeRTOS/Source/tasks.c **** 		{
 662:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 663:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 664:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 665:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 666:FreeRTOS/Source/tasks.c **** 
 667:FreeRTOS/Source/tasks.c **** 			/* Store the stack location in the TCB. */
 668:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 669:FreeRTOS/Source/tasks.c **** 
 670:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 671:FreeRTOS/Source/tasks.c **** 			{
 672:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 673:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 674:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 675:FreeRTOS/Source/tasks.c **** 			}
 676:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 677:FreeRTOS/Source/tasks.c **** 
 678:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 679:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pcName,
 680:FreeRTOS/Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 681:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 682:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 683:FreeRTOS/Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 684:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->xRegions );
 685:FreeRTOS/Source/tasks.c **** 
 686:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 687:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 688:FreeRTOS/Source/tasks.c **** 		}
 689:FreeRTOS/Source/tasks.c **** 
 690:FreeRTOS/Source/tasks.c **** 		return xReturn;
 691:FreeRTOS/Source/tasks.c **** 	}
 692:FreeRTOS/Source/tasks.c **** 
 693:FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 694:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 695:FreeRTOS/Source/tasks.c **** 
 696:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 697:FreeRTOS/Source/tasks.c **** 
 698:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 699:FreeRTOS/Source/tasks.c **** 	{
 700:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 701:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 702:FreeRTOS/Source/tasks.c **** 
 703:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 704:FreeRTOS/Source/tasks.c **** 
 705:FreeRTOS/Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 706:FreeRTOS/Source/tasks.c **** 		{
 707:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 708:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 709:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 710:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 711:FreeRTOS/Source/tasks.c **** 
 712:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 713:FreeRTOS/Source/tasks.c **** 			{
 714:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
 715:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 716:FreeRTOS/Source/tasks.c **** 
 717:FreeRTOS/Source/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 718:FreeRTOS/Source/tasks.c **** 				{
 719:FreeRTOS/Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 720:FreeRTOS/Source/tasks.c **** 					this task had a statically allocated stack in case it is
 721:FreeRTOS/Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 722:FreeRTOS/Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 723:FreeRTOS/Source/tasks.c **** 				}
 724:FreeRTOS/Source/tasks.c **** 				#endif
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 727:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pcName,
 728:FreeRTOS/Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 729:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 730:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 731:FreeRTOS/Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 732:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->xRegions );
 733:FreeRTOS/Source/tasks.c **** 
 734:FreeRTOS/Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 735:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 736:FreeRTOS/Source/tasks.c **** 			}
 737:FreeRTOS/Source/tasks.c **** 		}
 738:FreeRTOS/Source/tasks.c **** 
 739:FreeRTOS/Source/tasks.c **** 		return xReturn;
 740:FreeRTOS/Source/tasks.c **** 	}
 741:FreeRTOS/Source/tasks.c **** 
 742:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 743:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 746:FreeRTOS/Source/tasks.c **** 
 747:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 748:FreeRTOS/Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 749:FreeRTOS/Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 750:FreeRTOS/Source/tasks.c **** 							void * const pvParameters,
 751:FreeRTOS/Source/tasks.c **** 							UBaseType_t uxPriority,
 752:FreeRTOS/Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 753:FreeRTOS/Source/tasks.c **** 	{
 754:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 755:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 756:FreeRTOS/Source/tasks.c **** 
 757:FreeRTOS/Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 758:FreeRTOS/Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 759:FreeRTOS/Source/tasks.c **** 		the TCB then the stack. */
 760:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 761:FreeRTOS/Source/tasks.c **** 		{
 762:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 763:FreeRTOS/Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 764:FreeRTOS/Source/tasks.c **** 			allocation is being used. */
 765:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 766:FreeRTOS/Source/tasks.c **** 
 767:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 768:FreeRTOS/Source/tasks.c **** 			{
 769:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 770:FreeRTOS/Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 771:FreeRTOS/Source/tasks.c **** 				be deleted later if required. */
 772:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 775:FreeRTOS/Source/tasks.c **** 				{
 776:FreeRTOS/Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 777:FreeRTOS/Source/tasks.c **** 					vPortFree( pxNewTCB );
 778:FreeRTOS/Source/tasks.c **** 					pxNewTCB = NULL;
 779:FreeRTOS/Source/tasks.c **** 				}
 780:FreeRTOS/Source/tasks.c **** 			}
 781:FreeRTOS/Source/tasks.c **** 		}
 782:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 783:FreeRTOS/Source/tasks.c **** 		{
 784:FreeRTOS/Source/tasks.c **** 		StackType_t *pxStack;
 785:FreeRTOS/Source/tasks.c **** 
 786:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 787:FreeRTOS/Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 788:FreeRTOS/Source/tasks.c **** 
 789:FreeRTOS/Source/tasks.c **** 			if( pxStack != NULL )
 790:FreeRTOS/Source/tasks.c **** 			{
 791:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the TCB. */
 792:FreeRTOS/Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB != NULL )
 795:FreeRTOS/Source/tasks.c **** 				{
 796:FreeRTOS/Source/tasks.c **** 					/* Store the stack location in the TCB. */
 797:FreeRTOS/Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 798:FreeRTOS/Source/tasks.c **** 				}
 799:FreeRTOS/Source/tasks.c **** 				else
 800:FreeRTOS/Source/tasks.c **** 				{
 801:FreeRTOS/Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 802:FreeRTOS/Source/tasks.c **** 					it again. */
 803:FreeRTOS/Source/tasks.c **** 					vPortFree( pxStack );
 804:FreeRTOS/Source/tasks.c **** 				}
 805:FreeRTOS/Source/tasks.c **** 			}
 806:FreeRTOS/Source/tasks.c **** 			else
 807:FreeRTOS/Source/tasks.c **** 			{
 808:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
 809:FreeRTOS/Source/tasks.c **** 			}
 810:FreeRTOS/Source/tasks.c **** 		}
 811:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 812:FreeRTOS/Source/tasks.c **** 
 813:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
 814:FreeRTOS/Source/tasks.c **** 		{
 815:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 816:FreeRTOS/Source/tasks.c **** 			{
 817:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 818:FreeRTOS/Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 819:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 820:FreeRTOS/Source/tasks.c **** 			}
 821:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 824:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 825:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 826:FreeRTOS/Source/tasks.c **** 		}
 827:FreeRTOS/Source/tasks.c **** 		else
 828:FreeRTOS/Source/tasks.c **** 		{
 829:FreeRTOS/Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 830:FreeRTOS/Source/tasks.c **** 		}
 831:FreeRTOS/Source/tasks.c **** 
 832:FreeRTOS/Source/tasks.c **** 		return xReturn;
 833:FreeRTOS/Source/tasks.c **** 	}
 834:FreeRTOS/Source/tasks.c **** 
 835:FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 836:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 837:FreeRTOS/Source/tasks.c **** 
 838:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 839:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 840:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 841:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 842:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 843:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 844:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 845:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 846:FreeRTOS/Source/tasks.c **** {
 847:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 848:FreeRTOS/Source/tasks.c **** UBaseType_t x;
 849:FreeRTOS/Source/tasks.c **** 
 850:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 851:FreeRTOS/Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 852:FreeRTOS/Source/tasks.c **** 		BaseType_t xRunPrivileged;
 853:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 854:FreeRTOS/Source/tasks.c **** 		{
 855:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 856:FreeRTOS/Source/tasks.c **** 		}
 857:FreeRTOS/Source/tasks.c **** 		else
 858:FreeRTOS/Source/tasks.c **** 		{
 859:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 860:FreeRTOS/Source/tasks.c **** 		}
 861:FreeRTOS/Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 862:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 863:FreeRTOS/Source/tasks.c **** 
 864:FreeRTOS/Source/tasks.c **** 	configASSERT( pcName );
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 867:FreeRTOS/Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 868:FreeRTOS/Source/tasks.c **** 	{
 869:FreeRTOS/Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 870:FreeRTOS/Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 871:FreeRTOS/Source/tasks.c **** 	}
 872:FreeRTOS/Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 873:FreeRTOS/Source/tasks.c **** 
 874:FreeRTOS/Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 875:FreeRTOS/Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 876:FreeRTOS/Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 877:FreeRTOS/Source/tasks.c **** 	by the port. */
 878:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 879:FreeRTOS/Source/tasks.c **** 	{
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 881:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 882:FreeRTOS/Source/tasks.c **** 
 883:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 884:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 885:FreeRTOS/Source/tasks.c **** 
 886:FreeRTOS/Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 887:FreeRTOS/Source/tasks.c **** 		{
 888:FreeRTOS/Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 889:FreeRTOS/Source/tasks.c **** 			debugging. */
 890:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 891:FreeRTOS/Source/tasks.c **** 		}
 892:FreeRTOS/Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 893:FreeRTOS/Source/tasks.c **** 	}
 894:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 895:FreeRTOS/Source/tasks.c **** 	{
 896:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 897:FreeRTOS/Source/tasks.c **** 
 898:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 899:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 900:FreeRTOS/Source/tasks.c **** 
 901:FreeRTOS/Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 902:FreeRTOS/Source/tasks.c **** 		performed. */
 903:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 904:FreeRTOS/Source/tasks.c **** 	}
 905:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 906:FreeRTOS/Source/tasks.c **** 
 907:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
 908:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 909:FreeRTOS/Source/tasks.c **** 	{
 910:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 911:FreeRTOS/Source/tasks.c **** 
 912:FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 913:FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 914:FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 915:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == ( char ) 0x00 )
 916:FreeRTOS/Source/tasks.c **** 		{
 917:FreeRTOS/Source/tasks.c **** 			break;
 918:FreeRTOS/Source/tasks.c **** 		}
 919:FreeRTOS/Source/tasks.c **** 		else
 920:FreeRTOS/Source/tasks.c **** 		{
 921:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 922:FreeRTOS/Source/tasks.c **** 		}
 923:FreeRTOS/Source/tasks.c **** 	}
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 926:FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 927:FreeRTOS/Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 928:FreeRTOS/Source/tasks.c **** 
 929:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 930:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
 931:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 932:FreeRTOS/Source/tasks.c **** 	{
 933:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 934:FreeRTOS/Source/tasks.c **** 	}
 935:FreeRTOS/Source/tasks.c **** 	else
 936:FreeRTOS/Source/tasks.c **** 	{
 937:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 938:FreeRTOS/Source/tasks.c **** 	}
 939:FreeRTOS/Source/tasks.c **** 
 940:FreeRTOS/Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 941:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 942:FreeRTOS/Source/tasks.c **** 	{
 943:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 944:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 945:FreeRTOS/Source/tasks.c **** 	}
 946:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 949:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 950:FreeRTOS/Source/tasks.c **** 
 951:FreeRTOS/Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 952:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 953:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 954:FreeRTOS/Source/tasks.c **** 
 955:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
 956:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 957:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 958:FreeRTOS/Source/tasks.c **** 
 959:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 960:FreeRTOS/Source/tasks.c **** 	{
 961:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 962:FreeRTOS/Source/tasks.c **** 	}
 963:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 964:FreeRTOS/Source/tasks.c **** 
 965:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 966:FreeRTOS/Source/tasks.c **** 	{
 967:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 968:FreeRTOS/Source/tasks.c **** 	}
 969:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 970:FreeRTOS/Source/tasks.c **** 
 971:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 972:FreeRTOS/Source/tasks.c **** 	{
 973:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 974:FreeRTOS/Source/tasks.c **** 	}
 975:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 976:FreeRTOS/Source/tasks.c **** 
 977:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 978:FreeRTOS/Source/tasks.c **** 	{
 979:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 980:FreeRTOS/Source/tasks.c **** 	}
 981:FreeRTOS/Source/tasks.c **** 	#else
 982:FreeRTOS/Source/tasks.c **** 	{
 983:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 984:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
 985:FreeRTOS/Source/tasks.c **** 	}
 986:FreeRTOS/Source/tasks.c **** 	#endif
 987:FreeRTOS/Source/tasks.c **** 
 988:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 989:FreeRTOS/Source/tasks.c **** 	{
 990:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 991:FreeRTOS/Source/tasks.c **** 		{
 992:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 993:FreeRTOS/Source/tasks.c **** 		}
 994:FreeRTOS/Source/tasks.c **** 	}
 995:FreeRTOS/Source/tasks.c **** 	#endif
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 998:FreeRTOS/Source/tasks.c **** 	{
 999:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
1000:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1001:FreeRTOS/Source/tasks.c **** 	}
1002:FreeRTOS/Source/tasks.c **** 	#endif
1003:FreeRTOS/Source/tasks.c **** 
1004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
1005:FreeRTOS/Source/tasks.c **** 	{
1006:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
1007:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1008:FreeRTOS/Source/tasks.c **** 	}
1009:FreeRTOS/Source/tasks.c **** 	#endif
1010:FreeRTOS/Source/tasks.c **** 
1011:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1012:FreeRTOS/Source/tasks.c **** 	{
1013:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1014:FreeRTOS/Source/tasks.c **** 	}
1015:FreeRTOS/Source/tasks.c **** 	#endif
1016:FreeRTOS/Source/tasks.c **** 
1017:FreeRTOS/Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1018:FreeRTOS/Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1019:FreeRTOS/Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1020:FreeRTOS/Source/tasks.c **** 	the top of stack variable is updated. */
1021:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1022:FreeRTOS/Source/tasks.c **** 	{
1023:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1024:FreeRTOS/Source/tasks.c **** 	}
1025:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1026:FreeRTOS/Source/tasks.c **** 	{
1027:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1028:FreeRTOS/Source/tasks.c **** 	}
1029:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1030:FreeRTOS/Source/tasks.c **** 
1031:FreeRTOS/Source/tasks.c **** 	if( pxCreatedTask != NULL )
1032:FreeRTOS/Source/tasks.c **** 	{
1033:FreeRTOS/Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1034:FreeRTOS/Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1035:FreeRTOS/Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1036:FreeRTOS/Source/tasks.c **** 	}
1037:FreeRTOS/Source/tasks.c **** 	else
1038:FreeRTOS/Source/tasks.c **** 	{
1039:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1040:FreeRTOS/Source/tasks.c **** 	}
1041:FreeRTOS/Source/tasks.c **** }
1042:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1043:FreeRTOS/Source/tasks.c **** 
1044:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1045:FreeRTOS/Source/tasks.c **** {
1046:FreeRTOS/Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1047:FreeRTOS/Source/tasks.c **** 	updated. */
1048:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1049:FreeRTOS/Source/tasks.c **** 	{
1050:FreeRTOS/Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1051:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1052:FreeRTOS/Source/tasks.c **** 		{
1053:FreeRTOS/Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1054:FreeRTOS/Source/tasks.c **** 			the suspended state - make this the current task. */
1055:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1056:FreeRTOS/Source/tasks.c **** 
1057:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1058:FreeRTOS/Source/tasks.c **** 			{
1059:FreeRTOS/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1060:FreeRTOS/Source/tasks.c **** 				initialisation required.  We will not recover if this call
1061:FreeRTOS/Source/tasks.c **** 				fails, but we will report the failure. */
1062:FreeRTOS/Source/tasks.c **** 				prvInitialiseTaskLists();
1063:FreeRTOS/Source/tasks.c **** 			}
1064:FreeRTOS/Source/tasks.c **** 			else
1065:FreeRTOS/Source/tasks.c **** 			{
1066:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1067:FreeRTOS/Source/tasks.c **** 			}
1068:FreeRTOS/Source/tasks.c **** 		}
1069:FreeRTOS/Source/tasks.c **** 		else
1070:FreeRTOS/Source/tasks.c **** 		{
1071:FreeRTOS/Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1072:FreeRTOS/Source/tasks.c **** 			current task if it is the highest priority task to be created
1073:FreeRTOS/Source/tasks.c **** 			so far. */
1074:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1075:FreeRTOS/Source/tasks.c **** 			{
1076:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1077:FreeRTOS/Source/tasks.c **** 				{
1078:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1079:FreeRTOS/Source/tasks.c **** 				}
1080:FreeRTOS/Source/tasks.c **** 				else
1081:FreeRTOS/Source/tasks.c **** 				{
1082:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1083:FreeRTOS/Source/tasks.c **** 				}
1084:FreeRTOS/Source/tasks.c **** 			}
1085:FreeRTOS/Source/tasks.c **** 			else
1086:FreeRTOS/Source/tasks.c **** 			{
1087:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1088:FreeRTOS/Source/tasks.c **** 			}
1089:FreeRTOS/Source/tasks.c **** 		}
1090:FreeRTOS/Source/tasks.c **** 
1091:FreeRTOS/Source/tasks.c **** 		uxTaskNumber++;
1092:FreeRTOS/Source/tasks.c **** 
1093:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1094:FreeRTOS/Source/tasks.c **** 		{
1095:FreeRTOS/Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1096:FreeRTOS/Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1097:FreeRTOS/Source/tasks.c **** 		}
1098:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1099:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1100:FreeRTOS/Source/tasks.c **** 
1101:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1102:FreeRTOS/Source/tasks.c **** 
1103:FreeRTOS/Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1104:FreeRTOS/Source/tasks.c **** 	}
1105:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1106:FreeRTOS/Source/tasks.c **** 
1107:FreeRTOS/Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1108:FreeRTOS/Source/tasks.c **** 	{
1109:FreeRTOS/Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1110:FreeRTOS/Source/tasks.c **** 		then it should run now. */
1111:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1112:FreeRTOS/Source/tasks.c **** 		{
1113:FreeRTOS/Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1114:FreeRTOS/Source/tasks.c **** 		}
1115:FreeRTOS/Source/tasks.c **** 		else
1116:FreeRTOS/Source/tasks.c **** 		{
1117:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1118:FreeRTOS/Source/tasks.c **** 		}
1119:FreeRTOS/Source/tasks.c **** 	}
1120:FreeRTOS/Source/tasks.c **** 	else
1121:FreeRTOS/Source/tasks.c **** 	{
1122:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1123:FreeRTOS/Source/tasks.c **** 	}
1124:FreeRTOS/Source/tasks.c **** }
1125:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1128:FreeRTOS/Source/tasks.c **** 
1129:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1130:FreeRTOS/Source/tasks.c **** 	{
1131:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1132:FreeRTOS/Source/tasks.c **** 
1133:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1134:FreeRTOS/Source/tasks.c **** 		{
1135:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1136:FreeRTOS/Source/tasks.c **** 			being deleted. */
1137:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1138:FreeRTOS/Source/tasks.c **** 
1139:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list. */
1140:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1141:FreeRTOS/Source/tasks.c **** 			{
1142:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1143:FreeRTOS/Source/tasks.c **** 			}
1144:FreeRTOS/Source/tasks.c **** 			else
1145:FreeRTOS/Source/tasks.c **** 			{
1146:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1147:FreeRTOS/Source/tasks.c **** 			}
1148:FreeRTOS/Source/tasks.c **** 
1149:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1150:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1151:FreeRTOS/Source/tasks.c **** 			{
1152:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1153:FreeRTOS/Source/tasks.c **** 			}
1154:FreeRTOS/Source/tasks.c **** 			else
1155:FreeRTOS/Source/tasks.c **** 			{
1156:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1157:FreeRTOS/Source/tasks.c **** 			}
1158:FreeRTOS/Source/tasks.c **** 
1159:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1160:FreeRTOS/Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1161:FreeRTOS/Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1162:FreeRTOS/Source/tasks.c **** 			not return. */
1163:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
1164:FreeRTOS/Source/tasks.c **** 
1165:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1166:FreeRTOS/Source/tasks.c **** 			{
1167:FreeRTOS/Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1168:FreeRTOS/Source/tasks.c **** 				task itself, as a context switch to another task is required.
1169:FreeRTOS/Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1170:FreeRTOS/Source/tasks.c **** 				check the termination list and free up any memory allocated by
1171:FreeRTOS/Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1172:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1173:FreeRTOS/Source/tasks.c **** 
1174:FreeRTOS/Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1175:FreeRTOS/Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1176:FreeRTOS/Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1177:FreeRTOS/Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1178:FreeRTOS/Source/tasks.c **** 
1179:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1180:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1181:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
1182:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1183:FreeRTOS/Source/tasks.c **** 				required. */
1184:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1185:FreeRTOS/Source/tasks.c **** 			}
1186:FreeRTOS/Source/tasks.c **** 			else
1187:FreeRTOS/Source/tasks.c **** 			{
1188:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1189:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1190:FreeRTOS/Source/tasks.c **** 
1191:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1192:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
1193:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1194:FreeRTOS/Source/tasks.c **** 			}
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
1197:FreeRTOS/Source/tasks.c **** 		}
1198:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1199:FreeRTOS/Source/tasks.c **** 
1200:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1201:FreeRTOS/Source/tasks.c **** 		been deleted. */
1202:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1203:FreeRTOS/Source/tasks.c **** 		{
1204:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1205:FreeRTOS/Source/tasks.c **** 			{
1206:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1207:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1208:FreeRTOS/Source/tasks.c **** 			}
1209:FreeRTOS/Source/tasks.c **** 			else
1210:FreeRTOS/Source/tasks.c **** 			{
1211:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1212:FreeRTOS/Source/tasks.c **** 			}
1213:FreeRTOS/Source/tasks.c **** 		}
1214:FreeRTOS/Source/tasks.c **** 	}
1215:FreeRTOS/Source/tasks.c **** 
1216:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1217:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1218:FreeRTOS/Source/tasks.c **** 
1219:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1220:FreeRTOS/Source/tasks.c **** 
1221:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1222:FreeRTOS/Source/tasks.c **** 	{
1223:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
1224:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1225:FreeRTOS/Source/tasks.c **** 
1226:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1227:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1228:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1229:FreeRTOS/Source/tasks.c **** 
1230:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1231:FreeRTOS/Source/tasks.c **** 		{
1232:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1233:FreeRTOS/Source/tasks.c **** 			block. */
1234:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1235:FreeRTOS/Source/tasks.c **** 
1236:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1237:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1238:FreeRTOS/Source/tasks.c **** 
1239:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1240:FreeRTOS/Source/tasks.c **** 			{
1241:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
1242:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1243:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1244:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1245:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1246:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1247:FreeRTOS/Source/tasks.c **** 				{
1248:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1249:FreeRTOS/Source/tasks.c **** 				}
1250:FreeRTOS/Source/tasks.c **** 				else
1251:FreeRTOS/Source/tasks.c **** 				{
1252:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1253:FreeRTOS/Source/tasks.c **** 				}
1254:FreeRTOS/Source/tasks.c **** 			}
1255:FreeRTOS/Source/tasks.c **** 			else
1256:FreeRTOS/Source/tasks.c **** 			{
1257:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1258:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1259:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
1260:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1261:FreeRTOS/Source/tasks.c **** 				{
1262:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1263:FreeRTOS/Source/tasks.c **** 				}
1264:FreeRTOS/Source/tasks.c **** 				else
1265:FreeRTOS/Source/tasks.c **** 				{
1266:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1267:FreeRTOS/Source/tasks.c **** 				}
1268:FreeRTOS/Source/tasks.c **** 			}
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1271:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1272:FreeRTOS/Source/tasks.c **** 
1273:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1274:FreeRTOS/Source/tasks.c **** 			{
1275:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1276:FreeRTOS/Source/tasks.c **** 
1277:FreeRTOS/Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1278:FreeRTOS/Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1279:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1280:FreeRTOS/Source/tasks.c **** 			}
1281:FreeRTOS/Source/tasks.c **** 			else
1282:FreeRTOS/Source/tasks.c **** 			{
1283:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1284:FreeRTOS/Source/tasks.c **** 			}
1285:FreeRTOS/Source/tasks.c **** 		}
1286:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1287:FreeRTOS/Source/tasks.c **** 
1288:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1289:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1290:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1291:FreeRTOS/Source/tasks.c **** 		{
1292:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1293:FreeRTOS/Source/tasks.c **** 		}
1294:FreeRTOS/Source/tasks.c **** 		else
1295:FreeRTOS/Source/tasks.c **** 		{
1296:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1297:FreeRTOS/Source/tasks.c **** 		}
1298:FreeRTOS/Source/tasks.c **** 	}
1299:FreeRTOS/Source/tasks.c **** 
1300:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1301:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1302:FreeRTOS/Source/tasks.c **** 
1303:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1304:FreeRTOS/Source/tasks.c **** 
1305:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1306:FreeRTOS/Source/tasks.c **** 	{
1307:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1308:FreeRTOS/Source/tasks.c **** 
1309:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1310:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1311:FreeRTOS/Source/tasks.c **** 		{
1312:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1313:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
1314:FreeRTOS/Source/tasks.c **** 			{
1315:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
1316:FreeRTOS/Source/tasks.c **** 
1317:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
1318:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1319:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1320:FreeRTOS/Source/tasks.c **** 				is resumed.
1321:FreeRTOS/Source/tasks.c **** 
1322:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1323:FreeRTOS/Source/tasks.c **** 				executing task. */
1324:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1325:FreeRTOS/Source/tasks.c **** 			}
1326:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1327:FreeRTOS/Source/tasks.c **** 		}
1328:FreeRTOS/Source/tasks.c **** 		else
1329:FreeRTOS/Source/tasks.c **** 		{
1330:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1331:FreeRTOS/Source/tasks.c **** 		}
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1335:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1336:FreeRTOS/Source/tasks.c **** 		{
1337:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1338:FreeRTOS/Source/tasks.c **** 		}
1339:FreeRTOS/Source/tasks.c **** 		else
1340:FreeRTOS/Source/tasks.c **** 		{
1341:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1342:FreeRTOS/Source/tasks.c **** 		}
1343:FreeRTOS/Source/tasks.c **** 	}
1344:FreeRTOS/Source/tasks.c **** 
1345:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1346:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1347:FreeRTOS/Source/tasks.c **** 
1348:FreeRTOS/Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1349:FreeRTOS/Source/tasks.c **** 
1350:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1351:FreeRTOS/Source/tasks.c **** 	{
1352:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
1353:FreeRTOS/Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1354:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1355:FreeRTOS/Source/tasks.c **** 
1356:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1359:FreeRTOS/Source/tasks.c **** 		{
1360:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1361:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1362:FreeRTOS/Source/tasks.c **** 		}
1363:FreeRTOS/Source/tasks.c **** 		else
1364:FreeRTOS/Source/tasks.c **** 		{
1365:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1366:FreeRTOS/Source/tasks.c **** 			{
1367:FreeRTOS/Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1368:FreeRTOS/Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1369:FreeRTOS/Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1370:FreeRTOS/Source/tasks.c **** 			}
1371:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1374:FreeRTOS/Source/tasks.c **** 			{
1375:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1376:FreeRTOS/Source/tasks.c **** 				lists. */
1377:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1378:FreeRTOS/Source/tasks.c **** 			}
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1381:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1382:FreeRTOS/Source/tasks.c **** 				{
1383:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1384:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1385:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1386:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1387:FreeRTOS/Source/tasks.c **** 					{
1388:FreeRTOS/Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1389:FreeRTOS/Source/tasks.c **** 						{
1390:FreeRTOS/Source/tasks.c **** 							/* The task does not appear on the event list item of
1391:FreeRTOS/Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1392:FreeRTOS/Source/tasks.c **** 							blocked state if it is waiting on its notification
1393:FreeRTOS/Source/tasks.c **** 							rather than waiting on an object. */
1394:FreeRTOS/Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1395:FreeRTOS/Source/tasks.c **** 							{
1396:FreeRTOS/Source/tasks.c **** 								eReturn = eBlocked;
1397:FreeRTOS/Source/tasks.c **** 							}
1398:FreeRTOS/Source/tasks.c **** 							else
1399:FreeRTOS/Source/tasks.c **** 							{
1400:FreeRTOS/Source/tasks.c **** 								eReturn = eSuspended;
1401:FreeRTOS/Source/tasks.c **** 							}
1402:FreeRTOS/Source/tasks.c **** 						}
1403:FreeRTOS/Source/tasks.c **** 						#else
1404:FreeRTOS/Source/tasks.c **** 						{
1405:FreeRTOS/Source/tasks.c **** 							eReturn = eSuspended;
1406:FreeRTOS/Source/tasks.c **** 						}
1407:FreeRTOS/Source/tasks.c **** 						#endif
1408:FreeRTOS/Source/tasks.c **** 					}
1409:FreeRTOS/Source/tasks.c **** 					else
1410:FreeRTOS/Source/tasks.c **** 					{
1411:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1412:FreeRTOS/Source/tasks.c **** 					}
1413:FreeRTOS/Source/tasks.c **** 				}
1414:FreeRTOS/Source/tasks.c **** 			#endif
1415:FreeRTOS/Source/tasks.c **** 
1416:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1417:FreeRTOS/Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1418:FreeRTOS/Source/tasks.c **** 				{
1419:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1420:FreeRTOS/Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1421:FreeRTOS/Source/tasks.c **** 					all. */
1422:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1423:FreeRTOS/Source/tasks.c **** 				}
1424:FreeRTOS/Source/tasks.c **** 			#endif
1425:FreeRTOS/Source/tasks.c **** 
1426:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1427:FreeRTOS/Source/tasks.c **** 			{
1428:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1429:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1430:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1431:FreeRTOS/Source/tasks.c **** 			}
1432:FreeRTOS/Source/tasks.c **** 		}
1433:FreeRTOS/Source/tasks.c **** 
1434:FreeRTOS/Source/tasks.c **** 		return eReturn;
1435:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1436:FreeRTOS/Source/tasks.c **** 
1437:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1438:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1439:FreeRTOS/Source/tasks.c **** 
1440:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1441:FreeRTOS/Source/tasks.c **** 
1442:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1443:FreeRTOS/Source/tasks.c **** 	{
1444:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1445:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1446:FreeRTOS/Source/tasks.c **** 
1447:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1448:FreeRTOS/Source/tasks.c **** 		{
1449:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1450:FreeRTOS/Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1451:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1452:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1453:FreeRTOS/Source/tasks.c **** 		}
1454:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1455:FreeRTOS/Source/tasks.c **** 
1456:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1457:FreeRTOS/Source/tasks.c **** 	}
1458:FreeRTOS/Source/tasks.c **** 
1459:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1460:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1461:FreeRTOS/Source/tasks.c **** 
1462:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1463:FreeRTOS/Source/tasks.c **** 
1464:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1465:FreeRTOS/Source/tasks.c **** 	{
1466:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1467:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1468:FreeRTOS/Source/tasks.c **** 
1469:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1470:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1471:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1472:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1473:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1474:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1475:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1476:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1477:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1478:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1479:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1480:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1481:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1482:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1483:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1484:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1485:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1486:FreeRTOS/Source/tasks.c **** 
1487:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1488:FreeRTOS/Source/tasks.c **** 		{
1489:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1490:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1491:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1492:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1493:FreeRTOS/Source/tasks.c **** 		}
1494:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1495:FreeRTOS/Source/tasks.c **** 
1496:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1497:FreeRTOS/Source/tasks.c **** 	}
1498:FreeRTOS/Source/tasks.c **** 
1499:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1500:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1501:FreeRTOS/Source/tasks.c **** 
1502:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1503:FreeRTOS/Source/tasks.c **** 
1504:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1505:FreeRTOS/Source/tasks.c **** 	{
1506:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1507:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1508:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1509:FreeRTOS/Source/tasks.c **** 
1510:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1511:FreeRTOS/Source/tasks.c **** 
1512:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1513:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1516:FreeRTOS/Source/tasks.c **** 		}
1517:FreeRTOS/Source/tasks.c **** 		else
1518:FreeRTOS/Source/tasks.c **** 		{
1519:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1520:FreeRTOS/Source/tasks.c **** 		}
1521:FreeRTOS/Source/tasks.c **** 
1522:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1523:FreeRTOS/Source/tasks.c **** 		{
1524:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1525:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1526:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1527:FreeRTOS/Source/tasks.c **** 
1528:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1529:FreeRTOS/Source/tasks.c **** 
1530:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1531:FreeRTOS/Source/tasks.c **** 			{
1532:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1533:FreeRTOS/Source/tasks.c **** 			}
1534:FreeRTOS/Source/tasks.c **** 			#else
1535:FreeRTOS/Source/tasks.c **** 			{
1536:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1537:FreeRTOS/Source/tasks.c **** 			}
1538:FreeRTOS/Source/tasks.c **** 			#endif
1539:FreeRTOS/Source/tasks.c **** 
1540:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1541:FreeRTOS/Source/tasks.c **** 			{
1542:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1543:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1544:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1545:FreeRTOS/Source/tasks.c **** 				{
1546:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1547:FreeRTOS/Source/tasks.c **** 					{
1548:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1549:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1550:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1551:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1552:FreeRTOS/Source/tasks.c **** 						{
1553:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1554:FreeRTOS/Source/tasks.c **** 						}
1555:FreeRTOS/Source/tasks.c **** 						else
1556:FreeRTOS/Source/tasks.c **** 						{
1557:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1558:FreeRTOS/Source/tasks.c **** 						}
1559:FreeRTOS/Source/tasks.c **** 					}
1560:FreeRTOS/Source/tasks.c **** 					else
1561:FreeRTOS/Source/tasks.c **** 					{
1562:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1563:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1564:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1565:FreeRTOS/Source/tasks.c **** 					}
1566:FreeRTOS/Source/tasks.c **** 				}
1567:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1568:FreeRTOS/Source/tasks.c **** 				{
1569:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1570:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1571:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1572:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1573:FreeRTOS/Source/tasks.c **** 				}
1574:FreeRTOS/Source/tasks.c **** 				else
1575:FreeRTOS/Source/tasks.c **** 				{
1576:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1577:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1578:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1579:FreeRTOS/Source/tasks.c **** 				}
1580:FreeRTOS/Source/tasks.c **** 
1581:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1582:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1583:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1584:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1585:FreeRTOS/Source/tasks.c **** 
1586:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1587:FreeRTOS/Source/tasks.c **** 				{
1588:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1589:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1590:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1591:FreeRTOS/Source/tasks.c **** 					{
1592:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1593:FreeRTOS/Source/tasks.c **** 					}
1594:FreeRTOS/Source/tasks.c **** 					else
1595:FreeRTOS/Source/tasks.c **** 					{
1596:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1597:FreeRTOS/Source/tasks.c **** 					}
1598:FreeRTOS/Source/tasks.c **** 
1599:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1600:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1601:FreeRTOS/Source/tasks.c **** 				}
1602:FreeRTOS/Source/tasks.c **** 				#else
1603:FreeRTOS/Source/tasks.c **** 				{
1604:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1605:FreeRTOS/Source/tasks.c **** 				}
1606:FreeRTOS/Source/tasks.c **** 				#endif
1607:FreeRTOS/Source/tasks.c **** 
1608:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1609:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1610:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1611:FreeRTOS/Source/tasks.c **** 				{
1612:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1613:FreeRTOS/Source/tasks.c **** 				}
1614:FreeRTOS/Source/tasks.c **** 				else
1615:FreeRTOS/Source/tasks.c **** 				{
1616:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1617:FreeRTOS/Source/tasks.c **** 				}
1618:FreeRTOS/Source/tasks.c **** 
1619:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1620:FreeRTOS/Source/tasks.c **** 				nothing more than change its priority variable. However, if
1621:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1622:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1623:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1624:FreeRTOS/Source/tasks.c **** 				{
1625:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1626:FreeRTOS/Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1627:FreeRTOS/Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1628:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1629:FreeRTOS/Source/tasks.c **** 					{
1630:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1631:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1632:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1633:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1634:FreeRTOS/Source/tasks.c **** 					}
1635:FreeRTOS/Source/tasks.c **** 					else
1636:FreeRTOS/Source/tasks.c **** 					{
1637:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1638:FreeRTOS/Source/tasks.c **** 					}
1639:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1640:FreeRTOS/Source/tasks.c **** 				}
1641:FreeRTOS/Source/tasks.c **** 				else
1642:FreeRTOS/Source/tasks.c **** 				{
1643:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1644:FreeRTOS/Source/tasks.c **** 				}
1645:FreeRTOS/Source/tasks.c **** 
1646:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1647:FreeRTOS/Source/tasks.c **** 				{
1648:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1649:FreeRTOS/Source/tasks.c **** 				}
1650:FreeRTOS/Source/tasks.c **** 				else
1651:FreeRTOS/Source/tasks.c **** 				{
1652:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:FreeRTOS/Source/tasks.c **** 				}
1654:FreeRTOS/Source/tasks.c **** 
1655:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1656:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1657:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1658:FreeRTOS/Source/tasks.c **** 			}
1659:FreeRTOS/Source/tasks.c **** 		}
1660:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1661:FreeRTOS/Source/tasks.c **** 	}
1662:FreeRTOS/Source/tasks.c **** 
1663:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1664:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1665:FreeRTOS/Source/tasks.c **** 
1666:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1667:FreeRTOS/Source/tasks.c **** 
1668:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1669:FreeRTOS/Source/tasks.c **** 	{
1670:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1671:FreeRTOS/Source/tasks.c **** 
1672:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1673:FreeRTOS/Source/tasks.c **** 		{
1674:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1675:FreeRTOS/Source/tasks.c **** 			being suspended. */
1676:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1677:FreeRTOS/Source/tasks.c **** 
1678:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1679:FreeRTOS/Source/tasks.c **** 
1680:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1681:FreeRTOS/Source/tasks.c **** 			suspended list. */
1682:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1683:FreeRTOS/Source/tasks.c **** 			{
1684:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1685:FreeRTOS/Source/tasks.c **** 			}
1686:FreeRTOS/Source/tasks.c **** 			else
1687:FreeRTOS/Source/tasks.c **** 			{
1688:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1689:FreeRTOS/Source/tasks.c **** 			}
1690:FreeRTOS/Source/tasks.c **** 
1691:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1692:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1693:FreeRTOS/Source/tasks.c **** 			{
1694:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1695:FreeRTOS/Source/tasks.c **** 			}
1696:FreeRTOS/Source/tasks.c **** 			else
1697:FreeRTOS/Source/tasks.c **** 			{
1698:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1699:FreeRTOS/Source/tasks.c **** 			}
1700:FreeRTOS/Source/tasks.c **** 
1701:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1702:FreeRTOS/Source/tasks.c **** 
1703:FreeRTOS/Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1704:FreeRTOS/Source/tasks.c **** 			{
1705:FreeRTOS/Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1706:FreeRTOS/Source/tasks.c **** 				{
1707:FreeRTOS/Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1708:FreeRTOS/Source/tasks.c **** 					now suspended, so no notification was received. */
1709:FreeRTOS/Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1710:FreeRTOS/Source/tasks.c **** 				}
1711:FreeRTOS/Source/tasks.c **** 			}
1712:FreeRTOS/Source/tasks.c **** 			#endif
1713:FreeRTOS/Source/tasks.c **** 		}
1714:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1715:FreeRTOS/Source/tasks.c **** 
1716:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1717:FreeRTOS/Source/tasks.c **** 		{
1718:FreeRTOS/Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1719:FreeRTOS/Source/tasks.c **** 			task that is now in the Suspended state. */
1720:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1721:FreeRTOS/Source/tasks.c **** 			{
1722:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1723:FreeRTOS/Source/tasks.c **** 			}
1724:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1725:FreeRTOS/Source/tasks.c **** 		}
1726:FreeRTOS/Source/tasks.c **** 		else
1727:FreeRTOS/Source/tasks.c **** 		{
1728:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1729:FreeRTOS/Source/tasks.c **** 		}
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1732:FreeRTOS/Source/tasks.c **** 		{
1733:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1734:FreeRTOS/Source/tasks.c **** 			{
1735:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1736:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1737:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1738:FreeRTOS/Source/tasks.c **** 			}
1739:FreeRTOS/Source/tasks.c **** 			else
1740:FreeRTOS/Source/tasks.c **** 			{
1741:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1742:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1743:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1744:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1745:FreeRTOS/Source/tasks.c **** 				{
1746:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1747:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1748:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1749:FreeRTOS/Source/tasks.c **** 					is. */
1750:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1751:FreeRTOS/Source/tasks.c **** 				}
1752:FreeRTOS/Source/tasks.c **** 				else
1753:FreeRTOS/Source/tasks.c **** 				{
1754:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1755:FreeRTOS/Source/tasks.c **** 				}
1756:FreeRTOS/Source/tasks.c **** 			}
1757:FreeRTOS/Source/tasks.c **** 		}
1758:FreeRTOS/Source/tasks.c **** 		else
1759:FreeRTOS/Source/tasks.c **** 		{
1760:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1761:FreeRTOS/Source/tasks.c **** 		}
1762:FreeRTOS/Source/tasks.c **** 	}
1763:FreeRTOS/Source/tasks.c **** 
1764:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1765:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1768:FreeRTOS/Source/tasks.c **** 
1769:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1770:FreeRTOS/Source/tasks.c **** 	{
1771:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1772:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1773:FreeRTOS/Source/tasks.c **** 
1774:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1775:FreeRTOS/Source/tasks.c **** 		section. */
1776:FreeRTOS/Source/tasks.c **** 
1777:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1778:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1779:FreeRTOS/Source/tasks.c **** 
1780:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1781:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1782:FreeRTOS/Source/tasks.c **** 		{
1783:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1784:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1785:FreeRTOS/Source/tasks.c **** 			{
1786:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1787:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1788:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1789:FreeRTOS/Source/tasks.c **** 				{
1790:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1791:FreeRTOS/Source/tasks.c **** 				}
1792:FreeRTOS/Source/tasks.c **** 				else
1793:FreeRTOS/Source/tasks.c **** 				{
1794:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1795:FreeRTOS/Source/tasks.c **** 				}
1796:FreeRTOS/Source/tasks.c **** 			}
1797:FreeRTOS/Source/tasks.c **** 			else
1798:FreeRTOS/Source/tasks.c **** 			{
1799:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1800:FreeRTOS/Source/tasks.c **** 			}
1801:FreeRTOS/Source/tasks.c **** 		}
1802:FreeRTOS/Source/tasks.c **** 		else
1803:FreeRTOS/Source/tasks.c **** 		{
1804:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1805:FreeRTOS/Source/tasks.c **** 		}
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 		return xReturn;
1808:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1809:FreeRTOS/Source/tasks.c **** 
1810:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1811:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1812:FreeRTOS/Source/tasks.c **** 
1813:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1814:FreeRTOS/Source/tasks.c **** 
1815:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1816:FreeRTOS/Source/tasks.c **** 	{
1817:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1818:FreeRTOS/Source/tasks.c **** 
1819:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1820:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1821:FreeRTOS/Source/tasks.c **** 
1822:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1823:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1824:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1825:FreeRTOS/Source/tasks.c **** 		{
1826:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1827:FreeRTOS/Source/tasks.c **** 			{
1828:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1829:FreeRTOS/Source/tasks.c **** 				{
1830:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1831:FreeRTOS/Source/tasks.c **** 
1832:FreeRTOS/Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1833:FreeRTOS/Source/tasks.c **** 					suspended because this is inside a critical section. */
1834:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1835:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1836:FreeRTOS/Source/tasks.c **** 
1837:FreeRTOS/Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1838:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1839:FreeRTOS/Source/tasks.c **** 					{
1840:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1841:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1842:FreeRTOS/Source/tasks.c **** 						next yield. */
1843:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1844:FreeRTOS/Source/tasks.c **** 					}
1845:FreeRTOS/Source/tasks.c **** 					else
1846:FreeRTOS/Source/tasks.c **** 					{
1847:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Source/tasks.c **** 					}
1849:FreeRTOS/Source/tasks.c **** 				}
1850:FreeRTOS/Source/tasks.c **** 				else
1851:FreeRTOS/Source/tasks.c **** 				{
1852:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/Source/tasks.c **** 				}
1854:FreeRTOS/Source/tasks.c **** 			}
1855:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1856:FreeRTOS/Source/tasks.c **** 		}
1857:FreeRTOS/Source/tasks.c **** 		else
1858:FreeRTOS/Source/tasks.c **** 		{
1859:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1860:FreeRTOS/Source/tasks.c **** 		}
1861:FreeRTOS/Source/tasks.c **** 	}
1862:FreeRTOS/Source/tasks.c **** 
1863:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1866:FreeRTOS/Source/tasks.c **** 
1867:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1868:FreeRTOS/Source/tasks.c **** 
1869:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1870:FreeRTOS/Source/tasks.c **** 	{
1871:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1872:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1873:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1874:FreeRTOS/Source/tasks.c **** 
1875:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1876:FreeRTOS/Source/tasks.c **** 
1877:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1878:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1879:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1880:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1881:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1882:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1883:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1884:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1885:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1886:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1887:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1888:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1889:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1890:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1891:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1892:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1893:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1894:FreeRTOS/Source/tasks.c **** 
1895:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1896:FreeRTOS/Source/tasks.c **** 		{
1897:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1898:FreeRTOS/Source/tasks.c **** 			{
1899:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1902:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1903:FreeRTOS/Source/tasks.c **** 				{
1904:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1905:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1906:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1907:FreeRTOS/Source/tasks.c **** 					{
1908:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1909:FreeRTOS/Source/tasks.c **** 					}
1910:FreeRTOS/Source/tasks.c **** 					else
1911:FreeRTOS/Source/tasks.c **** 					{
1912:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1913:FreeRTOS/Source/tasks.c **** 					}
1914:FreeRTOS/Source/tasks.c **** 
1915:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1916:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1917:FreeRTOS/Source/tasks.c **** 				}
1918:FreeRTOS/Source/tasks.c **** 				else
1919:FreeRTOS/Source/tasks.c **** 				{
1920:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1921:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1922:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1923:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1924:FreeRTOS/Source/tasks.c **** 				}
1925:FreeRTOS/Source/tasks.c **** 			}
1926:FreeRTOS/Source/tasks.c **** 			else
1927:FreeRTOS/Source/tasks.c **** 			{
1928:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1929:FreeRTOS/Source/tasks.c **** 			}
1930:FreeRTOS/Source/tasks.c **** 		}
1931:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1932:FreeRTOS/Source/tasks.c **** 
1933:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1934:FreeRTOS/Source/tasks.c **** 	}
1935:FreeRTOS/Source/tasks.c **** 
1936:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1937:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1938:FreeRTOS/Source/tasks.c **** 
1939:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1940:FreeRTOS/Source/tasks.c **** {
1941:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1942:FreeRTOS/Source/tasks.c **** 
1943:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1944:FreeRTOS/Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1945:FreeRTOS/Source/tasks.c **** 	{
1946:FreeRTOS/Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1947:FreeRTOS/Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1948:FreeRTOS/Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1949:FreeRTOS/Source/tasks.c **** 
1950:FreeRTOS/Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1951:FreeRTOS/Source/tasks.c **** 		address of the RAM then create the idle task. */
1952:FreeRTOS/Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1953:FreeRTOS/Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1954:FreeRTOS/Source/tasks.c **** 												configIDLE_TASK_NAME,
1955:FreeRTOS/Source/tasks.c **** 												ulIdleTaskStackSize,
1956:FreeRTOS/Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1957:FreeRTOS/Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1958:FreeRTOS/Source/tasks.c **** 												pxIdleTaskStackBuffer,
1959:FreeRTOS/Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1960:FreeRTOS/Source/tasks.c **** 
1961:FreeRTOS/Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1962:FreeRTOS/Source/tasks.c **** 		{
1963:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
1964:FreeRTOS/Source/tasks.c **** 		}
1965:FreeRTOS/Source/tasks.c **** 		else
1966:FreeRTOS/Source/tasks.c **** 		{
1967:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 	}
1970:FreeRTOS/Source/tasks.c **** 	#else
1971:FreeRTOS/Source/tasks.c **** 	{
1972:FreeRTOS/Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1973:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1974:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
1975:FreeRTOS/Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
1976:FreeRTOS/Source/tasks.c **** 								( void * ) NULL,
1977:FreeRTOS/Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
1978:FreeRTOS/Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1979:FreeRTOS/Source/tasks.c **** 	}
1980:FreeRTOS/Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1981:FreeRTOS/Source/tasks.c **** 
1982:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1983:FreeRTOS/Source/tasks.c **** 	{
1984:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1985:FreeRTOS/Source/tasks.c **** 		{
1986:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1987:FreeRTOS/Source/tasks.c **** 		}
1988:FreeRTOS/Source/tasks.c **** 		else
1989:FreeRTOS/Source/tasks.c **** 		{
1990:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1991:FreeRTOS/Source/tasks.c **** 		}
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1994:FreeRTOS/Source/tasks.c **** 
1995:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1996:FreeRTOS/Source/tasks.c **** 	{
1997:FreeRTOS/Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1998:FreeRTOS/Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1999:FreeRTOS/Source/tasks.c **** 		the only macro called by the function. */
2000:FreeRTOS/Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2001:FreeRTOS/Source/tasks.c **** 		{
2002:FreeRTOS/Source/tasks.c **** 			freertos_tasks_c_additions_init();
2003:FreeRTOS/Source/tasks.c **** 		}
2004:FreeRTOS/Source/tasks.c **** 		#endif
2005:FreeRTOS/Source/tasks.c **** 
2006:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2007:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2008:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2009:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2010:FreeRTOS/Source/tasks.c **** 		starts to run. */
2011:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2014:FreeRTOS/Source/tasks.c **** 		{
2015:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2016:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
2017:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2018:FreeRTOS/Source/tasks.c **** 		}
2019:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2022:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
2023:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2024:FreeRTOS/Source/tasks.c **** 
2025:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2026:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2027:FreeRTOS/Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2028:FreeRTOS/Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2029:FreeRTOS/Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2030:FreeRTOS/Source/tasks.c **** 		FreeRTOSConfig.h file. */
2031:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2034:FreeRTOS/Source/tasks.c **** 
2035:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2036:FreeRTOS/Source/tasks.c **** 		portable interface. */
2037:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2038:FreeRTOS/Source/tasks.c **** 		{
2039:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2040:FreeRTOS/Source/tasks.c **** 			function will not return. */
2041:FreeRTOS/Source/tasks.c **** 		}
2042:FreeRTOS/Source/tasks.c **** 		else
2043:FreeRTOS/Source/tasks.c **** 		{
2044:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2045:FreeRTOS/Source/tasks.c **** 		}
2046:FreeRTOS/Source/tasks.c **** 	}
2047:FreeRTOS/Source/tasks.c **** 	else
2048:FreeRTOS/Source/tasks.c **** 	{
2049:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2050:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2051:FreeRTOS/Source/tasks.c **** 		or the timer task. */
2052:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2053:FreeRTOS/Source/tasks.c **** 	}
2054:FreeRTOS/Source/tasks.c **** 
2055:FreeRTOS/Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2056:FreeRTOS/Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2057:FreeRTOS/Source/tasks.c **** 	( void ) xIdleTaskHandle;
2058:FreeRTOS/Source/tasks.c **** }
2059:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2060:FreeRTOS/Source/tasks.c **** 
2061:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2062:FreeRTOS/Source/tasks.c **** {
2063:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2064:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2065:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2066:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2067:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2068:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
2069:FreeRTOS/Source/tasks.c **** }
2070:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2071:FreeRTOS/Source/tasks.c **** 
2072:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2073:FreeRTOS/Source/tasks.c **** {
2074:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2075:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2076:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2077:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
2078:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
2079:FreeRTOS/Source/tasks.c **** }
2080:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2081:FreeRTOS/Source/tasks.c **** 
2082:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
2087:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2088:FreeRTOS/Source/tasks.c **** 
2089:FreeRTOS/Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2090:FreeRTOS/Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2091:FreeRTOS/Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2092:FreeRTOS/Source/tasks.c **** 		running. */
2093:FreeRTOS/Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2094:FreeRTOS/Source/tasks.c **** 		{
2095:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2096:FreeRTOS/Source/tasks.c **** 			{
2097:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2098:FreeRTOS/Source/tasks.c **** 			}
2099:FreeRTOS/Source/tasks.c **** 		}
2100:FreeRTOS/Source/tasks.c **** 		#else
2101:FreeRTOS/Source/tasks.c **** 		{
2102:FreeRTOS/Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2103:FreeRTOS/Source/tasks.c **** 
2104:FreeRTOS/Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2105:FreeRTOS/Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2106:FreeRTOS/Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2107:FreeRTOS/Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2108:FreeRTOS/Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2109:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2110:FreeRTOS/Source/tasks.c **** 			{
2111:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2112:FreeRTOS/Source/tasks.c **** 			}
2113:FreeRTOS/Source/tasks.c **** 		}
2114:FreeRTOS/Source/tasks.c **** 		#endif
2115:FreeRTOS/Source/tasks.c **** 
2116:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2117:FreeRTOS/Source/tasks.c **** 		{
2118:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2119:FreeRTOS/Source/tasks.c **** 		}
2120:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2121:FreeRTOS/Source/tasks.c **** 		{
2122:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2123:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2124:FreeRTOS/Source/tasks.c **** 			processed. */
2125:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2126:FreeRTOS/Source/tasks.c **** 		}
2127:FreeRTOS/Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2128:FreeRTOS/Source/tasks.c **** 		{
2129:FreeRTOS/Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2130:FreeRTOS/Source/tasks.c **** 			idle priority.  This path can only be reached if
2131:FreeRTOS/Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2132:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2133:FreeRTOS/Source/tasks.c **** 		}
2134:FreeRTOS/Source/tasks.c **** 		else
2135:FreeRTOS/Source/tasks.c **** 		{
2136:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2137:FreeRTOS/Source/tasks.c **** 		}
2138:FreeRTOS/Source/tasks.c **** 
2139:FreeRTOS/Source/tasks.c **** 		return xReturn;
2140:FreeRTOS/Source/tasks.c **** 	}
2141:FreeRTOS/Source/tasks.c **** 
2142:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2143:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2144:FreeRTOS/Source/tasks.c **** 
2145:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2146:FreeRTOS/Source/tasks.c **** {
2147:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
2148:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2149:FreeRTOS/Source/tasks.c **** 
2150:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2151:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2152:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2153:FreeRTOS/Source/tasks.c **** 
2154:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2155:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2156:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2157:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2158:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2159:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2160:FreeRTOS/Source/tasks.c **** 	{
2161:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
2162:FreeRTOS/Source/tasks.c **** 
2163:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2164:FreeRTOS/Source/tasks.c **** 		{
2165:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2166:FreeRTOS/Source/tasks.c **** 			{
2167:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2168:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
2169:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2170:FreeRTOS/Source/tasks.c **** 				{
2171:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2172:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2173:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2174:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2175:FreeRTOS/Source/tasks.c **** 
2176:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2177:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
2178:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2179:FreeRTOS/Source/tasks.c **** 					{
2180:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2181:FreeRTOS/Source/tasks.c **** 					}
2182:FreeRTOS/Source/tasks.c **** 					else
2183:FreeRTOS/Source/tasks.c **** 					{
2184:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2185:FreeRTOS/Source/tasks.c **** 					}
2186:FreeRTOS/Source/tasks.c **** 				}
2187:FreeRTOS/Source/tasks.c **** 
2188:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2189:FreeRTOS/Source/tasks.c **** 				{
2190:FreeRTOS/Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2191:FreeRTOS/Source/tasks.c **** 					which may have prevented the next unblock time from being
2192:FreeRTOS/Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2193:FreeRTOS/Source/tasks.c **** 					important for low power tickless implementations, where
2194:FreeRTOS/Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2195:FreeRTOS/Source/tasks.c **** 					state. */
2196:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2197:FreeRTOS/Source/tasks.c **** 				}
2198:FreeRTOS/Source/tasks.c **** 
2199:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2200:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2201:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2202:FreeRTOS/Source/tasks.c **** 				time. */
2203:FreeRTOS/Source/tasks.c **** 				{
2204:FreeRTOS/Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2205:FreeRTOS/Source/tasks.c **** 
2206:FreeRTOS/Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2207:FreeRTOS/Source/tasks.c **** 					{
2208:FreeRTOS/Source/tasks.c **** 						do
2209:FreeRTOS/Source/tasks.c **** 						{
2210:FreeRTOS/Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2211:FreeRTOS/Source/tasks.c **** 							{
2212:FreeRTOS/Source/tasks.c **** 								xYieldPending = pdTRUE;
2213:FreeRTOS/Source/tasks.c **** 							}
2214:FreeRTOS/Source/tasks.c **** 							else
2215:FreeRTOS/Source/tasks.c **** 							{
2216:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2217:FreeRTOS/Source/tasks.c **** 							}
2218:FreeRTOS/Source/tasks.c **** 							--uxPendedCounts;
2219:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 						uxPendedTicks = 0;
2222:FreeRTOS/Source/tasks.c **** 					}
2223:FreeRTOS/Source/tasks.c **** 					else
2224:FreeRTOS/Source/tasks.c **** 					{
2225:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2226:FreeRTOS/Source/tasks.c **** 					}
2227:FreeRTOS/Source/tasks.c **** 				}
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2230:FreeRTOS/Source/tasks.c **** 				{
2231:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2232:FreeRTOS/Source/tasks.c **** 					{
2233:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2234:FreeRTOS/Source/tasks.c **** 					}
2235:FreeRTOS/Source/tasks.c **** 					#endif
2236:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2237:FreeRTOS/Source/tasks.c **** 				}
2238:FreeRTOS/Source/tasks.c **** 				else
2239:FreeRTOS/Source/tasks.c **** 				{
2240:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2241:FreeRTOS/Source/tasks.c **** 				}
2242:FreeRTOS/Source/tasks.c **** 			}
2243:FreeRTOS/Source/tasks.c **** 		}
2244:FreeRTOS/Source/tasks.c **** 		else
2245:FreeRTOS/Source/tasks.c **** 		{
2246:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2247:FreeRTOS/Source/tasks.c **** 		}
2248:FreeRTOS/Source/tasks.c **** 	}
2249:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2250:FreeRTOS/Source/tasks.c **** 
2251:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
2252:FreeRTOS/Source/tasks.c **** }
2253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2254:FreeRTOS/Source/tasks.c **** 
2255:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2256:FreeRTOS/Source/tasks.c **** {
2257:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
2258:FreeRTOS/Source/tasks.c **** 
2259:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2260:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2261:FreeRTOS/Source/tasks.c **** 	{
2262:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
2263:FreeRTOS/Source/tasks.c **** 	}
2264:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2265:FreeRTOS/Source/tasks.c **** 
2266:FreeRTOS/Source/tasks.c **** 	return xTicks;
2267:FreeRTOS/Source/tasks.c **** }
2268:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2269:FreeRTOS/Source/tasks.c **** 
2270:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2271:FreeRTOS/Source/tasks.c **** {
2272:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
2273:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2274:FreeRTOS/Source/tasks.c **** 
2275:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2276:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2277:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2278:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2279:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2280:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2281:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2282:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2283:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2284:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2285:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2286:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2287:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2288:FreeRTOS/Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2289:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2290:FreeRTOS/Source/tasks.c **** 
2291:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2292:FreeRTOS/Source/tasks.c **** 	{
2293:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
2294:FreeRTOS/Source/tasks.c **** 	}
2295:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2296:FreeRTOS/Source/tasks.c **** 
2297:FreeRTOS/Source/tasks.c **** 	return xReturn;
2298:FreeRTOS/Source/tasks.c **** }
2299:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2300:FreeRTOS/Source/tasks.c **** 
2301:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2302:FreeRTOS/Source/tasks.c **** {
2303:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2304:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
2305:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2306:FreeRTOS/Source/tasks.c **** }
2307:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2308:FreeRTOS/Source/tasks.c **** 
2309:FreeRTOS/Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2310:FreeRTOS/Source/tasks.c **** {
2311:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
2312:FreeRTOS/Source/tasks.c **** 
2313:FreeRTOS/Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2314:FreeRTOS/Source/tasks.c **** 	queried. */
2315:FreeRTOS/Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2316:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
2317:FreeRTOS/Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2318:FreeRTOS/Source/tasks.c **** }
2319:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2320:FreeRTOS/Source/tasks.c **** 
2321:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2322:FreeRTOS/Source/tasks.c **** 
2323:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2324:FreeRTOS/Source/tasks.c **** 	{
2325:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2326:FreeRTOS/Source/tasks.c **** 	UBaseType_t x;
2327:FreeRTOS/Source/tasks.c **** 	char cNextChar;
2328:FreeRTOS/Source/tasks.c **** 	BaseType_t xBreakLoop;
2329:FreeRTOS/Source/tasks.c **** 
2330:FreeRTOS/Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2331:FreeRTOS/Source/tasks.c **** 
2332:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2335:FreeRTOS/Source/tasks.c **** 
2336:FreeRTOS/Source/tasks.c **** 			do
2337:FreeRTOS/Source/tasks.c **** 			{
2338:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 				/* Check each character in the name looking for a match or
2341:FreeRTOS/Source/tasks.c **** 				mismatch. */
2342:FreeRTOS/Source/tasks.c **** 				xBreakLoop = pdFALSE;
2343:FreeRTOS/Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2344:FreeRTOS/Source/tasks.c **** 				{
2345:FreeRTOS/Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2346:FreeRTOS/Source/tasks.c **** 
2347:FreeRTOS/Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2348:FreeRTOS/Source/tasks.c **** 					{
2349:FreeRTOS/Source/tasks.c **** 						/* Characters didn't match. */
2350:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2351:FreeRTOS/Source/tasks.c **** 					}
2352:FreeRTOS/Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2353:FreeRTOS/Source/tasks.c **** 					{
2354:FreeRTOS/Source/tasks.c **** 						/* Both strings terminated, a match must have been
2355:FreeRTOS/Source/tasks.c **** 						found. */
2356:FreeRTOS/Source/tasks.c **** 						pxReturn = pxNextTCB;
2357:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2358:FreeRTOS/Source/tasks.c **** 					}
2359:FreeRTOS/Source/tasks.c **** 					else
2360:FreeRTOS/Source/tasks.c **** 					{
2361:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2362:FreeRTOS/Source/tasks.c **** 					}
2363:FreeRTOS/Source/tasks.c **** 
2364:FreeRTOS/Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2365:FreeRTOS/Source/tasks.c **** 					{
2366:FreeRTOS/Source/tasks.c **** 						break;
2367:FreeRTOS/Source/tasks.c **** 					}
2368:FreeRTOS/Source/tasks.c **** 				}
2369:FreeRTOS/Source/tasks.c **** 
2370:FreeRTOS/Source/tasks.c **** 				if( pxReturn != NULL )
2371:FreeRTOS/Source/tasks.c **** 				{
2372:FreeRTOS/Source/tasks.c **** 					/* The handle has been found. */
2373:FreeRTOS/Source/tasks.c **** 					break;
2374:FreeRTOS/Source/tasks.c **** 				}
2375:FreeRTOS/Source/tasks.c **** 
2376:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2377:FreeRTOS/Source/tasks.c **** 		}
2378:FreeRTOS/Source/tasks.c **** 		else
2379:FreeRTOS/Source/tasks.c **** 		{
2380:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2381:FreeRTOS/Source/tasks.c **** 		}
2382:FreeRTOS/Source/tasks.c **** 
2383:FreeRTOS/Source/tasks.c **** 		return pxReturn;
2384:FreeRTOS/Source/tasks.c **** 	}
2385:FreeRTOS/Source/tasks.c **** 
2386:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2387:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2390:FreeRTOS/Source/tasks.c **** 
2391:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2392:FreeRTOS/Source/tasks.c **** 	{
2393:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2394:FreeRTOS/Source/tasks.c **** 	TCB_t* pxTCB;
2395:FreeRTOS/Source/tasks.c **** 
2396:FreeRTOS/Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2397:FreeRTOS/Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2398:FreeRTOS/Source/tasks.c **** 
2399:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2400:FreeRTOS/Source/tasks.c **** 		{
2401:FreeRTOS/Source/tasks.c **** 			/* Search the ready lists. */
2402:FreeRTOS/Source/tasks.c **** 			do
2403:FreeRTOS/Source/tasks.c **** 			{
2404:FreeRTOS/Source/tasks.c **** 				uxQueue--;
2405:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2408:FreeRTOS/Source/tasks.c **** 				{
2409:FreeRTOS/Source/tasks.c **** 					/* Found the handle. */
2410:FreeRTOS/Source/tasks.c **** 					break;
2411:FreeRTOS/Source/tasks.c **** 				}
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 			/* Search the delayed lists. */
2416:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2417:FreeRTOS/Source/tasks.c **** 			{
2418:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2419:FreeRTOS/Source/tasks.c **** 			}
2420:FreeRTOS/Source/tasks.c **** 
2421:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2422:FreeRTOS/Source/tasks.c **** 			{
2423:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2424:FreeRTOS/Source/tasks.c **** 			}
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2427:FreeRTOS/Source/tasks.c **** 			{
2428:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2429:FreeRTOS/Source/tasks.c **** 				{
2430:FreeRTOS/Source/tasks.c **** 					/* Search the suspended list. */
2431:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2432:FreeRTOS/Source/tasks.c **** 				}
2433:FreeRTOS/Source/tasks.c **** 			}
2434:FreeRTOS/Source/tasks.c **** 			#endif
2435:FreeRTOS/Source/tasks.c **** 
2436:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2437:FreeRTOS/Source/tasks.c **** 			{
2438:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2439:FreeRTOS/Source/tasks.c **** 				{
2440:FreeRTOS/Source/tasks.c **** 					/* Search the deleted list. */
2441:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2442:FreeRTOS/Source/tasks.c **** 				}
2443:FreeRTOS/Source/tasks.c **** 			}
2444:FreeRTOS/Source/tasks.c **** 			#endif
2445:FreeRTOS/Source/tasks.c **** 		}
2446:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2447:FreeRTOS/Source/tasks.c **** 
2448:FreeRTOS/Source/tasks.c **** 		return pxTCB;
2449:FreeRTOS/Source/tasks.c **** 	}
2450:FreeRTOS/Source/tasks.c **** 
2451:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2452:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2453:FreeRTOS/Source/tasks.c **** 
2454:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2455:FreeRTOS/Source/tasks.c **** 
2456:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2457:FreeRTOS/Source/tasks.c **** 	{
2458:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2459:FreeRTOS/Source/tasks.c **** 
2460:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2461:FreeRTOS/Source/tasks.c **** 		{
2462:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2463:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2464:FreeRTOS/Source/tasks.c **** 			{
2465:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2466:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
2467:FreeRTOS/Source/tasks.c **** 				do
2468:FreeRTOS/Source/tasks.c **** 				{
2469:FreeRTOS/Source/tasks.c **** 					uxQueue--;
2470:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2471:FreeRTOS/Source/tasks.c **** 
2472:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2473:FreeRTOS/Source/tasks.c **** 
2474:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2475:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
2476:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2477:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2478:FreeRTOS/Source/tasks.c **** 
2479:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2480:FreeRTOS/Source/tasks.c **** 				{
2481:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2482:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2483:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2484:FreeRTOS/Source/tasks.c **** 				}
2485:FreeRTOS/Source/tasks.c **** 				#endif
2486:FreeRTOS/Source/tasks.c **** 
2487:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2488:FreeRTOS/Source/tasks.c **** 				{
2489:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2490:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
2491:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2492:FreeRTOS/Source/tasks.c **** 				}
2493:FreeRTOS/Source/tasks.c **** 				#endif
2494:FreeRTOS/Source/tasks.c **** 
2495:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2496:FreeRTOS/Source/tasks.c **** 				{
2497:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2498:FreeRTOS/Source/tasks.c **** 					{
2499:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2500:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2501:FreeRTOS/Source/tasks.c **** 						#else
2502:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2503:FreeRTOS/Source/tasks.c **** 						#endif
2504:FreeRTOS/Source/tasks.c **** 					}
2505:FreeRTOS/Source/tasks.c **** 				}
2506:FreeRTOS/Source/tasks.c **** 				#else
2507:FreeRTOS/Source/tasks.c **** 				{
2508:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2509:FreeRTOS/Source/tasks.c **** 					{
2510:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
2511:FreeRTOS/Source/tasks.c **** 					}
2512:FreeRTOS/Source/tasks.c **** 				}
2513:FreeRTOS/Source/tasks.c **** 				#endif
2514:FreeRTOS/Source/tasks.c **** 			}
2515:FreeRTOS/Source/tasks.c **** 			else
2516:FreeRTOS/Source/tasks.c **** 			{
2517:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2518:FreeRTOS/Source/tasks.c **** 			}
2519:FreeRTOS/Source/tasks.c **** 		}
2520:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2521:FreeRTOS/Source/tasks.c **** 
2522:FreeRTOS/Source/tasks.c **** 		return uxTask;
2523:FreeRTOS/Source/tasks.c **** 	}
2524:FreeRTOS/Source/tasks.c **** 
2525:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2527:FreeRTOS/Source/tasks.c **** 
2528:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2529:FreeRTOS/Source/tasks.c **** 
2530:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2531:FreeRTOS/Source/tasks.c **** 	{
2532:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2533:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2534:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2535:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
2536:FreeRTOS/Source/tasks.c **** 	}
2537:FreeRTOS/Source/tasks.c **** 
2538:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2539:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2540:FreeRTOS/Source/tasks.c **** 
2541:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2542:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2543:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2544:FreeRTOS/Source/tasks.c **** 1. */
2545:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2546:FreeRTOS/Source/tasks.c **** 
2547:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2548:FreeRTOS/Source/tasks.c **** 	{
2549:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2550:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2551:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
2552:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2553:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
2554:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2555:FreeRTOS/Source/tasks.c **** 	}
2556:FreeRTOS/Source/tasks.c **** 
2557:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2558:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2559:FreeRTOS/Source/tasks.c **** 
2560:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2561:FreeRTOS/Source/tasks.c **** 
2562:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2563:FreeRTOS/Source/tasks.c **** 	{
2564:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2565:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2566:FreeRTOS/Source/tasks.c **** 
2567:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
2568:FreeRTOS/Source/tasks.c **** 
2569:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2570:FreeRTOS/Source/tasks.c **** 		{
2571:FreeRTOS/Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2572:FreeRTOS/Source/tasks.c **** 			it is actually in the Blocked state. */
2573:FreeRTOS/Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2574:FreeRTOS/Source/tasks.c **** 			{
2575:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
2576:FreeRTOS/Source/tasks.c **** 
2577:FreeRTOS/Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2578:FreeRTOS/Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2579:FreeRTOS/Source/tasks.c **** 				scheduler is suspended. */
2580:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2581:FreeRTOS/Source/tasks.c **** 
2582:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2583:FreeRTOS/Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2584:FreeRTOS/Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2585:FreeRTOS/Source/tasks.c **** 				is used. */
2586:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2587:FreeRTOS/Source/tasks.c **** 				{
2588:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2589:FreeRTOS/Source/tasks.c **** 					{
2590:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2591:FreeRTOS/Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2592:FreeRTOS/Source/tasks.c **** 					}
2593:FreeRTOS/Source/tasks.c **** 					else
2594:FreeRTOS/Source/tasks.c **** 					{
2595:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2596:FreeRTOS/Source/tasks.c **** 					}
2597:FreeRTOS/Source/tasks.c **** 				}
2598:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2599:FreeRTOS/Source/tasks.c **** 
2600:FreeRTOS/Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2601:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2602:FreeRTOS/Source/tasks.c **** 
2603:FreeRTOS/Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2604:FreeRTOS/Source/tasks.c **** 				switch if preemption is turned off. */
2605:FreeRTOS/Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2606:FreeRTOS/Source/tasks.c **** 				{
2607:FreeRTOS/Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2608:FreeRTOS/Source/tasks.c **** 					performed if the unblocked task has a priority that is
2609:FreeRTOS/Source/tasks.c **** 					equal to or higher than the currently executing task. */
2610:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2611:FreeRTOS/Source/tasks.c **** 					{
2612:FreeRTOS/Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2613:FreeRTOS/Source/tasks.c **** 						is unsuspended. */
2614:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2615:FreeRTOS/Source/tasks.c **** 					}
2616:FreeRTOS/Source/tasks.c **** 					else
2617:FreeRTOS/Source/tasks.c **** 					{
2618:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2619:FreeRTOS/Source/tasks.c **** 					}
2620:FreeRTOS/Source/tasks.c **** 				}
2621:FreeRTOS/Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2622:FreeRTOS/Source/tasks.c **** 			}
2623:FreeRTOS/Source/tasks.c **** 			else
2624:FreeRTOS/Source/tasks.c **** 			{
2625:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
2626:FreeRTOS/Source/tasks.c **** 			}
2627:FreeRTOS/Source/tasks.c **** 		}
2628:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2629:FreeRTOS/Source/tasks.c **** 
2630:FreeRTOS/Source/tasks.c **** 		return xReturn;
2631:FreeRTOS/Source/tasks.c **** 	}
2632:FreeRTOS/Source/tasks.c **** 
2633:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2634:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2635:FreeRTOS/Source/tasks.c **** 
2636:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2637:FreeRTOS/Source/tasks.c **** {
2638:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
2639:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
2640:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2641:FreeRTOS/Source/tasks.c **** 
2642:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2643:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2644:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
2645:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2646:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2647:FreeRTOS/Source/tasks.c **** 	{
2648:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2649:FreeRTOS/Source/tasks.c **** 		block. */
2650:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2651:FreeRTOS/Source/tasks.c **** 
2652:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2653:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
2654:FreeRTOS/Source/tasks.c **** 		xTickCount = xConstTickCount;
2655:FreeRTOS/Source/tasks.c **** 
2656:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2657:FreeRTOS/Source/tasks.c **** 		{
2658:FreeRTOS/Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2659:FreeRTOS/Source/tasks.c **** 		}
2660:FreeRTOS/Source/tasks.c **** 		else
2661:FreeRTOS/Source/tasks.c **** 		{
2662:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2663:FreeRTOS/Source/tasks.c **** 		}
2664:FreeRTOS/Source/tasks.c **** 
2665:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2666:FreeRTOS/Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2667:FreeRTOS/Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2668:FreeRTOS/Source/tasks.c **** 		look any further down the list. */
2669:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2670:FreeRTOS/Source/tasks.c **** 		{
2671:FreeRTOS/Source/tasks.c **** 			for( ;; )
2672:FreeRTOS/Source/tasks.c **** 			{
2673:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2674:FreeRTOS/Source/tasks.c **** 				{
2675:FreeRTOS/Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2676:FreeRTOS/Source/tasks.c **** 					to the maximum possible value so it is extremely
2677:FreeRTOS/Source/tasks.c **** 					unlikely that the
2678:FreeRTOS/Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2679:FreeRTOS/Source/tasks.c **** 					next time through. */
2680:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2681:FreeRTOS/Source/tasks.c **** 					break;
2682:FreeRTOS/Source/tasks.c **** 				}
2683:FreeRTOS/Source/tasks.c **** 				else
2684:FreeRTOS/Source/tasks.c **** 				{
2685:FreeRTOS/Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2686:FreeRTOS/Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2687:FreeRTOS/Source/tasks.c **** 					at which the task at the head of the delayed list must
2688:FreeRTOS/Source/tasks.c **** 					be removed from the Blocked state. */
2689:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2690:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2691:FreeRTOS/Source/tasks.c **** 
2692:FreeRTOS/Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2693:FreeRTOS/Source/tasks.c **** 					{
2694:FreeRTOS/Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2695:FreeRTOS/Source/tasks.c **** 						item value is the time at which the task at the head
2696:FreeRTOS/Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2697:FreeRTOS/Source/tasks.c **** 						state -	so record the item value in
2698:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime. */
2699:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2700:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2701:FreeRTOS/Source/tasks.c **** 					}
2702:FreeRTOS/Source/tasks.c **** 					else
2703:FreeRTOS/Source/tasks.c **** 					{
2704:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2705:FreeRTOS/Source/tasks.c **** 					}
2706:FreeRTOS/Source/tasks.c **** 
2707:FreeRTOS/Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2708:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2709:FreeRTOS/Source/tasks.c **** 
2710:FreeRTOS/Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2711:FreeRTOS/Source/tasks.c **** 					it from the event list. */
2712:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2713:FreeRTOS/Source/tasks.c **** 					{
2714:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2715:FreeRTOS/Source/tasks.c **** 					}
2716:FreeRTOS/Source/tasks.c **** 					else
2717:FreeRTOS/Source/tasks.c **** 					{
2718:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2719:FreeRTOS/Source/tasks.c **** 					}
2720:FreeRTOS/Source/tasks.c **** 
2721:FreeRTOS/Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2722:FreeRTOS/Source/tasks.c **** 					list. */
2723:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2724:FreeRTOS/Source/tasks.c **** 
2725:FreeRTOS/Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2726:FreeRTOS/Source/tasks.c **** 					context switch if preemption is turned off. */
2727:FreeRTOS/Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2728:FreeRTOS/Source/tasks.c **** 					{
2729:FreeRTOS/Source/tasks.c **** 						/* Preemption is on, but a context switch should
2730:FreeRTOS/Source/tasks.c **** 						only be performed if the unblocked task has a
2731:FreeRTOS/Source/tasks.c **** 						priority that is equal to or higher than the
2732:FreeRTOS/Source/tasks.c **** 						currently executing task. */
2733:FreeRTOS/Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2734:FreeRTOS/Source/tasks.c **** 						{
2735:FreeRTOS/Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2736:FreeRTOS/Source/tasks.c **** 						}
2737:FreeRTOS/Source/tasks.c **** 						else
2738:FreeRTOS/Source/tasks.c **** 						{
2739:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2740:FreeRTOS/Source/tasks.c **** 						}
2741:FreeRTOS/Source/tasks.c **** 					}
2742:FreeRTOS/Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2743:FreeRTOS/Source/tasks.c **** 				}
2744:FreeRTOS/Source/tasks.c **** 			}
2745:FreeRTOS/Source/tasks.c **** 		}
2746:FreeRTOS/Source/tasks.c **** 
2747:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2748:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2749:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2750:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2751:FreeRTOS/Source/tasks.c **** 		{
2752:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2753:FreeRTOS/Source/tasks.c **** 			{
2754:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2755:FreeRTOS/Source/tasks.c **** 			}
2756:FreeRTOS/Source/tasks.c **** 			else
2757:FreeRTOS/Source/tasks.c **** 			{
2758:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2759:FreeRTOS/Source/tasks.c **** 			}
2760:FreeRTOS/Source/tasks.c **** 		}
2761:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2762:FreeRTOS/Source/tasks.c **** 
2763:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2764:FreeRTOS/Source/tasks.c **** 		{
2765:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2766:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2767:FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2768:FreeRTOS/Source/tasks.c **** 			{
2769:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2770:FreeRTOS/Source/tasks.c **** 			}
2771:FreeRTOS/Source/tasks.c **** 			else
2772:FreeRTOS/Source/tasks.c **** 			{
2773:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2774:FreeRTOS/Source/tasks.c **** 			}
2775:FreeRTOS/Source/tasks.c **** 		}
2776:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2777:FreeRTOS/Source/tasks.c **** 	}
2778:FreeRTOS/Source/tasks.c **** 	else
2779:FreeRTOS/Source/tasks.c **** 	{
2780:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
2781:FreeRTOS/Source/tasks.c **** 
2782:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2783:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2784:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2785:FreeRTOS/Source/tasks.c **** 		{
2786:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2787:FreeRTOS/Source/tasks.c **** 		}
2788:FreeRTOS/Source/tasks.c **** 		#endif
2789:FreeRTOS/Source/tasks.c **** 	}
2790:FreeRTOS/Source/tasks.c **** 
2791:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2792:FreeRTOS/Source/tasks.c **** 	{
2793:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2794:FreeRTOS/Source/tasks.c **** 		{
2795:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2796:FreeRTOS/Source/tasks.c **** 		}
2797:FreeRTOS/Source/tasks.c **** 		else
2798:FreeRTOS/Source/tasks.c **** 		{
2799:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2800:FreeRTOS/Source/tasks.c **** 		}
2801:FreeRTOS/Source/tasks.c **** 	}
2802:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2803:FreeRTOS/Source/tasks.c **** 
2804:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2805:FreeRTOS/Source/tasks.c **** }
2806:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2807:FreeRTOS/Source/tasks.c **** 
2808:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2809:FreeRTOS/Source/tasks.c **** 
2810:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2811:FreeRTOS/Source/tasks.c **** 	{
2812:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2813:FreeRTOS/Source/tasks.c **** 
2814:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2815:FreeRTOS/Source/tasks.c **** 		getting set. */
2816:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2817:FreeRTOS/Source/tasks.c **** 		{
2818:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2819:FreeRTOS/Source/tasks.c **** 		}
2820:FreeRTOS/Source/tasks.c **** 		else
2821:FreeRTOS/Source/tasks.c **** 		{
2822:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2823:FreeRTOS/Source/tasks.c **** 		}
2824:FreeRTOS/Source/tasks.c **** 
2825:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2826:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2827:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2828:FreeRTOS/Source/tasks.c **** 		{
2829:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2830:FreeRTOS/Source/tasks.c **** 		}
2831:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2832:FreeRTOS/Source/tasks.c **** 	}
2833:FreeRTOS/Source/tasks.c **** 
2834:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2835:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2836:FreeRTOS/Source/tasks.c **** 
2837:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2838:FreeRTOS/Source/tasks.c **** 
2839:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2840:FreeRTOS/Source/tasks.c **** 	{
2841:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2842:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2843:FreeRTOS/Source/tasks.c **** 
2844:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2845:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2846:FreeRTOS/Source/tasks.c **** 		{
2847:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2848:FreeRTOS/Source/tasks.c **** 		}
2849:FreeRTOS/Source/tasks.c **** 		else
2850:FreeRTOS/Source/tasks.c **** 		{
2851:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2852:FreeRTOS/Source/tasks.c **** 		}
2853:FreeRTOS/Source/tasks.c **** 
2854:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2855:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2856:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2857:FreeRTOS/Source/tasks.c **** 		{
2858:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2859:FreeRTOS/Source/tasks.c **** 		}
2860:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2861:FreeRTOS/Source/tasks.c **** 
2862:FreeRTOS/Source/tasks.c **** 		return xReturn;
2863:FreeRTOS/Source/tasks.c **** 	}
2864:FreeRTOS/Source/tasks.c **** 
2865:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2867:FreeRTOS/Source/tasks.c **** 
2868:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2869:FreeRTOS/Source/tasks.c **** 
2870:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2871:FreeRTOS/Source/tasks.c **** 	{
2872:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2873:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2874:FreeRTOS/Source/tasks.c **** 
2875:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2876:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2877:FreeRTOS/Source/tasks.c **** 		{
2878:FreeRTOS/Source/tasks.c **** 			xTCB = pxCurrentTCB;
2879:FreeRTOS/Source/tasks.c **** 		}
2880:FreeRTOS/Source/tasks.c **** 		else
2881:FreeRTOS/Source/tasks.c **** 		{
2882:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2883:FreeRTOS/Source/tasks.c **** 		}
2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2886:FreeRTOS/Source/tasks.c **** 		{
2887:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2888:FreeRTOS/Source/tasks.c **** 		}
2889:FreeRTOS/Source/tasks.c **** 		else
2890:FreeRTOS/Source/tasks.c **** 		{
2891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2892:FreeRTOS/Source/tasks.c **** 		}
2893:FreeRTOS/Source/tasks.c **** 
2894:FreeRTOS/Source/tasks.c **** 		return xReturn;
2895:FreeRTOS/Source/tasks.c **** 	}
2896:FreeRTOS/Source/tasks.c **** 
2897:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2898:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2899:FreeRTOS/Source/tasks.c **** 
2900:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2901:FreeRTOS/Source/tasks.c **** {
2902:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2903:FreeRTOS/Source/tasks.c **** 	{
2904:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2905:FreeRTOS/Source/tasks.c **** 		switch. */
2906:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2907:FreeRTOS/Source/tasks.c **** 	}
2908:FreeRTOS/Source/tasks.c **** 	else
2909:FreeRTOS/Source/tasks.c **** 	{
2910:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2911:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2912:FreeRTOS/Source/tasks.c **** 
2913:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2914:FreeRTOS/Source/tasks.c **** 		{
2915:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2916:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2917:FreeRTOS/Source/tasks.c **** 				#else
2918:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2919:FreeRTOS/Source/tasks.c **** 				#endif
2920:FreeRTOS/Source/tasks.c **** 
2921:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2922:FreeRTOS/Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2923:FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2924:FreeRTOS/Source/tasks.c **** 				protection here so count values are only valid until the timer
2925:FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2926:FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2927:FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2928:FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2929:FreeRTOS/Source/tasks.c **** 				{
2930:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2931:FreeRTOS/Source/tasks.c **** 				}
2932:FreeRTOS/Source/tasks.c **** 				else
2933:FreeRTOS/Source/tasks.c **** 				{
2934:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2935:FreeRTOS/Source/tasks.c **** 				}
2936:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2937:FreeRTOS/Source/tasks.c **** 		}
2938:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2939:FreeRTOS/Source/tasks.c **** 
2940:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2941:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2942:FreeRTOS/Source/tasks.c **** 
2943:FreeRTOS/Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
2944:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2945:FreeRTOS/Source/tasks.c **** 		{
2946:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2947:FreeRTOS/Source/tasks.c **** 		}
2948:FreeRTOS/Source/tasks.c **** 		#endif
2949:FreeRTOS/Source/tasks.c **** 
2950:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2951:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2952:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
2953:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2954:FreeRTOS/Source/tasks.c **** 
2955:FreeRTOS/Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
2956:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2957:FreeRTOS/Source/tasks.c **** 		{
2958:FreeRTOS/Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2959:FreeRTOS/Source/tasks.c **** 		}
2960:FreeRTOS/Source/tasks.c **** 		#endif
2961:FreeRTOS/Source/tasks.c **** 
2962:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2963:FreeRTOS/Source/tasks.c **** 		{
2964:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2965:FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2966:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2967:FreeRTOS/Source/tasks.c **** 		}
2968:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2969:FreeRTOS/Source/tasks.c **** 	}
2970:FreeRTOS/Source/tasks.c **** }
2971:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2972:FreeRTOS/Source/tasks.c **** 
2973:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2974:FreeRTOS/Source/tasks.c **** {
2975:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2976:FreeRTOS/Source/tasks.c **** 
2977:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2978:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2979:FreeRTOS/Source/tasks.c **** 
2980:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2981:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2982:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2983:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2984:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2985:FreeRTOS/Source/tasks.c **** 
2986:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2987:FreeRTOS/Source/tasks.c **** }
2988:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2989:FreeRTOS/Source/tasks.c **** 
2990:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2991:FreeRTOS/Source/tasks.c **** {
2992:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2993:FreeRTOS/Source/tasks.c **** 
2994:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2995:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2996:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2997:FreeRTOS/Source/tasks.c **** 
2998:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2999:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3000:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
3001:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3002:FreeRTOS/Source/tasks.c **** 
3003:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3004:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3005:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3006:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3007:FreeRTOS/Source/tasks.c **** 	the task level). */
3008:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3009:FreeRTOS/Source/tasks.c **** 
3010:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3011:FreeRTOS/Source/tasks.c **** }
3012:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3013:FreeRTOS/Source/tasks.c **** 
3014:FreeRTOS/Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3015:FreeRTOS/Source/tasks.c **** 
3016:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3017:FreeRTOS/Source/tasks.c **** 	{
3018:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
3019:FreeRTOS/Source/tasks.c **** 
3020:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
3021:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3022:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3023:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
3024:FreeRTOS/Source/tasks.c **** 
3025:FreeRTOS/Source/tasks.c **** 
3026:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3027:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3028:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3029:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
3030:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3031:FreeRTOS/Source/tasks.c **** 
3032:FreeRTOS/Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3033:FreeRTOS/Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3034:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3035:FreeRTOS/Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3036:FreeRTOS/Source/tasks.c **** 		{
3037:FreeRTOS/Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3038:FreeRTOS/Source/tasks.c **** 		}
3039:FreeRTOS/Source/tasks.c **** 
3040:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3041:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3042:FreeRTOS/Source/tasks.c **** 	}
3043:FreeRTOS/Source/tasks.c **** 
3044:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3045:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3046:FreeRTOS/Source/tasks.c **** 
3047:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3048:FreeRTOS/Source/tasks.c **** {
3049:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3050:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3051:FreeRTOS/Source/tasks.c **** 
3052:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3053:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
3054:FreeRTOS/Source/tasks.c **** 
3055:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3056:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3057:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
3058:FreeRTOS/Source/tasks.c **** 
3059:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3060:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3061:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3062:FreeRTOS/Source/tasks.c **** 
3063:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3064:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
3065:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3066:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3067:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3068:FreeRTOS/Source/tasks.c **** 
3069:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3070:FreeRTOS/Source/tasks.c **** 	{
3071:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3072:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3073:FreeRTOS/Source/tasks.c **** 	}
3074:FreeRTOS/Source/tasks.c **** 	else
3075:FreeRTOS/Source/tasks.c **** 	{
3076:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3077:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
3078:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3079:FreeRTOS/Source/tasks.c **** 	}
3080:FreeRTOS/Source/tasks.c **** 
3081:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3082:FreeRTOS/Source/tasks.c **** 	{
3083:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3084:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3085:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
3086:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
3087:FreeRTOS/Source/tasks.c **** 
3088:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3089:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3090:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3091:FreeRTOS/Source/tasks.c **** 	}
3092:FreeRTOS/Source/tasks.c **** 	else
3093:FreeRTOS/Source/tasks.c **** 	{
3094:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
3095:FreeRTOS/Source/tasks.c **** 	}
3096:FreeRTOS/Source/tasks.c **** 
3097:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3098:FreeRTOS/Source/tasks.c **** 	{
3099:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3100:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3101:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3102:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3103:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3104:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3105:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3106:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3107:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3108:FreeRTOS/Source/tasks.c **** 	}
3109:FreeRTOS/Source/tasks.c **** 	#endif
3110:FreeRTOS/Source/tasks.c **** 
3111:FreeRTOS/Source/tasks.c **** 	return xReturn;
3112:FreeRTOS/Source/tasks.c **** }
3113:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3114:FreeRTOS/Source/tasks.c **** 
3115:FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3116:FreeRTOS/Source/tasks.c **** {
3117:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3118:FreeRTOS/Source/tasks.c **** 
3119:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3120:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
3121:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3122:FreeRTOS/Source/tasks.c **** 
3123:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
3124:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3125:FreeRTOS/Source/tasks.c **** 
3126:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3127:FreeRTOS/Source/tasks.c **** 	event flags. */
3128:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3129:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3130:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3131:FreeRTOS/Source/tasks.c **** 
3132:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3133:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3134:FreeRTOS/Source/tasks.c **** 	lists. */
3135:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3136:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3137:FreeRTOS/Source/tasks.c **** 
3138:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3139:FreeRTOS/Source/tasks.c **** 	{
3140:FreeRTOS/Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3141:FreeRTOS/Source/tasks.c **** 		a context switch is required.  This function is called with the
3142:FreeRTOS/Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3143:FreeRTOS/Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3144:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3145:FreeRTOS/Source/tasks.c **** 	}
3146:FreeRTOS/Source/tasks.c **** }
3147:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3148:FreeRTOS/Source/tasks.c **** 
3149:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3150:FreeRTOS/Source/tasks.c **** {
3151:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3152:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3153:FreeRTOS/Source/tasks.c **** 	{
3154:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3155:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3156:FreeRTOS/Source/tasks.c **** 	}
3157:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3158:FreeRTOS/Source/tasks.c **** }
3159:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3160:FreeRTOS/Source/tasks.c **** 
3161:FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3162:FreeRTOS/Source/tasks.c **** {
3163:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3164:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3165:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3166:FreeRTOS/Source/tasks.c **** }
3167:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3168:FreeRTOS/Source/tasks.c **** 
3169:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3170:FreeRTOS/Source/tasks.c **** {
3171:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3172:FreeRTOS/Source/tasks.c **** 
3173:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3174:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
3175:FreeRTOS/Source/tasks.c **** 
3176:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3177:FreeRTOS/Source/tasks.c **** 	{
3178:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3179:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3180:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3181:FreeRTOS/Source/tasks.c **** 
3182:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3183:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3184:FreeRTOS/Source/tasks.c **** 			{
3185:FreeRTOS/Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3186:FreeRTOS/Source/tasks.c **** 				but has the same result. */
3187:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3188:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3189:FreeRTOS/Source/tasks.c **** 			}
3190:FreeRTOS/Source/tasks.c **** 			else
3191:FreeRTOS/Source/tasks.c **** 		#endif
3192:FreeRTOS/Source/tasks.c **** 
3193:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3194:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3195:FreeRTOS/Source/tasks.c **** 			{
3196:FreeRTOS/Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3197:FreeRTOS/Source/tasks.c **** 				specified is the maximum block time then the task should block
3198:FreeRTOS/Source/tasks.c **** 				indefinitely, and therefore never time out. */
3199:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
3200:FreeRTOS/Source/tasks.c **** 			}
3201:FreeRTOS/Source/tasks.c **** 			else
3202:FreeRTOS/Source/tasks.c **** 		#endif
3203:FreeRTOS/Source/tasks.c **** 
3204:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3205:FreeRTOS/Source/tasks.c **** 		{
3206:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which
3207:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3208:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3209:FreeRTOS/Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3210:FreeRTOS/Source/tasks.c **** 			was called. */
3211:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3212:FreeRTOS/Source/tasks.c **** 		}
3213:FreeRTOS/Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3214:FreeRTOS/Source/tasks.c **** 		{
3215:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3216:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3217:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3218:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
3219:FreeRTOS/Source/tasks.c **** 		}
3220:FreeRTOS/Source/tasks.c **** 		else
3221:FreeRTOS/Source/tasks.c **** 		{
3222:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait = 0;
3223:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3224:FreeRTOS/Source/tasks.c **** 		}
3225:FreeRTOS/Source/tasks.c **** 	}
3226:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3227:FreeRTOS/Source/tasks.c **** 
3228:FreeRTOS/Source/tasks.c **** 	return xReturn;
3229:FreeRTOS/Source/tasks.c **** }
3230:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3231:FreeRTOS/Source/tasks.c **** 
3232:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3233:FreeRTOS/Source/tasks.c **** {
3234:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
3235:FreeRTOS/Source/tasks.c **** }
3236:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3237:FreeRTOS/Source/tasks.c **** 
3238:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3239:FreeRTOS/Source/tasks.c **** 
3240:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3241:FreeRTOS/Source/tasks.c **** 	{
3242:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3243:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
3244:FreeRTOS/Source/tasks.c **** 
3245:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3246:FreeRTOS/Source/tasks.c **** 		{
3247:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3248:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3249:FreeRTOS/Source/tasks.c **** 		}
3250:FreeRTOS/Source/tasks.c **** 		else
3251:FreeRTOS/Source/tasks.c **** 		{
3252:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
3253:FreeRTOS/Source/tasks.c **** 		}
3254:FreeRTOS/Source/tasks.c **** 
3255:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3256:FreeRTOS/Source/tasks.c **** 	}
3257:FreeRTOS/Source/tasks.c **** 
3258:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3259:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3260:FreeRTOS/Source/tasks.c **** 
3261:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3262:FreeRTOS/Source/tasks.c **** 
3263:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3264:FreeRTOS/Source/tasks.c **** 	{
3265:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
3266:FreeRTOS/Source/tasks.c **** 
3267:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3268:FreeRTOS/Source/tasks.c **** 		{
3269:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3270:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3271:FreeRTOS/Source/tasks.c **** 		}
3272:FreeRTOS/Source/tasks.c **** 	}
3273:FreeRTOS/Source/tasks.c **** 
3274:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3275:FreeRTOS/Source/tasks.c **** 
3276:FreeRTOS/Source/tasks.c **** /*
3277:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3278:FreeRTOS/Source/tasks.c ****  * The Idle task.
3279:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3280:FreeRTOS/Source/tasks.c ****  *
3281:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3282:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3283:FreeRTOS/Source/tasks.c ****  *
3284:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3285:FreeRTOS/Source/tasks.c ****  *
3286:FreeRTOS/Source/tasks.c ****  */
3287:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3288:FreeRTOS/Source/tasks.c **** {
3289:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
3290:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
3291:FreeRTOS/Source/tasks.c **** 
3292:FreeRTOS/Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3293:FreeRTOS/Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3294:FreeRTOS/Source/tasks.c **** 
3295:FreeRTOS/Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3296:FreeRTOS/Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3297:FreeRTOS/Source/tasks.c **** 	any. */
3298:FreeRTOS/Source/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3299:FreeRTOS/Source/tasks.c **** 
3300:FreeRTOS/Source/tasks.c **** 	for( ;; )
3301:FreeRTOS/Source/tasks.c **** 	{
3302:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3303:FreeRTOS/Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3304:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3305:FreeRTOS/Source/tasks.c **** 
3306:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3307:FreeRTOS/Source/tasks.c **** 		{
3308:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3309:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
3310:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3311:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
3312:FreeRTOS/Source/tasks.c **** 			taskYIELD();
3313:FreeRTOS/Source/tasks.c **** 		}
3314:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3315:FreeRTOS/Source/tasks.c **** 
3316:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3317:FreeRTOS/Source/tasks.c **** 		{
3318:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3319:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3320:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
3321:FreeRTOS/Source/tasks.c **** 			timeslice.
3322:FreeRTOS/Source/tasks.c **** 
3323:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
3324:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3325:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3326:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3327:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3328:FreeRTOS/Source/tasks.c **** 			{
3329:FreeRTOS/Source/tasks.c **** 				taskYIELD();
3330:FreeRTOS/Source/tasks.c **** 			}
3331:FreeRTOS/Source/tasks.c **** 			else
3332:FreeRTOS/Source/tasks.c **** 			{
3333:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3334:FreeRTOS/Source/tasks.c **** 			}
3335:FreeRTOS/Source/tasks.c **** 		}
3336:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3337:FreeRTOS/Source/tasks.c **** 
3338:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3339:FreeRTOS/Source/tasks.c **** 		{
3340:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3341:FreeRTOS/Source/tasks.c **** 
3342:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3343:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
3344:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
3345:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3346:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3347:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
3348:FreeRTOS/Source/tasks.c **** 		}
3349:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3350:FreeRTOS/Source/tasks.c **** 
3351:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3352:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3353:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
3354:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3355:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3356:FreeRTOS/Source/tasks.c **** 		{
3357:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3358:FreeRTOS/Source/tasks.c **** 
3359:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3360:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3361:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
3362:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3363:FreeRTOS/Source/tasks.c **** 			valid. */
3364:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3365:FreeRTOS/Source/tasks.c **** 
3366:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3367:FreeRTOS/Source/tasks.c **** 			{
3368:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
3369:FreeRTOS/Source/tasks.c **** 				{
3370:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3371:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
3372:FreeRTOS/Source/tasks.c **** 					be used. */
3373:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3374:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3375:FreeRTOS/Source/tasks.c **** 
3376:FreeRTOS/Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3377:FreeRTOS/Source/tasks.c **** 					if the application does not want
3378:FreeRTOS/Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3379:FreeRTOS/Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3380:FreeRTOS/Source/tasks.c **** 
3381:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3382:FreeRTOS/Source/tasks.c **** 					{
3383:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3384:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3385:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3386:FreeRTOS/Source/tasks.c **** 					}
3387:FreeRTOS/Source/tasks.c **** 					else
3388:FreeRTOS/Source/tasks.c **** 					{
3389:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3390:FreeRTOS/Source/tasks.c **** 					}
3391:FreeRTOS/Source/tasks.c **** 				}
3392:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
3393:FreeRTOS/Source/tasks.c **** 			}
3394:FreeRTOS/Source/tasks.c **** 			else
3395:FreeRTOS/Source/tasks.c **** 			{
3396:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3397:FreeRTOS/Source/tasks.c **** 			}
3398:FreeRTOS/Source/tasks.c **** 		}
3399:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3400:FreeRTOS/Source/tasks.c **** 	}
3401:FreeRTOS/Source/tasks.c **** }
3402:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3403:FreeRTOS/Source/tasks.c **** 
3404:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3405:FreeRTOS/Source/tasks.c **** 
3406:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3407:FreeRTOS/Source/tasks.c **** 	{
3408:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3409:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3410:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3411:FreeRTOS/Source/tasks.c **** 
3412:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3413:FreeRTOS/Source/tasks.c **** 		{
3414:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3415:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3416:FreeRTOS/Source/tasks.c **** 		}
3417:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3418:FreeRTOS/Source/tasks.c **** 		{
3419:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3420:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3421:FreeRTOS/Source/tasks.c **** 		}
3422:FreeRTOS/Source/tasks.c **** 		else
3423:FreeRTOS/Source/tasks.c **** 		{
3424:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3425:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3426:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3427:FreeRTOS/Source/tasks.c **** 			interrupts. */
3428:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3429:FreeRTOS/Source/tasks.c **** 			{
3430:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3431:FreeRTOS/Source/tasks.c **** 			}
3432:FreeRTOS/Source/tasks.c **** 			else
3433:FreeRTOS/Source/tasks.c **** 			{
3434:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3435:FreeRTOS/Source/tasks.c **** 			}
3436:FreeRTOS/Source/tasks.c **** 		}
3437:FreeRTOS/Source/tasks.c **** 
3438:FreeRTOS/Source/tasks.c **** 		return eReturn;
3439:FreeRTOS/Source/tasks.c **** 	}
3440:FreeRTOS/Source/tasks.c **** 
3441:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3442:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3443:FreeRTOS/Source/tasks.c **** 
3444:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3445:FreeRTOS/Source/tasks.c **** 
3446:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3447:FreeRTOS/Source/tasks.c **** 	{
3448:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3449:FreeRTOS/Source/tasks.c **** 
3450:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3451:FreeRTOS/Source/tasks.c **** 		{
3452:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3453:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3454:FreeRTOS/Source/tasks.c **** 		}
3455:FreeRTOS/Source/tasks.c **** 	}
3456:FreeRTOS/Source/tasks.c **** 
3457:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3458:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3459:FreeRTOS/Source/tasks.c **** 
3460:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3461:FreeRTOS/Source/tasks.c **** 
3462:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3463:FreeRTOS/Source/tasks.c **** 	{
3464:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
3465:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3466:FreeRTOS/Source/tasks.c **** 
3467:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3468:FreeRTOS/Source/tasks.c **** 		{
3469:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3470:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3471:FreeRTOS/Source/tasks.c **** 		}
3472:FreeRTOS/Source/tasks.c **** 		else
3473:FreeRTOS/Source/tasks.c **** 		{
3474:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
3475:FreeRTOS/Source/tasks.c **** 		}
3476:FreeRTOS/Source/tasks.c **** 
3477:FreeRTOS/Source/tasks.c **** 		return pvReturn;
3478:FreeRTOS/Source/tasks.c **** 	}
3479:FreeRTOS/Source/tasks.c **** 
3480:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3481:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3482:FreeRTOS/Source/tasks.c **** 
3483:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3484:FreeRTOS/Source/tasks.c **** 
3485:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3486:FreeRTOS/Source/tasks.c **** 	{
3487:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3488:FreeRTOS/Source/tasks.c **** 
3489:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3490:FreeRTOS/Source/tasks.c **** 		the calling task. */
3491:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3492:FreeRTOS/Source/tasks.c **** 
3493:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3494:FreeRTOS/Source/tasks.c **** 	}
3495:FreeRTOS/Source/tasks.c **** 
3496:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3497:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3498:FreeRTOS/Source/tasks.c **** 
3499:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3500:FreeRTOS/Source/tasks.c **** {
3501:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3502:FreeRTOS/Source/tasks.c **** 
3503:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3504:FreeRTOS/Source/tasks.c **** 	{
3505:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3506:FreeRTOS/Source/tasks.c **** 	}
3507:FreeRTOS/Source/tasks.c **** 
3508:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3509:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3510:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3511:FreeRTOS/Source/tasks.c **** 
3512:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3513:FreeRTOS/Source/tasks.c **** 	{
3514:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3515:FreeRTOS/Source/tasks.c **** 	}
3516:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3517:FreeRTOS/Source/tasks.c **** 
3518:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3519:FreeRTOS/Source/tasks.c **** 	{
3520:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3521:FreeRTOS/Source/tasks.c **** 	}
3522:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3523:FreeRTOS/Source/tasks.c **** 
3524:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3525:FreeRTOS/Source/tasks.c **** 	using list2. */
3526:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3527:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3528:FreeRTOS/Source/tasks.c **** }
3529:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3530:FreeRTOS/Source/tasks.c **** 
3531:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3532:FreeRTOS/Source/tasks.c **** {
3533:FreeRTOS/Source/tasks.c **** 
3534:FreeRTOS/Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3535:FreeRTOS/Source/tasks.c **** 
3536:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3537:FreeRTOS/Source/tasks.c **** 	{
3538:FreeRTOS/Source/tasks.c **** 		TCB_t *pxTCB;
3539:FreeRTOS/Source/tasks.c **** 
3540:FreeRTOS/Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3541:FreeRTOS/Source/tasks.c **** 		being called too often in the idle task. */
3542:FreeRTOS/Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3543:FreeRTOS/Source/tasks.c **** 		{
3544:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
3545:FreeRTOS/Source/tasks.c **** 			{
3546:FreeRTOS/Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3547:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3548:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3549:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3550:FreeRTOS/Source/tasks.c **** 			}
3551:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
3552:FreeRTOS/Source/tasks.c **** 
3553:FreeRTOS/Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3554:FreeRTOS/Source/tasks.c **** 		}
3555:FreeRTOS/Source/tasks.c **** 	}
3556:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3557:FreeRTOS/Source/tasks.c **** }
3558:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3559:FreeRTOS/Source/tasks.c **** 
3560:FreeRTOS/Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3561:FreeRTOS/Source/tasks.c **** 
3562:FreeRTOS/Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3563:FreeRTOS/Source/tasks.c **** 	{
3564:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3565:FreeRTOS/Source/tasks.c **** 
3566:FreeRTOS/Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3567:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3568:FreeRTOS/Source/tasks.c **** 
3569:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3570:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3571:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3572:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3573:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3574:FreeRTOS/Source/tasks.c **** 
3575:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3576:FreeRTOS/Source/tasks.c **** 		{
3577:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3578:FreeRTOS/Source/tasks.c **** 		}
3579:FreeRTOS/Source/tasks.c **** 		#else
3580:FreeRTOS/Source/tasks.c **** 		{
3581:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3582:FreeRTOS/Source/tasks.c **** 		}
3583:FreeRTOS/Source/tasks.c **** 		#endif
3584:FreeRTOS/Source/tasks.c **** 
3585:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3586:FreeRTOS/Source/tasks.c **** 		{
3587:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3588:FreeRTOS/Source/tasks.c **** 		}
3589:FreeRTOS/Source/tasks.c **** 		#else
3590:FreeRTOS/Source/tasks.c **** 		{
3591:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3592:FreeRTOS/Source/tasks.c **** 		}
3593:FreeRTOS/Source/tasks.c **** 		#endif
3594:FreeRTOS/Source/tasks.c **** 
3595:FreeRTOS/Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3596:FreeRTOS/Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3597:FreeRTOS/Source/tasks.c **** 		state is just set to whatever is passed in. */
3598:FreeRTOS/Source/tasks.c **** 		if( eState != eInvalid )
3599:FreeRTOS/Source/tasks.c **** 		{
3600:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3601:FreeRTOS/Source/tasks.c **** 			{
3602:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3603:FreeRTOS/Source/tasks.c **** 			}
3604:FreeRTOS/Source/tasks.c **** 			else
3605:FreeRTOS/Source/tasks.c **** 			{
3606:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3607:FreeRTOS/Source/tasks.c **** 
3608:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3609:FreeRTOS/Source/tasks.c **** 				{
3610:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3611:FreeRTOS/Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3612:FreeRTOS/Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3613:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3614:FreeRTOS/Source/tasks.c **** 					{
3615:FreeRTOS/Source/tasks.c **** 						vTaskSuspendAll();
3616:FreeRTOS/Source/tasks.c **** 						{
3617:FreeRTOS/Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3618:FreeRTOS/Source/tasks.c **** 							{
3619:FreeRTOS/Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3620:FreeRTOS/Source/tasks.c **** 							}
3621:FreeRTOS/Source/tasks.c **** 						}
3622:FreeRTOS/Source/tasks.c **** 						( void ) xTaskResumeAll();
3623:FreeRTOS/Source/tasks.c **** 					}
3624:FreeRTOS/Source/tasks.c **** 				}
3625:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3626:FreeRTOS/Source/tasks.c **** 			}
3627:FreeRTOS/Source/tasks.c **** 		}
3628:FreeRTOS/Source/tasks.c **** 		else
3629:FreeRTOS/Source/tasks.c **** 		{
3630:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3631:FreeRTOS/Source/tasks.c **** 		}
3632:FreeRTOS/Source/tasks.c **** 
3633:FreeRTOS/Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3634:FreeRTOS/Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3635:FreeRTOS/Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3636:FreeRTOS/Source/tasks.c **** 		{
3637:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3638:FreeRTOS/Source/tasks.c **** 			{
3639:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3640:FreeRTOS/Source/tasks.c **** 			}
3641:FreeRTOS/Source/tasks.c **** 			#else
3642:FreeRTOS/Source/tasks.c **** 			{
3643:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3644:FreeRTOS/Source/tasks.c **** 			}
3645:FreeRTOS/Source/tasks.c **** 			#endif
3646:FreeRTOS/Source/tasks.c **** 		}
3647:FreeRTOS/Source/tasks.c **** 		else
3648:FreeRTOS/Source/tasks.c **** 		{
3649:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3650:FreeRTOS/Source/tasks.c **** 		}
3651:FreeRTOS/Source/tasks.c **** 	}
3652:FreeRTOS/Source/tasks.c **** 
3653:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3654:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3655:FreeRTOS/Source/tasks.c **** 
3656:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3657:FreeRTOS/Source/tasks.c **** 
3658:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3659:FreeRTOS/Source/tasks.c **** 	{
3660:FreeRTOS/Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3661:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3662:FreeRTOS/Source/tasks.c **** 
3663:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3664:FreeRTOS/Source/tasks.c **** 		{
3665:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3666:FreeRTOS/Source/tasks.c **** 
3667:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3668:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3669:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3670:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3671:FreeRTOS/Source/tasks.c **** 			do
3672:FreeRTOS/Source/tasks.c **** 			{
3673:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3674:FreeRTOS/Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3675:FreeRTOS/Source/tasks.c **** 				uxTask++;
3676:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3677:FreeRTOS/Source/tasks.c **** 		}
3678:FreeRTOS/Source/tasks.c **** 		else
3679:FreeRTOS/Source/tasks.c **** 		{
3680:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3681:FreeRTOS/Source/tasks.c **** 		}
3682:FreeRTOS/Source/tasks.c **** 
3683:FreeRTOS/Source/tasks.c **** 		return uxTask;
3684:FreeRTOS/Source/tasks.c **** 	}
3685:FreeRTOS/Source/tasks.c **** 
3686:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3687:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3688:FreeRTOS/Source/tasks.c **** 
3689:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3690:FreeRTOS/Source/tasks.c **** 
3691:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3692:FreeRTOS/Source/tasks.c **** 	{
3693:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3694:FreeRTOS/Source/tasks.c **** 
3695:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3696:FreeRTOS/Source/tasks.c **** 		{
3697:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3698:FreeRTOS/Source/tasks.c **** 			ulCount++;
3699:FreeRTOS/Source/tasks.c **** 		}
3700:FreeRTOS/Source/tasks.c **** 
3701:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3702:FreeRTOS/Source/tasks.c **** 
3703:FreeRTOS/Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3704:FreeRTOS/Source/tasks.c **** 	}
3705:FreeRTOS/Source/tasks.c **** 
3706:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3707:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3708:FreeRTOS/Source/tasks.c **** 
3709:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3710:FreeRTOS/Source/tasks.c **** 
3711:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3712:FreeRTOS/Source/tasks.c **** 	{
3713:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3714:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3715:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3716:FreeRTOS/Source/tasks.c **** 
3717:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3718:FreeRTOS/Source/tasks.c **** 
3719:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3720:FreeRTOS/Source/tasks.c **** 		{
3721:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3722:FreeRTOS/Source/tasks.c **** 		}
3723:FreeRTOS/Source/tasks.c **** 		#else
3724:FreeRTOS/Source/tasks.c **** 		{
3725:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3726:FreeRTOS/Source/tasks.c **** 		}
3727:FreeRTOS/Source/tasks.c **** 		#endif
3728:FreeRTOS/Source/tasks.c **** 
3729:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3730:FreeRTOS/Source/tasks.c **** 
3731:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3732:FreeRTOS/Source/tasks.c **** 	}
3733:FreeRTOS/Source/tasks.c **** 
3734:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3735:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3736:FreeRTOS/Source/tasks.c **** 
3737:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3738:FreeRTOS/Source/tasks.c **** 
3739:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3740:FreeRTOS/Source/tasks.c **** 	{
3741:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3742:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3743:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3744:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3745:FreeRTOS/Source/tasks.c **** 
3746:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3747:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3748:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3749:FreeRTOS/Source/tasks.c **** 		{
3750:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3751:FreeRTOS/Source/tasks.c **** 		}
3752:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3753:FreeRTOS/Source/tasks.c **** 
3754:FreeRTOS/Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3755:FreeRTOS/Source/tasks.c **** 		{
3756:FreeRTOS/Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3757:FreeRTOS/Source/tasks.c **** 			the stack and TCB. */
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3759:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
3760:FreeRTOS/Source/tasks.c **** 		}
3761:FreeRTOS/Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3762:FreeRTOS/Source/tasks.c **** 		{
3763:FreeRTOS/Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3764:FreeRTOS/Source/tasks.c **** 			check what was statically allocated before trying to free the
3765:FreeRTOS/Source/tasks.c **** 			memory. */
3766:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3767:FreeRTOS/Source/tasks.c **** 			{
3768:FreeRTOS/Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3769:FreeRTOS/Source/tasks.c **** 				must be freed. */
3770:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3771:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3772:FreeRTOS/Source/tasks.c **** 			}
3773:FreeRTOS/Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3774:FreeRTOS/Source/tasks.c **** 			{
3775:FreeRTOS/Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3776:FreeRTOS/Source/tasks.c **** 				only memory that must be freed. */
3777:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3778:FreeRTOS/Source/tasks.c **** 			}
3779:FreeRTOS/Source/tasks.c **** 			else
3780:FreeRTOS/Source/tasks.c **** 			{
3781:FreeRTOS/Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3782:FreeRTOS/Source/tasks.c **** 				nothing needs to be freed. */
3783:FreeRTOS/Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3784:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3785:FreeRTOS/Source/tasks.c **** 			}
3786:FreeRTOS/Source/tasks.c **** 		}
3787:FreeRTOS/Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3788:FreeRTOS/Source/tasks.c **** 	}
3789:FreeRTOS/Source/tasks.c **** 
3790:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3791:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3792:FreeRTOS/Source/tasks.c **** 
3793:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3794:FreeRTOS/Source/tasks.c **** {
 190               	.LM0:
 191               	.LFBB1:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
3795:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3796:FreeRTOS/Source/tasks.c **** 
3797:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 197               	.LM1:
 198 0000 E091 0000 		lds r30,pxDelayedTaskList
 199 0004 F091 0000 		lds r31,pxDelayedTaskList+1
 200 0008 8081      		ld r24,Z
 201 000a 8111      		cpse r24,__zero_reg__
 202 000c 00C0      		rjmp .L2
3798:FreeRTOS/Source/tasks.c **** 	{
3799:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3800:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3801:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3802:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3803:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 204               	.LM2:
 205 000e 8FEF      		ldi r24,lo8(-1)
 206 0010 9FEF      		ldi r25,lo8(-1)
 207 0012 00C0      		rjmp .L4
 208               	.L2:
 209               	.LBB6:
 210               	.LBB7:
3804:FreeRTOS/Source/tasks.c **** 	}
3805:FreeRTOS/Source/tasks.c **** 	else
3806:FreeRTOS/Source/tasks.c **** 	{
3807:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3808:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3809:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3810:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3811:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
 212               	.LM3:
 213 0014 E091 0000 		lds r30,pxDelayedTaskList
 214 0018 F091 0000 		lds r31,pxDelayedTaskList+1
 215 001c 0580      		ldd __tmp_reg__,Z+5
 216 001e F681      		ldd r31,Z+6
 217 0020 E02D      		mov r30,__tmp_reg__
3812:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 219               	.LM4:
 220 0022 0680      		ldd __tmp_reg__,Z+6
 221 0024 F781      		ldd r31,Z+7
 222 0026 E02D      		mov r30,__tmp_reg__
 223 0028 8281      		ldd r24,Z+2
 224 002a 9381      		ldd r25,Z+3
 225               	.L4:
 226 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 227 0030 8093 0000 		sts xNextTaskUnblockTime,r24
 228 0034 0895      		ret
 229               	.LBE7:
 230               	.LBE6:
 232               	.Lscope1:
 234               		.stabd	78,0,0
 239               	prvAddCurrentTaskToDelayedList:
 240               		.stabd	46,0,0
3813:FreeRTOS/Source/tasks.c **** 	}
3814:FreeRTOS/Source/tasks.c **** }
3815:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3816:FreeRTOS/Source/tasks.c **** 
3817:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3818:FreeRTOS/Source/tasks.c **** 
3819:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3820:FreeRTOS/Source/tasks.c **** 	{
3821:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3822:FreeRTOS/Source/tasks.c **** 
3823:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3824:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3825:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3826:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3827:FreeRTOS/Source/tasks.c **** 
3828:FreeRTOS/Source/tasks.c **** 		return xReturn;
3829:FreeRTOS/Source/tasks.c **** 	}
3830:FreeRTOS/Source/tasks.c **** 
3831:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3832:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3833:FreeRTOS/Source/tasks.c **** 
3834:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3835:FreeRTOS/Source/tasks.c **** 
3836:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3837:FreeRTOS/Source/tasks.c **** 	{
3838:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3839:FreeRTOS/Source/tasks.c **** 
3840:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3841:FreeRTOS/Source/tasks.c **** 		{
3842:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3843:FreeRTOS/Source/tasks.c **** 		}
3844:FreeRTOS/Source/tasks.c **** 		else
3845:FreeRTOS/Source/tasks.c **** 		{
3846:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3847:FreeRTOS/Source/tasks.c **** 			{
3848:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3849:FreeRTOS/Source/tasks.c **** 			}
3850:FreeRTOS/Source/tasks.c **** 			else
3851:FreeRTOS/Source/tasks.c **** 			{
3852:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3853:FreeRTOS/Source/tasks.c **** 			}
3854:FreeRTOS/Source/tasks.c **** 		}
3855:FreeRTOS/Source/tasks.c **** 
3856:FreeRTOS/Source/tasks.c **** 		return xReturn;
3857:FreeRTOS/Source/tasks.c **** 	}
3858:FreeRTOS/Source/tasks.c **** 
3859:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3860:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3861:FreeRTOS/Source/tasks.c **** 
3862:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3863:FreeRTOS/Source/tasks.c **** 
3864:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3865:FreeRTOS/Source/tasks.c **** 	{
3866:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
3867:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3868:FreeRTOS/Source/tasks.c **** 
3869:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3870:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3871:FreeRTOS/Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3872:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3873:FreeRTOS/Source/tasks.c **** 		{
3874:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3875:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3876:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3877:FreeRTOS/Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3878:FreeRTOS/Source/tasks.c **** 			{
3879:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3880:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3881:FreeRTOS/Source/tasks.c **** 				not being used for anything else. */
3882:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3883:FreeRTOS/Source/tasks.c **** 				{
3884:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3885:FreeRTOS/Source/tasks.c **** 				}
3886:FreeRTOS/Source/tasks.c **** 				else
3887:FreeRTOS/Source/tasks.c **** 				{
3888:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3889:FreeRTOS/Source/tasks.c **** 				}
3890:FreeRTOS/Source/tasks.c **** 
3891:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3892:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
3893:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3894:FreeRTOS/Source/tasks.c **** 				{
3895:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3896:FreeRTOS/Source/tasks.c **** 					{
3897:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3898:FreeRTOS/Source/tasks.c **** 					}
3899:FreeRTOS/Source/tasks.c **** 					else
3900:FreeRTOS/Source/tasks.c **** 					{
3901:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3902:FreeRTOS/Source/tasks.c **** 					}
3903:FreeRTOS/Source/tasks.c **** 
3904:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3905:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3906:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3907:FreeRTOS/Source/tasks.c **** 				}
3908:FreeRTOS/Source/tasks.c **** 				else
3909:FreeRTOS/Source/tasks.c **** 				{
3910:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3911:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3912:FreeRTOS/Source/tasks.c **** 				}
3913:FreeRTOS/Source/tasks.c **** 
3914:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3915:FreeRTOS/Source/tasks.c **** 
3916:FreeRTOS/Source/tasks.c **** 				/* Inheritance occurred. */
3917:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3918:FreeRTOS/Source/tasks.c **** 			}
3919:FreeRTOS/Source/tasks.c **** 			else
3920:FreeRTOS/Source/tasks.c **** 			{
3921:FreeRTOS/Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3922:FreeRTOS/Source/tasks.c **** 				{
3923:FreeRTOS/Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3924:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
3925:FreeRTOS/Source/tasks.c **** 					current priority of the mutex holder is not lower than the
3926:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex.
3927:FreeRTOS/Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
3928:FreeRTOS/Source/tasks.c **** 					priority, but inheritance would have occurred if that had
3929:FreeRTOS/Source/tasks.c **** 					not been the case. */
3930:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
3931:FreeRTOS/Source/tasks.c **** 				}
3932:FreeRTOS/Source/tasks.c **** 				else
3933:FreeRTOS/Source/tasks.c **** 				{
3934:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3935:FreeRTOS/Source/tasks.c **** 				}
3936:FreeRTOS/Source/tasks.c **** 			}
3937:FreeRTOS/Source/tasks.c **** 		}
3938:FreeRTOS/Source/tasks.c **** 		else
3939:FreeRTOS/Source/tasks.c **** 		{
3940:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3941:FreeRTOS/Source/tasks.c **** 		}
3942:FreeRTOS/Source/tasks.c **** 
3943:FreeRTOS/Source/tasks.c **** 		return xReturn;
3944:FreeRTOS/Source/tasks.c **** 	}
3945:FreeRTOS/Source/tasks.c **** 
3946:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3947:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3948:FreeRTOS/Source/tasks.c **** 
3949:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3950:FreeRTOS/Source/tasks.c **** 
3951:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3952:FreeRTOS/Source/tasks.c **** 	{
3953:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
3954:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3955:FreeRTOS/Source/tasks.c **** 
3956:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3957:FreeRTOS/Source/tasks.c **** 		{
3958:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3959:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3960:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3961:FreeRTOS/Source/tasks.c **** 			be the running state task. */
3962:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3963:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3964:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3965:FreeRTOS/Source/tasks.c **** 
3966:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3967:FreeRTOS/Source/tasks.c **** 			task? */
3968:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3969:FreeRTOS/Source/tasks.c **** 			{
3970:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3971:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3972:FreeRTOS/Source/tasks.c **** 				{
3973:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3974:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3975:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3976:FreeRTOS/Source/tasks.c **** 					holding task then it must be the running state task.  Remove
3977:FreeRTOS/Source/tasks.c **** 					the holding task from the ready list. */
3978:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3979:FreeRTOS/Source/tasks.c **** 					{
3980:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3981:FreeRTOS/Source/tasks.c **** 					}
3982:FreeRTOS/Source/tasks.c **** 					else
3983:FreeRTOS/Source/tasks.c **** 					{
3984:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3985:FreeRTOS/Source/tasks.c **** 					}
3986:FreeRTOS/Source/tasks.c **** 
3987:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3988:FreeRTOS/Source/tasks.c **** 					new	ready list. */
3989:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3990:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3991:FreeRTOS/Source/tasks.c **** 
3992:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3993:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3994:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3995:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3996:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3997:FreeRTOS/Source/tasks.c **** 
3998:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3999:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
4000:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4001:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
4002:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4003:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4004:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4005:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
4006:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4007:FreeRTOS/Source/tasks.c **** 				}
4008:FreeRTOS/Source/tasks.c **** 				else
4009:FreeRTOS/Source/tasks.c **** 				{
4010:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4011:FreeRTOS/Source/tasks.c **** 				}
4012:FreeRTOS/Source/tasks.c **** 			}
4013:FreeRTOS/Source/tasks.c **** 			else
4014:FreeRTOS/Source/tasks.c **** 			{
4015:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4016:FreeRTOS/Source/tasks.c **** 			}
4017:FreeRTOS/Source/tasks.c **** 		}
4018:FreeRTOS/Source/tasks.c **** 		else
4019:FreeRTOS/Source/tasks.c **** 		{
4020:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4021:FreeRTOS/Source/tasks.c **** 		}
4022:FreeRTOS/Source/tasks.c **** 
4023:FreeRTOS/Source/tasks.c **** 		return xReturn;
4024:FreeRTOS/Source/tasks.c **** 	}
4025:FreeRTOS/Source/tasks.c **** 
4026:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4027:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4028:FreeRTOS/Source/tasks.c **** 
4029:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4030:FreeRTOS/Source/tasks.c **** 
4031:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4032:FreeRTOS/Source/tasks.c **** 	{
4033:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4034:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4035:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4036:FreeRTOS/Source/tasks.c **** 
4037:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4038:FreeRTOS/Source/tasks.c **** 		{
4039:FreeRTOS/Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4040:FreeRTOS/Source/tasks.c **** 			one mutex. */
4041:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4042:FreeRTOS/Source/tasks.c **** 
4043:FreeRTOS/Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4044:FreeRTOS/Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4045:FreeRTOS/Source/tasks.c **** 			holding task's base priority and the priority of the highest
4046:FreeRTOS/Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4047:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4048:FreeRTOS/Source/tasks.c **** 			{
4049:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4050:FreeRTOS/Source/tasks.c **** 			}
4051:FreeRTOS/Source/tasks.c **** 			else
4052:FreeRTOS/Source/tasks.c **** 			{
4053:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4054:FreeRTOS/Source/tasks.c **** 			}
4055:FreeRTOS/Source/tasks.c **** 
4056:FreeRTOS/Source/tasks.c **** 			/* Does the priority need to change? */
4057:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4058:FreeRTOS/Source/tasks.c **** 			{
4059:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4060:FreeRTOS/Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4061:FreeRTOS/Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4062:FreeRTOS/Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4063:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4064:FreeRTOS/Source/tasks.c **** 				{
4065:FreeRTOS/Source/tasks.c **** 					/* If a task has timed out because it already holds the
4066:FreeRTOS/Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4067:FreeRTOS/Source/tasks.c **** 					its own priority. */
4068:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4069:FreeRTOS/Source/tasks.c **** 
4070:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4071:FreeRTOS/Source/tasks.c **** 					priority to facilitate determining the subject task's
4072:FreeRTOS/Source/tasks.c **** 					state. */
4073:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4074:FreeRTOS/Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4075:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4076:FreeRTOS/Source/tasks.c **** 
4077:FreeRTOS/Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4078:FreeRTOS/Source/tasks.c **** 					being used for anything else. */
4079:FreeRTOS/Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4080:FreeRTOS/Source/tasks.c **** 					{
4081:FreeRTOS/Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4082:FreeRTOS/Source/tasks.c **** 					}
4083:FreeRTOS/Source/tasks.c **** 					else
4084:FreeRTOS/Source/tasks.c **** 					{
4085:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4086:FreeRTOS/Source/tasks.c **** 					}
4087:FreeRTOS/Source/tasks.c **** 
4088:FreeRTOS/Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4089:FreeRTOS/Source/tasks.c **** 					then the task that holds the mutex could be in either the
4090:FreeRTOS/Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4091:FreeRTOS/Source/tasks.c **** 					from its current state list if it is in the Ready state as
4092:FreeRTOS/Source/tasks.c **** 					the task's priority is going to change and there is one
4093:FreeRTOS/Source/tasks.c **** 					Ready list per priority. */
4094:FreeRTOS/Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4095:FreeRTOS/Source/tasks.c **** 					{
4096:FreeRTOS/Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4097:FreeRTOS/Source/tasks.c **** 						{
4098:FreeRTOS/Source/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4099:FreeRTOS/Source/tasks.c **** 						}
4100:FreeRTOS/Source/tasks.c **** 						else
4101:FreeRTOS/Source/tasks.c **** 						{
4102:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4103:FreeRTOS/Source/tasks.c **** 						}
4104:FreeRTOS/Source/tasks.c **** 
4105:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4106:FreeRTOS/Source/tasks.c **** 					}
4107:FreeRTOS/Source/tasks.c **** 					else
4108:FreeRTOS/Source/tasks.c **** 					{
4109:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4110:FreeRTOS/Source/tasks.c **** 					}
4111:FreeRTOS/Source/tasks.c **** 				}
4112:FreeRTOS/Source/tasks.c **** 				else
4113:FreeRTOS/Source/tasks.c **** 				{
4114:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4115:FreeRTOS/Source/tasks.c **** 				}
4116:FreeRTOS/Source/tasks.c **** 			}
4117:FreeRTOS/Source/tasks.c **** 			else
4118:FreeRTOS/Source/tasks.c **** 			{
4119:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4120:FreeRTOS/Source/tasks.c **** 			}
4121:FreeRTOS/Source/tasks.c **** 		}
4122:FreeRTOS/Source/tasks.c **** 		else
4123:FreeRTOS/Source/tasks.c **** 		{
4124:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4125:FreeRTOS/Source/tasks.c **** 		}
4126:FreeRTOS/Source/tasks.c **** 	}
4127:FreeRTOS/Source/tasks.c **** 
4128:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4129:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4130:FreeRTOS/Source/tasks.c **** 
4131:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4132:FreeRTOS/Source/tasks.c **** 
4133:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
4134:FreeRTOS/Source/tasks.c **** 	{
4135:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4136:FreeRTOS/Source/tasks.c **** 
4137:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4138:FreeRTOS/Source/tasks.c **** 		{
4139:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4140:FreeRTOS/Source/tasks.c **** 
4141:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4142:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4143:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4144:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4145:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4146:FreeRTOS/Source/tasks.c **** 			critical section. */
4147:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4148:FreeRTOS/Source/tasks.c **** 			{
4149:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4150:FreeRTOS/Source/tasks.c **** 			}
4151:FreeRTOS/Source/tasks.c **** 		}
4152:FreeRTOS/Source/tasks.c **** 		else
4153:FreeRTOS/Source/tasks.c **** 		{
4154:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4155:FreeRTOS/Source/tasks.c **** 		}
4156:FreeRTOS/Source/tasks.c **** 	}
4157:FreeRTOS/Source/tasks.c **** 
4158:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4159:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4160:FreeRTOS/Source/tasks.c **** 
4161:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4162:FreeRTOS/Source/tasks.c **** 
4163:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
4164:FreeRTOS/Source/tasks.c **** 	{
4165:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4166:FreeRTOS/Source/tasks.c **** 		{
4167:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4168:FreeRTOS/Source/tasks.c **** 			{
4169:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4170:FreeRTOS/Source/tasks.c **** 
4171:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4172:FreeRTOS/Source/tasks.c **** 				{
4173:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
4174:FreeRTOS/Source/tasks.c **** 				}
4175:FreeRTOS/Source/tasks.c **** 				else
4176:FreeRTOS/Source/tasks.c **** 				{
4177:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4178:FreeRTOS/Source/tasks.c **** 				}
4179:FreeRTOS/Source/tasks.c **** 			}
4180:FreeRTOS/Source/tasks.c **** 			else
4181:FreeRTOS/Source/tasks.c **** 			{
4182:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4183:FreeRTOS/Source/tasks.c **** 			}
4184:FreeRTOS/Source/tasks.c **** 		}
4185:FreeRTOS/Source/tasks.c **** 		else
4186:FreeRTOS/Source/tasks.c **** 		{
4187:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4188:FreeRTOS/Source/tasks.c **** 		}
4189:FreeRTOS/Source/tasks.c **** 	}
4190:FreeRTOS/Source/tasks.c **** 
4191:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4192:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4193:FreeRTOS/Source/tasks.c **** 
4194:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4195:FreeRTOS/Source/tasks.c **** 
4196:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4197:FreeRTOS/Source/tasks.c **** 	{
4198:FreeRTOS/Source/tasks.c **** 	size_t x;
4199:FreeRTOS/Source/tasks.c **** 
4200:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
4201:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4202:FreeRTOS/Source/tasks.c **** 
4203:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4204:FreeRTOS/Source/tasks.c **** 		printed out. */
4205:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4206:FreeRTOS/Source/tasks.c **** 		{
4207:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4208:FreeRTOS/Source/tasks.c **** 		}
4209:FreeRTOS/Source/tasks.c **** 
4210:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
4211:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4212:FreeRTOS/Source/tasks.c **** 
4213:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
4214:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
4215:FreeRTOS/Source/tasks.c **** 	}
4216:FreeRTOS/Source/tasks.c **** 
4217:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4218:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4219:FreeRTOS/Source/tasks.c **** 
4220:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4221:FreeRTOS/Source/tasks.c **** 
4222:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4223:FreeRTOS/Source/tasks.c **** 	{
4224:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4225:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4226:FreeRTOS/Source/tasks.c **** 	char cStatus;
4227:FreeRTOS/Source/tasks.c **** 
4228:FreeRTOS/Source/tasks.c **** 		/*
4229:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4230:FreeRTOS/Source/tasks.c **** 		 *
4231:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4232:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4233:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4234:FreeRTOS/Source/tasks.c **** 		 *
4235:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4236:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4237:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
4238:FreeRTOS/Source/tasks.c **** 		 *
4239:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4240:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4241:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4242:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4243:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4244:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4245:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
4246:FreeRTOS/Source/tasks.c **** 		 *
4247:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4248:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4249:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
4250:FreeRTOS/Source/tasks.c **** 		 */
4251:FreeRTOS/Source/tasks.c **** 
4252:FreeRTOS/Source/tasks.c **** 
4253:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4254:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4255:FreeRTOS/Source/tasks.c **** 
4256:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4257:FreeRTOS/Source/tasks.c **** 		function is executing. */
4258:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4259:FreeRTOS/Source/tasks.c **** 
4260:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4261:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4262:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4263:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4264:FreeRTOS/Source/tasks.c **** 
4265:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4266:FreeRTOS/Source/tasks.c **** 		{
4267:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4268:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4269:FreeRTOS/Source/tasks.c **** 
4270:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4271:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4272:FreeRTOS/Source/tasks.c **** 			{
4273:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4274:FreeRTOS/Source/tasks.c **** 				{
4275:FreeRTOS/Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4276:FreeRTOS/Source/tasks.c **** 										break;
4277:FreeRTOS/Source/tasks.c **** 
4278:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4279:FreeRTOS/Source/tasks.c **** 										break;
4280:FreeRTOS/Source/tasks.c **** 
4281:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4282:FreeRTOS/Source/tasks.c **** 										break;
4283:FreeRTOS/Source/tasks.c **** 
4284:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4285:FreeRTOS/Source/tasks.c **** 										break;
4286:FreeRTOS/Source/tasks.c **** 
4287:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4288:FreeRTOS/Source/tasks.c **** 										break;
4289:FreeRTOS/Source/tasks.c **** 
4290:FreeRTOS/Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4291:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
4292:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
4293:FreeRTOS/Source/tasks.c **** 										cStatus = ( char ) 0x00;
4294:FreeRTOS/Source/tasks.c **** 										break;
4295:FreeRTOS/Source/tasks.c **** 				}
4296:FreeRTOS/Source/tasks.c **** 
4297:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4298:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
4299:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4300:FreeRTOS/Source/tasks.c **** 
4301:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
4302:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4303:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4304:FreeRTOS/Source/tasks.c **** 			}
4305:FreeRTOS/Source/tasks.c **** 
4306:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4307:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4308:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4309:FreeRTOS/Source/tasks.c **** 		}
4310:FreeRTOS/Source/tasks.c **** 		else
4311:FreeRTOS/Source/tasks.c **** 		{
4312:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4313:FreeRTOS/Source/tasks.c **** 		}
4314:FreeRTOS/Source/tasks.c **** 	}
4315:FreeRTOS/Source/tasks.c **** 
4316:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4317:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4318:FreeRTOS/Source/tasks.c **** 
4319:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4320:FreeRTOS/Source/tasks.c **** 
4321:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4322:FreeRTOS/Source/tasks.c **** 	{
4323:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4324:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4325:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4326:FreeRTOS/Source/tasks.c **** 
4327:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4328:FreeRTOS/Source/tasks.c **** 		{
4329:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4330:FreeRTOS/Source/tasks.c **** 		}
4331:FreeRTOS/Source/tasks.c **** 		#endif
4332:FreeRTOS/Source/tasks.c **** 
4333:FreeRTOS/Source/tasks.c **** 		/*
4334:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4335:FreeRTOS/Source/tasks.c **** 		 *
4336:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4337:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4338:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4339:FreeRTOS/Source/tasks.c **** 		 *
4340:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4341:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4342:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4343:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
4344:FreeRTOS/Source/tasks.c **** 		 *
4345:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4346:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4347:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4348:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4349:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4350:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4351:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
4352:FreeRTOS/Source/tasks.c **** 		 *
4353:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4354:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4355:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4356:FreeRTOS/Source/tasks.c **** 		 */
4357:FreeRTOS/Source/tasks.c **** 
4358:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4359:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4360:FreeRTOS/Source/tasks.c **** 
4361:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4362:FreeRTOS/Source/tasks.c **** 		function is executing. */
4363:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4364:FreeRTOS/Source/tasks.c **** 
4365:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4366:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4367:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4368:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4369:FreeRTOS/Source/tasks.c **** 
4370:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4371:FreeRTOS/Source/tasks.c **** 		{
4372:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4373:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4374:FreeRTOS/Source/tasks.c **** 
4375:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
4376:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
4377:FreeRTOS/Source/tasks.c **** 
4378:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
4379:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0UL )
4380:FreeRTOS/Source/tasks.c **** 			{
4381:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4382:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4383:FreeRTOS/Source/tasks.c **** 				{
4384:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4385:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4386:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4387:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4388:FreeRTOS/Source/tasks.c **** 
4389:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
4390:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
4391:FreeRTOS/Source/tasks.c **** 					easily. */
4392:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4393:FreeRTOS/Source/tasks.c **** 
4394:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4395:FreeRTOS/Source/tasks.c **** 					{
4396:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4397:FreeRTOS/Source/tasks.c **** 						{
4398:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4399:FreeRTOS/Source/tasks.c **** 						}
4400:FreeRTOS/Source/tasks.c **** 						#else
4401:FreeRTOS/Source/tasks.c **** 						{
4402:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4403:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4404:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4405:FreeRTOS/Source/tasks.c **** 						}
4406:FreeRTOS/Source/tasks.c **** 						#endif
4407:FreeRTOS/Source/tasks.c **** 					}
4408:FreeRTOS/Source/tasks.c **** 					else
4409:FreeRTOS/Source/tasks.c **** 					{
4410:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
4411:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
4412:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4413:FreeRTOS/Source/tasks.c **** 						{
4414:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4415:FreeRTOS/Source/tasks.c **** 						}
4416:FreeRTOS/Source/tasks.c **** 						#else
4417:FreeRTOS/Source/tasks.c **** 						{
4418:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4419:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4420:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4421:FreeRTOS/Source/tasks.c **** 						}
4422:FreeRTOS/Source/tasks.c **** 						#endif
4423:FreeRTOS/Source/tasks.c **** 					}
4424:FreeRTOS/Source/tasks.c **** 
4425:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4426:FreeRTOS/Source/tasks.c **** 				}
4427:FreeRTOS/Source/tasks.c **** 			}
4428:FreeRTOS/Source/tasks.c **** 			else
4429:FreeRTOS/Source/tasks.c **** 			{
4430:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4431:FreeRTOS/Source/tasks.c **** 			}
4432:FreeRTOS/Source/tasks.c **** 
4433:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4434:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4435:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4436:FreeRTOS/Source/tasks.c **** 		}
4437:FreeRTOS/Source/tasks.c **** 		else
4438:FreeRTOS/Source/tasks.c **** 		{
4439:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4440:FreeRTOS/Source/tasks.c **** 		}
4441:FreeRTOS/Source/tasks.c **** 	}
4442:FreeRTOS/Source/tasks.c **** 
4443:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4444:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4445:FreeRTOS/Source/tasks.c **** 
4446:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4447:FreeRTOS/Source/tasks.c **** {
4448:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
4449:FreeRTOS/Source/tasks.c **** 
4450:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4451:FreeRTOS/Source/tasks.c **** 
4452:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4453:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
4454:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4455:FreeRTOS/Source/tasks.c **** 
4456:FreeRTOS/Source/tasks.c **** 	return uxReturn;
4457:FreeRTOS/Source/tasks.c **** }
4458:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4459:FreeRTOS/Source/tasks.c **** 
4460:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4461:FreeRTOS/Source/tasks.c **** 
4462:FreeRTOS/Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4463:FreeRTOS/Source/tasks.c **** 	{
4464:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4465:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4466:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4467:FreeRTOS/Source/tasks.c **** 		{
4468:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4469:FreeRTOS/Source/tasks.c **** 		}
4470:FreeRTOS/Source/tasks.c **** 
4471:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
4472:FreeRTOS/Source/tasks.c **** 	}
4473:FreeRTOS/Source/tasks.c **** 
4474:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4475:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4476:FreeRTOS/Source/tasks.c **** 
4477:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4478:FreeRTOS/Source/tasks.c **** 
4479:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4480:FreeRTOS/Source/tasks.c **** 	{
4481:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
4482:FreeRTOS/Source/tasks.c **** 
4483:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4484:FreeRTOS/Source/tasks.c **** 		{
4485:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4486:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4487:FreeRTOS/Source/tasks.c **** 			{
4488:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4489:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4490:FreeRTOS/Source/tasks.c **** 
4491:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4492:FreeRTOS/Source/tasks.c **** 				{
4493:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4494:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4495:FreeRTOS/Source/tasks.c **** 
4496:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4497:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4498:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4499:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4500:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4501:FreeRTOS/Source/tasks.c **** 				}
4502:FreeRTOS/Source/tasks.c **** 				else
4503:FreeRTOS/Source/tasks.c **** 				{
4504:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4505:FreeRTOS/Source/tasks.c **** 				}
4506:FreeRTOS/Source/tasks.c **** 			}
4507:FreeRTOS/Source/tasks.c **** 			else
4508:FreeRTOS/Source/tasks.c **** 			{
4509:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4510:FreeRTOS/Source/tasks.c **** 			}
4511:FreeRTOS/Source/tasks.c **** 		}
4512:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4513:FreeRTOS/Source/tasks.c **** 
4514:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4515:FreeRTOS/Source/tasks.c **** 		{
4516:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4517:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4518:FreeRTOS/Source/tasks.c **** 
4519:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
4520:FreeRTOS/Source/tasks.c **** 			{
4521:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4522:FreeRTOS/Source/tasks.c **** 				{
4523:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4524:FreeRTOS/Source/tasks.c **** 				}
4525:FreeRTOS/Source/tasks.c **** 				else
4526:FreeRTOS/Source/tasks.c **** 				{
4527:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4528:FreeRTOS/Source/tasks.c **** 				}
4529:FreeRTOS/Source/tasks.c **** 			}
4530:FreeRTOS/Source/tasks.c **** 			else
4531:FreeRTOS/Source/tasks.c **** 			{
4532:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4533:FreeRTOS/Source/tasks.c **** 			}
4534:FreeRTOS/Source/tasks.c **** 
4535:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4536:FreeRTOS/Source/tasks.c **** 		}
4537:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4538:FreeRTOS/Source/tasks.c **** 
4539:FreeRTOS/Source/tasks.c **** 		return ulReturn;
4540:FreeRTOS/Source/tasks.c **** 	}
4541:FreeRTOS/Source/tasks.c **** 
4542:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4543:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4544:FreeRTOS/Source/tasks.c **** 
4545:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4546:FreeRTOS/Source/tasks.c **** 
4547:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4548:FreeRTOS/Source/tasks.c **** 	{
4549:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4550:FreeRTOS/Source/tasks.c **** 
4551:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4552:FreeRTOS/Source/tasks.c **** 		{
4553:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4554:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4555:FreeRTOS/Source/tasks.c **** 			{
4556:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4557:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4558:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4559:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4560:FreeRTOS/Source/tasks.c **** 
4561:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4562:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4563:FreeRTOS/Source/tasks.c **** 
4564:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4565:FreeRTOS/Source/tasks.c **** 				{
4566:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4567:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4568:FreeRTOS/Source/tasks.c **** 
4569:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4570:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4571:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4572:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4573:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4574:FreeRTOS/Source/tasks.c **** 				}
4575:FreeRTOS/Source/tasks.c **** 				else
4576:FreeRTOS/Source/tasks.c **** 				{
4577:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4578:FreeRTOS/Source/tasks.c **** 				}
4579:FreeRTOS/Source/tasks.c **** 			}
4580:FreeRTOS/Source/tasks.c **** 			else
4581:FreeRTOS/Source/tasks.c **** 			{
4582:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4583:FreeRTOS/Source/tasks.c **** 			}
4584:FreeRTOS/Source/tasks.c **** 		}
4585:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4586:FreeRTOS/Source/tasks.c **** 
4587:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4588:FreeRTOS/Source/tasks.c **** 		{
4589:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4590:FreeRTOS/Source/tasks.c **** 
4591:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
4592:FreeRTOS/Source/tasks.c **** 			{
4593:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4594:FreeRTOS/Source/tasks.c **** 				have changed. */
4595:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4596:FreeRTOS/Source/tasks.c **** 			}
4597:FreeRTOS/Source/tasks.c **** 
4598:FreeRTOS/Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4599:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4600:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4601:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4602:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4603:FreeRTOS/Source/tasks.c **** 			{
4604:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4605:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4606:FreeRTOS/Source/tasks.c **** 			}
4607:FreeRTOS/Source/tasks.c **** 			else
4608:FreeRTOS/Source/tasks.c **** 			{
4609:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4610:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4611:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4612:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4613:FreeRTOS/Source/tasks.c **** 			}
4614:FreeRTOS/Source/tasks.c **** 
4615:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4616:FreeRTOS/Source/tasks.c **** 		}
4617:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4618:FreeRTOS/Source/tasks.c **** 
4619:FreeRTOS/Source/tasks.c **** 		return xReturn;
4620:FreeRTOS/Source/tasks.c **** 	}
4621:FreeRTOS/Source/tasks.c **** 
4622:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4623:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4624:FreeRTOS/Source/tasks.c **** 
4625:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4626:FreeRTOS/Source/tasks.c **** 
4627:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4628:FreeRTOS/Source/tasks.c **** 	{
4629:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4630:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4631:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4632:FreeRTOS/Source/tasks.c **** 
4633:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4634:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4635:FreeRTOS/Source/tasks.c **** 
4636:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4637:FreeRTOS/Source/tasks.c **** 		{
4638:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4639:FreeRTOS/Source/tasks.c **** 			{
4640:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4641:FreeRTOS/Source/tasks.c **** 			}
4642:FreeRTOS/Source/tasks.c **** 
4643:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4644:FreeRTOS/Source/tasks.c **** 
4645:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4646:FreeRTOS/Source/tasks.c **** 
4647:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4648:FreeRTOS/Source/tasks.c **** 			{
4649:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4650:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4651:FreeRTOS/Source/tasks.c **** 					break;
4652:FreeRTOS/Source/tasks.c **** 
4653:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4654:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4655:FreeRTOS/Source/tasks.c **** 					break;
4656:FreeRTOS/Source/tasks.c **** 
4657:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4658:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4659:FreeRTOS/Source/tasks.c **** 					break;
4660:FreeRTOS/Source/tasks.c **** 
4661:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4662:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4663:FreeRTOS/Source/tasks.c **** 					{
4664:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4665:FreeRTOS/Source/tasks.c **** 					}
4666:FreeRTOS/Source/tasks.c **** 					else
4667:FreeRTOS/Source/tasks.c **** 					{
4668:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4669:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4670:FreeRTOS/Source/tasks.c **** 					}
4671:FreeRTOS/Source/tasks.c **** 					break;
4672:FreeRTOS/Source/tasks.c **** 
4673:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4674:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4675:FreeRTOS/Source/tasks.c **** 					updated. */
4676:FreeRTOS/Source/tasks.c **** 					break;
4677:FreeRTOS/Source/tasks.c **** 
4678:FreeRTOS/Source/tasks.c **** 				default:
4679:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4680:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4681:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4682:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4683:FreeRTOS/Source/tasks.c **** 
4684:FreeRTOS/Source/tasks.c **** 					break;
4685:FreeRTOS/Source/tasks.c **** 			}
4686:FreeRTOS/Source/tasks.c **** 
4687:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4688:FreeRTOS/Source/tasks.c **** 
4689:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4690:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4691:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4692:FreeRTOS/Source/tasks.c **** 			{
4693:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4694:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4695:FreeRTOS/Source/tasks.c **** 
4696:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4697:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4698:FreeRTOS/Source/tasks.c **** 
4699:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4700:FreeRTOS/Source/tasks.c **** 				{
4701:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4702:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4703:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4704:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4705:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4706:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4707:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4708:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4709:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4710:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4711:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4712:FreeRTOS/Source/tasks.c **** 				}
4713:FreeRTOS/Source/tasks.c **** 				#endif
4714:FreeRTOS/Source/tasks.c **** 
4715:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4716:FreeRTOS/Source/tasks.c **** 				{
4717:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4718:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4719:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4720:FreeRTOS/Source/tasks.c **** 				}
4721:FreeRTOS/Source/tasks.c **** 				else
4722:FreeRTOS/Source/tasks.c **** 				{
4723:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4724:FreeRTOS/Source/tasks.c **** 				}
4725:FreeRTOS/Source/tasks.c **** 			}
4726:FreeRTOS/Source/tasks.c **** 			else
4727:FreeRTOS/Source/tasks.c **** 			{
4728:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4729:FreeRTOS/Source/tasks.c **** 			}
4730:FreeRTOS/Source/tasks.c **** 		}
4731:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4732:FreeRTOS/Source/tasks.c **** 
4733:FreeRTOS/Source/tasks.c **** 		return xReturn;
4734:FreeRTOS/Source/tasks.c **** 	}
4735:FreeRTOS/Source/tasks.c **** 
4736:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4737:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4738:FreeRTOS/Source/tasks.c **** 
4739:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4740:FreeRTOS/Source/tasks.c **** 
4741:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4742:FreeRTOS/Source/tasks.c **** 	{
4743:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4744:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4745:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4746:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4747:FreeRTOS/Source/tasks.c **** 
4748:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4749:FreeRTOS/Source/tasks.c **** 
4750:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4751:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4752:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4753:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4754:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4755:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4756:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4757:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4758:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4759:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4760:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4761:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4762:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4763:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4764:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4765:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4766:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4767:FreeRTOS/Source/tasks.c **** 
4768:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4769:FreeRTOS/Source/tasks.c **** 
4770:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4771:FreeRTOS/Source/tasks.c **** 		{
4772:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4773:FreeRTOS/Source/tasks.c **** 			{
4774:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4775:FreeRTOS/Source/tasks.c **** 			}
4776:FreeRTOS/Source/tasks.c **** 
4777:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4778:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4779:FreeRTOS/Source/tasks.c **** 
4780:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4781:FreeRTOS/Source/tasks.c **** 			{
4782:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4783:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4784:FreeRTOS/Source/tasks.c **** 					break;
4785:FreeRTOS/Source/tasks.c **** 
4786:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4787:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4788:FreeRTOS/Source/tasks.c **** 					break;
4789:FreeRTOS/Source/tasks.c **** 
4790:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4791:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4792:FreeRTOS/Source/tasks.c **** 					break;
4793:FreeRTOS/Source/tasks.c **** 
4794:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4795:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4796:FreeRTOS/Source/tasks.c **** 					{
4797:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4798:FreeRTOS/Source/tasks.c **** 					}
4799:FreeRTOS/Source/tasks.c **** 					else
4800:FreeRTOS/Source/tasks.c **** 					{
4801:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4802:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4803:FreeRTOS/Source/tasks.c **** 					}
4804:FreeRTOS/Source/tasks.c **** 					break;
4805:FreeRTOS/Source/tasks.c **** 
4806:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4807:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4808:FreeRTOS/Source/tasks.c **** 					updated. */
4809:FreeRTOS/Source/tasks.c **** 					break;
4810:FreeRTOS/Source/tasks.c **** 
4811:FreeRTOS/Source/tasks.c **** 				default:
4812:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4813:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4814:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4815:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4816:FreeRTOS/Source/tasks.c **** 					break;
4817:FreeRTOS/Source/tasks.c **** 			}
4818:FreeRTOS/Source/tasks.c **** 
4819:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4820:FreeRTOS/Source/tasks.c **** 
4821:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4822:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4823:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4824:FreeRTOS/Source/tasks.c **** 			{
4825:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4826:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4827:FreeRTOS/Source/tasks.c **** 
4828:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4829:FreeRTOS/Source/tasks.c **** 				{
4830:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4831:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4832:FreeRTOS/Source/tasks.c **** 				}
4833:FreeRTOS/Source/tasks.c **** 				else
4834:FreeRTOS/Source/tasks.c **** 				{
4835:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4836:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4837:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4838:FreeRTOS/Source/tasks.c **** 				}
4839:FreeRTOS/Source/tasks.c **** 
4840:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4841:FreeRTOS/Source/tasks.c **** 				{
4842:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4843:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4844:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4845:FreeRTOS/Source/tasks.c **** 					{
4846:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4847:FreeRTOS/Source/tasks.c **** 					}
4848:FreeRTOS/Source/tasks.c **** 
4849:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4850:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
4851:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
4852:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
4853:FreeRTOS/Source/tasks.c **** 				}
4854:FreeRTOS/Source/tasks.c **** 				else
4855:FreeRTOS/Source/tasks.c **** 				{
4856:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4857:FreeRTOS/Source/tasks.c **** 				}
4858:FreeRTOS/Source/tasks.c **** 			}
4859:FreeRTOS/Source/tasks.c **** 		}
4860:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4861:FreeRTOS/Source/tasks.c **** 
4862:FreeRTOS/Source/tasks.c **** 		return xReturn;
4863:FreeRTOS/Source/tasks.c **** 	}
4864:FreeRTOS/Source/tasks.c **** 
4865:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4867:FreeRTOS/Source/tasks.c **** 
4868:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4869:FreeRTOS/Source/tasks.c **** 
4870:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4871:FreeRTOS/Source/tasks.c **** 	{
4872:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4873:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4874:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4875:FreeRTOS/Source/tasks.c **** 
4876:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4877:FreeRTOS/Source/tasks.c **** 
4878:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4879:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4880:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4881:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4882:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4883:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4884:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4885:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4886:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4887:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4888:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4889:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4890:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4891:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4892:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4893:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4894:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4895:FreeRTOS/Source/tasks.c **** 
4896:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4897:FreeRTOS/Source/tasks.c **** 
4898:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4899:FreeRTOS/Source/tasks.c **** 		{
4900:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4901:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4902:FreeRTOS/Source/tasks.c **** 
4903:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4904:FreeRTOS/Source/tasks.c **** 			semaphore. */
4905:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4906:FreeRTOS/Source/tasks.c **** 
4907:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4908:FreeRTOS/Source/tasks.c **** 
4909:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4910:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4911:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4912:FreeRTOS/Source/tasks.c **** 			{
4913:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4914:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4915:FreeRTOS/Source/tasks.c **** 
4916:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4917:FreeRTOS/Source/tasks.c **** 				{
4918:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4919:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4920:FreeRTOS/Source/tasks.c **** 				}
4921:FreeRTOS/Source/tasks.c **** 				else
4922:FreeRTOS/Source/tasks.c **** 				{
4923:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4924:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4925:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4926:FreeRTOS/Source/tasks.c **** 				}
4927:FreeRTOS/Source/tasks.c **** 
4928:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4929:FreeRTOS/Source/tasks.c **** 				{
4930:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4931:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4932:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4933:FreeRTOS/Source/tasks.c **** 					{
4934:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4935:FreeRTOS/Source/tasks.c **** 					}
4936:FreeRTOS/Source/tasks.c **** 
4937:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4938:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
4939:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
4940:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
4941:FreeRTOS/Source/tasks.c **** 				}
4942:FreeRTOS/Source/tasks.c **** 				else
4943:FreeRTOS/Source/tasks.c **** 				{
4944:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4945:FreeRTOS/Source/tasks.c **** 				}
4946:FreeRTOS/Source/tasks.c **** 			}
4947:FreeRTOS/Source/tasks.c **** 		}
4948:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4949:FreeRTOS/Source/tasks.c **** 	}
4950:FreeRTOS/Source/tasks.c **** 
4951:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4952:FreeRTOS/Source/tasks.c **** 
4953:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4954:FreeRTOS/Source/tasks.c **** 
4955:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4956:FreeRTOS/Source/tasks.c **** 
4957:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4958:FreeRTOS/Source/tasks.c **** 	{
4959:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
4960:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4961:FreeRTOS/Source/tasks.c **** 
4962:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4963:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
4964:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4965:FreeRTOS/Source/tasks.c **** 
4966:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4967:FreeRTOS/Source/tasks.c **** 		{
4968:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4969:FreeRTOS/Source/tasks.c **** 			{
4970:FreeRTOS/Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4971:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
4972:FreeRTOS/Source/tasks.c **** 			}
4973:FreeRTOS/Source/tasks.c **** 			else
4974:FreeRTOS/Source/tasks.c **** 			{
4975:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
4976:FreeRTOS/Source/tasks.c **** 			}
4977:FreeRTOS/Source/tasks.c **** 		}
4978:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4979:FreeRTOS/Source/tasks.c **** 
4980:FreeRTOS/Source/tasks.c **** 		return xReturn;
4981:FreeRTOS/Source/tasks.c **** 	}
4982:FreeRTOS/Source/tasks.c **** 
4983:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4984:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4985:FreeRTOS/Source/tasks.c **** 
4986:FreeRTOS/Source/tasks.c **** 
4987:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4988:FreeRTOS/Source/tasks.c **** {
 242               	.LM5:
 243               	.LFBB2:
 244 0036 FF92      		push r15
 245 0038 0F93      		push r16
 246 003a 1F93      		push r17
 247 003c CF93      		push r28
 248 003e DF93      		push r29
 249               	/* prologue: function */
 250               	/* frame size = 0 */
 251               	/* stack size = 5 */
 252               	.L__stack_usage = 5
 253 0040 EC01      		movw r28,r24
 254 0042 F62E      		mov r15,r22
4989:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
4990:FreeRTOS/Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 256               	.LM6:
 257 0044 0091 0000 		lds r16,xTickCount
 258 0048 1091 0000 		lds r17,xTickCount+1
4991:FreeRTOS/Source/tasks.c **** 
4992:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4993:FreeRTOS/Source/tasks.c **** 	{
4994:FreeRTOS/Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4995:FreeRTOS/Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4996:FreeRTOS/Source/tasks.c **** 		when the task leaves the Blocked state. */
4997:FreeRTOS/Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4998:FreeRTOS/Source/tasks.c **** 	}
4999:FreeRTOS/Source/tasks.c **** 	#endif
5000:FreeRTOS/Source/tasks.c **** 
5001:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5002:FreeRTOS/Source/tasks.c **** 	as the same list item is used for both lists. */
5003:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 260               	.LM7:
 261 004c 8091 0000 		lds r24,pxCurrentTCB
 262 0050 9091 0000 		lds r25,pxCurrentTCB+1
 263 0054 0296      		adiw r24,2
 264 0056 0E94 0000 		call uxListRemove
5004:FreeRTOS/Source/tasks.c **** 	{
5005:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5006:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5007:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
5008:FreeRTOS/Source/tasks.c **** 	}
5009:FreeRTOS/Source/tasks.c **** 	else
5010:FreeRTOS/Source/tasks.c **** 	{
5011:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5012:FreeRTOS/Source/tasks.c **** 	}
5013:FreeRTOS/Source/tasks.c **** 
5014:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5015:FreeRTOS/Source/tasks.c **** 	{
5016:FreeRTOS/Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 266               	.LM8:
 267 005a CF3F      		cpi r28,-1
 268 005c 8FEF      		ldi r24,-1
 269 005e D807      		cpc r29,r24
 270 0060 01F4      		brne .L7
 272               	.LM9:
 273 0062 FF20      		tst r15
 274 0064 01F0      		breq .L7
 275               	.LBB10:
 276               	.LBB11:
5017:FreeRTOS/Source/tasks.c **** 		{
5018:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5019:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5020:FreeRTOS/Source/tasks.c **** 			indefinitely. */
5021:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 278               	.LM10:
 279 0066 6091 0000 		lds r22,pxCurrentTCB
 280 006a 7091 0000 		lds r23,pxCurrentTCB+1
 281 006e 6E5F      		subi r22,-2
 282 0070 7F4F      		sbci r23,-1
 283 0072 80E0      		ldi r24,lo8(xSuspendedTaskList)
 284 0074 90E0      		ldi r25,hi8(xSuspendedTaskList)
 285               	/* epilogue start */
 286               	.LBE11:
 287               	.LBE10:
5022:FreeRTOS/Source/tasks.c **** 		}
5023:FreeRTOS/Source/tasks.c **** 		else
5024:FreeRTOS/Source/tasks.c **** 		{
5025:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5026:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5027:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
5028:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5029:FreeRTOS/Source/tasks.c **** 
5030:FreeRTOS/Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5031:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5032:FreeRTOS/Source/tasks.c **** 
5033:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5034:FreeRTOS/Source/tasks.c **** 			{
5035:FreeRTOS/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5036:FreeRTOS/Source/tasks.c **** 				list. */
5037:FreeRTOS/Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5038:FreeRTOS/Source/tasks.c **** 			}
5039:FreeRTOS/Source/tasks.c **** 			else
5040:FreeRTOS/Source/tasks.c **** 			{
5041:FreeRTOS/Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5042:FreeRTOS/Source/tasks.c **** 				is used. */
5043:FreeRTOS/Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5044:FreeRTOS/Source/tasks.c **** 
5045:FreeRTOS/Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5046:FreeRTOS/Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5047:FreeRTOS/Source/tasks.c **** 				needs to be updated too. */
5048:FreeRTOS/Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5049:FreeRTOS/Source/tasks.c **** 				{
5050:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5051:FreeRTOS/Source/tasks.c **** 				}
5052:FreeRTOS/Source/tasks.c **** 				else
5053:FreeRTOS/Source/tasks.c **** 				{
5054:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5055:FreeRTOS/Source/tasks.c **** 				}
5056:FreeRTOS/Source/tasks.c **** 			}
5057:FreeRTOS/Source/tasks.c **** 		}
5058:FreeRTOS/Source/tasks.c **** 	}
5059:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5060:FreeRTOS/Source/tasks.c **** 	{
5061:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5062:FreeRTOS/Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5063:FreeRTOS/Source/tasks.c **** 		will manage it correctly. */
5064:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
5065:FreeRTOS/Source/tasks.c **** 
5066:FreeRTOS/Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5067:FreeRTOS/Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5068:FreeRTOS/Source/tasks.c **** 
5069:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5070:FreeRTOS/Source/tasks.c **** 		{
5071:FreeRTOS/Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5072:FreeRTOS/Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5073:FreeRTOS/Source/tasks.c **** 		}
5074:FreeRTOS/Source/tasks.c **** 		else
5075:FreeRTOS/Source/tasks.c **** 		{
5076:FreeRTOS/Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5077:FreeRTOS/Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5078:FreeRTOS/Source/tasks.c **** 
5079:FreeRTOS/Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5080:FreeRTOS/Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5081:FreeRTOS/Source/tasks.c **** 			too. */
5082:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5083:FreeRTOS/Source/tasks.c **** 			{
5084:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5085:FreeRTOS/Source/tasks.c **** 			}
5086:FreeRTOS/Source/tasks.c **** 			else
5087:FreeRTOS/Source/tasks.c **** 			{
5088:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5089:FreeRTOS/Source/tasks.c **** 			}
5090:FreeRTOS/Source/tasks.c **** 		}
5091:FreeRTOS/Source/tasks.c **** 
5092:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5093:FreeRTOS/Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5094:FreeRTOS/Source/tasks.c **** 	}
5095:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5096:FreeRTOS/Source/tasks.c **** }
 289               	.LM11:
 290 0076 DF91      		pop r29
 291 0078 CF91      		pop r28
 292 007a 1F91      		pop r17
 293 007c 0F91      		pop r16
 294 007e FF90      		pop r15
 295               	.LBB13:
 296               	.LBB12:
5021:FreeRTOS/Source/tasks.c **** 		}
 298               	.LM12:
 299 0080 0C94 0000 		jmp vListInsertEnd
 300               	.L7:
 301               	.LBE12:
 302               	.LBE13:
5028:FreeRTOS/Source/tasks.c **** 
 304               	.LM13:
 305 0084 C00F      		add r28,r16
 306 0086 D11F      		adc r29,r17
5031:FreeRTOS/Source/tasks.c **** 
 308               	.LM14:
 309 0088 E091 0000 		lds r30,pxCurrentTCB
 310 008c F091 0000 		lds r31,pxCurrentTCB+1
 311 0090 D383      		std Z+3,r29
 312 0092 C283      		std Z+2,r28
5037:FreeRTOS/Source/tasks.c **** 			}
 314               	.LM15:
 315 0094 6091 0000 		lds r22,pxCurrentTCB
 316 0098 7091 0000 		lds r23,pxCurrentTCB+1
5033:FreeRTOS/Source/tasks.c **** 			{
 318               	.LM16:
 319 009c C017      		cp r28,r16
 320 009e D107      		cpc r29,r17
 321 00a0 00F4      		brsh .L8
5037:FreeRTOS/Source/tasks.c **** 			}
 323               	.LM17:
 324 00a2 8091 0000 		lds r24,pxOverflowDelayedTaskList
 325 00a6 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 326 00aa 6E5F      		subi r22,-2
 327 00ac 7F4F      		sbci r23,-1
 328               	/* epilogue start */
 330               	.LM18:
 331 00ae DF91      		pop r29
 332 00b0 CF91      		pop r28
 333 00b2 1F91      		pop r17
 334 00b4 0F91      		pop r16
 335 00b6 FF90      		pop r15
5037:FreeRTOS/Source/tasks.c **** 			}
 337               	.LM19:
 338 00b8 0C94 0000 		jmp vListInsert
 339               	.L8:
5043:FreeRTOS/Source/tasks.c **** 
 341               	.LM20:
 342 00bc 8091 0000 		lds r24,pxDelayedTaskList
 343 00c0 9091 0000 		lds r25,pxDelayedTaskList+1
 344 00c4 6E5F      		subi r22,-2
 345 00c6 7F4F      		sbci r23,-1
 346 00c8 0E94 0000 		call vListInsert
5048:FreeRTOS/Source/tasks.c **** 				{
 348               	.LM21:
 349 00cc 8091 0000 		lds r24,xNextTaskUnblockTime
 350 00d0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 351 00d4 C817      		cp r28,r24
 352 00d6 D907      		cpc r29,r25
 353 00d8 00F4      		brsh .L6
5050:FreeRTOS/Source/tasks.c **** 				}
 355               	.LM22:
 356 00da D093 0000 		sts xNextTaskUnblockTime+1,r29
 357 00de C093 0000 		sts xNextTaskUnblockTime,r28
 358               	.L6:
 359               	/* epilogue start */
 361               	.LM23:
 362 00e2 DF91      		pop r29
 363 00e4 CF91      		pop r28
 364 00e6 1F91      		pop r17
 365 00e8 0F91      		pop r16
 366 00ea FF90      		pop r15
 367 00ec 0895      		ret
 373               	.Lscope2:
 375               		.stabd	78,0,0
 379               	prvIdleTask:
 380               		.stabd	46,0,0
3288:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 382               	.LM24:
 383               	.LFBB3:
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 0 */
 387               	.L__stack_usage = 0
 388               	.L14:
 389               	.LBB20:
 390               	.LBB21:
3542:FreeRTOS/Source/tasks.c **** 		{
 392               	.LM25:
 393 00ee 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 394 00f2 8823      		tst r24
 395 00f4 01F0      		breq .L18
3544:FreeRTOS/Source/tasks.c **** 			{
 397               	.LM26:
 398               	/* #APP */
 399               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 400 00f6 0FB6      		in		__tmp_reg__, __SREG__
 401               	 ;  0 "" 2
 402               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 403 00f8 F894      		cli
 404               	 ;  0 "" 2
 405               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 406 00fa 0F92      		push	__tmp_reg__
 407               	 ;  0 "" 2
3546:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 409               	.LM27:
 410               	/* #NOAPP */
 411 00fc E091 0000 		lds r30,xTasksWaitingTermination+5
 412 0100 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 413 0104 C681      		ldd r28,Z+6
 414 0106 D781      		ldd r29,Z+7
3547:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 416               	.LM28:
 417 0108 CE01      		movw r24,r28
 418 010a 0296      		adiw r24,2
 419 010c 0E94 0000 		call uxListRemove
3548:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 421               	.LM29:
 422 0110 8091 0000 		lds r24,uxCurrentNumberOfTasks
 423 0114 8150      		subi r24,lo8(-(-1))
 424 0116 8093 0000 		sts uxCurrentNumberOfTasks,r24
3549:FreeRTOS/Source/tasks.c **** 			}
 426               	.LM30:
 427 011a 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 428 011e 8150      		subi r24,lo8(-(-1))
 429 0120 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3551:FreeRTOS/Source/tasks.c **** 
 431               	.LM31:
 432               	/* #APP */
 433               	 ;  3551 "FreeRTOS/Source/tasks.c" 1
 434 0124 0F90      		pop		__tmp_reg__
 435               	 ;  0 "" 2
 436               	 ;  3551 "FreeRTOS/Source/tasks.c" 1
 437 0126 0FBE      		out		__SREG__, __tmp_reg__
 438               	 ;  0 "" 2
 439               	/* #NOAPP */
 440               	.LBB22:
 441               	.LBB23:
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 443               	.LM32:
 444 0128 8F89      		ldd r24,Y+23
 445 012a 988D      		ldd r25,Y+24
 446 012c 0E94 0000 		call vPortFree
3759:FreeRTOS/Source/tasks.c **** 		}
 448               	.LM33:
 449 0130 CE01      		movw r24,r28
 450 0132 0E94 0000 		call vPortFree
 451 0136 00C0      		rjmp .L14
 452               	.L18:
 453               	.LBE23:
 454               	.LBE22:
 455               	.LBE21:
 456               	.LBE20:
3327:FreeRTOS/Source/tasks.c **** 			{
 458               	.LM34:
 459 0138 8091 0000 		lds r24,pxReadyTasksLists
 460 013c 8230      		cpi r24,lo8(2)
 461 013e 00F0      		brlo .L16
3329:FreeRTOS/Source/tasks.c **** 			}
 463               	.LM35:
 464 0140 0E94 0000 		call vPortYield
 465               	.L16:
 466               	.LBB24:
3347:FreeRTOS/Source/tasks.c **** 		}
 468               	.LM36:
 469 0144 0E94 0000 		call vApplicationIdleHook
 470               	.LBE24:
3400:FreeRTOS/Source/tasks.c **** }
 472               	.LM37:
 473 0148 00C0      		rjmp .L14
 478               	.Lscope3:
 480               		.stabd	78,0,0
 487               	.global	xTaskCreate
 489               	xTaskCreate:
 490               		.stabd	46,0,0
 753:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 492               	.LM38:
 493               	.LFBB4:
 494 014a 3F92      		push r3
 495 014c 4F92      		push r4
 496 014e 5F92      		push r5
 497 0150 6F92      		push r6
 498 0152 7F92      		push r7
 499 0154 8F92      		push r8
 500 0156 9F92      		push r9
 501 0158 AF92      		push r10
 502 015a BF92      		push r11
 503 015c CF92      		push r12
 504 015e DF92      		push r13
 505 0160 EF92      		push r14
 506 0162 FF92      		push r15
 507 0164 0F93      		push r16
 508 0166 1F93      		push r17
 509 0168 CF93      		push r28
 510 016a DF93      		push r29
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 17 */
 514               	.L__stack_usage = 17
 515 016c 4C01      		movw r8,r24
 516 016e 162F      		mov r17,r22
 517 0170 372E      		mov r3,r23
 518 0172 6A01      		movw r12,r20
 519 0174 5901      		movw r10,r18
 520               	.LBB32:
 787:FreeRTOS/Source/tasks.c **** 
 522               	.LM39:
 523 0176 CA01      		movw r24,r20
 524 0178 0E94 0000 		call pvPortMalloc
 525 017c 2C01      		movw r4,r24
 789:FreeRTOS/Source/tasks.c **** 			{
 527               	.LM40:
 528 017e 892B      		or r24,r25
 529 0180 01F4      		brne .+2
 530 0182 00C0      		rjmp .L20
 792:FreeRTOS/Source/tasks.c **** 
 532               	.LM41:
 533 0184 86E2      		ldi r24,lo8(38)
 534 0186 90E0      		ldi r25,0
 535 0188 0E94 0000 		call pvPortMalloc
 536 018c EC01      		movw r28,r24
 794:FreeRTOS/Source/tasks.c **** 				{
 538               	.LM42:
 539 018e 892B      		or r24,r25
 540 0190 01F0      		breq .L21
 797:FreeRTOS/Source/tasks.c **** 				}
 542               	.LM43:
 543 0192 588E      		std Y+24,r5
 544 0194 4F8A      		std Y+23,r4
 545               	.LBE32:
 546               	.LBB33:
 547               	.LBB34:
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 549               	.LM44:
 550 0196 C601      		movw r24,r12
 551 0198 0197      		sbiw r24,1
 552 019a 3201      		movw r6,r4
 553 019c 680E      		add r6,r24
 554 019e 791E      		adc r7,r25
 555 01a0 BE01      		movw r22,r28
 556 01a2 675E      		subi r22,-25
 557 01a4 7F4F      		sbci r23,-1
 558 01a6 E12F      		mov r30,r17
 559 01a8 F32D      		mov r31,r3
 560 01aa CF01      		movw r24,r30
 561 01ac 0896      		adiw r24,8
 562 01ae 00C0      		rjmp .L22
 563               	.L21:
 564               	.LBE34:
 565               	.LBE33:
 566               	.LBB36:
 803:FreeRTOS/Source/tasks.c **** 				}
 568               	.LM45:
 569 01b0 C201      		movw r24,r4
 570 01b2 0E94 0000 		call vPortFree
 571 01b6 00C0      		rjmp .L20
 572               	.L45:
 573               	.LBE36:
 574               	.LBB37:
 575               	.LBB35:
 908:FreeRTOS/Source/tasks.c **** 	{
 577               	.LM46:
 578 01b8 E817      		cp r30,r24
 579 01ba F907      		cpc r31,r25
 580 01bc 01F0      		breq .L23
 581               	.L22:
 582 01be 9F01      		movw r18,r30
 910:FreeRTOS/Source/tasks.c **** 
 584               	.LM47:
 585 01c0 4191      		ld r20,Z+
 586 01c2 DB01      		movw r26,r22
 587 01c4 4D93      		st X+,r20
 588 01c6 BD01      		movw r22,r26
 915:FreeRTOS/Source/tasks.c **** 		{
 590               	.LM48:
 591 01c8 D901      		movw r26,r18
 592 01ca 2C91      		ld r18,X
 593 01cc 2111      		cpse r18,__zero_reg__
 594 01ce 00C0      		rjmp .L45
 595               	.L23:
 927:FreeRTOS/Source/tasks.c **** 
 597               	.LM49:
 598 01d0 18A2      		std Y+32,__zero_reg__
 599 01d2 0430      		cpi r16,lo8(4)
 600 01d4 00F0      		brlo .L24
 601 01d6 03E0      		ldi r16,lo8(3)
 602               	.L24:
 940:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 604               	.LM50:
 605 01d8 0E8B      		std Y+22,r16
 948:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 607               	.LM51:
 608 01da 6E01      		movw r12,r28
 609 01dc B2E0      		ldi r27,2
 610 01de CB0E      		add r12,r27
 611 01e0 D11C      		adc r13,__zero_reg__
 612 01e2 C601      		movw r24,r12
 613 01e4 0E94 0000 		call vListInitialiseItem
 949:FreeRTOS/Source/tasks.c **** 
 615               	.LM52:
 616 01e8 CE01      		movw r24,r28
 617 01ea 0C96      		adiw r24,12
 618 01ec 0E94 0000 		call vListInitialiseItem
 953:FreeRTOS/Source/tasks.c **** 
 620               	.LM53:
 621 01f0 D987      		std Y+9,r29
 622 01f2 C887      		std Y+8,r28
 956:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 624               	.LM54:
 625 01f4 84E0      		ldi r24,lo8(4)
 626 01f6 90E0      		ldi r25,0
 627 01f8 801B      		sub r24,r16
 628 01fa 9109      		sbc r25,__zero_reg__
 629 01fc 9D87      		std Y+13,r25
 630 01fe 8C87      		std Y+12,r24
 957:FreeRTOS/Source/tasks.c **** 
 632               	.LM55:
 633 0200 DB8B      		std Y+19,r29
 634 0202 CA8B      		std Y+18,r28
 999:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 636               	.LM56:
 637 0204 19A2      		std Y+33,__zero_reg__
 638 0206 1AA2      		std Y+34,__zero_reg__
 639 0208 1BA2      		std Y+35,__zero_reg__
 640 020a 1CA2      		std Y+36,__zero_reg__
1000:FreeRTOS/Source/tasks.c **** 	}
 642               	.LM57:
 643 020c 1DA2      		std Y+37,__zero_reg__
1027:FreeRTOS/Source/tasks.c **** 	}
 645               	.LM58:
 646 020e A501      		movw r20,r10
 647 0210 B401      		movw r22,r8
 648 0212 C301      		movw r24,r6
 649 0214 0E94 0000 		call pxPortInitialiseStack
 650 0218 9983      		std Y+1,r25
 651 021a 8883      		st Y,r24
1031:FreeRTOS/Source/tasks.c **** 	{
 653               	.LM59:
 654 021c E114      		cp r14,__zero_reg__
 655 021e F104      		cpc r15,__zero_reg__
 656 0220 01F0      		breq .L25
1035:FreeRTOS/Source/tasks.c **** 	}
 658               	.LM60:
 659 0222 F701      		movw r30,r14
 660 0224 D183      		std Z+1,r29
 661 0226 C083      		st Z,r28
 662               	.L25:
 663               	.LBE35:
 664               	.LBE37:
 665               	.LBB38:
 666               	.LBB39:
1048:FreeRTOS/Source/tasks.c **** 	{
 668               	.LM61:
 669               	/* #APP */
 670               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 671 0228 0FB6      		in		__tmp_reg__, __SREG__
 672               	 ;  0 "" 2
 673               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 674 022a F894      		cli
 675               	 ;  0 "" 2
 676               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 677 022c 0F92      		push	__tmp_reg__
 678               	 ;  0 "" 2
1050:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 680               	.LM62:
 681               	/* #NOAPP */
 682 022e 8091 0000 		lds r24,uxCurrentNumberOfTasks
 683 0232 8F5F      		subi r24,lo8(-(1))
 684 0234 8093 0000 		sts uxCurrentNumberOfTasks,r24
1051:FreeRTOS/Source/tasks.c **** 		{
 686               	.LM63:
 687 0238 8091 0000 		lds r24,pxCurrentTCB
 688 023c 9091 0000 		lds r25,pxCurrentTCB+1
 689 0240 892B      		or r24,r25
 690 0242 01F4      		brne .L26
1055:FreeRTOS/Source/tasks.c **** 
 692               	.LM64:
 693 0244 D093 0000 		sts pxCurrentTCB+1,r29
 694 0248 C093 0000 		sts pxCurrentTCB,r28
1057:FreeRTOS/Source/tasks.c **** 			{
 696               	.LM65:
 697 024c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 698 0250 8130      		cpi r24,lo8(1)
 699 0252 01F0      		breq .+2
 700 0254 00C0      		rjmp .L28
 701               	.LBB40:
 702               	.LBB41:
3505:FreeRTOS/Source/tasks.c **** 	}
 704               	.LM66:
 705 0256 80E0      		ldi r24,lo8(pxReadyTasksLists)
 706 0258 90E0      		ldi r25,hi8(pxReadyTasksLists)
 707 025a 0E94 0000 		call vListInitialise
 708 025e 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 709 0260 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 710 0262 0E94 0000 		call vListInitialise
 711 0266 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 712 0268 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 713 026a 0E94 0000 		call vListInitialise
 714 026e 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 715 0270 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 716 0272 0E94 0000 		call vListInitialise
3508:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 718               	.LM67:
 719 0276 80E0      		ldi r24,lo8(xDelayedTaskList1)
 720 0278 90E0      		ldi r25,hi8(xDelayedTaskList1)
 721 027a 0E94 0000 		call vListInitialise
3509:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 723               	.LM68:
 724 027e 80E0      		ldi r24,lo8(xDelayedTaskList2)
 725 0280 90E0      		ldi r25,hi8(xDelayedTaskList2)
 726 0282 0E94 0000 		call vListInitialise
3510:FreeRTOS/Source/tasks.c **** 
 728               	.LM69:
 729 0286 80E0      		ldi r24,lo8(xPendingReadyList)
 730 0288 90E0      		ldi r25,hi8(xPendingReadyList)
 731 028a 0E94 0000 		call vListInitialise
3514:FreeRTOS/Source/tasks.c **** 	}
 733               	.LM70:
 734 028e 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 735 0290 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 736 0292 0E94 0000 		call vListInitialise
3520:FreeRTOS/Source/tasks.c **** 	}
 738               	.LM71:
 739 0296 80E0      		ldi r24,lo8(xSuspendedTaskList)
 740 0298 90E0      		ldi r25,hi8(xSuspendedTaskList)
 741 029a 0E94 0000 		call vListInitialise
3526:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 743               	.LM72:
 744 029e 80E0      		ldi r24,lo8(xDelayedTaskList1)
 745 02a0 90E0      		ldi r25,hi8(xDelayedTaskList1)
 746 02a2 9093 0000 		sts pxDelayedTaskList+1,r25
 747 02a6 8093 0000 		sts pxDelayedTaskList,r24
3527:FreeRTOS/Source/tasks.c **** }
 749               	.LM73:
 750 02aa 80E0      		ldi r24,lo8(xDelayedTaskList2)
 751 02ac 90E0      		ldi r25,hi8(xDelayedTaskList2)
 752 02ae 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 753 02b2 8093 0000 		sts pxOverflowDelayedTaskList,r24
 754 02b6 00C0      		rjmp .L28
 755               	.L26:
 756               	.LBE41:
 757               	.LBE40:
1074:FreeRTOS/Source/tasks.c **** 			{
 759               	.LM74:
 760 02b8 8091 0000 		lds r24,xSchedulerRunning
 761 02bc 8111      		cpse r24,__zero_reg__
 762 02be 00C0      		rjmp .L28
1076:FreeRTOS/Source/tasks.c **** 				{
 764               	.LM75:
 765 02c0 E091 0000 		lds r30,pxCurrentTCB
 766 02c4 F091 0000 		lds r31,pxCurrentTCB+1
 767 02c8 9689      		ldd r25,Z+22
 768 02ca 8E89      		ldd r24,Y+22
 769 02cc 8917      		cp r24,r25
 770 02ce 00F0      		brlo .L28
1078:FreeRTOS/Source/tasks.c **** 				}
 772               	.LM76:
 773 02d0 D093 0000 		sts pxCurrentTCB+1,r29
 774 02d4 C093 0000 		sts pxCurrentTCB,r28
 775               	.L28:
1091:FreeRTOS/Source/tasks.c **** 
 777               	.LM77:
 778 02d8 8091 0000 		lds r24,uxTaskNumber
 779 02dc 8F5F      		subi r24,lo8(-(1))
 780 02de 8093 0000 		sts uxTaskNumber,r24
1101:FreeRTOS/Source/tasks.c **** 
 782               	.LM78:
 783 02e2 8E89      		ldd r24,Y+22
 784 02e4 9091 0000 		lds r25,uxTopReadyPriority
 785 02e8 9817      		cp r25,r24
 786 02ea 00F4      		brsh .L30
 787 02ec 8093 0000 		sts uxTopReadyPriority,r24
 788               	.L30:
 789 02f0 F9E0      		ldi r31,lo8(9)
 790 02f2 8F9F      		mul r24,r31
 791 02f4 C001      		movw r24,r0
 792 02f6 1124      		clr __zero_reg__
 793 02f8 B601      		movw r22,r12
 794 02fa 8050      		subi r24,lo8(-(pxReadyTasksLists))
 795 02fc 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 796 02fe 0E94 0000 		call vListInsertEnd
1105:FreeRTOS/Source/tasks.c **** 
 798               	.LM79:
 799               	/* #APP */
 800               	 ;  1105 "FreeRTOS/Source/tasks.c" 1
 801 0302 0F90      		pop		__tmp_reg__
 802               	 ;  0 "" 2
 803               	 ;  1105 "FreeRTOS/Source/tasks.c" 1
 804 0304 0FBE      		out		__SREG__, __tmp_reg__
 805               	 ;  0 "" 2
1107:FreeRTOS/Source/tasks.c **** 	{
 807               	.LM80:
 808               	/* #NOAPP */
 809 0306 8091 0000 		lds r24,xSchedulerRunning
 810 030a 8823      		tst r24
 811 030c 01F0      		breq .L33
1111:FreeRTOS/Source/tasks.c **** 		{
 813               	.LM81:
 814 030e E091 0000 		lds r30,pxCurrentTCB
 815 0312 F091 0000 		lds r31,pxCurrentTCB+1
 816 0316 9689      		ldd r25,Z+22
 817 0318 8E89      		ldd r24,Y+22
 818 031a 9817      		cp r25,r24
 819 031c 00F4      		brsh .L33
1113:FreeRTOS/Source/tasks.c **** 		}
 821               	.LM82:
 822 031e 0E94 0000 		call vPortYield
 823               	.L33:
 824               	.LBE39:
 825               	.LBE38:
 825:FreeRTOS/Source/tasks.c **** 		}
 827               	.LM83:
 828 0322 81E0      		ldi r24,lo8(1)
 829 0324 00C0      		rjmp .L44
 830               	.L20:
 829:FreeRTOS/Source/tasks.c **** 		}
 832               	.LM84:
 833 0326 8FEF      		ldi r24,lo8(-1)
 834               	.L44:
 835               	/* epilogue start */
 833:FreeRTOS/Source/tasks.c **** 
 837               	.LM85:
 838 0328 DF91      		pop r29
 839 032a CF91      		pop r28
 840 032c 1F91      		pop r17
 841 032e 0F91      		pop r16
 842 0330 FF90      		pop r15
 843 0332 EF90      		pop r14
 844 0334 DF90      		pop r13
 845 0336 CF90      		pop r12
 846 0338 BF90      		pop r11
 847 033a AF90      		pop r10
 848 033c 9F90      		pop r9
 849 033e 8F90      		pop r8
 850 0340 7F90      		pop r7
 851 0342 6F90      		pop r6
 852 0344 5F90      		pop r5
 853 0346 4F90      		pop r4
 854 0348 3F90      		pop r3
 855 034a 0895      		ret
 873               	.Lscope4:
 875               		.stabd	78,0,0
 878               	.global	vTaskDelete
 880               	vTaskDelete:
 881               		.stabd	46,0,0
1130:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 883               	.LM86:
 884               	.LFBB5:
 885 034c 0F93      		push r16
 886 034e 1F93      		push r17
 887 0350 CF93      		push r28
 888 0352 DF93      		push r29
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 4 */
 892               	.L__stack_usage = 4
 893 0354 EC01      		movw r28,r24
1133:FreeRTOS/Source/tasks.c **** 		{
 895               	.LM87:
 896               	/* #APP */
 897               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 898 0356 0FB6      		in		__tmp_reg__, __SREG__
 899               	 ;  0 "" 2
 900               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 901 0358 F894      		cli
 902               	 ;  0 "" 2
 903               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 904 035a 0F92      		push	__tmp_reg__
 905               	 ;  0 "" 2
1137:FreeRTOS/Source/tasks.c **** 
 907               	.LM88:
 908               	/* #NOAPP */
 909 035c 892B      		or r24,r25
 910 035e 01F4      		brne .L47
1137:FreeRTOS/Source/tasks.c **** 
 912               	.LM89:
 913 0360 C091 0000 		lds r28,pxCurrentTCB
 914 0364 D091 0000 		lds r29,pxCurrentTCB+1
 915               	.L47:
1140:FreeRTOS/Source/tasks.c **** 			{
 917               	.LM90:
 918 0368 8E01      		movw r16,r28
 919 036a 0E5F      		subi r16,-2
 920 036c 1F4F      		sbci r17,-1
 921 036e C801      		movw r24,r16
 922 0370 0E94 0000 		call uxListRemove
1150:FreeRTOS/Source/tasks.c **** 			{
 924               	.LM91:
 925 0374 8C89      		ldd r24,Y+20
 926 0376 9D89      		ldd r25,Y+21
 927 0378 892B      		or r24,r25
 928 037a 01F0      		breq .L48
1152:FreeRTOS/Source/tasks.c **** 			}
 930               	.LM92:
 931 037c CE01      		movw r24,r28
 932 037e 0C96      		adiw r24,12
 933 0380 0E94 0000 		call uxListRemove
 934               	.L48:
1163:FreeRTOS/Source/tasks.c **** 
 936               	.LM93:
 937 0384 8091 0000 		lds r24,uxTaskNumber
 938 0388 8F5F      		subi r24,lo8(-(1))
 939 038a 8093 0000 		sts uxTaskNumber,r24
1165:FreeRTOS/Source/tasks.c **** 			{
 941               	.LM94:
 942 038e 8091 0000 		lds r24,pxCurrentTCB
 943 0392 9091 0000 		lds r25,pxCurrentTCB+1
 944 0396 C817      		cp r28,r24
 945 0398 D907      		cpc r29,r25
 946 039a 01F4      		brne .L49
1172:FreeRTOS/Source/tasks.c **** 
 948               	.LM95:
 949 039c B801      		movw r22,r16
 950 039e 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 951 03a0 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 952 03a2 0E94 0000 		call vListInsertEnd
1177:FreeRTOS/Source/tasks.c **** 
 954               	.LM96:
 955 03a6 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 956 03aa 8F5F      		subi r24,lo8(-(1))
 957 03ac 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 958 03b0 00C0      		rjmp .L50
 959               	.L49:
1188:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 961               	.LM97:
 962 03b2 8091 0000 		lds r24,uxCurrentNumberOfTasks
 963 03b6 8150      		subi r24,lo8(-(-1))
 964 03b8 8093 0000 		sts uxCurrentNumberOfTasks,r24
 965               	.LBB44:
 966               	.LBB45:
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 968               	.LM98:
 969 03bc 8F89      		ldd r24,Y+23
 970 03be 988D      		ldd r25,Y+24
 971 03c0 0E94 0000 		call vPortFree
3759:FreeRTOS/Source/tasks.c **** 		}
 973               	.LM99:
 974 03c4 CE01      		movw r24,r28
 975 03c6 0E94 0000 		call vPortFree
 976               	.LBE45:
 977               	.LBE44:
1193:FreeRTOS/Source/tasks.c **** 			}
 979               	.LM100:
 980 03ca 0E94 0000 		call prvResetNextTaskUnblockTime
 981               	.L50:
1198:FreeRTOS/Source/tasks.c **** 
 983               	.LM101:
 984               	/* #APP */
 985               	 ;  1198 "FreeRTOS/Source/tasks.c" 1
 986 03ce 0F90      		pop		__tmp_reg__
 987               	 ;  0 "" 2
 988               	 ;  1198 "FreeRTOS/Source/tasks.c" 1
 989 03d0 0FBE      		out		__SREG__, __tmp_reg__
 990               	 ;  0 "" 2
1202:FreeRTOS/Source/tasks.c **** 		{
 992               	.LM102:
 993               	/* #NOAPP */
 994 03d2 8091 0000 		lds r24,xSchedulerRunning
 995 03d6 8823      		tst r24
 996 03d8 01F0      		breq .L46
1204:FreeRTOS/Source/tasks.c **** 			{
 998               	.LM103:
 999 03da 8091 0000 		lds r24,pxCurrentTCB
 1000 03de 9091 0000 		lds r25,pxCurrentTCB+1
 1001 03e2 C817      		cp r28,r24
 1002 03e4 D907      		cpc r29,r25
 1003 03e6 01F4      		brne .L46
1207:FreeRTOS/Source/tasks.c **** 			}
 1005               	.LM104:
 1006 03e8 0E94 0000 		call vPortYield
 1007               	.L46:
 1008               	/* epilogue start */
1214:FreeRTOS/Source/tasks.c **** 
 1010               	.LM105:
 1011 03ec DF91      		pop r29
 1012 03ee CF91      		pop r28
 1013 03f0 1F91      		pop r17
 1014 03f2 0F91      		pop r16
 1015 03f4 0895      		ret
 1017               	.Lscope5:
 1019               		.stabd	78,0,0
 1022               	.global	vTaskResume
 1024               	vTaskResume:
 1025               		.stabd	46,0,0
1816:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1027               	.LM106:
 1028               	.LFBB6:
 1029 03f6 0F93      		push r16
 1030 03f8 1F93      		push r17
 1031 03fa CF93      		push r28
 1032 03fc DF93      		push r29
 1033               	/* prologue: function */
 1034               	/* frame size = 0 */
 1035               	/* stack size = 4 */
 1036               	.L__stack_usage = 4
1824:FreeRTOS/Source/tasks.c **** 		{
 1038               	.LM107:
 1039 03fe 2091 0000 		lds r18,pxCurrentTCB
 1040 0402 3091 0000 		lds r19,pxCurrentTCB+1
 1041 0406 8217      		cp r24,r18
 1042 0408 9307      		cpc r25,r19
 1043 040a 01F0      		breq .L58
1824:FreeRTOS/Source/tasks.c **** 		{
 1045               	.LM108:
 1046 040c 0097      		sbiw r24,0
 1047 040e 01F0      		breq .L58
1826:FreeRTOS/Source/tasks.c **** 			{
 1049               	.LM109:
 1050               	/* #APP */
 1051               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1052 0410 0FB6      		in		__tmp_reg__, __SREG__
 1053               	 ;  0 "" 2
 1054               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1055 0412 F894      		cli
 1056               	 ;  0 "" 2
 1057               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1058 0414 0F92      		push	__tmp_reg__
 1059               	 ;  0 "" 2
 1060               	/* #NOAPP */
 1061               	.LBB50:
 1062               	.LBB51:
1781:FreeRTOS/Source/tasks.c **** 		{
 1064               	.LM110:
 1065 0416 FC01      		movw r30,r24
 1066 0418 2285      		ldd r18,Z+10
 1067 041a 3385      		ldd r19,Z+11
 1068 041c 2050      		subi r18,lo8(xSuspendedTaskList)
 1069 041e 3040      		sbci r19,hi8(xSuspendedTaskList)
 1070 0420 01F4      		brne .L61
 1071               	.LBB52:
 1072               	.LBB53:
1784:FreeRTOS/Source/tasks.c **** 			{
 1074               	.LM111:
 1075 0422 FC01      		movw r30,r24
 1076 0424 2489      		ldd r18,Z+20
 1077 0426 3589      		ldd r19,Z+21
 1078 0428 F0E0      		ldi r31,hi8(xPendingReadyList)
 1079 042a 2030      		cpi r18,lo8(xPendingReadyList)
 1080 042c 3F07      		cpc r19,r31
 1081 042e 01F0      		breq .L61
1788:FreeRTOS/Source/tasks.c **** 				{
 1083               	.LM112:
 1084 0430 232B      		or r18,r19
 1085 0432 01F4      		brne .L61
 1086 0434 EC01      		movw r28,r24
 1087               	.LBE53:
 1088               	.LBE52:
 1089               	.LBE51:
 1090               	.LBE50:
1834:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1092               	.LM113:
 1093 0436 8C01      		movw r16,r24
 1094 0438 0E5F      		subi r16,-2
 1095 043a 1F4F      		sbci r17,-1
 1096 043c C801      		movw r24,r16
 1097 043e 0E94 0000 		call uxListRemove
1835:FreeRTOS/Source/tasks.c **** 
 1099               	.LM114:
 1100 0442 8E89      		ldd r24,Y+22
 1101 0444 9091 0000 		lds r25,uxTopReadyPriority
 1102 0448 9817      		cp r25,r24
 1103 044a 00F4      		brsh .L65
1835:FreeRTOS/Source/tasks.c **** 
 1105               	.LM115:
 1106 044c 8093 0000 		sts uxTopReadyPriority,r24
 1107               	.L65:
1835:FreeRTOS/Source/tasks.c **** 
 1109               	.LM116:
 1110 0450 29E0      		ldi r18,lo8(9)
 1111 0452 829F      		mul r24,r18
 1112 0454 C001      		movw r24,r0
 1113 0456 1124      		clr __zero_reg__
 1114 0458 B801      		movw r22,r16
 1115 045a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1116 045c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1117 045e 0E94 0000 		call vListInsertEnd
1838:FreeRTOS/Source/tasks.c **** 					{
 1119               	.LM117:
 1120 0462 E091 0000 		lds r30,pxCurrentTCB
 1121 0466 F091 0000 		lds r31,pxCurrentTCB+1
 1122 046a 9E89      		ldd r25,Y+22
 1123 046c 8689      		ldd r24,Z+22
 1124 046e 9817      		cp r25,r24
 1125 0470 00F0      		brlo .L61
1843:FreeRTOS/Source/tasks.c **** 					}
 1127               	.LM118:
 1128 0472 0E94 0000 		call vPortYield
 1129               	.L61:
1855:FreeRTOS/Source/tasks.c **** 		}
 1131               	.LM119:
 1132               	/* #APP */
 1133               	 ;  1855 "FreeRTOS/Source/tasks.c" 1
 1134 0476 0F90      		pop		__tmp_reg__
 1135               	 ;  0 "" 2
 1136               	 ;  1855 "FreeRTOS/Source/tasks.c" 1
 1137 0478 0FBE      		out		__SREG__, __tmp_reg__
 1138               	 ;  0 "" 2
 1139               	/* #NOAPP */
 1140               	.L58:
 1141               	/* epilogue start */
1861:FreeRTOS/Source/tasks.c **** 
 1143               	.LM120:
 1144 047a DF91      		pop r29
 1145 047c CF91      		pop r28
 1146 047e 1F91      		pop r17
 1147 0480 0F91      		pop r16
 1148 0482 0895      		ret
 1150               	.Lscope6:
 1152               		.stabd	78,0,0
 1155               	.global	xTaskResumeFromISR
 1157               	xTaskResumeFromISR:
 1158               		.stabd	46,0,0
1870:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1160               	.LM121:
 1161               	.LFBB7:
 1162 0484 EF92      		push r14
 1163 0486 FF92      		push r15
 1164 0488 1F93      		push r17
 1165 048a CF93      		push r28
 1166 048c DF93      		push r29
 1167               	/* prologue: function */
 1168               	/* frame size = 0 */
 1169               	/* stack size = 5 */
 1170               	.L__stack_usage = 5
 1171 048e EC01      		movw r28,r24
 1172               	.LBB58:
 1173               	.LBB59:
1781:FreeRTOS/Source/tasks.c **** 		{
 1175               	.LM122:
 1176 0490 8A85      		ldd r24,Y+10
 1177 0492 9B85      		ldd r25,Y+11
 1178 0494 8050      		subi r24,lo8(xSuspendedTaskList)
 1179 0496 9040      		sbci r25,hi8(xSuspendedTaskList)
 1180 0498 01F4      		brne .L80
 1181               	.LBB60:
 1182               	.LBB61:
1784:FreeRTOS/Source/tasks.c **** 			{
 1184               	.LM123:
 1185 049a 8C89      		ldd r24,Y+20
 1186 049c 9D89      		ldd r25,Y+21
 1187 049e 20E0      		ldi r18,hi8(xPendingReadyList)
 1188 04a0 8030      		cpi r24,lo8(xPendingReadyList)
 1189 04a2 9207      		cpc r25,r18
 1190 04a4 01F0      		breq .L80
1788:FreeRTOS/Source/tasks.c **** 				{
 1192               	.LM124:
 1193 04a6 892B      		or r24,r25
 1194 04a8 01F4      		brne .L80
 1195               	.LBE61:
 1196               	.LBE60:
 1197               	.LBE59:
 1198               	.LBE58:
1902:FreeRTOS/Source/tasks.c **** 				{
 1200               	.LM125:
 1201 04aa 8091 0000 		lds r24,uxSchedulerSuspended
 1202 04ae 8823      		tst r24
 1203 04b0 01F0      		breq .L77
1923:FreeRTOS/Source/tasks.c **** 				}
 1205               	.LM126:
 1206 04b2 BE01      		movw r22,r28
 1207 04b4 645F      		subi r22,-12
 1208 04b6 7F4F      		sbci r23,-1
 1209 04b8 80E0      		ldi r24,lo8(xPendingReadyList)
 1210 04ba 90E0      		ldi r25,hi8(xPendingReadyList)
 1211 04bc 0E94 0000 		call vListInsertEnd
 1212               	.L80:
1871:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1214               	.LM127:
 1215 04c0 10E0      		ldi r17,0
1933:FreeRTOS/Source/tasks.c **** 	}
 1217               	.LM128:
 1218 04c2 00C0      		rjmp .L81
 1219               	.L77:
1906:FreeRTOS/Source/tasks.c **** 					{
 1221               	.LM129:
 1222 04c4 E091 0000 		lds r30,pxCurrentTCB
 1223 04c8 F091 0000 		lds r31,pxCurrentTCB+1
1871:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1225               	.LM130:
 1226 04cc 11E0      		ldi r17,lo8(1)
 1227 04ce 9E89      		ldd r25,Y+22
 1228 04d0 8689      		ldd r24,Z+22
 1229 04d2 9817      		cp r25,r24
 1230 04d4 00F4      		brsh .L75
 1231 04d6 10E0      		ldi r17,0
 1232               	.L75:
1915:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1234               	.LM131:
 1235 04d8 7E01      		movw r14,r28
 1236 04da 82E0      		ldi r24,2
 1237 04dc E80E      		add r14,r24
 1238 04de F11C      		adc r15,__zero_reg__
 1239 04e0 C701      		movw r24,r14
 1240 04e2 0E94 0000 		call uxListRemove
1916:FreeRTOS/Source/tasks.c **** 				}
 1242               	.LM132:
 1243 04e6 8E89      		ldd r24,Y+22
 1244 04e8 9091 0000 		lds r25,uxTopReadyPriority
 1245 04ec 9817      		cp r25,r24
 1246 04ee 00F4      		brsh .L76
1916:FreeRTOS/Source/tasks.c **** 				}
 1248               	.LM133:
 1249 04f0 8093 0000 		sts uxTopReadyPriority,r24
 1250               	.L76:
1916:FreeRTOS/Source/tasks.c **** 				}
 1252               	.LM134:
 1253 04f4 29E0      		ldi r18,lo8(9)
 1254 04f6 829F      		mul r24,r18
 1255 04f8 C001      		movw r24,r0
 1256 04fa 1124      		clr __zero_reg__
 1257 04fc B701      		movw r22,r14
 1258 04fe 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1259 0500 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1260 0502 0E94 0000 		call vListInsertEnd
 1261               	.L81:
1934:FreeRTOS/Source/tasks.c **** 
 1263               	.LM135:
 1264 0506 812F      		mov r24,r17
 1265               	/* epilogue start */
 1266 0508 DF91      		pop r29
 1267 050a CF91      		pop r28
 1268 050c 1F91      		pop r17
 1269 050e FF90      		pop r15
 1270 0510 EF90      		pop r14
 1271 0512 0895      		ret
 1276               	.Lscope7:
 1278               		.stabd	78,0,0
 1279               		.section	.rodata.str1.1,"aMS",@progbits,1
 1280               	.LC0:
 1281 0000 4944 4C45 		.string	"IDLE"
 1281      00
 1282               		.text
 1284               	.global	vTaskStartScheduler
 1286               	vTaskStartScheduler:
 1287               		.stabd	46,0,0
1940:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 1289               	.LM136:
 1290               	.LFBB8:
 1291 0514 EF92      		push r14
 1292 0516 FF92      		push r15
 1293 0518 0F93      		push r16
 1294               	/* prologue: function */
 1295               	/* frame size = 0 */
 1296               	/* stack size = 3 */
 1297               	.L__stack_usage = 3
1973:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
 1299               	.LM137:
 1300 051a 80E0      		ldi r24,lo8(xIdleTaskHandle)
 1301 051c E82E      		mov r14,r24
 1302 051e 80E0      		ldi r24,hi8(xIdleTaskHandle)
 1303 0520 F82E      		mov r15,r24
 1304 0522 00E0      		ldi r16,0
 1305 0524 20E0      		ldi r18,0
 1306 0526 30E0      		ldi r19,0
 1307 0528 45E5      		ldi r20,lo8(85)
 1308 052a 50E0      		ldi r21,0
 1309 052c 60E0      		ldi r22,lo8(.LC0)
 1310 052e 70E0      		ldi r23,hi8(.LC0)
 1311 0530 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1312 0532 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1313 0534 0E94 0000 		call xTaskCreate
1995:FreeRTOS/Source/tasks.c **** 	{
 1315               	.LM138:
 1316 0538 8130      		cpi r24,lo8(1)
 1317 053a 01F4      		brne .L83
2011:FreeRTOS/Source/tasks.c **** 
 1319               	.LM139:
 1320               	/* #APP */
 1321               	 ;  2011 "FreeRTOS/Source/tasks.c" 1
 1322 053c F894      		cli
 1323               	 ;  0 "" 2
2021:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1325               	.LM140:
 1326               	/* #NOAPP */
 1327 053e 2FEF      		ldi r18,lo8(-1)
 1328 0540 3FEF      		ldi r19,lo8(-1)
 1329 0542 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1330 0546 2093 0000 		sts xNextTaskUnblockTime,r18
2022:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1332               	.LM141:
 1333 054a 8093 0000 		sts xSchedulerRunning,r24
2023:FreeRTOS/Source/tasks.c **** 
 1335               	.LM142:
 1336 054e 1092 0000 		sts xTickCount+1,__zero_reg__
 1337 0552 1092 0000 		sts xTickCount,__zero_reg__
 1338               	/* epilogue start */
2058:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1340               	.LM143:
 1341 0556 0F91      		pop r16
 1342 0558 FF90      		pop r15
 1343 055a EF90      		pop r14
2037:FreeRTOS/Source/tasks.c **** 		{
 1345               	.LM144:
 1346 055c 0C94 0000 		jmp xPortStartScheduler
 1347               	.L83:
 1348               	/* epilogue start */
2058:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1350               	.LM145:
 1351 0560 0F91      		pop r16
 1352 0562 FF90      		pop r15
 1353 0564 EF90      		pop r14
 1354 0566 0895      		ret
 1359               	.Lscope8:
 1361               		.stabd	78,0,0
 1363               	.global	vTaskEndScheduler
 1365               	vTaskEndScheduler:
 1366               		.stabd	46,0,0
2062:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1368               	.LM146:
 1369               	.LFBB9:
 1370               	/* prologue: function */
 1371               	/* frame size = 0 */
 1372               	/* stack size = 0 */
 1373               	.L__stack_usage = 0
2066:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1375               	.LM147:
 1376               	/* #APP */
 1377               	 ;  2066 "FreeRTOS/Source/tasks.c" 1
 1378 0568 F894      		cli
 1379               	 ;  0 "" 2
2067:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1381               	.LM148:
 1382               	/* #NOAPP */
 1383 056a 1092 0000 		sts xSchedulerRunning,__zero_reg__
2068:FreeRTOS/Source/tasks.c **** }
 1385               	.LM149:
 1386 056e 0C94 0000 		jmp vPortEndScheduler
 1388               	.Lscope9:
 1390               		.stabd	78,0,0
 1392               	.global	vTaskSuspendAll
 1394               	vTaskSuspendAll:
 1395               		.stabd	46,0,0
2073:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1397               	.LM150:
 1398               	.LFBB10:
 1399               	/* prologue: function */
 1400               	/* frame size = 0 */
 1401               	/* stack size = 0 */
 1402               	.L__stack_usage = 0
2078:FreeRTOS/Source/tasks.c **** }
 1404               	.LM151:
 1405 0572 8091 0000 		lds r24,uxSchedulerSuspended
 1406 0576 8F5F      		subi r24,lo8(-(1))
 1407 0578 8093 0000 		sts uxSchedulerSuspended,r24
 1408 057c 0895      		ret
 1410               	.Lscope10:
 1412               		.stabd	78,0,0
 1414               	.global	xTaskGetTickCount
 1416               	xTaskGetTickCount:
 1417               		.stabd	46,0,0
2256:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1419               	.LM152:
 1420               	.LFBB11:
 1421               	/* prologue: function */
 1422               	/* frame size = 0 */
 1423               	/* stack size = 0 */
 1424               	.L__stack_usage = 0
2260:FreeRTOS/Source/tasks.c **** 	{
 1426               	.LM153:
 1427               	/* #APP */
 1428               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1429 057e 0FB6      		in		__tmp_reg__, __SREG__
 1430               	 ;  0 "" 2
 1431               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1432 0580 F894      		cli
 1433               	 ;  0 "" 2
 1434               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1435 0582 0F92      		push	__tmp_reg__
 1436               	 ;  0 "" 2
2262:FreeRTOS/Source/tasks.c **** 	}
 1438               	.LM154:
 1439               	/* #NOAPP */
 1440 0584 8091 0000 		lds r24,xTickCount
 1441 0588 9091 0000 		lds r25,xTickCount+1
2264:FreeRTOS/Source/tasks.c **** 
 1443               	.LM155:
 1444               	/* #APP */
 1445               	 ;  2264 "FreeRTOS/Source/tasks.c" 1
 1446 058c 0F90      		pop		__tmp_reg__
 1447               	 ;  0 "" 2
 1448               	 ;  2264 "FreeRTOS/Source/tasks.c" 1
 1449 058e 0FBE      		out		__SREG__, __tmp_reg__
 1450               	 ;  0 "" 2
2267:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1452               	.LM156:
 1453               	/* #NOAPP */
 1454 0590 0895      		ret
 1459               	.Lscope11:
 1461               		.stabd	78,0,0
 1463               	.global	xTaskGetTickCountFromISR
 1465               	xTaskGetTickCountFromISR:
 1466               		.stabd	46,0,0
2271:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1468               	.LM157:
 1469               	.LFBB12:
 1470               	/* prologue: function */
 1471               	/* frame size = 0 */
 1472               	/* stack size = 0 */
 1473               	.L__stack_usage = 0
2293:FreeRTOS/Source/tasks.c **** 	}
 1475               	.LM158:
 1476 0592 8091 0000 		lds r24,xTickCount
 1477 0596 9091 0000 		lds r25,xTickCount+1
2298:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1479               	.LM159:
 1480 059a 0895      		ret
 1485               	.Lscope12:
 1487               		.stabd	78,0,0
 1489               	.global	uxTaskGetNumberOfTasks
 1491               	uxTaskGetNumberOfTasks:
 1492               		.stabd	46,0,0
2302:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1494               	.LM160:
 1495               	.LFBB13:
 1496               	/* prologue: function */
 1497               	/* frame size = 0 */
 1498               	/* stack size = 0 */
 1499               	.L__stack_usage = 0
2305:FreeRTOS/Source/tasks.c **** }
 1501               	.LM161:
 1502 059c 8091 0000 		lds r24,uxCurrentNumberOfTasks
2306:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1504               	.LM162:
 1505 05a0 0895      		ret
 1507               	.Lscope13:
 1509               		.stabd	78,0,0
 1512               	.global	pcTaskGetName
 1514               	pcTaskGetName:
 1515               		.stabd	46,0,0
2310:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 1517               	.LM163:
 1518               	.LFBB14:
 1519               	/* prologue: function */
 1520               	/* frame size = 0 */
 1521               	/* stack size = 0 */
 1522               	.L__stack_usage = 0
2315:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1524               	.LM164:
 1525 05a2 0097      		sbiw r24,0
 1526 05a4 01F4      		brne .L91
2315:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1528               	.LM165:
 1529 05a6 8091 0000 		lds r24,pxCurrentTCB
 1530 05aa 9091 0000 		lds r25,pxCurrentTCB+1
 1531               	.L91:
2318:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1533               	.LM166:
 1534 05ae 4996      		adiw r24,25
 1535 05b0 0895      		ret
 1537               	.Lscope14:
 1539               		.stabd	78,0,0
 1541               	.global	xTaskIncrementTick
 1543               	xTaskIncrementTick:
 1544               		.stabd	46,0,0
2637:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1546               	.LM167:
 1547               	.LFBB15:
 1548 05b2 CF92      		push r12
 1549 05b4 DF92      		push r13
 1550 05b6 EF92      		push r14
 1551 05b8 FF92      		push r15
 1552 05ba 0F93      		push r16
 1553 05bc 1F93      		push r17
 1554 05be CF93      		push r28
 1555 05c0 DF93      		push r29
 1556               	/* prologue: function */
 1557               	/* frame size = 0 */
 1558               	/* stack size = 8 */
 1559               	.L__stack_usage = 8
2646:FreeRTOS/Source/tasks.c **** 	{
 1561               	.LM168:
 1562 05c2 8091 0000 		lds r24,uxSchedulerSuspended
 1563 05c6 8111      		cpse r24,__zero_reg__
 1564 05c8 00C0      		rjmp .L93
 1565               	.LBB62:
2650:FreeRTOS/Source/tasks.c **** 
 1567               	.LM169:
 1568 05ca 0091 0000 		lds r16,xTickCount
 1569 05ce 1091 0000 		lds r17,xTickCount+1
 1570 05d2 0F5F      		subi r16,-1
 1571 05d4 1F4F      		sbci r17,-1
2654:FreeRTOS/Source/tasks.c **** 
 1573               	.LM170:
 1574 05d6 1093 0000 		sts xTickCount+1,r17
 1575 05da 0093 0000 		sts xTickCount,r16
2656:FreeRTOS/Source/tasks.c **** 		{
 1577               	.LM171:
 1578 05de 0115      		cp r16,__zero_reg__
 1579 05e0 1105      		cpc r17,__zero_reg__
 1580 05e2 01F4      		brne .L94
 1581               	.LBB63:
2658:FreeRTOS/Source/tasks.c **** 		}
 1583               	.LM172:
 1584 05e4 8091 0000 		lds r24,pxDelayedTaskList
 1585 05e8 9091 0000 		lds r25,pxDelayedTaskList+1
 1586 05ec 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1587 05f0 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1588 05f4 3093 0000 		sts pxDelayedTaskList+1,r19
 1589 05f8 2093 0000 		sts pxDelayedTaskList,r18
 1590 05fc 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1591 0600 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1592 0604 8091 0000 		lds r24,xNumOfOverflows
 1593 0608 8F5F      		subi r24,lo8(-(1))
 1594 060a 8093 0000 		sts xNumOfOverflows,r24
 1595 060e 0E94 0000 		call prvResetNextTaskUnblockTime
 1596               	.L94:
 1597               	.LBE63:
2669:FreeRTOS/Source/tasks.c **** 		{
 1599               	.LM173:
 1600 0612 8091 0000 		lds r24,xNextTaskUnblockTime
 1601 0616 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1602 061a C0E0      		ldi r28,0
 1603 061c 0817      		cp r16,r24
 1604 061e 1907      		cpc r17,r25
 1605 0620 00F4      		brsh .+2
 1606 0622 00C0      		rjmp .L95
2723:FreeRTOS/Source/tasks.c **** 
 1608               	.LM174:
 1609 0624 D9E0      		ldi r29,lo8(9)
 1610               	.L96:
2673:FreeRTOS/Source/tasks.c **** 				{
 1612               	.LM175:
 1613 0626 E091 0000 		lds r30,pxDelayedTaskList
 1614 062a F091 0000 		lds r31,pxDelayedTaskList+1
 1615 062e 8081      		ld r24,Z
 1616 0630 8111      		cpse r24,__zero_reg__
 1617 0632 00C0      		rjmp .L97
2680:FreeRTOS/Source/tasks.c **** 					break;
 1619               	.LM176:
 1620 0634 8FEF      		ldi r24,lo8(-1)
 1621 0636 9FEF      		ldi r25,lo8(-1)
 1622 0638 00C0      		rjmp .L111
 1623               	.L97:
2689:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1625               	.LM177:
 1626 063a E091 0000 		lds r30,pxDelayedTaskList
 1627 063e F091 0000 		lds r31,pxDelayedTaskList+1
 1628 0642 0580      		ldd __tmp_reg__,Z+5
 1629 0644 F681      		ldd r31,Z+6
 1630 0646 E02D      		mov r30,__tmp_reg__
 1631 0648 E680      		ldd r14,Z+6
 1632 064a F780      		ldd r15,Z+7
2690:FreeRTOS/Source/tasks.c **** 
 1634               	.LM178:
 1635 064c D701      		movw r26,r14
 1636 064e 1296      		adiw r26,2
 1637 0650 8D91      		ld r24,X+
 1638 0652 9C91      		ld r25,X
 1639 0654 1397      		sbiw r26,2+1
2692:FreeRTOS/Source/tasks.c **** 					{
 1641               	.LM179:
 1642 0656 0817      		cp r16,r24
 1643 0658 1907      		cpc r17,r25
 1644 065a 00F4      		brsh .L98
 1645               	.L111:
2699:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1647               	.LM180:
 1648 065c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1649 0660 8093 0000 		sts xNextTaskUnblockTime,r24
2700:FreeRTOS/Source/tasks.c **** 					}
 1651               	.LM181:
 1652 0664 00C0      		rjmp .L95
 1653               	.L98:
2708:FreeRTOS/Source/tasks.c **** 
 1655               	.LM182:
 1656 0666 6701      		movw r12,r14
 1657 0668 B2E0      		ldi r27,2
 1658 066a CB0E      		add r12,r27
 1659 066c D11C      		adc r13,__zero_reg__
 1660 066e C601      		movw r24,r12
 1661 0670 0E94 0000 		call uxListRemove
2712:FreeRTOS/Source/tasks.c **** 					{
 1663               	.LM183:
 1664 0674 F701      		movw r30,r14
 1665 0676 8489      		ldd r24,Z+20
 1666 0678 9589      		ldd r25,Z+21
 1667 067a 892B      		or r24,r25
 1668 067c 01F0      		breq .L99
2714:FreeRTOS/Source/tasks.c **** 					}
 1670               	.LM184:
 1671 067e C701      		movw r24,r14
 1672 0680 0C96      		adiw r24,12
 1673 0682 0E94 0000 		call uxListRemove
 1674               	.L99:
2723:FreeRTOS/Source/tasks.c **** 
 1676               	.LM185:
 1677 0686 D701      		movw r26,r14
 1678 0688 5696      		adiw r26,22
 1679 068a 8C91      		ld r24,X
 1680 068c 9091 0000 		lds r25,uxTopReadyPriority
 1681 0690 9817      		cp r25,r24
 1682 0692 00F4      		brsh .L100
2723:FreeRTOS/Source/tasks.c **** 
 1684               	.LM186:
 1685 0694 8093 0000 		sts uxTopReadyPriority,r24
 1686               	.L100:
2723:FreeRTOS/Source/tasks.c **** 
 1688               	.LM187:
 1689 0698 D89F      		mul r29,r24
 1690 069a C001      		movw r24,r0
 1691 069c 1124      		clr __zero_reg__
 1692 069e B601      		movw r22,r12
 1693 06a0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1694 06a2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1695 06a4 0E94 0000 		call vListInsertEnd
2733:FreeRTOS/Source/tasks.c **** 						{
 1697               	.LM188:
 1698 06a8 E091 0000 		lds r30,pxCurrentTCB
 1699 06ac F091 0000 		lds r31,pxCurrentTCB+1
 1700 06b0 D701      		movw r26,r14
 1701 06b2 5696      		adiw r26,22
 1702 06b4 9C91      		ld r25,X
 1703 06b6 8689      		ldd r24,Z+22
 1704 06b8 9817      		cp r25,r24
 1705 06ba 00F4      		brsh .+2
 1706 06bc 00C0      		rjmp .L96
2735:FreeRTOS/Source/tasks.c **** 						}
 1708               	.LM189:
 1709 06be C1E0      		ldi r28,lo8(1)
 1710 06c0 00C0      		rjmp .L96
 1711               	.L95:
2752:FreeRTOS/Source/tasks.c **** 			{
 1713               	.LM190:
 1714 06c2 E091 0000 		lds r30,pxCurrentTCB
 1715 06c6 F091 0000 		lds r31,pxCurrentTCB+1
 1716 06ca E689      		ldd r30,Z+22
 1717 06cc B9E0      		ldi r27,lo8(9)
 1718 06ce EB9F      		mul r30,r27
 1719 06d0 F001      		movw r30,r0
 1720 06d2 1124      		clr __zero_reg__
 1721 06d4 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1722 06d6 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1723 06d8 8081      		ld r24,Z
 1724 06da 8230      		cpi r24,lo8(2)
 1725 06dc 00F0      		brlo .L102
2754:FreeRTOS/Source/tasks.c **** 			}
 1727               	.LM191:
 1728 06de C1E0      		ldi r28,lo8(1)
 1729 06e0 00C0      		rjmp .L102
 1730               	.L93:
 1731               	.LBE62:
2780:FreeRTOS/Source/tasks.c **** 
 1733               	.LM192:
 1734 06e2 8091 0000 		lds r24,uxPendedTicks
 1735 06e6 8F5F      		subi r24,lo8(-(1))
 1736 06e8 8093 0000 		sts uxPendedTicks,r24
2640:FreeRTOS/Source/tasks.c **** 
 1738               	.LM193:
 1739 06ec C0E0      		ldi r28,0
 1740               	.L102:
2793:FreeRTOS/Source/tasks.c **** 		{
 1742               	.LM194:
 1743 06ee 8091 0000 		lds r24,xYieldPending
 1744 06f2 8111      		cpse r24,__zero_reg__
2795:FreeRTOS/Source/tasks.c **** 		}
 1746               	.LM195:
 1747 06f4 C1E0      		ldi r28,lo8(1)
 1748               	.L103:
2805:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1750               	.LM196:
 1751 06f6 8C2F      		mov r24,r28
 1752               	/* epilogue start */
 1753 06f8 DF91      		pop r29
 1754 06fa CF91      		pop r28
 1755 06fc 1F91      		pop r17
 1756 06fe 0F91      		pop r16
 1757 0700 FF90      		pop r15
 1758 0702 EF90      		pop r14
 1759 0704 DF90      		pop r13
 1760 0706 CF90      		pop r12
 1761 0708 0895      		ret
 1774               	.Lscope15:
 1776               		.stabd	78,0,0
 1778               	.global	xTaskResumeAll
 1780               	xTaskResumeAll:
 1781               		.stabd	46,0,0
2146:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
 1783               	.LM197:
 1784               	.LFBB16:
 1785 070a EF92      		push r14
 1786 070c FF92      		push r15
 1787 070e 0F93      		push r16
 1788 0710 1F93      		push r17
 1789 0712 CF93      		push r28
 1790 0714 DF93      		push r29
 1791               	/* prologue: function */
 1792               	/* frame size = 0 */
 1793               	/* stack size = 6 */
 1794               	.L__stack_usage = 6
2159:FreeRTOS/Source/tasks.c **** 	{
 1796               	.LM198:
 1797               	/* #APP */
 1798               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1799 0716 0FB6      		in		__tmp_reg__, __SREG__
 1800               	 ;  0 "" 2
 1801               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1802 0718 F894      		cli
 1803               	 ;  0 "" 2
 1804               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1805 071a 0F92      		push	__tmp_reg__
 1806               	 ;  0 "" 2
2161:FreeRTOS/Source/tasks.c **** 
 1808               	.LM199:
 1809               	/* #NOAPP */
 1810 071c 8091 0000 		lds r24,uxSchedulerSuspended
 1811 0720 8150      		subi r24,lo8(-(-1))
 1812 0722 8093 0000 		sts uxSchedulerSuspended,r24
2163:FreeRTOS/Source/tasks.c **** 		{
 1814               	.LM200:
 1815 0726 8091 0000 		lds r24,uxSchedulerSuspended
 1816 072a 8823      		tst r24
 1817 072c 01F0      		breq .L113
 1818               	.L115:
2148:FreeRTOS/Source/tasks.c **** 
 1820               	.LM201:
 1821 072e 80E0      		ldi r24,0
 1822 0730 00C0      		rjmp .L114
 1823               	.L113:
2165:FreeRTOS/Source/tasks.c **** 			{
 1825               	.LM202:
 1826 0732 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1827 0736 8823      		tst r24
 1828 0738 01F0      		breq .L115
 1829 073a C0E0      		ldi r28,0
 1830 073c D0E0      		ldi r29,0
2174:FreeRTOS/Source/tasks.c **** 
 1832               	.LM203:
 1833 073e 89E0      		ldi r24,lo8(9)
 1834 0740 F82E      		mov r15,r24
2180:FreeRTOS/Source/tasks.c **** 					}
 1836               	.LM204:
 1837 0742 EE24      		clr r14
 1838 0744 E394      		inc r14
 1839               	.L116:
2169:FreeRTOS/Source/tasks.c **** 				{
 1841               	.LM205:
 1842 0746 8091 0000 		lds r24,xPendingReadyList
 1843 074a 8823      		tst r24
 1844 074c 01F0      		breq .L140
2171:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1846               	.LM206:
 1847 074e E091 0000 		lds r30,xPendingReadyList+5
 1848 0752 F091 0000 		lds r31,xPendingReadyList+5+1
 1849 0756 C681      		ldd r28,Z+6
 1850 0758 D781      		ldd r29,Z+7
2172:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1852               	.LM207:
 1853 075a CE01      		movw r24,r28
 1854 075c 0C96      		adiw r24,12
 1855 075e 0E94 0000 		call uxListRemove
2173:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1857               	.LM208:
 1858 0762 8E01      		movw r16,r28
 1859 0764 0E5F      		subi r16,-2
 1860 0766 1F4F      		sbci r17,-1
 1861 0768 C801      		movw r24,r16
 1862 076a 0E94 0000 		call uxListRemove
2174:FreeRTOS/Source/tasks.c **** 
 1864               	.LM209:
 1865 076e 8E89      		ldd r24,Y+22
 1866 0770 9091 0000 		lds r25,uxTopReadyPriority
 1867 0774 9817      		cp r25,r24
 1868 0776 00F4      		brsh .L117
2174:FreeRTOS/Source/tasks.c **** 
 1870               	.LM210:
 1871 0778 8093 0000 		sts uxTopReadyPriority,r24
 1872               	.L117:
2174:FreeRTOS/Source/tasks.c **** 
 1874               	.LM211:
 1875 077c F89E      		mul r15,r24
 1876 077e C001      		movw r24,r0
 1877 0780 1124      		clr __zero_reg__
 1878 0782 B801      		movw r22,r16
 1879 0784 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1880 0786 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1881 0788 0E94 0000 		call vListInsertEnd
2178:FreeRTOS/Source/tasks.c **** 					{
 1883               	.LM212:
 1884 078c E091 0000 		lds r30,pxCurrentTCB
 1885 0790 F091 0000 		lds r31,pxCurrentTCB+1
 1886 0794 9E89      		ldd r25,Y+22
 1887 0796 8689      		ldd r24,Z+22
 1888 0798 9817      		cp r25,r24
 1889 079a 00F0      		brlo .L116
2180:FreeRTOS/Source/tasks.c **** 					}
 1891               	.LM213:
 1892 079c E092 0000 		sts xYieldPending,r14
 1893 07a0 00C0      		rjmp .L116
 1894               	.L140:
2188:FreeRTOS/Source/tasks.c **** 				{
 1896               	.LM214:
 1897 07a2 CD2B      		or r28,r29
 1898 07a4 01F0      		breq .L120
2196:FreeRTOS/Source/tasks.c **** 				}
 1900               	.LM215:
 1901 07a6 0E94 0000 		call prvResetNextTaskUnblockTime
 1902               	.L120:
 1903               	.LBB64:
2204:FreeRTOS/Source/tasks.c **** 
 1905               	.LM216:
 1906 07aa C091 0000 		lds r28,uxPendedTicks
2206:FreeRTOS/Source/tasks.c **** 					{
 1908               	.LM217:
 1909 07ae CC23      		tst r28
 1910 07b0 01F0      		breq .L121
2212:FreeRTOS/Source/tasks.c **** 							}
 1912               	.LM218:
 1913 07b2 D1E0      		ldi r29,lo8(1)
 1914               	.L123:
2210:FreeRTOS/Source/tasks.c **** 							{
 1916               	.LM219:
 1917 07b4 0E94 0000 		call xTaskIncrementTick
 1918 07b8 8111      		cpse r24,__zero_reg__
2212:FreeRTOS/Source/tasks.c **** 							}
 1920               	.LM220:
 1921 07ba D093 0000 		sts xYieldPending,r29
 1922               	.L122:
2218:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 1924               	.LM221:
 1925 07be C150      		subi r28,lo8(-(-1))
2219:FreeRTOS/Source/tasks.c **** 
 1927               	.LM222:
 1928 07c0 01F4      		brne .L123
2221:FreeRTOS/Source/tasks.c **** 					}
 1930               	.LM223:
 1931 07c2 1092 0000 		sts uxPendedTicks,__zero_reg__
 1932               	.L121:
 1933               	.LBE64:
2229:FreeRTOS/Source/tasks.c **** 				{
 1935               	.LM224:
 1936 07c6 8091 0000 		lds r24,xYieldPending
 1937 07ca 8823      		tst r24
 1938 07cc 01F4      		brne .+2
 1939 07ce 00C0      		rjmp .L115
2236:FreeRTOS/Source/tasks.c **** 				}
 1941               	.LM225:
 1942 07d0 0E94 0000 		call vPortYield
2233:FreeRTOS/Source/tasks.c **** 					}
 1944               	.LM226:
 1945 07d4 81E0      		ldi r24,lo8(1)
 1946               	.L114:
2249:FreeRTOS/Source/tasks.c **** 
 1948               	.LM227:
 1949               	/* #APP */
 1950               	 ;  2249 "FreeRTOS/Source/tasks.c" 1
 1951 07d6 0F90      		pop		__tmp_reg__
 1952               	 ;  0 "" 2
 1953               	 ;  2249 "FreeRTOS/Source/tasks.c" 1
 1954 07d8 0FBE      		out		__SREG__, __tmp_reg__
 1955               	 ;  0 "" 2
 1956               	/* epilogue start */
2252:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1958               	.LM228:
 1959               	/* #NOAPP */
 1960 07da DF91      		pop r29
 1961 07dc CF91      		pop r28
 1962 07de 1F91      		pop r17
 1963 07e0 0F91      		pop r16
 1964 07e2 FF90      		pop r15
 1965 07e4 EF90      		pop r14
 1966 07e6 0895      		ret
 1975               	.Lscope16:
 1977               		.stabd	78,0,0
 1981               	.global	vTaskDelayUntil
 1983               	vTaskDelayUntil:
 1984               		.stabd	46,0,0
1222:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 1986               	.LM229:
 1987               	.LFBB17:
 1988 07e8 0F93      		push r16
 1989 07ea 1F93      		push r17
 1990 07ec CF93      		push r28
 1991 07ee DF93      		push r29
 1992               	/* prologue: function */
 1993               	/* frame size = 0 */
 1994               	/* stack size = 4 */
 1995               	.L__stack_usage = 4
 1996 07f0 8C01      		movw r16,r24
 1997 07f2 EB01      		movw r28,r22
1230:FreeRTOS/Source/tasks.c **** 		{
 1999               	.LM230:
 2000 07f4 0E94 0000 		call vTaskSuspendAll
 2001               	.LBB65:
1234:FreeRTOS/Source/tasks.c **** 
 2003               	.LM231:
 2004 07f8 4091 0000 		lds r20,xTickCount
 2005 07fc 5091 0000 		lds r21,xTickCount+1
1237:FreeRTOS/Source/tasks.c **** 
 2007               	.LM232:
 2008 0800 F801      		movw r30,r16
 2009 0802 2081      		ld r18,Z
 2010 0804 3181      		ldd r19,Z+1
 2011 0806 C901      		movw r24,r18
 2012 0808 8C0F      		add r24,r28
 2013 080a 9D1F      		adc r25,r29
1239:FreeRTOS/Source/tasks.c **** 			{
 2015               	.LM233:
 2016 080c 4217      		cp r20,r18
 2017 080e 5307      		cpc r21,r19
 2018 0810 00F4      		brsh .L142
1246:FreeRTOS/Source/tasks.c **** 				{
 2020               	.LM234:
 2021 0812 8217      		cp r24,r18
 2022 0814 9307      		cpc r25,r19
 2023 0816 00F4      		brsh .L148
 2024 0818 00C0      		rjmp .L155
 2025               	.L142:
1260:FreeRTOS/Source/tasks.c **** 				{
 2027               	.LM235:
 2028 081a 8217      		cp r24,r18
 2029 081c 9307      		cpc r25,r19
 2030 081e 00F0      		brlo .L149
 2031               	.L155:
 2032               	.LBE65:
1224:FreeRTOS/Source/tasks.c **** 
 2034               	.LM236:
 2035 0820 21E0      		ldi r18,lo8(1)
 2036 0822 4817      		cp r20,r24
 2037 0824 5907      		cpc r21,r25
 2038 0826 00F0      		brlo .L143
 2039               	.L148:
1224:FreeRTOS/Source/tasks.c **** 
 2041               	.LM237:
 2042 0828 20E0      		ldi r18,0
 2043 082a 00C0      		rjmp .L143
 2044               	.L149:
 2045               	.LBB66:
1262:FreeRTOS/Source/tasks.c **** 				}
 2047               	.LM238:
 2048 082c 21E0      		ldi r18,lo8(1)
 2049               	.L143:
1271:FreeRTOS/Source/tasks.c **** 
 2051               	.LM239:
 2052 082e F801      		movw r30,r16
 2053 0830 9183      		std Z+1,r25
 2054 0832 8083      		st Z,r24
1273:FreeRTOS/Source/tasks.c **** 			{
 2056               	.LM240:
 2057 0834 2223      		tst r18
 2058 0836 01F0      		breq .L146
1279:FreeRTOS/Source/tasks.c **** 			}
 2060               	.LM241:
 2061 0838 60E0      		ldi r22,0
 2062 083a 841B      		sub r24,r20
 2063 083c 950B      		sbc r25,r21
 2064 083e 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2065               	.L146:
 2066               	.LBE66:
1286:FreeRTOS/Source/tasks.c **** 
 2068               	.LM242:
 2069 0842 0E94 0000 		call xTaskResumeAll
1290:FreeRTOS/Source/tasks.c **** 		{
 2071               	.LM243:
 2072 0846 8111      		cpse r24,__zero_reg__
 2073 0848 00C0      		rjmp .L141
1292:FreeRTOS/Source/tasks.c **** 		}
 2075               	.LM244:
 2076 084a 0E94 0000 		call vPortYield
 2077               	.L141:
 2078               	/* epilogue start */
1298:FreeRTOS/Source/tasks.c **** 
 2080               	.LM245:
 2081 084e DF91      		pop r29
 2082 0850 CF91      		pop r28
 2083 0852 1F91      		pop r17
 2084 0854 0F91      		pop r16
 2085 0856 0895      		ret
 2097               	.Lscope17:
 2099               		.stabd	78,0,0
 2102               	.global	vTaskDelay
 2104               	vTaskDelay:
 2105               		.stabd	46,0,0
1306:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 2107               	.LM246:
 2108               	.LFBB18:
 2109 0858 CF93      		push r28
 2110 085a DF93      		push r29
 2111               	/* prologue: function */
 2112               	/* frame size = 0 */
 2113               	/* stack size = 2 */
 2114               	.L__stack_usage = 2
 2115 085c EC01      		movw r28,r24
1310:FreeRTOS/Source/tasks.c **** 		{
 2117               	.LM247:
 2118 085e 892B      		or r24,r25
 2119 0860 01F4      		brne .L157
 2120               	.L159:
1337:FreeRTOS/Source/tasks.c **** 		}
 2122               	.LM248:
 2123 0862 0E94 0000 		call vPortYield
 2124 0866 00C0      		rjmp .L156
 2125               	.L157:
1313:FreeRTOS/Source/tasks.c **** 			{
 2127               	.LM249:
 2128 0868 0E94 0000 		call vTaskSuspendAll
1324:FreeRTOS/Source/tasks.c **** 			}
 2130               	.LM250:
 2131 086c 60E0      		ldi r22,0
 2132 086e CE01      		movw r24,r28
 2133 0870 0E94 0000 		call prvAddCurrentTaskToDelayedList
1326:FreeRTOS/Source/tasks.c **** 		}
 2135               	.LM251:
 2136 0874 0E94 0000 		call xTaskResumeAll
1335:FreeRTOS/Source/tasks.c **** 		{
 2138               	.LM252:
 2139 0878 8823      		tst r24
 2140 087a 01F0      		breq .L159
 2141               	.L156:
 2142               	/* epilogue start */
1343:FreeRTOS/Source/tasks.c **** 
 2144               	.LM253:
 2145 087c DF91      		pop r29
 2146 087e CF91      		pop r28
 2147 0880 0895      		ret
 2149               	.Lscope18:
 2151               		.stabd	78,0,0
 2153               	.global	vTaskSwitchContext
 2155               	vTaskSwitchContext:
 2156               		.stabd	46,0,0
2901:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2158               	.LM254:
 2159               	.LFBB19:
 2160               	/* prologue: function */
 2161               	/* frame size = 0 */
 2162               	/* stack size = 0 */
 2163               	.L__stack_usage = 0
2902:FreeRTOS/Source/tasks.c **** 	{
 2165               	.LM255:
 2166 0882 8091 0000 		lds r24,uxSchedulerSuspended
 2167 0886 8823      		tst r24
 2168 0888 01F0      		breq .L164
2906:FreeRTOS/Source/tasks.c **** 	}
 2170               	.LM256:
 2171 088a 81E0      		ldi r24,lo8(1)
 2172 088c 8093 0000 		sts xYieldPending,r24
 2173 0890 0895      		ret
 2174               	.L164:
 2175               	.LBB71:
 2176               	.LBB72:
2910:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2178               	.LM257:
 2179 0892 1092 0000 		sts xYieldPending,__zero_reg__
 2180               	.LBB73:
2952:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2182               	.LM258:
 2183 0896 8091 0000 		lds r24,uxTopReadyPriority
 2184 089a 69E0      		ldi r22,lo8(9)
 2185               	.L166:
 2186 089c 482F      		mov r20,r24
 2187 089e 50E0      		ldi r21,0
 2188 08a0 649F      		mul r22,r20
 2189 08a2 9001      		movw r18,r0
 2190 08a4 659F      		mul r22,r21
 2191 08a6 300D      		add r19,r0
 2192 08a8 1124      		clr __zero_reg__
 2193 08aa F901      		movw r30,r18
 2194 08ac E050      		subi r30,lo8(-(pxReadyTasksLists))
 2195 08ae F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2196 08b0 9081      		ld r25,Z
 2197 08b2 9111      		cpse r25,__zero_reg__
 2198 08b4 00C0      		rjmp .L169
 2199 08b6 8150      		subi r24,lo8(-(-1))
 2200 08b8 00C0      		rjmp .L166
 2201               	.L169:
 2202               	.LBB74:
 2203 08ba A181      		ldd r26,Z+1
 2204 08bc B281      		ldd r27,Z+2
 2205 08be 1296      		adiw r26,2
 2206 08c0 0D90      		ld __tmp_reg__,X+
 2207 08c2 BC91      		ld r27,X
 2208 08c4 A02D      		mov r26,__tmp_reg__
 2209 08c6 B283      		std Z+2,r27
 2210 08c8 A183      		std Z+1,r26
 2211 08ca 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 2212 08cc 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 2213 08ce A217      		cp r26,r18
 2214 08d0 B307      		cpc r27,r19
 2215 08d2 01F4      		brne .L168
 2216 08d4 1296      		adiw r26,2
 2217 08d6 2D91      		ld r18,X+
 2218 08d8 3C91      		ld r19,X
 2219 08da 1397      		sbiw r26,2+1
 2220 08dc 3283      		std Z+2,r19
 2221 08de 2183      		std Z+1,r18
 2222               	.L168:
 2223 08e0 99E0      		ldi r25,lo8(9)
 2224 08e2 949F      		mul r25,r20
 2225 08e4 F001      		movw r30,r0
 2226 08e6 959F      		mul r25,r21
 2227 08e8 F00D      		add r31,r0
 2228 08ea 1124      		clr __zero_reg__
 2229 08ec E050      		subi r30,lo8(-(pxReadyTasksLists))
 2230 08ee F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2231 08f0 0180      		ldd __tmp_reg__,Z+1
 2232 08f2 F281      		ldd r31,Z+2
 2233 08f4 E02D      		mov r30,__tmp_reg__
 2234 08f6 2681      		ldd r18,Z+6
 2235 08f8 3781      		ldd r19,Z+7
 2236 08fa 3093 0000 		sts pxCurrentTCB+1,r19
 2237 08fe 2093 0000 		sts pxCurrentTCB,r18
 2238               	.LBE74:
 2239 0902 8093 0000 		sts uxTopReadyPriority,r24
 2240 0906 0895      		ret
 2241               	.LBE73:
 2242               	.LBE72:
 2243               	.LBE71:
 2248               	.Lscope19:
 2250               		.stabd	78,0,0
 2253               	.global	vTaskSuspend
 2255               	vTaskSuspend:
 2256               		.stabd	46,0,0
1669:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 2258               	.LM259:
 2259               	.LFBB20:
 2260 0908 0F93      		push r16
 2261 090a 1F93      		push r17
 2262 090c CF93      		push r28
 2263 090e DF93      		push r29
 2264               	/* prologue: function */
 2265               	/* frame size = 0 */
 2266               	/* stack size = 4 */
 2267               	.L__stack_usage = 4
 2268 0910 EC01      		movw r28,r24
1672:FreeRTOS/Source/tasks.c **** 		{
 2270               	.LM260:
 2271               	/* #APP */
 2272               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2273 0912 0FB6      		in		__tmp_reg__, __SREG__
 2274               	 ;  0 "" 2
 2275               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2276 0914 F894      		cli
 2277               	 ;  0 "" 2
 2278               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2279 0916 0F92      		push	__tmp_reg__
 2280               	 ;  0 "" 2
1676:FreeRTOS/Source/tasks.c **** 
 2282               	.LM261:
 2283               	/* #NOAPP */
 2284 0918 892B      		or r24,r25
 2285 091a 01F4      		brne .L171
1676:FreeRTOS/Source/tasks.c **** 
 2287               	.LM262:
 2288 091c C091 0000 		lds r28,pxCurrentTCB
 2289 0920 D091 0000 		lds r29,pxCurrentTCB+1
 2290               	.L171:
1682:FreeRTOS/Source/tasks.c **** 			{
 2292               	.LM263:
 2293 0924 8E01      		movw r16,r28
 2294 0926 0E5F      		subi r16,-2
 2295 0928 1F4F      		sbci r17,-1
 2296 092a C801      		movw r24,r16
 2297 092c 0E94 0000 		call uxListRemove
1692:FreeRTOS/Source/tasks.c **** 			{
 2299               	.LM264:
 2300 0930 8C89      		ldd r24,Y+20
 2301 0932 9D89      		ldd r25,Y+21
 2302 0934 892B      		or r24,r25
 2303 0936 01F0      		breq .L172
1694:FreeRTOS/Source/tasks.c **** 			}
 2305               	.LM265:
 2306 0938 CE01      		movw r24,r28
 2307 093a 0C96      		adiw r24,12
 2308 093c 0E94 0000 		call uxListRemove
 2309               	.L172:
1701:FreeRTOS/Source/tasks.c **** 
 2311               	.LM266:
 2312 0940 B801      		movw r22,r16
 2313 0942 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2314 0944 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2315 0946 0E94 0000 		call vListInsertEnd
1705:FreeRTOS/Source/tasks.c **** 				{
 2317               	.LM267:
 2318 094a 8DA1      		ldd r24,Y+37
 2319 094c 8130      		cpi r24,lo8(1)
 2320 094e 01F4      		brne .L173
1709:FreeRTOS/Source/tasks.c **** 				}
 2322               	.LM268:
 2323 0950 1DA2      		std Y+37,__zero_reg__
 2324               	.L173:
1714:FreeRTOS/Source/tasks.c **** 
 2326               	.LM269:
 2327               	/* #APP */
 2328               	 ;  1714 "FreeRTOS/Source/tasks.c" 1
 2329 0952 0F90      		pop		__tmp_reg__
 2330               	 ;  0 "" 2
 2331               	 ;  1714 "FreeRTOS/Source/tasks.c" 1
 2332 0954 0FBE      		out		__SREG__, __tmp_reg__
 2333               	 ;  0 "" 2
1716:FreeRTOS/Source/tasks.c **** 		{
 2335               	.LM270:
 2336               	/* #NOAPP */
 2337 0956 8091 0000 		lds r24,xSchedulerRunning
 2338 095a 8823      		tst r24
 2339 095c 01F0      		breq .L174
1720:FreeRTOS/Source/tasks.c **** 			{
 2341               	.LM271:
 2342               	/* #APP */
 2343               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2344 095e 0FB6      		in		__tmp_reg__, __SREG__
 2345               	 ;  0 "" 2
 2346               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2347 0960 F894      		cli
 2348               	 ;  0 "" 2
 2349               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2350 0962 0F92      		push	__tmp_reg__
 2351               	 ;  0 "" 2
1722:FreeRTOS/Source/tasks.c **** 			}
 2353               	.LM272:
 2354               	/* #NOAPP */
 2355 0964 0E94 0000 		call prvResetNextTaskUnblockTime
1724:FreeRTOS/Source/tasks.c **** 		}
 2357               	.LM273:
 2358               	/* #APP */
 2359               	 ;  1724 "FreeRTOS/Source/tasks.c" 1
 2360 0968 0F90      		pop		__tmp_reg__
 2361               	 ;  0 "" 2
 2362               	 ;  1724 "FreeRTOS/Source/tasks.c" 1
 2363 096a 0FBE      		out		__SREG__, __tmp_reg__
 2364               	 ;  0 "" 2
 2365               	/* #NOAPP */
 2366               	.L174:
1731:FreeRTOS/Source/tasks.c **** 		{
 2368               	.LM274:
 2369 096c 8091 0000 		lds r24,pxCurrentTCB
 2370 0970 9091 0000 		lds r25,pxCurrentTCB+1
 2371 0974 C817      		cp r28,r24
 2372 0976 D907      		cpc r29,r25
 2373 0978 01F4      		brne .L170
1733:FreeRTOS/Source/tasks.c **** 			{
 2375               	.LM275:
 2376 097a 8091 0000 		lds r24,xSchedulerRunning
 2377 097e 8823      		tst r24
 2378 0980 01F0      		breq .L176
1737:FreeRTOS/Source/tasks.c **** 			}
 2380               	.LM276:
 2381 0982 0E94 0000 		call vPortYield
 2382 0986 00C0      		rjmp .L170
 2383               	.L176:
1744:FreeRTOS/Source/tasks.c **** 				{
 2385               	.LM277:
 2386 0988 9091 0000 		lds r25,xSuspendedTaskList
 2387 098c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2388 0990 9813      		cpse r25,r24
 2389 0992 00C0      		rjmp .L177
1750:FreeRTOS/Source/tasks.c **** 				}
 2391               	.LM278:
 2392 0994 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 2393 0998 1092 0000 		sts pxCurrentTCB,__zero_reg__
 2394 099c 00C0      		rjmp .L170
 2395               	.L177:
 2396               	/* epilogue start */
1762:FreeRTOS/Source/tasks.c **** 
 2398               	.LM279:
 2399 099e DF91      		pop r29
 2400 09a0 CF91      		pop r28
 2401 09a2 1F91      		pop r17
 2402 09a4 0F91      		pop r16
1754:FreeRTOS/Source/tasks.c **** 				}
 2404               	.LM280:
 2405 09a6 0C94 0000 		jmp vTaskSwitchContext
 2406               	.L170:
 2407               	/* epilogue start */
1762:FreeRTOS/Source/tasks.c **** 
 2409               	.LM281:
 2410 09aa DF91      		pop r29
 2411 09ac CF91      		pop r28
 2412 09ae 1F91      		pop r17
 2413 09b0 0F91      		pop r16
 2414 09b2 0895      		ret
 2416               	.Lscope20:
 2418               		.stabd	78,0,0
 2422               	.global	vTaskPlaceOnEventList
 2424               	vTaskPlaceOnEventList:
 2425               		.stabd	46,0,0
2974:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2427               	.LM282:
 2428               	.LFBB21:
 2429 09b4 CF93      		push r28
 2430 09b6 DF93      		push r29
 2431               	/* prologue: function */
 2432               	/* frame size = 0 */
 2433               	/* stack size = 2 */
 2434               	.L__stack_usage = 2
 2435 09b8 EB01      		movw r28,r22
2984:FreeRTOS/Source/tasks.c **** 
 2437               	.LM283:
 2438 09ba 6091 0000 		lds r22,pxCurrentTCB
 2439 09be 7091 0000 		lds r23,pxCurrentTCB+1
 2440 09c2 645F      		subi r22,-12
 2441 09c4 7F4F      		sbci r23,-1
 2442 09c6 0E94 0000 		call vListInsert
2986:FreeRTOS/Source/tasks.c **** }
 2444               	.LM284:
 2445 09ca 61E0      		ldi r22,lo8(1)
 2446 09cc CE01      		movw r24,r28
 2447               	/* epilogue start */
2987:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2449               	.LM285:
 2450 09ce DF91      		pop r29
 2451 09d0 CF91      		pop r28
2986:FreeRTOS/Source/tasks.c **** }
 2453               	.LM286:
 2454 09d2 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2456               	.Lscope21:
 2458               		.stabd	78,0,0
 2463               	.global	vTaskPlaceOnUnorderedEventList
 2465               	vTaskPlaceOnUnorderedEventList:
 2466               		.stabd	46,0,0
2991:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2468               	.LM287:
 2469               	.LFBB22:
 2470 09d6 CF93      		push r28
 2471 09d8 DF93      		push r29
 2472               	/* prologue: function */
 2473               	/* frame size = 0 */
 2474               	/* stack size = 2 */
 2475               	.L__stack_usage = 2
 2476 09da EA01      		movw r28,r20
3001:FreeRTOS/Source/tasks.c **** 
 2478               	.LM288:
 2479 09dc E091 0000 		lds r30,pxCurrentTCB
 2480 09e0 F091 0000 		lds r31,pxCurrentTCB+1
 2481 09e4 7068      		ori r23,128
 2482 09e6 7587      		std Z+13,r23
 2483 09e8 6487      		std Z+12,r22
3008:FreeRTOS/Source/tasks.c **** 
 2485               	.LM289:
 2486 09ea 6091 0000 		lds r22,pxCurrentTCB
 2487 09ee 7091 0000 		lds r23,pxCurrentTCB+1
 2488 09f2 645F      		subi r22,-12
 2489 09f4 7F4F      		sbci r23,-1
 2490 09f6 0E94 0000 		call vListInsertEnd
3010:FreeRTOS/Source/tasks.c **** }
 2492               	.LM290:
 2493 09fa 61E0      		ldi r22,lo8(1)
 2494 09fc CE01      		movw r24,r28
 2495               	/* epilogue start */
3011:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2497               	.LM291:
 2498 09fe DF91      		pop r29
 2499 0a00 CF91      		pop r28
3010:FreeRTOS/Source/tasks.c **** }
 2501               	.LM292:
 2502 0a02 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2504               	.Lscope22:
 2506               		.stabd	78,0,0
 2509               	.global	xTaskRemoveFromEventList
 2511               	xTaskRemoveFromEventList:
 2512               		.stabd	46,0,0
3048:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2514               	.LM293:
 2515               	.LFBB23:
 2516 0a06 0F93      		push r16
 2517 0a08 1F93      		push r17
 2518 0a0a CF93      		push r28
 2519 0a0c DF93      		push r29
 2520               	/* prologue: function */
 2521               	/* frame size = 0 */
 2522               	/* stack size = 4 */
 2523               	.L__stack_usage = 4
3065:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2525               	.LM294:
 2526 0a0e DC01      		movw r26,r24
 2527 0a10 1596      		adiw r26,5
 2528 0a12 ED91      		ld r30,X+
 2529 0a14 FC91      		ld r31,X
 2530 0a16 1697      		sbiw r26,5+1
 2531 0a18 C681      		ldd r28,Z+6
 2532 0a1a D781      		ldd r29,Z+7
3067:FreeRTOS/Source/tasks.c **** 
 2534               	.LM295:
 2535 0a1c 8E01      		movw r16,r28
 2536 0a1e 045F      		subi r16,-12
 2537 0a20 1F4F      		sbci r17,-1
 2538 0a22 C801      		movw r24,r16
 2539 0a24 0E94 0000 		call uxListRemove
3069:FreeRTOS/Source/tasks.c **** 	{
 2541               	.LM296:
 2542 0a28 8091 0000 		lds r24,uxSchedulerSuspended
 2543 0a2c 8111      		cpse r24,__zero_reg__
 2544 0a2e 00C0      		rjmp .L187
3071:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2546               	.LM297:
 2547 0a30 0A50      		subi r16,10
 2548 0a32 1109      		sbc r17,__zero_reg__
 2549 0a34 C801      		movw r24,r16
 2550 0a36 0E94 0000 		call uxListRemove
3072:FreeRTOS/Source/tasks.c **** 	}
 2552               	.LM298:
 2553 0a3a 8E89      		ldd r24,Y+22
 2554 0a3c 9091 0000 		lds r25,uxTopReadyPriority
 2555 0a40 9817      		cp r25,r24
 2556 0a42 00F4      		brsh .L188
3072:FreeRTOS/Source/tasks.c **** 	}
 2558               	.LM299:
 2559 0a44 8093 0000 		sts uxTopReadyPriority,r24
 2560               	.L188:
3072:FreeRTOS/Source/tasks.c **** 	}
 2562               	.LM300:
 2563 0a48 B9E0      		ldi r27,lo8(9)
 2564 0a4a 8B9F      		mul r24,r27
 2565 0a4c C001      		movw r24,r0
 2566 0a4e 1124      		clr __zero_reg__
 2567 0a50 B801      		movw r22,r16
 2568 0a52 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2569 0a54 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2570 0a56 00C0      		rjmp .L192
 2571               	.L187:
3078:FreeRTOS/Source/tasks.c **** 	}
 2573               	.LM301:
 2574 0a58 B801      		movw r22,r16
 2575 0a5a 80E0      		ldi r24,lo8(xPendingReadyList)
 2576 0a5c 90E0      		ldi r25,hi8(xPendingReadyList)
 2577               	.L192:
 2578 0a5e 0E94 0000 		call vListInsertEnd
3081:FreeRTOS/Source/tasks.c **** 	{
 2580               	.LM302:
 2581 0a62 E091 0000 		lds r30,pxCurrentTCB
 2582 0a66 F091 0000 		lds r31,pxCurrentTCB+1
 2583 0a6a 9E89      		ldd r25,Y+22
 2584 0a6c 8689      		ldd r24,Z+22
 2585 0a6e 8917      		cp r24,r25
 2586 0a70 00F4      		brsh .L191
3090:FreeRTOS/Source/tasks.c **** 	}
 2588               	.LM303:
 2589 0a72 81E0      		ldi r24,lo8(1)
 2590 0a74 8093 0000 		sts xYieldPending,r24
 2591 0a78 00C0      		rjmp .L190
 2592               	.L191:
3094:FreeRTOS/Source/tasks.c **** 	}
 2594               	.LM304:
 2595 0a7a 80E0      		ldi r24,0
 2596               	.L190:
 2597               	/* epilogue start */
3112:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2599               	.LM305:
 2600 0a7c DF91      		pop r29
 2601 0a7e CF91      		pop r28
 2602 0a80 1F91      		pop r17
 2603 0a82 0F91      		pop r16
 2604 0a84 0895      		ret
 2610               	.Lscope23:
 2612               		.stabd	78,0,0
 2616               	.global	vTaskRemoveFromUnorderedEventList
 2618               	vTaskRemoveFromUnorderedEventList:
 2619               		.stabd	46,0,0
3116:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2621               	.LM306:
 2622               	.LFBB24:
 2623 0a86 0F93      		push r16
 2624 0a88 1F93      		push r17
 2625 0a8a CF93      		push r28
 2626 0a8c DF93      		push r29
 2627               	/* prologue: function */
 2628               	/* frame size = 0 */
 2629               	/* stack size = 4 */
 2630               	.L__stack_usage = 4
3124:FreeRTOS/Source/tasks.c **** 
 2632               	.LM307:
 2633 0a8e 7068      		ori r23,128
 2634 0a90 FC01      		movw r30,r24
 2635 0a92 7183      		std Z+1,r23
 2636 0a94 6083      		st Z,r22
3128:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2638               	.LM308:
 2639 0a96 C681      		ldd r28,Z+6
 2640 0a98 D781      		ldd r29,Z+7
3130:FreeRTOS/Source/tasks.c **** 
 2642               	.LM309:
 2643 0a9a 0E94 0000 		call uxListRemove
3135:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2645               	.LM310:
 2646 0a9e 8E01      		movw r16,r28
 2647 0aa0 0E5F      		subi r16,-2
 2648 0aa2 1F4F      		sbci r17,-1
 2649 0aa4 C801      		movw r24,r16
 2650 0aa6 0E94 0000 		call uxListRemove
3136:FreeRTOS/Source/tasks.c **** 
 2652               	.LM311:
 2653 0aaa 8E89      		ldd r24,Y+22
 2654 0aac 9091 0000 		lds r25,uxTopReadyPriority
 2655 0ab0 9817      		cp r25,r24
 2656 0ab2 00F4      		brsh .L194
3136:FreeRTOS/Source/tasks.c **** 
 2658               	.LM312:
 2659 0ab4 8093 0000 		sts uxTopReadyPriority,r24
 2660               	.L194:
3136:FreeRTOS/Source/tasks.c **** 
 2662               	.LM313:
 2663 0ab8 F9E0      		ldi r31,lo8(9)
 2664 0aba 8F9F      		mul r24,r31
 2665 0abc C001      		movw r24,r0
 2666 0abe 1124      		clr __zero_reg__
 2667 0ac0 B801      		movw r22,r16
 2668 0ac2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2669 0ac4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2670 0ac6 0E94 0000 		call vListInsertEnd
3138:FreeRTOS/Source/tasks.c **** 	{
 2672               	.LM314:
 2673 0aca E091 0000 		lds r30,pxCurrentTCB
 2674 0ace F091 0000 		lds r31,pxCurrentTCB+1
 2675 0ad2 9E89      		ldd r25,Y+22
 2676 0ad4 8689      		ldd r24,Z+22
 2677 0ad6 8917      		cp r24,r25
 2678 0ad8 00F4      		brsh .L193
3144:FreeRTOS/Source/tasks.c **** 	}
 2680               	.LM315:
 2681 0ada 81E0      		ldi r24,lo8(1)
 2682 0adc 8093 0000 		sts xYieldPending,r24
 2683               	.L193:
 2684               	/* epilogue start */
3146:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2686               	.LM316:
 2687 0ae0 DF91      		pop r29
 2688 0ae2 CF91      		pop r28
 2689 0ae4 1F91      		pop r17
 2690 0ae6 0F91      		pop r16
 2691 0ae8 0895      		ret
 2696               	.Lscope24:
 2698               		.stabd	78,0,0
 2701               	.global	vTaskSetTimeOutState
 2703               	vTaskSetTimeOutState:
 2704               		.stabd	46,0,0
3150:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2706               	.LM317:
 2707               	.LFBB25:
 2708               	/* prologue: function */
 2709               	/* frame size = 0 */
 2710               	/* stack size = 0 */
 2711               	.L__stack_usage = 0
3152:FreeRTOS/Source/tasks.c **** 	{
 2713               	.LM318:
 2714               	/* #APP */
 2715               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2716 0aea 0FB6      		in		__tmp_reg__, __SREG__
 2717               	 ;  0 "" 2
 2718               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2719 0aec F894      		cli
 2720               	 ;  0 "" 2
 2721               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2722 0aee 0F92      		push	__tmp_reg__
 2723               	 ;  0 "" 2
3154:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2725               	.LM319:
 2726               	/* #NOAPP */
 2727 0af0 2091 0000 		lds r18,xNumOfOverflows
 2728 0af4 FC01      		movw r30,r24
 2729 0af6 2083      		st Z,r18
3155:FreeRTOS/Source/tasks.c **** 	}
 2731               	.LM320:
 2732 0af8 2091 0000 		lds r18,xTickCount
 2733 0afc 3091 0000 		lds r19,xTickCount+1
 2734 0b00 3283      		std Z+2,r19
 2735 0b02 2183      		std Z+1,r18
3157:FreeRTOS/Source/tasks.c **** }
 2737               	.LM321:
 2738               	/* #APP */
 2739               	 ;  3157 "FreeRTOS/Source/tasks.c" 1
 2740 0b04 0F90      		pop		__tmp_reg__
 2741               	 ;  0 "" 2
 2742               	 ;  3157 "FreeRTOS/Source/tasks.c" 1
 2743 0b06 0FBE      		out		__SREG__, __tmp_reg__
 2744               	 ;  0 "" 2
 2745               	/* #NOAPP */
 2746 0b08 0895      		ret
 2748               	.Lscope25:
 2750               		.stabd	78,0,0
 2753               	.global	vTaskInternalSetTimeOutState
 2755               	vTaskInternalSetTimeOutState:
 2756               		.stabd	46,0,0
3162:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2758               	.LM322:
 2759               	.LFBB26:
 2760               	/* prologue: function */
 2761               	/* frame size = 0 */
 2762               	/* stack size = 0 */
 2763               	.L__stack_usage = 0
3164:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2765               	.LM323:
 2766 0b0a 2091 0000 		lds r18,xNumOfOverflows
 2767 0b0e FC01      		movw r30,r24
 2768 0b10 2083      		st Z,r18
3165:FreeRTOS/Source/tasks.c **** }
 2770               	.LM324:
 2771 0b12 2091 0000 		lds r18,xTickCount
 2772 0b16 3091 0000 		lds r19,xTickCount+1
 2773 0b1a 3283      		std Z+2,r19
 2774 0b1c 2183      		std Z+1,r18
 2775 0b1e 0895      		ret
 2777               	.Lscope26:
 2779               		.stabd	78,0,0
 2783               	.global	xTaskCheckForTimeOut
 2785               	xTaskCheckForTimeOut:
 2786               		.stabd	46,0,0
3170:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 2788               	.LM325:
 2789               	.LFBB27:
 2790 0b20 CF93      		push r28
 2791 0b22 DF93      		push r29
 2792               	/* prologue: function */
 2793               	/* frame size = 0 */
 2794               	/* stack size = 2 */
 2795               	.L__stack_usage = 2
3176:FreeRTOS/Source/tasks.c **** 	{
 2797               	.LM326:
 2798               	/* #APP */
 2799               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2800 0b24 0FB6      		in		__tmp_reg__, __SREG__
 2801               	 ;  0 "" 2
 2802               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2803 0b26 F894      		cli
 2804               	 ;  0 "" 2
 2805               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2806 0b28 0F92      		push	__tmp_reg__
 2807               	 ;  0 "" 2
 2808               	/* #NOAPP */
 2809               	.LBB75:
3179:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2811               	.LM327:
 2812 0b2a 4091 0000 		lds r20,xTickCount
 2813 0b2e 5091 0000 		lds r21,xTickCount+1
3194:FreeRTOS/Source/tasks.c **** 			{
 2815               	.LM328:
 2816 0b32 DB01      		movw r26,r22
 2817 0b34 2D91      		ld r18,X+
 2818 0b36 3C91      		ld r19,X
 2819 0b38 2F3F      		cpi r18,-1
 2820 0b3a BFEF      		ldi r27,-1
 2821 0b3c 3B07      		cpc r19,r27
 2822 0b3e 01F0      		breq .L202
3180:FreeRTOS/Source/tasks.c **** 
 2824               	.LM329:
 2825 0b40 EC01      		movw r28,r24
 2826 0b42 E981      		ldd r30,Y+1
 2827 0b44 FA81      		ldd r31,Y+2
3204:FreeRTOS/Source/tasks.c **** 		{
 2829               	.LM330:
 2830 0b46 A091 0000 		lds r26,xNumOfOverflows
 2831 0b4a B881      		ld r27,Y
 2832 0b4c BA17      		cp r27,r26
 2833 0b4e 01F0      		breq .L200
3204:FreeRTOS/Source/tasks.c **** 		{
 2835               	.LM331:
 2836 0b50 4E17      		cp r20,r30
 2837 0b52 5F07      		cpc r21,r31
 2838 0b54 00F4      		brsh .L203
 2839               	.L200:
3180:FreeRTOS/Source/tasks.c **** 
 2841               	.LM332:
 2842 0b56 4E1B      		sub r20,r30
 2843 0b58 5F0B      		sbc r21,r31
 2844 0b5a FB01      		movw r30,r22
3213:FreeRTOS/Source/tasks.c **** 		{
 2846               	.LM333:
 2847 0b5c 4217      		cp r20,r18
 2848 0b5e 5307      		cpc r21,r19
 2849 0b60 00F4      		brsh .L201
3216:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2851               	.LM334:
 2852 0b62 241B      		sub r18,r20
 2853 0b64 350B      		sbc r19,r21
 2854 0b66 3183      		std Z+1,r19
 2855 0b68 2083      		st Z,r18
3217:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2857               	.LM335:
 2858 0b6a 0E94 0000 		call vTaskInternalSetTimeOutState
 2859 0b6e 00C0      		rjmp .L202
 2860               	.L201:
3222:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2862               	.LM336:
 2863 0b70 1182      		std Z+1,__zero_reg__
 2864 0b72 1082      		st Z,__zero_reg__
 2865 0b74 00C0      		rjmp .L203
 2866               	.L202:
3199:FreeRTOS/Source/tasks.c **** 			}
 2868               	.LM337:
 2869 0b76 80E0      		ldi r24,0
 2870 0b78 00C0      		rjmp .L199
 2871               	.L203:
3211:FreeRTOS/Source/tasks.c **** 		}
 2873               	.LM338:
 2874 0b7a 81E0      		ldi r24,lo8(1)
 2875               	.L199:
 2876               	.LBE75:
3226:FreeRTOS/Source/tasks.c **** 
 2878               	.LM339:
 2879               	/* #APP */
 2880               	 ;  3226 "FreeRTOS/Source/tasks.c" 1
 2881 0b7c 0F90      		pop		__tmp_reg__
 2882               	 ;  0 "" 2
 2883               	 ;  3226 "FreeRTOS/Source/tasks.c" 1
 2884 0b7e 0FBE      		out		__SREG__, __tmp_reg__
 2885               	 ;  0 "" 2
 2886               	/* epilogue start */
3229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2888               	.LM340:
 2889               	/* #NOAPP */
 2890 0b80 DF91      		pop r29
 2891 0b82 CF91      		pop r28
 2892 0b84 0895      		ret
 2901               	.Lscope27:
 2903               		.stabd	78,0,0
 2905               	.global	vTaskMissedYield
 2907               	vTaskMissedYield:
 2908               		.stabd	46,0,0
3233:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 2910               	.LM341:
 2911               	.LFBB28:
 2912               	/* prologue: function */
 2913               	/* frame size = 0 */
 2914               	/* stack size = 0 */
 2915               	.L__stack_usage = 0
3234:FreeRTOS/Source/tasks.c **** }
 2917               	.LM342:
 2918 0b86 81E0      		ldi r24,lo8(1)
 2919 0b88 8093 0000 		sts xYieldPending,r24
 2920 0b8c 0895      		ret
 2922               	.Lscope28:
 2924               		.stabd	78,0,0
 2926               	.global	uxTaskResetEventItemValue
 2928               	uxTaskResetEventItemValue:
 2929               		.stabd	46,0,0
4447:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
 2931               	.LM343:
 2932               	.LFBB29:
 2933               	/* prologue: function */
 2934               	/* frame size = 0 */
 2935               	/* stack size = 0 */
 2936               	.L__stack_usage = 0
4450:FreeRTOS/Source/tasks.c **** 
 2938               	.LM344:
 2939 0b8e E091 0000 		lds r30,pxCurrentTCB
 2940 0b92 F091 0000 		lds r31,pxCurrentTCB+1
 2941 0b96 8485      		ldd r24,Z+12
 2942 0b98 9585      		ldd r25,Z+13
4454:FreeRTOS/Source/tasks.c **** 
 2944               	.LM345:
 2945 0b9a E091 0000 		lds r30,pxCurrentTCB
 2946 0b9e F091 0000 		lds r31,pxCurrentTCB+1
 2947 0ba2 A091 0000 		lds r26,pxCurrentTCB
 2948 0ba6 B091 0000 		lds r27,pxCurrentTCB+1
 2949 0baa 5696      		adiw r26,22
 2950 0bac 4C91      		ld r20,X
 2951 0bae 24E0      		ldi r18,lo8(4)
 2952 0bb0 30E0      		ldi r19,0
 2953 0bb2 241B      		sub r18,r20
 2954 0bb4 3109      		sbc r19,__zero_reg__
 2955 0bb6 3587      		std Z+13,r19
 2956 0bb8 2487      		std Z+12,r18
4457:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2958               	.LM346:
 2959 0bba 0895      		ret
 2964               	.Lscope29:
 2966               		.stabd	78,0,0
 2970               	.global	ulTaskNotifyTake
 2972               	ulTaskNotifyTake:
 2973               		.stabd	46,0,0
4480:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
 2975               	.LM347:
 2976               	.LFBB30:
 2977 0bbc 0F93      		push r16
 2978 0bbe 1F93      		push r17
 2979               	/* prologue: function */
 2980               	/* frame size = 0 */
 2981               	/* stack size = 2 */
 2982               	.L__stack_usage = 2
 2983 0bc0 182F      		mov r17,r24
 2984 0bc2 CB01      		movw r24,r22
4483:FreeRTOS/Source/tasks.c **** 		{
 2986               	.LM348:
 2987               	/* #APP */
 2988               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 2989 0bc4 0FB6      		in		__tmp_reg__, __SREG__
 2990               	 ;  0 "" 2
 2991               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 2992 0bc6 F894      		cli
 2993               	 ;  0 "" 2
 2994               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 2995 0bc8 0F92      		push	__tmp_reg__
 2996               	 ;  0 "" 2
4486:FreeRTOS/Source/tasks.c **** 			{
 2998               	.LM349:
 2999               	/* #NOAPP */
 3000 0bca E091 0000 		lds r30,pxCurrentTCB
 3001 0bce F091 0000 		lds r31,pxCurrentTCB+1
 3002 0bd2 41A1      		ldd r20,Z+33
 3003 0bd4 52A1      		ldd r21,Z+34
 3004 0bd6 63A1      		ldd r22,Z+35
 3005 0bd8 74A1      		ldd r23,Z+36
 3006 0bda 452B      		or r20,r21
 3007 0bdc 462B      		or r20,r22
 3008 0bde 472B      		or r20,r23
 3009 0be0 01F4      		brne .L208
4489:FreeRTOS/Source/tasks.c **** 
 3011               	.LM350:
 3012 0be2 E091 0000 		lds r30,pxCurrentTCB
 3013 0be6 F091 0000 		lds r31,pxCurrentTCB+1
 3014 0bea 21E0      		ldi r18,lo8(1)
 3015 0bec 25A3      		std Z+37,r18
4491:FreeRTOS/Source/tasks.c **** 				{
 3017               	.LM351:
 3018 0bee 0097      		sbiw r24,0
 3019 0bf0 01F0      		breq .L208
4493:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 3021               	.LM352:
 3022 0bf2 61E0      		ldi r22,lo8(1)
 3023 0bf4 0E94 0000 		call prvAddCurrentTaskToDelayedList
4500:FreeRTOS/Source/tasks.c **** 				}
 3025               	.LM353:
 3026 0bf8 0E94 0000 		call vPortYield
 3027               	.L208:
4512:FreeRTOS/Source/tasks.c **** 
 3029               	.LM354:
 3030               	/* #APP */
 3031               	 ;  4512 "FreeRTOS/Source/tasks.c" 1
 3032 0bfc 0F90      		pop		__tmp_reg__
 3033               	 ;  0 "" 2
 3034               	 ;  4512 "FreeRTOS/Source/tasks.c" 1
 3035 0bfe 0FBE      		out		__SREG__, __tmp_reg__
 3036               	 ;  0 "" 2
4514:FreeRTOS/Source/tasks.c **** 		{
 3038               	.LM355:
 3039               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3040 0c00 0FB6      		in		__tmp_reg__, __SREG__
 3041               	 ;  0 "" 2
 3042               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3043 0c02 F894      		cli
 3044               	 ;  0 "" 2
 3045               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3046 0c04 0F92      		push	__tmp_reg__
 3047               	 ;  0 "" 2
4517:FreeRTOS/Source/tasks.c **** 
 3049               	.LM356:
 3050               	/* #NOAPP */
 3051 0c06 E091 0000 		lds r30,pxCurrentTCB
 3052 0c0a F091 0000 		lds r31,pxCurrentTCB+1
 3053 0c0e 61A1      		ldd r22,Z+33
 3054 0c10 72A1      		ldd r23,Z+34
 3055 0c12 83A1      		ldd r24,Z+35
 3056 0c14 94A1      		ldd r25,Z+36
4519:FreeRTOS/Source/tasks.c **** 			{
 3058               	.LM357:
 3059 0c16 6115      		cp r22,__zero_reg__
 3060 0c18 7105      		cpc r23,__zero_reg__
 3061 0c1a 8105      		cpc r24,__zero_reg__
 3062 0c1c 9105      		cpc r25,__zero_reg__
 3063 0c1e 01F0      		breq .L210
4523:FreeRTOS/Source/tasks.c **** 				}
 3065               	.LM358:
 3066 0c20 E091 0000 		lds r30,pxCurrentTCB
 3067 0c24 F091 0000 		lds r31,pxCurrentTCB+1
4521:FreeRTOS/Source/tasks.c **** 				{
 3069               	.LM359:
 3070 0c28 1123      		tst r17
 3071 0c2a 01F0      		breq .L211
4523:FreeRTOS/Source/tasks.c **** 				}
 3073               	.LM360:
 3074 0c2c 11A2      		std Z+33,__zero_reg__
 3075 0c2e 12A2      		std Z+34,__zero_reg__
 3076 0c30 13A2      		std Z+35,__zero_reg__
 3077 0c32 14A2      		std Z+36,__zero_reg__
 3078 0c34 00C0      		rjmp .L210
 3079               	.L211:
4527:FreeRTOS/Source/tasks.c **** 				}
 3081               	.LM361:
 3082 0c36 8B01      		movw r16,r22
 3083 0c38 9C01      		movw r18,r24
 3084 0c3a 0150      		subi r16,1
 3085 0c3c 1109      		sbc r17,__zero_reg__
 3086 0c3e 2109      		sbc r18,__zero_reg__
 3087 0c40 3109      		sbc r19,__zero_reg__
 3088 0c42 01A3      		std Z+33,r16
 3089 0c44 12A3      		std Z+34,r17
 3090 0c46 23A3      		std Z+35,r18
 3091 0c48 34A3      		std Z+36,r19
 3092               	.L210:
4535:FreeRTOS/Source/tasks.c **** 		}
 3094               	.LM362:
 3095 0c4a E091 0000 		lds r30,pxCurrentTCB
 3096 0c4e F091 0000 		lds r31,pxCurrentTCB+1
 3097 0c52 15A2      		std Z+37,__zero_reg__
4537:FreeRTOS/Source/tasks.c **** 
 3099               	.LM363:
 3100               	/* #APP */
 3101               	 ;  4537 "FreeRTOS/Source/tasks.c" 1
 3102 0c54 0F90      		pop		__tmp_reg__
 3103               	 ;  0 "" 2
 3104               	 ;  4537 "FreeRTOS/Source/tasks.c" 1
 3105 0c56 0FBE      		out		__SREG__, __tmp_reg__
 3106               	 ;  0 "" 2
 3107               	/* epilogue start */
4540:FreeRTOS/Source/tasks.c **** 
 3109               	.LM364:
 3110               	/* #NOAPP */
 3111 0c58 1F91      		pop r17
 3112 0c5a 0F91      		pop r16
 3113 0c5c 0895      		ret
 3118               	.Lscope30:
 3120               		.stabd	78,0,0
 3126               	.global	xTaskNotifyWait
 3128               	xTaskNotifyWait:
 3129               		.stabd	46,0,0
4548:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 3131               	.LM365:
 3132               	.LFBB31:
 3133 0c5e 4F92      		push r4
 3134 0c60 5F92      		push r5
 3135 0c62 6F92      		push r6
 3136 0c64 7F92      		push r7
 3137 0c66 8F92      		push r8
 3138 0c68 9F92      		push r9
 3139 0c6a AF92      		push r10
 3140 0c6c BF92      		push r11
 3141 0c6e EF92      		push r14
 3142 0c70 FF92      		push r15
 3143 0c72 0F93      		push r16
 3144 0c74 1F93      		push r17
 3145               	/* prologue: function */
 3146               	/* frame size = 0 */
 3147               	/* stack size = 12 */
 3148               	.L__stack_usage = 12
 3149 0c76 4901      		movw r8,r18
 3150 0c78 5A01      		movw r10,r20
4551:FreeRTOS/Source/tasks.c **** 		{
 3152               	.LM366:
 3153               	/* #APP */
 3154               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3155 0c7a 0FB6      		in		__tmp_reg__, __SREG__
 3156               	 ;  0 "" 2
 3157               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3158 0c7c F894      		cli
 3159               	 ;  0 "" 2
 3160               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3161 0c7e 0F92      		push	__tmp_reg__
 3162               	 ;  0 "" 2
4554:FreeRTOS/Source/tasks.c **** 			{
 3164               	.LM367:
 3165               	/* #NOAPP */
 3166 0c80 E091 0000 		lds r30,pxCurrentTCB
 3167 0c84 F091 0000 		lds r31,pxCurrentTCB+1
 3168 0c88 25A1      		ldd r18,Z+37
 3169 0c8a 2230      		cpi r18,lo8(2)
 3170 0c8c 01F0      		breq .L220
4559:FreeRTOS/Source/tasks.c **** 
 3172               	.LM368:
 3173 0c8e E091 0000 		lds r30,pxCurrentTCB
 3174 0c92 F091 0000 		lds r31,pxCurrentTCB+1
 3175 0c96 21A1      		ldd r18,Z+33
 3176 0c98 32A1      		ldd r19,Z+34
 3177 0c9a 43A1      		ldd r20,Z+35
 3178 0c9c 54A1      		ldd r21,Z+36
 3179 0c9e 2B01      		movw r4,r22
 3180 0ca0 3C01      		movw r6,r24
 3181 0ca2 4094      		com r4
 3182 0ca4 5094      		com r5
 3183 0ca6 6094      		com r6
 3184 0ca8 7094      		com r7
 3185 0caa D301      		movw r26,r6
 3186 0cac C201      		movw r24,r4
 3187 0cae 8223      		and r24,r18
 3188 0cb0 9323      		and r25,r19
 3189 0cb2 A423      		and r26,r20
 3190 0cb4 B523      		and r27,r21
 3191 0cb6 81A3      		std Z+33,r24
 3192 0cb8 92A3      		std Z+34,r25
 3193 0cba A3A3      		std Z+35,r26
 3194 0cbc B4A3      		std Z+36,r27
4562:FreeRTOS/Source/tasks.c **** 
 3196               	.LM369:
 3197 0cbe E091 0000 		lds r30,pxCurrentTCB
 3198 0cc2 F091 0000 		lds r31,pxCurrentTCB+1
 3199 0cc6 81E0      		ldi r24,lo8(1)
 3200 0cc8 85A3      		std Z+37,r24
4564:FreeRTOS/Source/tasks.c **** 				{
 3202               	.LM370:
 3203 0cca E114      		cp r14,__zero_reg__
 3204 0ccc F104      		cpc r15,__zero_reg__
 3205 0cce 01F0      		breq .L220
4566:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 3207               	.LM371:
 3208 0cd0 61E0      		ldi r22,lo8(1)
 3209 0cd2 C701      		movw r24,r14
 3210 0cd4 0E94 0000 		call prvAddCurrentTaskToDelayedList
4573:FreeRTOS/Source/tasks.c **** 				}
 3212               	.LM372:
 3213 0cd8 0E94 0000 		call vPortYield
 3214               	.L220:
4585:FreeRTOS/Source/tasks.c **** 
 3216               	.LM373:
 3217               	/* #APP */
 3218               	 ;  4585 "FreeRTOS/Source/tasks.c" 1
 3219 0cdc 0F90      		pop		__tmp_reg__
 3220               	 ;  0 "" 2
 3221               	 ;  4585 "FreeRTOS/Source/tasks.c" 1
 3222 0cde 0FBE      		out		__SREG__, __tmp_reg__
 3223               	 ;  0 "" 2
4587:FreeRTOS/Source/tasks.c **** 		{
 3225               	.LM374:
 3226               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3227 0ce0 0FB6      		in		__tmp_reg__, __SREG__
 3228               	 ;  0 "" 2
 3229               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3230 0ce2 F894      		cli
 3231               	 ;  0 "" 2
 3232               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3233 0ce4 0F92      		push	__tmp_reg__
 3234               	 ;  0 "" 2
4591:FreeRTOS/Source/tasks.c **** 			{
 3236               	.LM375:
 3237               	/* #NOAPP */
 3238 0ce6 0115      		cp r16,__zero_reg__
 3239 0ce8 1105      		cpc r17,__zero_reg__
 3240 0cea 01F0      		breq .L222
4595:FreeRTOS/Source/tasks.c **** 			}
 3242               	.LM376:
 3243 0cec E091 0000 		lds r30,pxCurrentTCB
 3244 0cf0 F091 0000 		lds r31,pxCurrentTCB+1
 3245 0cf4 81A1      		ldd r24,Z+33
 3246 0cf6 92A1      		ldd r25,Z+34
 3247 0cf8 A3A1      		ldd r26,Z+35
 3248 0cfa B4A1      		ldd r27,Z+36
 3249 0cfc F801      		movw r30,r16
 3250 0cfe 8083      		st Z,r24
 3251 0d00 9183      		std Z+1,r25
 3252 0d02 A283      		std Z+2,r26
 3253 0d04 B383      		std Z+3,r27
 3254               	.L222:
4602:FreeRTOS/Source/tasks.c **** 			{
 3256               	.LM377:
 3257 0d06 E091 0000 		lds r30,pxCurrentTCB
 3258 0d0a F091 0000 		lds r31,pxCurrentTCB+1
 3259 0d0e 85A1      		ldd r24,Z+37
 3260 0d10 8230      		cpi r24,lo8(2)
 3261 0d12 01F4      		brne .L224
4611:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3263               	.LM378:
 3264 0d14 E091 0000 		lds r30,pxCurrentTCB
 3265 0d18 F091 0000 		lds r31,pxCurrentTCB+1
 3266 0d1c 41A1      		ldd r20,Z+33
 3267 0d1e 52A1      		ldd r21,Z+34
 3268 0d20 63A1      		ldd r22,Z+35
 3269 0d22 74A1      		ldd r23,Z+36
 3270 0d24 D501      		movw r26,r10
 3271 0d26 C401      		movw r24,r8
 3272 0d28 8095      		com r24
 3273 0d2a 9095      		com r25
 3274 0d2c A095      		com r26
 3275 0d2e B095      		com r27
 3276 0d30 8423      		and r24,r20
 3277 0d32 9523      		and r25,r21
 3278 0d34 A623      		and r26,r22
 3279 0d36 B723      		and r27,r23
 3280 0d38 81A3      		std Z+33,r24
 3281 0d3a 92A3      		std Z+34,r25
 3282 0d3c A3A3      		std Z+35,r26
 3283 0d3e B4A3      		std Z+36,r27
4612:FreeRTOS/Source/tasks.c **** 			}
 3285               	.LM379:
 3286 0d40 81E0      		ldi r24,lo8(1)
 3287 0d42 00C0      		rjmp .L223
 3288               	.L224:
4605:FreeRTOS/Source/tasks.c **** 			}
 3290               	.LM380:
 3291 0d44 80E0      		ldi r24,0
 3292               	.L223:
4615:FreeRTOS/Source/tasks.c **** 		}
 3294               	.LM381:
 3295 0d46 E091 0000 		lds r30,pxCurrentTCB
 3296 0d4a F091 0000 		lds r31,pxCurrentTCB+1
 3297 0d4e 15A2      		std Z+37,__zero_reg__
4617:FreeRTOS/Source/tasks.c **** 
 3299               	.LM382:
 3300               	/* #APP */
 3301               	 ;  4617 "FreeRTOS/Source/tasks.c" 1
 3302 0d50 0F90      		pop		__tmp_reg__
 3303               	 ;  0 "" 2
 3304               	 ;  4617 "FreeRTOS/Source/tasks.c" 1
 3305 0d52 0FBE      		out		__SREG__, __tmp_reg__
 3306               	 ;  0 "" 2
 3307               	/* epilogue start */
4620:FreeRTOS/Source/tasks.c **** 
 3309               	.LM383:
 3310               	/* #NOAPP */
 3311 0d54 1F91      		pop r17
 3312 0d56 0F91      		pop r16
 3313 0d58 FF90      		pop r15
 3314 0d5a EF90      		pop r14
 3315 0d5c BF90      		pop r11
 3316 0d5e AF90      		pop r10
 3317 0d60 9F90      		pop r9
 3318 0d62 8F90      		pop r8
 3319 0d64 7F90      		pop r7
 3320 0d66 6F90      		pop r6
 3321 0d68 5F90      		pop r5
 3322 0d6a 4F90      		pop r4
 3323 0d6c 0895      		ret
 3328               	.Lscope31:
 3330               		.stabd	78,0,0
 3336               	.global	xTaskGenericNotify
 3338               	xTaskGenericNotify:
 3339               		.stabd	46,0,0
4628:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3341               	.LM384:
 3342               	.LFBB32:
 3343 0d6e 0F93      		push r16
 3344 0d70 1F93      		push r17
 3345 0d72 CF93      		push r28
 3346 0d74 DF93      		push r29
 3347               	/* prologue: function */
 3348               	/* frame size = 0 */
 3349               	/* stack size = 4 */
 3350               	.L__stack_usage = 4
 3351 0d76 FC01      		movw r30,r24
4636:FreeRTOS/Source/tasks.c **** 		{
 3353               	.LM385:
 3354               	/* #APP */
 3355               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3356 0d78 0FB6      		in		__tmp_reg__, __SREG__
 3357               	 ;  0 "" 2
 3358               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3359 0d7a F894      		cli
 3360               	 ;  0 "" 2
 3361               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3362 0d7c 0F92      		push	__tmp_reg__
 3363               	 ;  0 "" 2
4638:FreeRTOS/Source/tasks.c **** 			{
 3365               	.LM386:
 3366               	/* #NOAPP */
 3367 0d7e 0115      		cp r16,__zero_reg__
 3368 0d80 1105      		cpc r17,__zero_reg__
 3369 0d82 01F0      		breq .L232
4640:FreeRTOS/Source/tasks.c **** 			}
 3371               	.LM387:
 3372 0d84 81A1      		ldd r24,Z+33
 3373 0d86 92A1      		ldd r25,Z+34
 3374 0d88 A3A1      		ldd r26,Z+35
 3375 0d8a B4A1      		ldd r27,Z+36
 3376 0d8c E801      		movw r28,r16
 3377 0d8e 8883      		st Y,r24
 3378 0d90 9983      		std Y+1,r25
 3379 0d92 AA83      		std Y+2,r26
 3380 0d94 BB83      		std Y+3,r27
 3381               	.L232:
4643:FreeRTOS/Source/tasks.c **** 
 3383               	.LM388:
 3384 0d96 35A1      		ldd r19,Z+37
4645:FreeRTOS/Source/tasks.c **** 
 3386               	.LM389:
 3387 0d98 82E0      		ldi r24,lo8(2)
 3388 0d9a 85A3      		std Z+37,r24
4647:FreeRTOS/Source/tasks.c **** 			{
 3390               	.LM390:
 3391 0d9c 2230      		cpi r18,lo8(2)
 3392 0d9e 01F0      		breq .L234
 3393 0da0 00F4      		brsh .L235
 3394 0da2 2130      		cpi r18,lo8(1)
 3395 0da4 01F4      		brne .L233
4650:FreeRTOS/Source/tasks.c **** 					break;
 3397               	.LM391:
 3398 0da6 81A1      		ldd r24,Z+33
 3399 0da8 92A1      		ldd r25,Z+34
 3400 0daa A3A1      		ldd r26,Z+35
 3401 0dac B4A1      		ldd r27,Z+36
 3402 0dae 482B      		or r20,r24
 3403 0db0 592B      		or r21,r25
 3404 0db2 6A2B      		or r22,r26
 3405 0db4 7B2B      		or r23,r27
 3406 0db6 00C0      		rjmp .L247
 3407               	.L235:
4647:FreeRTOS/Source/tasks.c **** 			{
 3409               	.LM392:
 3410 0db8 2330      		cpi r18,lo8(3)
 3411 0dba 01F0      		breq .L247
 3412 0dbc 2430      		cpi r18,lo8(4)
 3413 0dbe 01F0      		breq .L238
 3414 0dc0 00C0      		rjmp .L233
 3415               	.L234:
4654:FreeRTOS/Source/tasks.c **** 					break;
 3417               	.LM393:
 3418 0dc2 81A1      		ldd r24,Z+33
 3419 0dc4 92A1      		ldd r25,Z+34
 3420 0dc6 A3A1      		ldd r26,Z+35
 3421 0dc8 B4A1      		ldd r27,Z+36
 3422 0dca 0196      		adiw r24,1
 3423 0dcc A11D      		adc r26,__zero_reg__
 3424 0dce B11D      		adc r27,__zero_reg__
 3425 0dd0 81A3      		std Z+33,r24
 3426 0dd2 92A3      		std Z+34,r25
 3427 0dd4 A3A3      		std Z+35,r26
 3428 0dd6 B4A3      		std Z+36,r27
4655:FreeRTOS/Source/tasks.c **** 
 3430               	.LM394:
 3431 0dd8 00C0      		rjmp .L233
 3432               	.L238:
4662:FreeRTOS/Source/tasks.c **** 					{
 3434               	.LM395:
 3435 0dda 3230      		cpi r19,lo8(2)
 3436 0ddc 01F0      		breq .L243
 3437               	.L247:
4664:FreeRTOS/Source/tasks.c **** 					}
 3439               	.LM396:
 3440 0dde 41A3      		std Z+33,r20
 3441 0de0 52A3      		std Z+34,r21
 3442 0de2 63A3      		std Z+35,r22
 3443 0de4 74A3      		std Z+36,r23
 3444               	.L233:
4691:FreeRTOS/Source/tasks.c **** 			{
 3446               	.LM397:
 3447 0de6 3130      		cpi r19,lo8(1)
 3448 0de8 01F4      		brne .L248
 3449 0dea EF01      		movw r28,r30
4693:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3451               	.LM398:
 3452 0dec 8F01      		movw r16,r30
 3453 0dee 0E5F      		subi r16,-2
 3454 0df0 1F4F      		sbci r17,-1
 3455 0df2 C801      		movw r24,r16
 3456 0df4 0E94 0000 		call uxListRemove
4694:FreeRTOS/Source/tasks.c **** 
 3458               	.LM399:
 3459 0df8 8E89      		ldd r24,Y+22
 3460 0dfa 9091 0000 		lds r25,uxTopReadyPriority
 3461 0dfe 9817      		cp r25,r24
 3462 0e00 00F4      		brsh .L241
4694:FreeRTOS/Source/tasks.c **** 
 3464               	.LM400:
 3465 0e02 8093 0000 		sts uxTopReadyPriority,r24
 3466               	.L241:
4694:FreeRTOS/Source/tasks.c **** 
 3468               	.LM401:
 3469 0e06 29E0      		ldi r18,lo8(9)
 3470 0e08 829F      		mul r24,r18
 3471 0e0a C001      		movw r24,r0
 3472 0e0c 1124      		clr __zero_reg__
 3473 0e0e B801      		movw r22,r16
 3474 0e10 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3475 0e12 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3476 0e14 0E94 0000 		call vListInsertEnd
4715:FreeRTOS/Source/tasks.c **** 				{
 3478               	.LM402:
 3479 0e18 E091 0000 		lds r30,pxCurrentTCB
 3480 0e1c F091 0000 		lds r31,pxCurrentTCB+1
 3481 0e20 9E89      		ldd r25,Y+22
 3482 0e22 8689      		ldd r24,Z+22
 3483 0e24 8917      		cp r24,r25
 3484 0e26 00F4      		brsh .L248
4719:FreeRTOS/Source/tasks.c **** 				}
 3486               	.LM403:
 3487 0e28 0E94 0000 		call vPortYield
 3488               	.L248:
 3489 0e2c 81E0      		ldi r24,lo8(1)
 3490 0e2e 00C0      		rjmp .L239
 3491               	.L243:
4669:FreeRTOS/Source/tasks.c **** 					}
 3493               	.LM404:
 3494 0e30 80E0      		ldi r24,0
 3495               	.L239:
4731:FreeRTOS/Source/tasks.c **** 
 3497               	.LM405:
 3498               	/* #APP */
 3499               	 ;  4731 "FreeRTOS/Source/tasks.c" 1
 3500 0e32 0F90      		pop		__tmp_reg__
 3501               	 ;  0 "" 2
 3502               	 ;  4731 "FreeRTOS/Source/tasks.c" 1
 3503 0e34 0FBE      		out		__SREG__, __tmp_reg__
 3504               	 ;  0 "" 2
 3505               	/* epilogue start */
4734:FreeRTOS/Source/tasks.c **** 
 3507               	.LM406:
 3508               	/* #NOAPP */
 3509 0e36 DF91      		pop r29
 3510 0e38 CF91      		pop r28
 3511 0e3a 1F91      		pop r17
 3512 0e3c 0F91      		pop r16
 3513 0e3e 0895      		ret
 3519               	.Lscope32:
 3521               		.stabd	78,0,0
 3528               	.global	xTaskGenericNotifyFromISR
 3530               	xTaskGenericNotifyFromISR:
 3531               		.stabd	46,0,0
4742:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3533               	.LM407:
 3534               	.LFBB33:
 3535 0e40 EF92      		push r14
 3536 0e42 FF92      		push r15
 3537 0e44 0F93      		push r16
 3538 0e46 1F93      		push r17
 3539 0e48 CF93      		push r28
 3540 0e4a DF93      		push r29
 3541               	/* prologue: function */
 3542               	/* frame size = 0 */
 3543               	/* stack size = 6 */
 3544               	.L__stack_usage = 6
 3545 0e4c FC01      		movw r30,r24
4772:FreeRTOS/Source/tasks.c **** 			{
 3547               	.LM408:
 3548 0e4e 0115      		cp r16,__zero_reg__
 3549 0e50 1105      		cpc r17,__zero_reg__
 3550 0e52 01F0      		breq .L250
4774:FreeRTOS/Source/tasks.c **** 			}
 3552               	.LM409:
 3553 0e54 81A1      		ldd r24,Z+33
 3554 0e56 92A1      		ldd r25,Z+34
 3555 0e58 A3A1      		ldd r26,Z+35
 3556 0e5a B4A1      		ldd r27,Z+36
 3557 0e5c E801      		movw r28,r16
 3558 0e5e 8883      		st Y,r24
 3559 0e60 9983      		std Y+1,r25
 3560 0e62 AA83      		std Y+2,r26
 3561 0e64 BB83      		std Y+3,r27
 3562               	.L250:
4777:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3564               	.LM410:
 3565 0e66 35A1      		ldd r19,Z+37
4778:FreeRTOS/Source/tasks.c **** 
 3567               	.LM411:
 3568 0e68 82E0      		ldi r24,lo8(2)
 3569 0e6a 85A3      		std Z+37,r24
4780:FreeRTOS/Source/tasks.c **** 			{
 3571               	.LM412:
 3572 0e6c 2230      		cpi r18,lo8(2)
 3573 0e6e 01F0      		breq .L252
 3574 0e70 00F4      		brsh .L253
 3575 0e72 2130      		cpi r18,lo8(1)
 3576 0e74 01F4      		brne .L251
4783:FreeRTOS/Source/tasks.c **** 					break;
 3578               	.LM413:
 3579 0e76 81A1      		ldd r24,Z+33
 3580 0e78 92A1      		ldd r25,Z+34
 3581 0e7a A3A1      		ldd r26,Z+35
 3582 0e7c B4A1      		ldd r27,Z+36
 3583 0e7e 482B      		or r20,r24
 3584 0e80 592B      		or r21,r25
 3585 0e82 6A2B      		or r22,r26
 3586 0e84 7B2B      		or r23,r27
 3587 0e86 00C0      		rjmp .L271
 3588               	.L253:
4780:FreeRTOS/Source/tasks.c **** 			{
 3590               	.LM414:
 3591 0e88 2330      		cpi r18,lo8(3)
 3592 0e8a 01F0      		breq .L271
 3593 0e8c 2430      		cpi r18,lo8(4)
 3594 0e8e 01F0      		breq .L256
 3595 0e90 00C0      		rjmp .L251
 3596               	.L252:
4787:FreeRTOS/Source/tasks.c **** 					break;
 3598               	.LM415:
 3599 0e92 81A1      		ldd r24,Z+33
 3600 0e94 92A1      		ldd r25,Z+34
 3601 0e96 A3A1      		ldd r26,Z+35
 3602 0e98 B4A1      		ldd r27,Z+36
 3603 0e9a 0196      		adiw r24,1
 3604 0e9c A11D      		adc r26,__zero_reg__
 3605 0e9e B11D      		adc r27,__zero_reg__
 3606 0ea0 81A3      		std Z+33,r24
 3607 0ea2 92A3      		std Z+34,r25
 3608 0ea4 A3A3      		std Z+35,r26
 3609 0ea6 B4A3      		std Z+36,r27
4788:FreeRTOS/Source/tasks.c **** 
 3611               	.LM416:
 3612 0ea8 00C0      		rjmp .L251
 3613               	.L256:
4795:FreeRTOS/Source/tasks.c **** 					{
 3615               	.LM417:
 3616 0eaa 3230      		cpi r19,lo8(2)
 3617 0eac 01F0      		breq .L264
 3618               	.L271:
4797:FreeRTOS/Source/tasks.c **** 					}
 3620               	.LM418:
 3621 0eae 41A3      		std Z+33,r20
 3622 0eb0 52A3      		std Z+34,r21
 3623 0eb2 63A3      		std Z+35,r22
 3624 0eb4 74A3      		std Z+36,r23
 3625               	.L251:
4823:FreeRTOS/Source/tasks.c **** 			{
 3627               	.LM419:
 3628 0eb6 3130      		cpi r19,lo8(1)
 3629 0eb8 01F0      		breq .L258
 3630               	.L262:
4742:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3632               	.LM420:
 3633 0eba 81E0      		ldi r24,lo8(1)
 3634 0ebc 00C0      		rjmp .L257
 3635               	.L258:
 3636 0ebe EF01      		movw r28,r30
4828:FreeRTOS/Source/tasks.c **** 				{
 3638               	.LM421:
 3639 0ec0 8091 0000 		lds r24,uxSchedulerSuspended
 3640 0ec4 8111      		cpse r24,__zero_reg__
 3641 0ec6 00C0      		rjmp .L259
4830:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3643               	.LM422:
 3644 0ec8 8F01      		movw r16,r30
 3645 0eca 0E5F      		subi r16,-2
 3646 0ecc 1F4F      		sbci r17,-1
 3647 0ece C801      		movw r24,r16
 3648 0ed0 0E94 0000 		call uxListRemove
4831:FreeRTOS/Source/tasks.c **** 				}
 3650               	.LM423:
 3651 0ed4 8E89      		ldd r24,Y+22
 3652 0ed6 9091 0000 		lds r25,uxTopReadyPriority
 3653 0eda 9817      		cp r25,r24
 3654 0edc 00F4      		brsh .L260
4831:FreeRTOS/Source/tasks.c **** 				}
 3656               	.LM424:
 3657 0ede 8093 0000 		sts uxTopReadyPriority,r24
 3658               	.L260:
4831:FreeRTOS/Source/tasks.c **** 				}
 3660               	.LM425:
 3661 0ee2 E9E0      		ldi r30,lo8(9)
 3662 0ee4 8E9F      		mul r24,r30
 3663 0ee6 C001      		movw r24,r0
 3664 0ee8 1124      		clr __zero_reg__
 3665 0eea B801      		movw r22,r16
 3666 0eec 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3667 0eee 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3668 0ef0 00C0      		rjmp .L272
 3669               	.L259:
4837:FreeRTOS/Source/tasks.c **** 				}
 3671               	.LM426:
 3672 0ef2 BF01      		movw r22,r30
 3673 0ef4 645F      		subi r22,-12
 3674 0ef6 7F4F      		sbci r23,-1
 3675 0ef8 80E0      		ldi r24,lo8(xPendingReadyList)
 3676 0efa 90E0      		ldi r25,hi8(xPendingReadyList)
 3677               	.L272:
 3678 0efc 0E94 0000 		call vListInsertEnd
4840:FreeRTOS/Source/tasks.c **** 				{
 3680               	.LM427:
 3681 0f00 E091 0000 		lds r30,pxCurrentTCB
 3682 0f04 F091 0000 		lds r31,pxCurrentTCB+1
 3683 0f08 9E89      		ldd r25,Y+22
 3684 0f0a 8689      		ldd r24,Z+22
 3685 0f0c 8917      		cp r24,r25
 3686 0f0e 00F4      		brsh .L262
4844:FreeRTOS/Source/tasks.c **** 					{
 3688               	.LM428:
 3689 0f10 E114      		cp r14,__zero_reg__
 3690 0f12 F104      		cpc r15,__zero_reg__
 3691 0f14 01F0      		breq .L263
4846:FreeRTOS/Source/tasks.c **** 					}
 3693               	.LM429:
 3694 0f16 81E0      		ldi r24,lo8(1)
 3695 0f18 E701      		movw r28,r14
 3696 0f1a 8883      		st Y,r24
 3697               	.L263:
4852:FreeRTOS/Source/tasks.c **** 				}
 3699               	.LM430:
 3700 0f1c 81E0      		ldi r24,lo8(1)
 3701 0f1e 8093 0000 		sts xYieldPending,r24
 3702 0f22 00C0      		rjmp .L257
 3703               	.L264:
4802:FreeRTOS/Source/tasks.c **** 					}
 3705               	.LM431:
 3706 0f24 80E0      		ldi r24,0
 3707               	.L257:
 3708               	/* epilogue start */
4863:FreeRTOS/Source/tasks.c **** 
 3710               	.LM432:
 3711 0f26 DF91      		pop r29
 3712 0f28 CF91      		pop r28
 3713 0f2a 1F91      		pop r17
 3714 0f2c 0F91      		pop r16
 3715 0f2e FF90      		pop r15
 3716 0f30 EF90      		pop r14
 3717 0f32 0895      		ret
 3723               	.Lscope33:
 3725               		.stabd	78,0,0
 3729               	.global	vTaskNotifyGiveFromISR
 3731               	vTaskNotifyGiveFromISR:
 3732               		.stabd	46,0,0
4871:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3734               	.LM433:
 3735               	.LFBB34:
 3736 0f34 EF92      		push r14
 3737 0f36 FF92      		push r15
 3738 0f38 0F93      		push r16
 3739 0f3a 1F93      		push r17
 3740 0f3c CF93      		push r28
 3741 0f3e DF93      		push r29
 3742               	/* prologue: function */
 3743               	/* frame size = 0 */
 3744               	/* stack size = 6 */
 3745               	.L__stack_usage = 6
 3746 0f40 FC01      		movw r30,r24
4900:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3748               	.LM434:
 3749 0f42 25A1      		ldd r18,Z+37
4901:FreeRTOS/Source/tasks.c **** 
 3751               	.LM435:
 3752 0f44 82E0      		ldi r24,lo8(2)
 3753 0f46 85A3      		std Z+37,r24
4905:FreeRTOS/Source/tasks.c **** 
 3755               	.LM436:
 3756 0f48 81A1      		ldd r24,Z+33
 3757 0f4a 92A1      		ldd r25,Z+34
 3758 0f4c A3A1      		ldd r26,Z+35
 3759 0f4e B4A1      		ldd r27,Z+36
 3760 0f50 0196      		adiw r24,1
 3761 0f52 A11D      		adc r26,__zero_reg__
 3762 0f54 B11D      		adc r27,__zero_reg__
 3763 0f56 81A3      		std Z+33,r24
 3764 0f58 92A3      		std Z+34,r25
 3765 0f5a A3A3      		std Z+35,r26
 3766 0f5c B4A3      		std Z+36,r27
4911:FreeRTOS/Source/tasks.c **** 			{
 3768               	.LM437:
 3769 0f5e 2130      		cpi r18,lo8(1)
 3770 0f60 01F4      		brne .L273
 3771 0f62 8B01      		movw r16,r22
 3772 0f64 EF01      		movw r28,r30
4916:FreeRTOS/Source/tasks.c **** 				{
 3774               	.LM438:
 3775 0f66 8091 0000 		lds r24,uxSchedulerSuspended
 3776 0f6a 8111      		cpse r24,__zero_reg__
 3777 0f6c 00C0      		rjmp .L276
4918:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3779               	.LM439:
 3780 0f6e 7F01      		movw r14,r30
 3781 0f70 22E0      		ldi r18,2
 3782 0f72 E20E      		add r14,r18
 3783 0f74 F11C      		adc r15,__zero_reg__
 3784 0f76 C701      		movw r24,r14
 3785 0f78 0E94 0000 		call uxListRemove
4919:FreeRTOS/Source/tasks.c **** 				}
 3787               	.LM440:
 3788 0f7c 8E89      		ldd r24,Y+22
 3789 0f7e 9091 0000 		lds r25,uxTopReadyPriority
 3790 0f82 9817      		cp r25,r24
 3791 0f84 00F4      		brsh .L277
4919:FreeRTOS/Source/tasks.c **** 				}
 3793               	.LM441:
 3794 0f86 8093 0000 		sts uxTopReadyPriority,r24
 3795               	.L277:
4919:FreeRTOS/Source/tasks.c **** 				}
 3797               	.LM442:
 3798 0f8a E9E0      		ldi r30,lo8(9)
 3799 0f8c 8E9F      		mul r24,r30
 3800 0f8e C001      		movw r24,r0
 3801 0f90 1124      		clr __zero_reg__
 3802 0f92 B701      		movw r22,r14
 3803 0f94 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3804 0f96 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3805 0f98 00C0      		rjmp .L284
 3806               	.L276:
4925:FreeRTOS/Source/tasks.c **** 				}
 3808               	.LM443:
 3809 0f9a BF01      		movw r22,r30
 3810 0f9c 645F      		subi r22,-12
 3811 0f9e 7F4F      		sbci r23,-1
 3812 0fa0 80E0      		ldi r24,lo8(xPendingReadyList)
 3813 0fa2 90E0      		ldi r25,hi8(xPendingReadyList)
 3814               	.L284:
 3815 0fa4 0E94 0000 		call vListInsertEnd
4928:FreeRTOS/Source/tasks.c **** 				{
 3817               	.LM444:
 3818 0fa8 E091 0000 		lds r30,pxCurrentTCB
 3819 0fac F091 0000 		lds r31,pxCurrentTCB+1
 3820 0fb0 9E89      		ldd r25,Y+22
 3821 0fb2 8689      		ldd r24,Z+22
 3822 0fb4 8917      		cp r24,r25
 3823 0fb6 00F4      		brsh .L273
4932:FreeRTOS/Source/tasks.c **** 					{
 3825               	.LM445:
 3826 0fb8 0115      		cp r16,__zero_reg__
 3827 0fba 1105      		cpc r17,__zero_reg__
 3828 0fbc 01F0      		breq .L280
4934:FreeRTOS/Source/tasks.c **** 					}
 3830               	.LM446:
 3831 0fbe 81E0      		ldi r24,lo8(1)
 3832 0fc0 F801      		movw r30,r16
 3833 0fc2 8083      		st Z,r24
 3834               	.L280:
4940:FreeRTOS/Source/tasks.c **** 				}
 3836               	.LM447:
 3837 0fc4 81E0      		ldi r24,lo8(1)
 3838 0fc6 8093 0000 		sts xYieldPending,r24
 3839               	.L273:
 3840               	/* epilogue start */
4949:FreeRTOS/Source/tasks.c **** 
 3842               	.LM448:
 3843 0fca DF91      		pop r29
 3844 0fcc CF91      		pop r28
 3845 0fce 1F91      		pop r17
 3846 0fd0 0F91      		pop r16
 3847 0fd2 FF90      		pop r15
 3848 0fd4 EF90      		pop r14
 3849 0fd6 0895      		ret
 3854               	.Lscope34:
 3856               		.stabd	78,0,0
 3859               	.global	xTaskNotifyStateClear
 3861               	xTaskNotifyStateClear:
 3862               		.stabd	46,0,0
4958:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 3864               	.LM449:
 3865               	.LFBB35:
 3866               	/* prologue: function */
 3867               	/* frame size = 0 */
 3868               	/* stack size = 0 */
 3869               	.L__stack_usage = 0
4964:FreeRTOS/Source/tasks.c **** 
 3871               	.LM450:
 3872 0fd8 0097      		sbiw r24,0
 3873 0fda 01F4      		brne .L286
4964:FreeRTOS/Source/tasks.c **** 
 3875               	.LM451:
 3876 0fdc 8091 0000 		lds r24,pxCurrentTCB
 3877 0fe0 9091 0000 		lds r25,pxCurrentTCB+1
 3878               	.L286:
4966:FreeRTOS/Source/tasks.c **** 		{
 3880               	.LM452:
 3881               	/* #APP */
 3882               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 3883 0fe4 0FB6      		in		__tmp_reg__, __SREG__
 3884               	 ;  0 "" 2
 3885               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 3886 0fe6 F894      		cli
 3887               	 ;  0 "" 2
 3888               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 3889 0fe8 0F92      		push	__tmp_reg__
 3890               	 ;  0 "" 2
4968:FreeRTOS/Source/tasks.c **** 			{
 3892               	.LM453:
 3893               	/* #NOAPP */
 3894 0fea FC01      		movw r30,r24
 3895 0fec 25A1      		ldd r18,Z+37
 3896 0fee 2230      		cpi r18,lo8(2)
 3897 0ff0 01F4      		brne .L288
4970:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 3899               	.LM454:
 3900 0ff2 15A2      		std Z+37,__zero_reg__
4971:FreeRTOS/Source/tasks.c **** 			}
 3902               	.LM455:
 3903 0ff4 81E0      		ldi r24,lo8(1)
 3904 0ff6 00C0      		rjmp .L287
 3905               	.L288:
4975:FreeRTOS/Source/tasks.c **** 			}
 3907               	.LM456:
 3908 0ff8 80E0      		ldi r24,0
 3909               	.L287:
4978:FreeRTOS/Source/tasks.c **** 
 3911               	.LM457:
 3912               	/* #APP */
 3913               	 ;  4978 "FreeRTOS/Source/tasks.c" 1
 3914 0ffa 0F90      		pop		__tmp_reg__
 3915               	 ;  0 "" 2
 3916               	 ;  4978 "FreeRTOS/Source/tasks.c" 1
 3917 0ffc 0FBE      		out		__SREG__, __tmp_reg__
 3918               	 ;  0 "" 2
4981:FreeRTOS/Source/tasks.c **** 
 3920               	.LM458:
 3921               	/* #NOAPP */
 3922 0ffe 0895      		ret
 3927               	.Lscope35:
 3929               		.stabd	78,0,0
 3930               		.local	uxSchedulerSuspended
 3931               		.comm	uxSchedulerSuspended,1,1
 3932               		.local	xIdleTaskHandle
 3933               		.comm	xIdleTaskHandle,2,1
 3934               		.local	xNextTaskUnblockTime
 3935               		.comm	xNextTaskUnblockTime,2,1
 3936               		.local	uxTaskNumber
 3937               		.comm	uxTaskNumber,1,1
 3938               		.local	xNumOfOverflows
 3939               		.comm	xNumOfOverflows,1,1
 3940               		.local	xYieldPending
 3941               		.comm	xYieldPending,1,1
 3942               		.local	uxPendedTicks
 3943               		.comm	uxPendedTicks,1,1
 3944               		.local	xSchedulerRunning
 3945               		.comm	xSchedulerRunning,1,1
 3946               		.local	uxTopReadyPriority
 3947               		.comm	uxTopReadyPriority,1,1
 3948               		.local	xTickCount
 3949               		.comm	xTickCount,2,1
 3950               		.local	uxCurrentNumberOfTasks
 3951               		.comm	uxCurrentNumberOfTasks,1,1
 3952               		.local	xSuspendedTaskList
 3953               		.comm	xSuspendedTaskList,9,1
 3954               		.local	uxDeletedTasksWaitingCleanUp
 3955               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 3956               		.local	xTasksWaitingTermination
 3957               		.comm	xTasksWaitingTermination,9,1
 3958               		.local	xPendingReadyList
 3959               		.comm	xPendingReadyList,9,1
 3960               		.local	pxOverflowDelayedTaskList
 3961               		.comm	pxOverflowDelayedTaskList,2,1
 3962               		.local	pxDelayedTaskList
 3963               		.comm	pxDelayedTaskList,2,1
 3964               		.local	xDelayedTaskList2
 3965               		.comm	xDelayedTaskList2,9,1
 3966               		.local	xDelayedTaskList1
 3967               		.comm	xDelayedTaskList1,9,1
 3968               		.local	pxReadyTasksLists
 3969               		.comm	pxReadyTasksLists,36,1
 3970               	.global	pxCurrentTCB
 3971               		.section .bss
 3974               	pxCurrentTCB:
 3975 0000 0000      		.zero	2
 3997               		.text
 3999               	.Letext0:
 4000               		.ident	"GCC: (GNU) 5.4.0"
 4001               	.global __do_copy_data
 4002               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/cceIRSmT.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cceIRSmT.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cceIRSmT.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cceIRSmT.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cceIRSmT.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cceIRSmT.s:187    .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/cceIRSmT.s:3961   .bss:000000000000002e pxDelayedTaskList
     /tmp/cceIRSmT.s:3933   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/cceIRSmT.s:239    .text:0000000000000036 prvAddCurrentTaskToDelayedList
     /tmp/cceIRSmT.s:3947   .bss:000000000000000d xTickCount
     /tmp/cceIRSmT.s:3974   .bss:0000000000000000 pxCurrentTCB
     /tmp/cceIRSmT.s:3951   .bss:0000000000000010 xSuspendedTaskList
     /tmp/cceIRSmT.s:3959   .bss:000000000000002c pxOverflowDelayedTaskList
     /tmp/cceIRSmT.s:379    .text:00000000000000ee prvIdleTask
     /tmp/cceIRSmT.s:3953   .bss:0000000000000019 uxDeletedTasksWaitingCleanUp
     /tmp/cceIRSmT.s:3955   .bss:000000000000001a xTasksWaitingTermination
     /tmp/cceIRSmT.s:3949   .bss:000000000000000f uxCurrentNumberOfTasks
     /tmp/cceIRSmT.s:3967   .bss:0000000000000042 pxReadyTasksLists
     /tmp/cceIRSmT.s:489    .text:000000000000014a xTaskCreate
     /tmp/cceIRSmT.s:3965   .bss:0000000000000039 xDelayedTaskList1
     /tmp/cceIRSmT.s:3963   .bss:0000000000000030 xDelayedTaskList2
     /tmp/cceIRSmT.s:3957   .bss:0000000000000023 xPendingReadyList
     /tmp/cceIRSmT.s:3943   .bss:000000000000000b xSchedulerRunning
     /tmp/cceIRSmT.s:3935   .bss:0000000000000007 uxTaskNumber
     /tmp/cceIRSmT.s:3945   .bss:000000000000000c uxTopReadyPriority
     /tmp/cceIRSmT.s:880    .text:000000000000034c vTaskDelete
     /tmp/cceIRSmT.s:1024   .text:00000000000003f6 vTaskResume
     /tmp/cceIRSmT.s:1157   .text:0000000000000484 xTaskResumeFromISR
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/cceIRSmT.s:1286   .text:0000000000000514 vTaskStartScheduler
     /tmp/cceIRSmT.s:3931   .bss:0000000000000003 xIdleTaskHandle
     /tmp/cceIRSmT.s:1365   .text:0000000000000568 vTaskEndScheduler
     /tmp/cceIRSmT.s:1394   .text:0000000000000572 vTaskSuspendAll
     /tmp/cceIRSmT.s:1416   .text:000000000000057e xTaskGetTickCount
     /tmp/cceIRSmT.s:1465   .text:0000000000000592 xTaskGetTickCountFromISR
     /tmp/cceIRSmT.s:1491   .text:000000000000059c uxTaskGetNumberOfTasks
     /tmp/cceIRSmT.s:1514   .text:00000000000005a2 pcTaskGetName
     /tmp/cceIRSmT.s:1543   .text:00000000000005b2 xTaskIncrementTick
     /tmp/cceIRSmT.s:3937   .bss:0000000000000008 xNumOfOverflows
     /tmp/cceIRSmT.s:3941   .bss:000000000000000a uxPendedTicks
     /tmp/cceIRSmT.s:3939   .bss:0000000000000009 xYieldPending
     /tmp/cceIRSmT.s:1780   .text:000000000000070a xTaskResumeAll
     /tmp/cceIRSmT.s:1983   .text:00000000000007e8 vTaskDelayUntil
     /tmp/cceIRSmT.s:2104   .text:0000000000000858 vTaskDelay
     /tmp/cceIRSmT.s:2155   .text:0000000000000882 vTaskSwitchContext
     /tmp/cceIRSmT.s:2255   .text:0000000000000908 vTaskSuspend
     /tmp/cceIRSmT.s:2424   .text:00000000000009b4 vTaskPlaceOnEventList
     /tmp/cceIRSmT.s:2465   .text:00000000000009d6 vTaskPlaceOnUnorderedEventList
     /tmp/cceIRSmT.s:2511   .text:0000000000000a06 xTaskRemoveFromEventList
     /tmp/cceIRSmT.s:2618   .text:0000000000000a86 vTaskRemoveFromUnorderedEventList
     /tmp/cceIRSmT.s:2703   .text:0000000000000aea vTaskSetTimeOutState
     /tmp/cceIRSmT.s:2755   .text:0000000000000b0a vTaskInternalSetTimeOutState
     /tmp/cceIRSmT.s:2785   .text:0000000000000b20 xTaskCheckForTimeOut
     /tmp/cceIRSmT.s:2907   .text:0000000000000b86 vTaskMissedYield
     /tmp/cceIRSmT.s:2928   .text:0000000000000b8e uxTaskResetEventItemValue
     /tmp/cceIRSmT.s:2972   .text:0000000000000bbc ulTaskNotifyTake
     /tmp/cceIRSmT.s:3128   .text:0000000000000c5e xTaskNotifyWait
     /tmp/cceIRSmT.s:3338   .text:0000000000000d6e xTaskGenericNotify
     /tmp/cceIRSmT.s:3530   .text:0000000000000e40 xTaskGenericNotifyFromISR
     /tmp/cceIRSmT.s:3731   .text:0000000000000f34 vTaskNotifyGiveFromISR
     /tmp/cceIRSmT.s:3861   .text:0000000000000fd8 xTaskNotifyStateClear

UNDEFINED SYMBOLS
uxListRemove
vListInsertEnd
vListInsert
vPortFree
vPortYield
vApplicationIdleHook
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss
